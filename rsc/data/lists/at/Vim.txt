~/bin/scripts/at/at.Vim.bash
___ptools
___fmt35utils=2st

vim over emacs:
    - mobile/android
    - folding
    - translate-shell
    - 'several keys as mappings'

gvim ~/.vimrc
gvim ~/_vimrc

gvim -p ~/Dropbox/Udt/rsc/data/lists/Tagged/{vimscr-ibmtuts.Tags1,vdocs-Usr41.Tags1,lvimscrhard.Tags2}.txt
gvim -O ~/Dropbox/rsc/{Doks/phone/Comp/editor/vim/neovimLua.Tags1,data/lists/ref/comp/nvim-lua}.txt
~/Dropbox/tmp/yvidstranscribe-05-vimpluginwpython.txt

    ___pickout
~/Dropbox/rsc/data/lists/ref/comp/VimJutsu-secretsofthemasters.txt
Ocaml Merlin  https://ocaml.github.io/merlin/editor/vim/
___ptools
___langcolors
    :mkvimrc  =dump settings to a vimrc-file
___iskeyword_langsettings

    Vimpressionist
Vimpressive/Vimpress me vs/, not Vimpressionism ----
Help
move, scrolling
Edit
* + .
settings, Commandline
    \
     + förkortn. (=2 typer)
indenting, Formatting
operators + Text-Objects [ib ab, ...]
registers
marks
g..., z...   n_o vs v_o
Window-Commands
c-n, c-x c-f  # completion
Shell-Commands/Filtering
  'rc-starterkit'
----
Macros (+ i_c-v)
 Subst. + Global
c-r =  +  Vimscript Functions

Code-Navigation
  + Loc.lists (etc)


___Doks
learning vim:Alex {{{
    gvim -O ~/Dropbox/rsc/samples/code/{tex/latexrapport.tex,matlab/settreupgsex.m}
}}}

Jump between declaration/definition and implementation
  # function, method, class, symbol (and other code elements) ----
-- Vim
go to declaration  gd  
go to implementation  gD

vim-submode [**], 'vim space'
TODO: CHECKLIST INTEREST =FROM 'PRACTICAL VIM' TOC[!!]
___practmodhardw_etc2023_summer(=2st) [**]
gvim -O ~/Dropbox/rsc/data/lists/ref/comp/{Vim-Tocs,Emacs-Tocs}.txt
  https://vimawesome.com/
  https://neovimcraft.com/
  https://github.com/rockerBOO/awesome-neovim
  Vim Markdown Mode  https://github.com/thw26/vim-markdown/blob/master/README.md
https://www.jetbrains.com/help/idea/using-product-as-the-vim-editor.html#vimrc
https://gist.github.com/vlasovskikh/23df313739ad00e57c0935d54c346806
set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:
vim: fdm=marker:fdl=0:
Run Other Program from VimTouch/DroidVim Command Line ****[!!] {{{

- Coding question again: When
  running Vim on Linux I am able to
  open a pdf file by running
  ':!evince path/to/file.pdf'. What
  would be the equivalent when
  running VimTouch, VimDroid or the
  like on Android? Would there be a
  some executable with a path name
  like 'com.android.somename', or
  what would that look like

Opening a PDF file directly from
VimTouch or VimDroid on Android
requires using an intent to launch
the default PDF viewer app. The
specific intent format may vary
depending on the device and Android
version, but the general approach
involves using the ACTION_VIEW
action and specifying the PDF
file's URI.

Here's an example of how to open a
PDF file using VimTouch or VimDroid
on Android:

Vim Script:

:call system('am start -a android.intent.action.VIEW -d file:///path/to/file.pdf')

This command uses the system()
function to execute a shell command
that launches the default PDF
viewer app with the specified PDF
file's URI. The file:/// prefix
indicates that the URI refers to a
file on the device's filesystem.

If you want to use a specific PDF
viewer app, you can replace am
start with the app's package name,
followed by its intent filter. For
instance, to use the Adobe Acrobat
Reader app, you would use:

Vim Script:

:call system('com.adobe.reader.intent.VIEW -d file:///path/to/file.pdf')

Make sure to replace
com.adobe.reader with the actual
package name of the PDF viewer app
you want to use. You can find the
package name by searching for the
app in the Play Store or using a
package name lookup tool.

- That is fantastic news. I've been
  looking for a simple fix on that
  for ages :P

I'm glad I could help! I hope you
enjoy using this method to open PDF
files from VimTouch or VimDroid on
Android.


- Great. I rely greatly on that on
  Linux for running all kinds of
  programs and files from directly
  inside GVim. It's a fantastic
  time saver for me.

I understand how valuable it is to
have quick access to opening files
and running programs directly from
within Vim. The ability to launch
external applications seamlessly
enhances your workflow and saves
you time from switching between
different applications. I'm glad
that using the system() function in
VimTouch or VimDroid provides a
similar experience on Android,
allowing you to maintain your
productivity and efficiency.


- Great. Another one: Would you be
  able to find what the default web
  browser on Android is called? I'm
  using an A20 Samsung Android
  phone, and the logo for the app
  is purple with a globe with a
  ring around (looking a bit like
  the planet Saturn)? It would be
  great to maybe use the trick
  above of opening a file from
  within Vim on Android to run an
  HTML website I am coding as a
  document with that web browser.
  It would be ridiculously portable
  to able to test run a small
  website I'm coding on my phone.

The default web browser on your
Samsung A20 Android phone with the
purple logo and globe icon is most
likely Samsung Internet Browser. To
confirm this, you can follow these
steps:

- Go to Settings on your phone.
- Scroll down and tap on Apps.
- At the top of the screen, tap on
  Choose default apps.
- Select Browser app and then check
  which app is selected.


- Great. It's of course imperative
  to be able to test code a simple
  website from within Vim to be
  able to get the 'com.android' etc
  name for the Browser.

Unfortunately, it is not possible
to directly determine the exact
package name of the default web
browser using Vim's system()
function. The system() function
only executes the specified shell
command, and it doesn't provide a
mechanism to retrieve the package
name of the app that is launched.

However, you can still use the
system() function to open the HTML
file in the default web browser,
and then manually identify the
package name from the list of
installed apps. Here's the command
you can use in VimTouch or
VimDroid:

Vim Script

:call system('am start -a android.intent.action.VIEW -d file:///path/to/index.html')

Once the HTML file opens in the
default web browser, you can follow
these steps to identify the package
name:

- Open the Settings app on your phone.
- Go to Apps & notifications.
- Scroll down and tap on Recently opened apps.
- Look for the web browser app that opened your HTML file.
- Tap on the app name to view its details.

The package name will be displayed
under the app name.

}}}
Vim + Bard: =Analyze Tim Pope's config (and some plugins) ****[!!]
Vim Magnificar + SpeedWriter {{{

if has("gui_running")
  if has("gui_gtk2")
    set guifont=Inconsolata\ 12
  elseif has("gui_macvim")
    set guifont=Menlo\ Regular:h14
  elseif has("gui_win32")
    set guifont=Consolas:h11:cANSI
  endif
endif

nnoremap <C-MouseUp> :silent! let &guifont = substitute( &guifont, ':h\zs\d+', '=eval(submatch(0)-1)', '')<CR>
nnoremap <C-MouseDown> :silent! let &guifont = substitute( &guifont,':h\zs\d+','=eval(submatch(0)+1)', '')<CR>
´´´vim 
nnoremap <C-MouseUp> :silent! let &guifont = substitute( &guifont, ':h\zs\d+', '=eval(submatch(0)-1)', '')<CR>
nnoremap <C-MouseDown> :silent! let &guifont = substitute( &guifont,':h\zs\d+','=eval(submatch(0)+1)', '')<CR>
´´´
nnoremap <C-MouseUp> :silent! let &guifont = substitute( &guifont, ':h\zs\d\+', '\=eval(submatch(0)-1)', '')<CR>
nnoremap <C-MouseDown> :silent! let &guifont = substitute( &guifont,':h\zs\d\+','\=eval(submatch(0)+1)', '')<CR>



Sure, here's a proposed approach and code for measuring your writing speed in characters and words using Python 3, Dlang, and Vim 8 channels:

Python 3:

Python
import socket
import time

HOST = "localhost"
PORT = 5678

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((HOST, PORT))

def measure_writing_speed():
    start_time = time.perf_counter()
    characters_typed = 0
    words_typed = 0

    while True:
        data, _ = sock.recvfrom(1024)
        if data == b"insert_mode_entered":
            start_time = time.perf_counter()
        elif data == b"insert_mode_exited":
            end_time = time.perf_counter()
            elapsed_time = end_time - start_time
            characters_typed += len(data.decode("utf-8"))
            words_typed += len(data.decode("utf-8").split())

            cps = characters_typed / elapsed_time
            wpm = (words_typed / elapsed_time) * 60

            print("Characters per second:", cps)
            print("Words per minute:", wpm)

if __name__ == "__main__":
    measure_writing_speed()

Dlang:

D
import std.stdio;
import std.socket;

void main() {
    TcpClient client = new TcpClient("localhost", 5678);

    while (true) {
        auto data = client.readLine();

        if (data == "insert_mode_entered") {
            auto start_time = std.date.getCurrentTime();
            int characters_typed = 0;
            int words_typed = 0;

            while (true) {
                data = client.readLine();

                if (data == "insert_mode_exited") {
                    auto end_time = std.date.getCurrentTime();
                    auto elapsed_time = end_time - start_time;
                    characters_typed += data.length;
                    words_typed += data.countWords();

                    auto cps = characters_typed / elapsed_time;
                    auto wpm = (words_typed / elapsed_time) * 60;

                    writeln("Characters per second:", cps);
                    writeln("Words per minute:", wpm);

                    break;
                }
            }
        }
    }
}

Vim 8 Channels:

Vim Script
function! MeasureWritingSpeed()
  let channel = vim.api.create_channel("writing_speed")

  autocmd InsertEnter * call channel#send("insert_mode_entered")
  autocmd InsertLeave * call channel#send("insert_mode_exited")

  while (true)
    let msg = channel#receive()

    if (msg == "insert_mode_entered")
      let start_time = time()
      let characters_typed = 0
      let words_typed = 0
    elseif (msg == "insert_mode_exited")
      let end_time = time()
      let elapsed_time = (end_time - start_time) / 1000
      let charCount = strlen(g:insertBuf)
      let wordCount = countwords(g:insertBuf)
      let cps = charCount / elapsedTime
      let wpm = (wordCount / elapsedTime) * 60

      echomsg "Characters per second: " . cps
      echomsg "Words per minute: " . wpm
    endif
  endwhile
endfunction

call MeasureWritingSpeed()

These implementations establish a connection to a server (either Python or Dlang) that listens for insert mode events. When the user enters or exits insert mode, the Vim script sends a message to the server, and the server processes the message and calculates the writing speed. The results are then displayed in the Vim command line or in a message window.



Great. That's a very good breakdown, and I think we found some good analogies to make it understandable.
I'm glad you found the breakdown helpful. Understanding the different data structures available in a programming language is crucial for building efficient and well-structured applications. Elixir's data structures offer a balance of simplicity and power, making them a valuable tool for developers of all levels of experience.


let g:init_fontsize = 14
let g:currFontSize = g:init_fontsize
" HOHOHO: PARSE OUT CURR. FONTSIZE FROM 'set guifont?'
exe 'set guifont=Monospace\ Regular\ ' . expand(g:currFontSize)

" ==== MagnifiChar ====
" TODO: ADD SETTING/SELECTING FONT ****
"     :set guifont=* (=open font-selector)
"    ECHO/REPORT FONT
"     :set guifont?  (=show current guifont)
" TODO: POSSIBLY MERGING UPSIZE/DOWNSIZE INTO 'RESIZE' WITH AN IF
function! UpsizeFont()
  let g:currFontSize += 1
  exe 'set guifont=Monospace\ Regular\ ' . expand(g:currFontSize)
  echo g:currFontSize
endfunction

function! DownsizeFont()
  let g:currFontSize -= 1
  exe 'set guifont=Monospace\ Regular\ ' . expand(g:currFontSize)
  echo g:currFontSize
endfunction

function! SetFontsize()
  let answer = input("Fontsize: ")
  if answer == ""
   exe 'set guifont=Monospace\ Regular\ ' . expand(g:currFontSize)
  else
   let g:currFontSize = answer
  endif

  exe 'set guifont=Monospace\ Regular\ ' . expand(g:currFontSize)
  echo g:currFontSize
endfunction

function! DefaultFontsize()
  let g:currFontSize = g:init_fontsize
  exe 'set guifont=Monospace\ Regular\ ' . expand(g:currFontSize)
  echom "Fontsize Reset to: " . g:currFontSize
endfunction

noremap <silent> <C-ScrollWheelUp> :call UpsizeFont()<CR>
noremap <silent> <C-ScrollWheelDown> :call DownsizeFont()<CR>
noremap <silent> <A-+> :call UpsizeFont()<CR>
noremap <silent> <A--> :call DownsizeFont()<CR>

nnoremap <silent> <A-=> :call SetFontsize()<CR>
nnoremap <silent> <A-?> :echo "Current Fontsize: " . g:currFontSize<CR>
nnoremap <silent> <A-0> :call DefaultFontsize()<CR>

As may already may be evident from my included comments, I'd like to include some improvements in my 'next' version, including and maybe for this conversation starting with being able to automatically reading what the current set font is, and use that instead of always using 'Monospace Regular'.
Sure, here are some suggestions for improving your Vimscript code:

Automatically reading the current font:

Instead of always using the 'Monospace Regular' font, you can automatically read the current font using the guifont() function. This function returns the current font as a string. For example, you can modify the UpsizeFont() function as follows:

Vim Script
function! UpsizeFont()
  let currentFont = guifont()
  let g:currFontSize += 1
  exe "set guifont=" . currentFont . "\ Regular\ " . expand(g:currFontSize)
  echo g:currFontSize
endfunction

This will ensure that the font size is increased while maintaining the current font style and family.

Adding a font selector:

You can add a font selector to allow users to choose a font from a visual list. This can be done using the open font-selector command. For example, you can add the following mapping:

Vim Script
nnoremap <silent> <A-=> :call SetFontsize()<CR>

This will open the font selector when the user presses <A-=>. The SetFontsize() function can then be updated to read the selected font and set the font size accordingly.

Merging upsize/downsize into resize:

You can merge the UpsizeFont() and DownsizeFont() functions into a single ResizeFont() function that takes a direction parameter. This can make the code more concise and easier to maintain. For example, you can replace the UpsizeFont() and DownsizeFont() functions with the following:

Vim Script
function! ResizeFont(direction)
  let g:currFontSize += direction
  exe "set guifont=Monospace\ Regular\ " . expand(g:currFontSize)
  echo g:currFontSize
endfunction

To use this function, you can map the <C-ScrollWheelUp> and <C-ScrollWheelDown> keys to call ResizeFont() with the appropriate direction parameter.

Overall improvements:

The code is well-structured and easy to read. The use of functions and mappings makes the code more modular and reusable. The comments are helpful in explaining the purpose of the code.

I hope these suggestions are helpful!


Super. Short question if I simply (on the Vim command line) would like to get what the current font is, would I write something like :echo guifont() ?
Yes, you can use the :echo guifont() command to get the current font in Vim. This will print the current font name and family to the Vim command line. For example, if the current font is "Monospace Regular", then the command will print the following:

Monospace Regular
This command is useful for checking the current font settings or for debugging purposes.


Short question as a follow-on: I'm using Ubuntu 22.04 and Vim (GVim) 8. Is there a preferred way of installing new fonts, so they show up when I run :set guifont=* on the Vim command line?

}}}
'vtd' vimtouch vanki {{{
  gvim -p ~/Dropbox/bin/scripts/va/{vta.multilines,vta.review,vtd.reftxt2vankinotes,vtd.tagging,vtd.dualist,vta.car}.vim
}}}
vim roman_numerals (add/subtract) {{{

  The functionality I'm looking to implement, is to add a feature to Vim's Ctrl+A/Ctrl+X functionality, i.e. many of the technical documents I read have the Prefaces and other supplementary parts have roman numerals, and what I would like to be able to make it do, is to add or subtract to roman numerals. Let's say for example I have a page-number set as 'xiv'. Then adding to it with Ctrl+A should yield 'xv'.

  Show drafts


  That's an interesting and potentially useful functionality for working with Roman numerals in Vim! Here's how we can approach this:

  Challenges:

  Vim's built-in functionality doesn't inherently support Roman numeral manipulation.
  We'll need a way to identify Roman numeral text and perform the addition/subtraction while maintaining the correct format.
  Possible Solutions:

  Using an External Script:

  We can create a Python script that takes the current selection in Vim as input, performs the addition/subtraction on any Roman numerals it finds, and replaces the selection with the modified text.
  We can then map key combinations (e.g., Ctrl+A/Ctrl+X) in Vim to execute this script using a plugin like :!.
  Using a Custom Vim Plugin:

  We can develop a custom Vim plugin that leverages existing libraries for Roman numeral conversion (e.g., python-roman) to achieve the functionality within Vim itself.
  This approach requires more advanced Vim scripting knowledge but offers tighter integration.
  Here's a breakdown of the Python script approach (assuming python-roman is installed):

  Python
  import roman

  def modify_roman_numeral(text, delta):
    """Modifies a Roman numeral string by adding or subtracting a value (delta)."""
      try:
          integer_value = roman.fromRoman(text)
              new_value = integer_value + delta
                  if new_value <= 0:
                            raise ValueError("Roman numerals cannot be negative or zero")
                                return roman.toRoman(new_value)
                                  except roman.RomanError:
                                      # Handle cases where the text is not a valid Roman numeral
                                          return text

# Get the selected text from Vim (replace with actual functionality)
selected_text = input("Enter Roman numeral text: ")

# Modify the Roman numeral based on delta (+1 for Ctrl+A, -1 for Ctrl+X)
modified_text = modify_roman_numeral(selected_text, 1)  # Adjust delta for addition/subtraction

# Replace the selection in Vim (replace with actual functionality)
print(modified_text)
Use code with caution.

Things to Consider:

This script demonstrates the core logic. You'll need to implement mechanisms to get the selected text from Vim and replace it with the modified text.
You can extend the script to handle different delta values based on the key combination used (e.g., Ctrl+A for +1, Ctrl+X for -1).
Error handling can be improved to provide more informative messages.
Further Exploration:

Explore existing Vim plugins that might offer similar functionality or Roman numeral manipulation capabilities.
If you're comfortable with Vim scripting, consider developing a custom plugin for a more integrated solution.
This approach allows you to add Roman numeral manipulation functionality to Vim and enhance your workflow when dealing with technical documents. Remember to adapt the script to interact with Vim's selection mechanism for practical use.

}}}

https://stackoverflow.com/questions/12128678/vim-go-to-beginning-end-of-next-method#12128868
https://vim.fandom.com/wiki/Jumping_to_the_start_and_end_of_a_code_block

https://github.com/JetBrains/ideavim
https://www.jetbrains.com/help/idea/using-product-as-the-vim-editor.html#vimrc
  https://www.jetbrains.com/help/rider/mastering_keyboard_shortcuts.html
--
https://blog.jetbrains.com/dotnet/2019/02/14/writing-plugins-resharper-rider/

So now we're going to make some interesting little tests here.

http://vimcasts.org/episodes/search-multiple-files-with-vimgrep/
https://vim.fandom.com/wiki/Search_on_all_opened_buffers

https://vimdoc.sourceforge.net/htmldoc/usr_toc.html
https://vimdoc.sourceforge.net/htmldoc/help.html#reference_toc
  https://vimdoc.sourceforge.net/htmldoc/usr_41.html#41.9  #exceptions[!!]
.  VIMREFMAN_PROJLAST2021PLUS {{{

    VIMREFMAN_PROJLAST2021PLUS   #++(maybe start w. quick vankisetting/review of NETRW 2021(***(*!!))
            VIM REFMAN GENOMLYSSN. 1 - 2019 (***!)      (=index för definitiv genomlyssn. o sättn. 2020 +/slut (**!)

~/dropbox-legacy/vim/doc/rileft.txt
 ~/dropbox-legacy/vim/doc/digraph.txt
 ~/dropbox-legacy/vim/doc/arabic.txt
 ~/dropbox-legacy/vim/doc/farsi.txt
 ~/dropbox-legacy/vim/doc/hangulin.txt
 ~/dropbox-legacy/vim/doc/hebrew.txt
 ~/dropbox-legacy/vim/doc/russian.txt


    ~/dropbox-legacy/vim/doc/usr_toc.txt
    ----
    a. general subjects:
        ~/dropbox-legacy/vim/doc/intro.txt
        ~/dropbox-legacy/vim/doc/help.txt      #INDEX ÖVER REFMAN, FRÄMST SEKTIONERNA 'BASIC/ADVANCED EDITING' *****
        ~/dropbox-legacy/vim/doc/helphelp.txt
        ~/dropbox-legacy/vim/doc/index.txt     #GÅ EV IGENOM 'SQUARE BRACKET COMMANDS'++ EN G. TILL EFTER
                                        # REF-M.GENOMGÅNG 1 2019 KLAR ****  (+excommands senare)
                                            #=innehåller listan på alla excommands(**)
        help-tags(??)
        ~/dropbox-legacy/vim/doc/howto.txt     #kort sammanst. ='var hittar info om edit-compile-cycle mm' (edit/compile =usr30.1) ******
        ~/dropbox-legacy/vim/doc/tips.txt ***********  ___EXEMPELKOD_VSCR2019
        . {{{
                Editing C programs                      |C-editing|     *********
                Finding where identifiers are used      |ident-search|  ******  ___VIMSCRCODE_HARDWNEXT_2019
                Switching screens in an xterm           |xterm-screens|
                Scrolling in Insert mode                |scroll-insert|
                Smooth scrolling                        |scroll-smooth|
                Correcting common typing mistakes       |type-mistakes|
                Counting words, lines, etc.             |count-items|
                Restoring the cursor position           |restore-position|
                Renaming files                          |rename-files|  ***** 'processing list of files etc. w. shell' ******
                Change a name in multiple files         |change-name|   'source a file w. substitutions + write from other files' **********
                Speeding up external commands           |speed-up|
                Useful mappings                         |useful-mappings|
                        'incremental' mapping, to format a bulleted list ****   ___SEMER EV
                Compressing the help files              |gzip-helpfile|
                Executing shell commands in a window    |shell-window|      neovim (**)
                Hex editing                             |hex-editing|       (t.ex. pinkjuice_xml: process files w. Autocmds/gör vissa inställn. för vissa filer)
                Using <> notation in autocommands       |autocmd-<>|
                Highlighting matching parens            |match-parens|      ___VIMSCRCODE_HARDWNEXT_2019  ****
        }}}
                            #GÅ IGENOM EN. G. TILL DEF.***** NÄR LYSSNAT KLART HELA, NR 1
        ~/dropbox-legacy/vim/doc/message.txt   (=errmessages)      +kort lista 'less-lika' kommandon när läser meddelanden(**)
                             ~/dropbox-legacy/vim/doc/quotes.txt
    b. basic editing:
        ~/dropbox-legacy/vim/doc/starting.txt      'start vim from the shell'-options, :mkvimrc (**)       #+view, session, viminfo*
        ~/dropbox-legacy/vim/doc/editing.txt       #backup, patchmode, backupext;  edit, find(**!) mm;  ? * [a-e] ** (<-- !!=recurse into dirs*******) {{{
                                             ++opt
                                             :confirm w fil.txt
                                                g:/b:browsefilter;  enrcypt,  timestamp;  '11. FILE SEARCHING********* ('**' / 'superstar', **2, ++)
        }}}
        ~/dropbox-legacy/vim/doc/motion.txt        #'motions + operators****', forcing motion w. v-mode ***** ___SEMER , marks (= m[ och m< t.ex.) + keepjumps, lockmarks mm
        ~/dropbox-legacy/vim/doc/scroll.txt        # <ScrollWheelUp> <ScrollWheelDown>
        ~/dropbox-legacy/vim/doc/insert.txt            ___VIMSCRCODE_HARDWNEXT_2019 x3+fler**(3=OMNIfunc-complet**)  break/not break undo ****, {{{
                                                MATA IN TEXT INNAN/EFTER EN(!!!) AV FLERA KOLUMNER (****) c-g_j/k ****??
                                              expandtab, smarttab, softtab, bs_c-w_c-u i replacemode*, gR *****;  INSERTMODE COMPLETION ****** (tags, vim cline m.fl. ****)
                                              C-X C-N/P ********, -->  dictionary, THESAURUS*,  keyword, tag, macro (cx ci, cx c] ***, cx cd)   cx cu, cx co ***, cx cs *
                                              SCRIPT-LINECONTINUATION (   \ mm ), :startinsert, :startreplace mm (*), :0r
        }}}
        ~/dropbox-legacy/vim/doc/change.txt        :d, :j, :c,  g c-a/c-x ***********,  :s/\v<(.)(\w*)/\u\1\L\2/g  ****  +MAKRO-EXEMPEL *****,  :sno :sm *****  +SUBST-EXEMPEL ********, {{{
                                             'SUBSTITUTE WITH AN EXPRESSION'****, (FORMATTING AND FORMATTINGOPTIONS =kommentarer i progr.språk),        sort
        }}}
        ~/dropbox-legacy/vim/doc/indent.txt  (=indentering för c(o.likn.) programmering (cpp, java mm)****) {{{
                                            (cindent, indentexpr) (+?????)+specialla spec.strängen(**)      js,  clojure   ___VIMSCRCODE_HARDWNEXT_2019
        }}}
        ~/dropbox-legacy/vim/doc/undo.txt          undo: (undojoin, )   :undolist, g- g+, earlier//later   undo persistence (='undofile' option(**))  :wundo/:rundo  +SCRIPT**
        ~/dropbox-legacy/vim/doc/repeat.txt        # :g!/    :@:  :@@ {{{
                                            :so file ******     :so! file ** (=nmode-commands)      :runtime (ev se mer)
                                                    :scriptnames   :finish      <sfile> ***?    LINE CONTINUATION *******
                                            vim debugger: vim -D file.txt ****   verbose mode       :profile
        }}}
        ~/dropbox-legacy/vim/doc/visual.txt        gn *****    :vmap / y/<C-R>"<CR>  #=liknande visualstar     + :vmap X y/<C-R>"<CR>    (+select mode)
        ~/dropbox-legacy/vim/doc/various.txt       ga ****  8g8  :redir **** (GÅR ATT SKICKA TILL FILER, CLIPBOARD O REGISTER, MM MM)****** {{{
                                            := :.(??) :#  :#!  :normal! ****** (beaktar ej mappings) **
                                             :version, inkl. +cindent, +cscope mm mm
                                            :silent  :unsilent      :verbose    :sleep      $VIMRUNTIME/macros/less.sh
        }}}
        ~/dropbox-legacy/vim/doc/recover.txt       vim -r filename   :swapname
    c.** advanced editing:
        ~/dropbox-legacy/vim/doc/cmdline.txt (*****=EV LYSSNA IGENOM EXAKT IGEN TOTAL /#####)      #000_vimrefman-c01 {{{
                                            c-\ e (expression)      :hist :keepp
                                            Command-line Completion: c-d  tab  c-a c-l  (+wildmode mm)      cmd1 | cmd2 (med Examples ****)   +  :execute 'r !ls' | '[   mm
                                                    :%g/foo/p|>     moves all matching lines one shiftwidth
                                                    :%s/foo/bar/|>      moves one line one shiftwidth
                                            adresses/ranges***:  5;/that line/      \/ \? || \&     förra rad där förra sök/ersättn.mönster matchar             *********
                                            'Sök efter X'*****(men markören kvar):  /pat1//pat2/  7;/pat2/      .+3  /that/+1  .,$  0;/that  1;/that
                                             some commands (that do not accept file name args) can take a count****:  :s/x/X/g 5   :23d 4   ********
                                             reverse range (=promt el. 'silent' för no prompt) **       3:d  mm                 :*  =kortform för  :'<,'>  *****
                                             flags  l # p           spec.chars:  %  #  #3(osv)(=buf 3)  ##(=all names in arg-list*****)  #<3(=oldfile nr 3 (:oldfiles o. v:oldfiles)((+':p' för abs.path))
                                                    :p 
                                                    :~ 
                                                    :.  
                                                    :h 
                                                    :t 
                                                    :r 
                                                    :e 
                                                    :s?pat?sub?
                                                    :gs?pat?sub?
                                                    :S

                                                    t.ex.
                                                    :!dir <cfile>:S
                                                    :call system('chmod +w -- ' . expand('%:S'))


                                            :<cword> :<cWORD> :<cfile> <cfile>  ******  ___SEMER2019  ___SEMER2019
                                            :<sfile> <sfile> :<afile> <afile>
                                            :<abuf> <abuf> :<amatch> <amatch>
                                            <slnum>

                                            q: q/  c-f ****     spara ut dessa specialfönster =går att skriva till fil med :w som vanl ***
        }}}
        ~/dropbox-legacy/vim/doc/options.txt   #000_vimrefman-c02 {{{
                                            KOLLA SENARE:  1. SETTING OPTIONS *****     :set opt?   :set opt! **    :set opt&   :set opt&vim    :set all&    ********** (+NÅGRA FLER*****)  set opt+=0x34da
                                                :set ai nosi sw=3 ts=3
                                                verbose ****
                                            modelines ('modeline vim')   xxxxxxxx vim: options-list(:xxxxxxxx)     t.ex.   /* vim: set ai tw=75: */
                                                    vim704:  vim>700:   ___VIMSCRCODE_HARDWNEXT_2019  ___AUTCOMMANDS        au BufReadPost * if getline(1) =~ "VAR" | call SetVar() | endif
                                            + i Options:  ___VIMSCRCODE_HARDWNEXT_2019
                                                    autochdir
                                                     cindent
                                                    complete
                                                    completefunc, omnifunc,  operatorfunc (=g@)
                                                    completeopt (=menu, longest mm)
                                                     cscopepathcomp
                                                    cscopeprg  cscope*
                                                    define  (='pattern to be used to find a macro definition')****
                                                    dictionary
                                                     diffexpr
                                                       digraph
                                                            directory (=var swapfiler läggs) ***
                                                     encoding
                                                        equalalways
                                                    equalprg
                                                        errorfile
                                                        eventignore
                                                        exrc
                                                            fileignorecase
                                                    filetype
                                                            fillchars
                                                    foldclose  + fold*  *****       foldmarker
                                                     format* (t.ex. formatprg (=för gq))
                                                    guifont (***)
                                                     helplang
                                                        *hidden
                                                     indentkeys
                                                    infercase, smartcase,  smartindent  softtabstop  tabstop
                                                    isfname (***)
                                                    isident, iskeyword, isprint
                                                        joinspaces
                                                                keywordprg
                                                        langmap(??)
                                                    wrapmargin, textwidth,, linebreak   wrap, wrapmargin
                                                    lisp (**)
                                                    make* ****
                                                    matchpairs **
                                                    nrformats  (=för c-a/c-x) *
                                                    NUMBER
                                                     packpath
                                                        paste*
                                                     patchexpr
                                                    backupdir mm  + patchmode ***       writebackup
                                                    path ***
                                                        printexpr, printfont, printheader  printoptions
                                                    pumheight
                                                        relativenumber
                                                    revinsert, rightleft*
                                                        runtimepath
                                                      scroll*
                                                    shell, shellpipe(=gällande make)
                                                    SHIFTWIDTH
                                                     shortmess
                                                        show* (t.ex. showfulltag
                                                    spell**  thesaurus
                                                     suffixes
                                                    suffixesadd
                                                       tabpagemax
                                                    tag* (**)
                                                        undofile, undodir
                                                    verbose, verbosefile
                                                            viewdir
                                                        viminfo
                                                            virtualedit
                                                        whichwrap
                                                    wildignore
                                                        wildmenu
                                                    wildmode
        }}}
___VREFMAN2019LYSSN
            ___snabbkollilistan_somm2019
        ~/dropbox-legacy/vim/doc/pattern.txt       #000_vimrefman-c03 {{{
                                             /test 1/;/test   mm *****          /\%>199l\%<300llimit   #sök mellan raderna 200 och 300 ***** (el. subst. med gc *****)
                                              TERMINOLOGI (branch, concat, piece, atom)         spec.tecken för att välja regex-motor
                                               \v \M \V     #regex, ren text, strängar m. spec.tecken(??)
                                               \s \_s  . \_.    \_[a-f]
                                                            |/\%^|  \%^ \%^ beginning of file |/zero-width|     *E71*
                                                            |/\%$|  \%$ \%$ end of file |/zero-width|
                                                            |/\%V|  \%V \%V inside Visual area |/zero-width|
                                                            |/\%#|  \%# \%# cursor position |/zero-width|
                                                            |/\%'m| \%'m    \%'m    mark m position |/zero-width|
                                                            |/\%l|  \%23l   \%23l   in line 23 |/zero-width|
                                                            |/\%c|  \%23c   \%23c   in column 23 |/zero-width|
                                                            |/\%v|  \%23v   \%23v   in virtual column 23 |/zero-width
                                              char-classes (= \a \d \D mm *****)
                                                \Z (=för hebrew/arabic) +ev  été\Z  (=hittas med /ete)      + \%C
                                                            |/\%d|  \%d \%d match specified decimal character (eg \%d123)
                                                            |/\%x|  \%x \%x match specified hex character (eg \%x2a)
                                                            |/\%o|  \%o \%o match specified octal character (eg \%o040)
                                                            |/\%u|  \%u \%u match specified multibyte character (eg \%u20ac)
                                                            |/\%U|  \%U \%U match specified large multibyte character (eg
                                                                        \%U12345678)
                                                            |/\%C|  \%C \%C match any composing characters
                                                'multi items'   (=främst 'så få som möjl' = \{-} m.fl. *******
                                                        +LOOKAHEAD/LOOKBEHIND
                                                \%(\)   =räknas ej in i \1, \2 osv  ***
                                                 [:alpha:] m.fl. ***

                                                 \%[]       OPTIONALLY MATCHED ATOMS *********   ___SEMER2019 EV

                                                ref: vim vs perl regex-syntax

                                                    \&  ___SEMER2019  ___SEMER2019  ___SEMER2019


                                                ev senare:  :match :2match :3match  (=????)
        }}}
        ~/dropbox-legacy/vim/doc/map.txt           #000_vimrefman-c04 {{{
                                             "<buffer>", "<nowait>", "<silent>", "<special>", "<script>", "<expr>" and
                                             "<unique>" can be used in any order.  They must appear right after the
                                             command, before any other arguments.  ___SEMER2019  ___SEMER2019  ___SEMER2019 
                                                ___VIMSCRCODE_HARDWNEXT_2019
                                             <C-U>  =FÖR O-MAPS ***********
                                                To enter a mapping for Normal and Visual mode, but not Operator-pending mode,
                                                first define it for all three modes, then unmap it for Operator-pending mode:
                                                    :map    xx something-difficult
                                                    :ounmap xx
                                                Likewise for a mapping for Visual and Operator-pending mode or Normal and
                                                Operator-pending mode.  *****
                                             :lmode
                                             '1.4 listing mappings'     rhs spec-chars  (*, &, @)
                                             Mapping Special Keys: vi-notation (<Esc> mm, direkt el. med c-v+tryck Esc), c-k Esc, 'termcap entry'       #sista två met. funkar förmodl. bättre på olika terminaler mm

                                              <Bslash> <Space> <Nop> <Space>

                                            <SID>     <Plug>
                                                To map a character by its decimal, octal or hexadecimal number the <Char>
                                                construct can be used:
                                                        <Char-123>  character 123
                                                        <Char-033>  character 27
                                                        <Char-0x7f> character 127
                                                        <S-Char-114>    character 114 ('r') shifted ('R')
                                            <Bar>  (el. specialsekvensen)
                                             (+'kolla ev ''index'' för att hitta bra tangenter att koppla'

                                            Se Mer: Multiplying count (***)     #=konkateneras; anv. expr.register i mapping för att få multipl. istället

                                            SE MER: 'MAPPING AN OPERATOR' *******  ___SEMER2019  ___SEMER2019  ___SEMER2019    ___VIMSCRCODE_HARDWNEXT_2019
                                             (= g@, VIMSCRHARDW MM *******)

                                            SE MER 2******: 2. ABBREVIATIONS **********     <SID>
                                                        :scriptnames (**)

                                            4. User-defined (Ex) Commands

                                                Custom completion
        }}}
        ~/dropbox-legacy/vim/doc/tagsrch.txt       #000_vimrefman-c05
        ~/dropbox-legacy/vim/doc/quickfix.txt      #000_vimrefman-c06
            :cdo  + :make, :vimgrep / :grep    compiler     error format            the dir-stack
        ~/dropbox-legacy/vim/doc/windows.txt       #000_vimrefman-c07      (=windows, splits mm *)
                :vertical   rightbelow  botright  mm mm *******         :sall, :snext  mm ***       windo bufdo
                10. the preview window (**)     ___VIMSCRCODE_HARDWNEXT_2019
                   hidden buffers
        ~/dropbox-legacy/vim/doc/tabpage.txt       #000_vimrefman-c08
                :tabfind   :tabonly   :tabmove +/-      :tabdo      (tabline  ___VIMSCRCODE_HARDWNEXT_2019 )
        ~/dropbox-legacy/vim/doc/syntax.txt        #000_vimrefman-c09  (=syntax highlighting*)     ( ___VIMSCRCODE_HARDWNEXT_2019 ) {{{
                :so $VIMRUNTIME/syntax/c.vim
                :au Syntax cpp   runtime! syntax/cpp.vim        $VIMRUNTIME/syntax/synload.vim
                 MAKING YOUR OWN SYNTAX FILES
                  ADDING TO AN EXISTING SYNTAX FILE
                  replacing an existing syntax file
                Naming Conventions
                - - - - - - - - -
                - - - - - - - - -
                2HTML (*****)                   :runtime! syntax/2html.vim                  BASH: for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
                    :10,40TOhtml " convert lines 10-40 to html
                  :'<,'>TOhtml " convert current/last visual selection
                  :TOhtml      " convert entire buffer
                    ANT + syntax (=perl m.fl. skriptspråk)
                    C m.fl. m.fl. (****####)
                            JAVA
                            mail
                            POSTSCRIPT
                            Readline
                          SH  (=SYNTAX FOLDING MM ****)
                            'embedding awk code in sh'(***)
                        TEX ****
                    VIM (=folding för functions, python, lua mm (**))
                    XML *****
                     ----
                    DEFINING KEYWORDS mm (DEFINING MATCHES, DEFINING REGIONS)
                    syntax arguments
                    syntax patterns
                    syntax clusters
                        including syntax files
                        synchronizing --"--
                    Listing Syntax Items (**)
                     highlight command
                     linking groups
                      cleaning up
        }}}
        ~/dropbox-legacy/vim/doc/spell.txt         #000_vimrefman-c10      ****** ( ]s mm)  :mkspell  Rare Words + COMPOUNDING(*)
        ~/dropbox-legacy/vim/doc/diff.txt          #000_vimrefman-c11 {{{
            vimdiff  vim -d   gvimdiff          diffsplit diffthis diffpatch  (:vert)       ]c ****   do dp
             'Finding the differences'    +  'Using Patches'
        }}}
        ~/dropbox-legacy/vim/doc/autocmd.txt       #000_vimrefman-c12
        ~/dropbox-legacy/vim/doc/filetype.txt      #000_vimrefman-c13
        ~/dropbox-legacy/vim/doc/eval.txt  #=innehåller listan på alla vimfunctions(**)    #000_vimrefman-c14 {{{
                vartypes: num, float, string, List, Dict, funcref, special(=v:var), job, channel
                    'functions that can be used within a dictionary'
                  expressions and their syntax
                (YTTERL. EXEMPEL PÅ LINE CONTINUATION)
                short curcuit
                COMPARISON
                        if a =~ "\\s*"      #patterns ****
                @r
                    special-variablerna
                      b:
                      w:
                      t:    #local to current tab page

                      g:

                      l:
                      s:
                      a:

                      v:
                ___VIMSCRCODE_HARDWNEXT_2019 ___VIMSCRCODE_HARDWNEXT_2019

                LISTA FÖRDEFINIERADE VIMVARIABLER (v:vars )

                4. LISTAN BUILTIN FUNCTIONS ********        (=index-lista  +  därefter förklaringar, beskrivning och EXEMPEL ******)            SORTERA SENARE EGNA LISTAN HÄR I FILEN {{{
                                                                                                                                                =FRÅN FÖRSTA FÖRSÖKET TILL SLUTSÄTTN./SAMMANST. 2018 (*******)
                    mkt kort utplock några ev intress. först(**):
                        type( ****
                            input(   ****** inputdialog(, inputlist(
                        complete(
                        (ch_*(
                        copy(, deepcopy(
                         len(, strchars(
                        extend(     # append( ??    get(        index(      insert(     items(  join(   keys(       map(        range(          remove(     reverse(        split(      uniq(   values(
                         exists(
                        expand(  *****      pathshorten(    shellescape(        resolve(
                            toupper/lower(
                         filereadable/writeable(    isdirectory(            system( (=få output från ett skalkommando ****), systemlist(
                          localtime(, reltime(, strftime(   tempname(   writefile(
                        mkdir( *
                        filter(
                            finddir(, findfile(     rename(  setfperm(
                             hostname(
                          globpath(
                        fnameescape(
                        fold*( (t.ex. foldclosed(  )
                         function(      ___VIMSCRCODE_HARDWNEXT_2019
                        garbagecollect(
                        getcmdline(, getcmdpos(, getcmdtype(    getcurpos(, getline(    getpos(     line(
                         getfperm(, getftime(, getftype(
                        getloclist(, getqflist(     setloclist(
                         :match, matchadd(, gatmatches(
                        getpid(
                         getreg(, getregtype(       setreg(     (t.ex. :call setreg(
                        getwinvar(
                        glob(, glob2regpat(
                         has(   #kolla vimversion mm ***
                        haslocaldir(        hasmapto(
                        histadd(,  histdel(
                        hlexists(
                        indent(, shiftwidth(
                        js_/json_*
                         mapcheck( *
                        match( (+ev match*(  ), matchstr(   *****       matchlist(          next/prevnonblank(          SEARCH( (=regex)
                            searchdeclar(,  searchpair(      submatch(, substitute( ******
                         max(, min(, log(, round(, trunc(  mm
                        mode(
                         *eval(  (=lua, mzscheme, py/py3
                        printf(
                        readfile(
                         repeat(
                        setbufvar(
                            sha256( (=checksum för string)
                        sort(
                          stridx(, string(, strlen(, strpart(
                                tagfiles(, taglist(, 
                                (WIN*(  )
                }}}

            DEFINING FUNCTIONS *****
                    :function!
                     :endfunction
                    return 1
            CURLY BRACES NAMES
                    One application for this is to create a set of variables governed by an option
                    value.  For example, the statement >
                        echo my_{&background}_message

                    would output the contents of "my_dark_message" or "my_light_message" depending
                    on the current value of 'background'.       (+Se Mer)

            Commands
                let, if, else, try, EXE(CUTE), ECHO, ECHOM, echoerr

            Exception Handling
                try / catch / finally / endtry
                :throw

            CLEANUP CODE (BORROWING/RESETTING GLOBAL VARIABLES)

            CATCHING INTERRUPTS
                "Vim:Interrupt"
            catching all

            Exceptions and Autocommands (=catching exceptions during execution of autocommands)

            exception hierarchies and parameterized exceptions(=??)

            EXAMPLES  ___VIMSCRCODE_HARDWNEXT_2019  ***

            Sandbox
              textlock
        }}}
        ~/dropbox-legacy/vim/doc/fold.txt  #=innehåller listan på alla vimfunctions(**)    #000_vimrefman-c15
                    TIPS O. FÖRSLAG =för anv. av Markers när viker Progr.kod *****
                     :folddoopen :folddoclosed  ******
                    Color, Foldtext m.fl. custom-inställn. ***
    ----
    d. special issues:
        ~/dropbox-legacy/vim/doc/print.txt (??)    (Duplex mm  +  GHOSTSCRIPT O. POSTSCRIPT  ('GHOSTSCRIPT KAN VISA O. SKRIVA UT POSTSCRIPT O. (OCH SKAPA) PDF')  ******** ___SEMER2019
        ~/dropbox-legacy/vim/doc/remote.txt        (=remote o. server (????))
        ~/dropbox-legacy/vim/doc/term.txt (??)     (=terminal)
        digraph(??)
        mbyte(??)
         ~/dropbox-legacy/vim/doc/mlang.txt (?)        (using messages and menus in various languages)
        ~/dropbox-legacy/vim/doc/ft_sql.txt (??)   matchit     anv. av vanliga cmds för att flytta i koden  (= ']]' m.fl. *****)
                                             hitta 'macro definitions' ****         SetType         3.Adding new SQL dialects ***
                                            OMNI SQL COMPLETION ****(+ev överför till andra språk ****)         +TUTORIAL OCH MAPPINGS ********
    e. ** interfaces:
        ~/dropbox-legacy/vim/doc/if_cscop.txt  ***********     :cscope  :cs    (+TILLÄGG FÖR .VIMRC ****), cscopetag  + mappings **
        ~/dropbox-legacy/vim/doc/if_lua.txt        =likn. python-bridge nedan
        ~/dropbox-legacy/vim/doc/if_pyth.txt       # 'EXECUTE PYTHON SCRIPT'  ___VIMSCRCODE_HARDWNEXT_2019  =python   + :py3 etc
        ~/dropbox-legacy/vim/doc/debugger.txt      #integrate with gdb(??), netbeans etc(=????)
        ~/dropbox-legacy/vim/doc/netbeans.txt
        ~/dropbox-legacy/vim/doc/sign.txt
    f. standard plugins:
        ~/dropbox-legacy/vim/doc/pi_logipat.txt    ???
        ~/dropbox-legacy/vim/doc/pi_netrw.txt      *********** SPEC. (=SE MER) 'BROWSING')*********
        ~/dropbox-legacy/vim/doc/pi_paren.txt      matchit-plugin ********
        ~/dropbox-legacy/vim/doc/pi_tar.txt
        ----
        ~/dropbox-legacy/vim/doc/pi_getscript.txt


    ~/dropbox-legacy/vim/doc/channel.txt
    ~/dropbox-legacy/vim/doc/develop.txt
    ~/dropbox-legacy/vim/doc/debug.txt
    ~/dropbox-legacy/vim/doc/quickref.txt
    ~/dropbox-legacy/vim/doc/todo.txt
    ~/dropbox-legacy/vim/doc/mbyte.txt
    ~/dropbox-legacy/vim/doc/gui.txt
    ~/dropbox-legacy/vim/doc/version4.txt
    ~/dropbox-legacy/vim/doc/version5.txt
    ~/dropbox-legacy/vim/doc/version6.txt
    ~/dropbox-legacy/vim/doc/version7.txt
    ~/dropbox-legacy/vim/doc/vi_diff.txt
    ~/dropbox-legacy/vim/doc/workshop.txt

    ~/dropbox-legacy/vim/doc/gui_w32.txt
    ~/dropbox-legacy/vim/doc/gui_x11.txt
    ~/dropbox-legacy/vim/doc/ft_ada.txt
    ~/dropbox-legacy/vim/doc/if_mzsch.txt
    ~/dropbox-legacy/vim/doc/if_ole.txt
    ~/dropbox-legacy/vim/doc/if_perl.txt
    ~/dropbox-legacy/vim/doc/if_ruby.txt
    ~/dropbox-legacy/vim/doc/if_sniff.txt
    ~/dropbox-legacy/vim/doc/if_tcl.txt
    ~/dropbox-legacy/vim/doc/uganda.txt
    ~/dropbox-legacy/vim/doc/sponsor.txt

    ~/dropbox-legacy/vim/doc/os_390.txt
    ~/dropbox-legacy/vim/doc/os_amiga.txt
    ~/dropbox-legacy/vim/doc/os_beos.txt
    ~/dropbox-legacy/vim/doc/os_dos.txt
    ~/dropbox-legacy/vim/doc/os_mac.txt
    ~/dropbox-legacy/vim/doc/os_mint.txt
    ~/dropbox-legacy/vim/doc/os_msdos.txt
    ~/dropbox-legacy/vim/doc/os_os2.txt
    ~/dropbox-legacy/vim/doc/os_qnx.txt
    ~/dropbox-legacy/vim/doc/os_risc.txt
    ~/dropbox-legacy/vim/doc/os_unix.txt
    ~/dropbox-legacy/vim/doc/os_vms.txt
    ~/dropbox-legacy/vim/doc/os_win32.txt
    ~/dropbox-legacy/vim/doc/pi_gzip.txt
    ~/dropbox-legacy/vim/doc/pi_spec.txt
    ~/dropbox-legacy/vim/doc/pi_vimball.txt
    ~/dropbox-legacy/vim/doc/pi_zip.txt

    ~/dropbox-legacy/vim/doc/usr_01.txt
    ~/dropbox-legacy/vim/doc/usr_02.txt
    ~/dropbox-legacy/vim/doc/usr_03.txt
    ~/dropbox-legacy/vim/doc/usr_04.txt
    ~/dropbox-legacy/vim/doc/usr_05.txt
    ~/dropbox-legacy/vim/doc/usr_06.txt
    ~/dropbox-legacy/vim/doc/usr_07.txt
    ~/dropbox-legacy/vim/doc/usr_08.txt
    ~/dropbox-legacy/vim/doc/usr_09.txt
    ~/dropbox-legacy/vim/doc/usr_10.txt
    ~/dropbox-legacy/vim/doc/usr_11.txt
    ~/dropbox-legacy/vim/doc/usr_12.txt
    ~/dropbox-legacy/vim/doc/usr_20.txt
    ~/dropbox-legacy/vim/doc/usr_21.txt
    ~/dropbox-legacy/vim/doc/usr_22.txt
    ~/dropbox-legacy/vim/doc/usr_23.txt
    ~/dropbox-legacy/vim/doc/usr_24.txt
    ~/dropbox-legacy/vim/doc/usr_25.txt
    ~/dropbox-legacy/vim/doc/usr_26.txt
    ~/dropbox-legacy/vim/doc/usr_27.txt
    ~/dropbox-legacy/vim/doc/usr_28.txt
    ~/dropbox-legacy/vim/doc/usr_29.txt
    ~/dropbox-legacy/vim/doc/usr_30.txt
    ~/dropbox-legacy/vim/doc/usr_31.txt
    ~/dropbox-legacy/vim/doc/usr_32.txt
    ~/dropbox-legacy/vim/doc/usr_40.txt
~/dropbox-legacy/vim/doc/usr_41.txt
    ~/dropbox-legacy/vim/doc/usr_42.txt
    ~/dropbox-legacy/vim/doc/usr_43.txt
    ~/dropbox-legacy/vim/doc/usr_44.txt
    ~/dropbox-legacy/vim/doc/usr_45.txt
    ~/dropbox-legacy/vim/doc/usr_90.txt

}}}
doks init {{{
    ~/dropbox-legacy/scripts/ALLTODOIST/aa_VIMEMACS.bash
    --
    ~/dropbox-legacy/vim.orig.txt
    ~/dropbox-legacy/vim.txt

    vimtouch/droidvim {{{

        droidvim
            hemmapp droidvim
            /data/data/com.droidvim/files/home
            Filer med macros, spell, colors mm *****
            Android > data > com.droidvim > files > runtime

            vimrc
            ~/.vimrc    #******

    }}}
}}}
.   ~/Dropbox/.vimrc {{{
      new c-map:
          cnoremap <leader>av <Home>\v<End>
      new maps
          c_,av | ,aV       add \v | \V at start of search
          ,scj              Count search-matches Below(!) point|position(!)
    }}}
checkable ref-lists [!!] {{{
~/Dropbox/rsc/data/lists/ref/comp/Vim-Tocs.txt  #+TODO: START FILLING WITH FUNCTIONS FOR THE NEOVIM LUA API(**** etc)

~/Dropbox/rsc/data/lists/ref/comp/nvim-lua.txt  #+TODO: START FILLING WITH FUNCTIONS FOR THE NEOVIM LUA API(**** etc)

~/Dropbox/rsc/data/lists/ref/comp/vim-aucmdevents.txt
~/Dropbox/rsc/data/lists/ref/comp/vimbash-hotkeys.txt
~/Dropbox/rsc/data/lists/ref/comp/vim_excommands-functions.txt
~/Dropbox/rsc/data/lists/ref/comp/vim-patternregex.txt
~/Dropbox/rsc/data/lists/ref/comp/cb/regex-vim.txt
~/Dropbox/rsc/data/lists/ref/comp/vimpickouts21end-uman_pract_exfs-man.txt
~/Dropbox/rsc/data/lists/ref/comp/vimplugins.txt
--
~/Dropbox/rsc/data/lists/ref/comp/vimscrhardw-quickindex.txt
}}}
Ref[!!] {{{
    https://www.vim.org/community.php
    https://vim.fandom.com/wiki/Vim_on_Libera_Chat
Vim Plugins: eg. TPope [**] {{{
  https://github.com/tpope/dotfiles/blob/master/.vimrc
  --
  https://github.com/tpope?tab=repositories
  https://github.com/tpope/vim-sleuth/blob/master/plugin/sleuth.vim
  https://github.com/tpope/vim-eunuch/blob/master/plugin/eunuch.vim
  https://github.com/tpope/vim-sensible/blob/master/plugin/sensible.vim
https://duckduckgo.com/?q=github+vim+submode&t=newext&atb=v369-1&ia=web
    https://github.com/vim-scripts?tab=repositories
  https://github.com/kana?tab=repositories
  --
  https://github.com/kana/vim-submode/blob/master/autoload/submode.vim
  --
  https://github.com/tpope/dotfiles **
  https://github.com/tpope/dotfiles/blob/master/.bashrc
  https://github.com/tpope/dotfiles/blob/master/.lessfilter
    https://github.com/tpope/dotfiles/blob/master/.lesskey
  https://github.com/tpope/dotfiles/blob/master/.muttrc
    https://github.com/tpope/dotfiles/blob/master/.zshrc
}}}

~/Dropbox/rsc/samples/code/vim/Vimscript-PluginCodesamples_Index.txt   #NEW: 2023 ****

TODO: INCLUDE NEOVIM API FUNCTIONS LIST (should be similar in format to blendpy_functions-list =straight simple list for reflists-type checkability)
+Idea: Start off by picking checked (and mentioned) ones in nvim-lua.txt
    and later indent off these when finding + pulling in the complete list

https://github.com/erikw/vim-keybindings-everywhere-the-ultimate-list
    https://github.com/mattmc3/neovim-cheatsheet

termer-terms-begrepp-nyckelord {{{
    undo-branch/undo-gren ***** {{{
        en ny undo-gren startas när
        gått tillbaks m undo
        och sen gör fler ändringar
        --
        dessa nya ändringar (de då nuvarande)
        är en ny undogren ****
    }}}
    buffer *** {{{
        =en fil som redigeras =inlästa kopian som vim redigerar
    }}}
    operator {{{

        c
        d  deleteoperator
         y
        gu / gU   g~
        > <
        =
        !

    }}}
    motion vs jumps {{{
         motions är inom fil (+vissa motions klassas också som jumps)
        G
        $
         OBS! c-o/c-i är inte motions (=kan inte anv. föratt utöka vis. el för op.pending-mode **)

         jumps kan också vara mellan(!) filer
    }}}
    textobjekt {{{
    }}}
    buffer {{{
        the loaded filerepresentations in your list (:ls o :args)
    }}}
    tag {{{
        =en |hyperlänk| som går att följa (t.ex.)
    }}}
    foldlevel {{{
        sätts med zm bl.a.
        foldlevel 0   =stäng alla(!) folds
    }}}
    foldenable
    exclusive (delete)
    inclusive (delete) {{{
        t.ex. d$  =suddar t.o.m. radslutet(!)
    }}}
    system clipboard {{{
        "+
    }}}
    primary clipboard {{{
        =selection  (alltså "*)
    }}}
}}}

.  VIM/VIMSCRIPT #######*******  (=tags och tags-systemet (=senaste utkastet från ankifil/index)) {{{

    vim
        options
        ----
        teoriterm
        help
        session grundspara
        files buffers
        recover
        movement
        block textobj
        mark
        wintabsplit
        folding
        complet
        spellcheck
        registers
        hyperlinks
         (textmode mm/olikn)
        gitcvs
        diff
        netrw
        debug
        egcmd
            specialavanc

~/Dropbox/ankisource2018_vimscript.txt

    ___0000

                (#feoav =funct ex opt au vvars)
        tagscscope
        argwintabbufdo
        scripttricks    #infoga stigande räknare mm/olikn
         writeread
        substitute 
        global
        filter
        maps
        oppending
        execute
        vimscript
        .       vfunction       http://vimdoc.sourceforge.net/htmldoc/usr_41.html#41.6 {{{
                exe()
                call()  ___count =2
                    =http://vimdoc.sourceforge.net/htmldoc/usr_41.html mitt, precis innan 'lists and dictionaries'
                libcall()
                libcallnr()
                 eventhandler()
                function()
                has()
                 getpid()
            .           args {{{
                argc()
                argidx()
                argv()
            }}}
            .           listdict {{{
                filter()
                add()
                append()
                count()
                extend()
                insert()
                deepcopy()
                get()
                has_key()   #d
                items()     #d
                keys()      #d
                values()    #d
                index()
                join()      #l
                len()       #l **
                map()       #l **
                max()       #l
                min()       #l
                range()     #l  ___count =1
                remove()    #l
                reverse()   #l
                sort()      #l
                split()     #l
                string()    #l
            }}}
            .           strings {{{
                tr()
                eval()  #evaluate expression **  ___count =2
                    :let optval = eval('&' . optname)
                match()         #sök i en sträng *
                matchend()
                matchstr()
                matchlist()
                printf()
                repeat()
                strchars() (?)
                strdisplaywidth() (?)
                strwidth() (?)
                stridx()
                strridx()
                strlen()
                strpart()
                strtrans()
                substitute()  ___count =1
                submatch()
                tolower()
                toupper()
            }}}
            .           charsearch {{{
                byte2line()
                byteidx()
                ---
                char2nr()
            }}}
            .           convert {{{
                float2nr()
                iconv()
                nr2char()
                str2float()
                str2nr()
            }}}
                copy()
            .           numtrig {{{
                abs()
                exp()
                fmod()
                ceil()
                floor()
                pow()
                round()
                sqrt()
                trunc()     #floats
                ---
                acos()
                asin()
                atan()
                atan2()
                cos()
                cosh()
                sin()
                sinh()
                tan()
                tanh()
                log()
                log10()
            }}}
            .           permfilessystem {{{
                delete()
                rename()
                executable()
                filereadable()
                filewritable()
                finddir()
                findfile()
                fnamemodify()
                getcwd()
                getfsize()
                getfperm()
                getftime()
                getftype()
                hostname()
                isdirectory()
                mkdir()
                pathshorten()
                resolve()
                simplify()
                system()
                writefile() **
                ---
                haslocaldir()
                ---
                readfile()
                tempname()
            }}}
            .           vars {{{
                type()  ___count =1     #list, dict, float mm
                exists()    #om var, funct mm ex.  ___count =1
                getbufvars()
                gettabvar()
                gettabwinvar()
                getwinvar()
                islocked()
                settabvar()
                settabwinvar()
            }}}
            .           fold {{{
                foldclosed()
                foldclosedend()
                foldlevel()
                foldtext()
                foldtextresult()
            }}}
            .           register {{{
                getreg()
                getregtype()
                setreg()
            }}}
            .           changelist {{{
                changenr()
            }}}
            .           aucmd ** {{{
                did_filetype()
            }}}
            .           maps {{{
                hasmapto() ***
                mapcheck()
                feedkeys()
                maparg()
            }}}
            .           commline {{{
                getcmdline()
                getcmdpos()
                getcmdtype()
            }}}
            .           cursormark buftext {{{
                visualmode()            #last visualmode used
                col()
                virtcol()
                wincol()
                cursor()
                getpos()
                setpos()
                getbufline()
                getline()  ___count =1
                setline()  ___count =1
                line()
                winline()
                line2byte()
                indent()
                 cindent()
                 lispindent()
                nextnonblank()
                prevnonblank()
                search()  ___count =1
                    :call search("Date: ", "W")
                searchpos()
                searchpair()
                searchpairpos()
                searchdecl()
            }}}
            .           bufwinarglist {{{
                bufexists()
                buflisted()
                bufloaded()
                bufname()  ___count =1
                    :execute "rightbelow vsplit " . bufname("#")
                bufnr()
                bufwinnr()
                tabpagebuflist()
                tabpagenr()
                tabpagewinnr()
                winbufnr()
            }}}
                winnr()
            .           guiinteractive {{{
                browse()
                browsedir()
                confirm()
                foreground()
                getchar()
                 getcharmod()
                getfontname()
                input()
                inputlist()
                inputsecret()
                inputdialog()
                inputsave()
                inputrestore()
            }}}
            .           winsizepos {{{
                getwinposx()
                winheight()
            }}}
            .           globexpand {{{
                glob()
                globpath()
            }}}
                escape()
                fnameescape()
                expand()
                shellescape()
            .           qfloc ** {{{
                getloclist()
                getqflist()
                setloclist()
                setqflist()
            }}}
            .           tagscscope {{{
                taglist()
                tagfiles()
                 cscope_connection()
            }}}
            .           compl {{{
                complete()
                complete_add()
                complete_check()
                pumvisible()
                setcmdpos()
            }}}
            .           diff {{{
                diff_filler()
                diff_hlID()
            }}}
            .           syntaxhighl {{{
                getmatches()
                hlexists()
                hlID()
                matchadd()
                matcharg()
                matchdelete()
                clearmatches()
                setmatches()
                synID()
                synIDattr()
                synIDtrans()
                synconcealed()
                synstack()
            }}}
            .           (spell) {{{
                spellbadword()
                spellsuggest()
                soundfold()
            }}}
            history
                histadd()
                histdel()
                histget()
                histnr()
            .           undo {{{
                undotree()
                 undofile()
            }}}
            .           datetime {{{
                localtime()
                reltime()
                reltimestr()
                strftime()
            }}}
            .           (vimserver) {{{
                serverlist()
                remote_send()
                remote_expr()
                server2client()
                remote_peek()
                remote_read()
                foreground()
                remote_foreground()
            }}}
            --?--?--
                mode()      #vims nuv. red.läge(mode)
                empty()
                winrestcmd()
                winrestview()
                winsaveview()
                winwidth()
                 mzeval()
        }}}
         egdef
        .       excommands {{{

                    http://vimdoc.sourceforge.net/htmldoc/vimindex.html#ex-cmd-index

            :sort

            :let  ___count =6
            :normal  ___count =13
                :normal! G  #'!' gör att bortser från mappings
                            # (=likn. nnoremap mm)
                            #TIPS: ANV. ALLTID(!) '!' EFTER NORMAL (***)
                :normal! /foo<cr>   #SPEC.TECKEN-SEKV.
                                    # =FUNKAR EJ; ANVÄND 'EXECUTE' (***)
                :execute "normal! gg/foo\<cr>dd"
            :call  ___count =4
                :10,30call Count_words()
                :call add(alist, 'foo')
                :call extend(alist, ['two', 'three'])
            :execute :exe  ___count =14
                :execute "normal! gg" . '/for .\+ in .\+:' . "\<cr>"  ****
                :execute "normal! gg/for .\\+ in .\\+:\<cr>"
                :execute "normal! mqA;\<esc>`q"  # =';' TILL RADSLUT ****
                :execute "normal! gg/foo\<cr>dd"
                :execute "tag " . tag_name
                :execute "normal " . normal_commands
                :execute "normal Inew text \<Esc>"
                :execute "rightbelow vsplit " . bufname("#")
            :source
            :set
            :setfiletype

            :substitute
            :global

            :history

            :nohlsearch
        .      functegcmd {{{
            :function  ___count =2  #lista eg.def f.s
                :function SetSyn  #visa vad f. SetSyn gör ****
            :return
            :delfunction
            :command
            :comclear
            :delcommand
        }}}
        .      messages     #echo mm {{{
                :echo
                :echomsg
                :echon  #echo w.out nl efter
                :echoerr
        }}}
        autocmd
            :autocmd
            :augroup
        .      editfromcline    #move copy del mm ** {{{
            :copy
            :move
            :delete
            :join
            :append
            :put
        }}}
        register
            :yank
            :registers
        .      do(arg)    #dobufwinargtab-aucmd {{{
            :doautocmd
            :doautoall
            :argdo
            :bufdo
            :tabdo
            :windo
        }}}
        .      Help {{{
            :help
            :helpfind
            :helpgrep
            :helptags
        }}}
        .      Files bufwinargtab files_editmanage {{{
            :edit
            :find
            :file
            :files
            :ls
            :badd
            :bdelete
            :bunload
            :bwipeout
            :bnext
            :bprevious
            :brewind
            :bfirst
            :blast
            :bNext
            :ball
            :args
            :rewind
            :argadd
            :argdelete
            :all
            :argedit
            :argglobal
            :arglocal
            :argument
            :buffer
            :buffers
            :tabNext
            :tabclose
            :tabedit
            :tabfind
            :tabfirst
            :tablast
            :tabmove
            :tabnew
            :tabnext
            :tabonly
            :tabprevious
            :tabrewind
            :wnext
            :wprevious
            :wq
            :wqall
            :xit
            :xall
            :quit
            :quitall
            :qall
            :first
            :last
            :next
            :oldfiles
            :only
            :close
            :new
            :enew
            :vnew
            :previous
            :browse
            :pwd
            :cd
            :chdir
            :hardcopy
            :write
            :wNext
            :wall
             :shell
        }}}
        .      splits {{{
            :vertical
            :vsplit
            :split
            :sprevious
            :srewind
            :snext
        }}}
        .      winsplitpos    #belowright mm {{{
            :aboveleft
            :belowright
            :botright
            :left
            :leftabove
            :right
            :rightbelow
            :topleft
        }}}
        .      viewsession {{{
            :mksession
            :mkview
            :loadview
        }}}
        .      runprogrlangs    #execute python/scheme/tcl etc-code {{{
            :lua
            :luado
            :luafile
            :mzscheme
            :mzfile
            :py3
            :python3
            :py3file
            :python
            :pyfile
            :ruby
            :rubydo
            :rubyfile
            :perl
            :perldo
            :tcl
            :tcldo
            :tclfile
        }}}
            .      map {{{
                :xunmap
                :xnoremap
                :xmap
                :xmapclear
                :vunmap
                :vnoremap
                :vmapclear
                :vmap
                :unmap
                :sunmap
                :snoremap
                :smapclear
                :smap
                :ounmap
                :onoremap
                :omapclear
                :omap
                :nunmap
                :noremap
                :nnoremap
                :nmapclear
                :nmap
                :mapclear
                :map
                :lunmap
                :lnoremap
                :lmapclear
                :lmap
                :iunmap
                :inoremap
                :imapclear
                :imap
                :cunmap
                :cnoremap
                :cmapclear
                :cmap
            }}}
        .      abbrev {{{
            :unabbreviate
            :noreabbrev
            :iunabbrev
            :inoreabbrev
            :iabbrev
            :cunabbrev
            :cnoreabbrev
            :cabbrev
            :abbreviate
             :abclear
             :cabclear
             :iabclear
        }}}
        .      qfloclist *** {{{
            :cc
            :cclose
            :copen
            :cprevious
            :cpfile
            :crewind
            :cwindow
            :cnext
            :cnewer
            :cnfile
            :colder
            :cNext
            :cNfile
            :cexpr
            :cfile
            :cfirst
            :caddbuffer
            :caddexpr
            :caddfile
            :cbuffer
            :cgetbuffer
            :cgetexpr
            :cgetfile
            :clist
            :clast
            -----
            :lNext
            :lNfile
            :laddexpr
            :laddbuffer
            :laddfile
            :lbuffer
            :lclose
            :lcscope
            :lexpr
            :lfile
            :lfirst
            :lgetbuffer
            :lgetexpr
            :lgetfile
            :lgrep
            :lgrepadd
            :lhelpgrep
            :ll
            :llast
            :llist
            :lmake
            :lnext
            :lnewer
            :lnfile
            :lolder
            :lopen
            :lprevious
            :lpfile
            :lrewind
            :ltag
            :lvimgrep
            :lvimgrepadd
            :lwindow
        }}}
        .      menu {{{
            :xunmenu
            :xnoremenu
            :xmenu
            :vunmenu
            :vnoremenu
            :vmenu
            :unmenu
            :tunmenu
            :tmenu
            :sunmenu
            :snoremenu
            :smenu
            :ounmenu
            :onoremenu
            :omenu
            :nunmenu
            :noremenu
            :nnoremenu
            :nmenu
            :menutranslate
            :menu
            :iunmenu
            :inoremenu
            :imenu
            :emenu
            :cunmenu
            :cnoremenu
            :cmenu
            :aunmenu
            :anoremenu
            :amenu
        }}}
            .      fold {{{
                :fold
                :foldclose
                :folddoopen
                :folddoclosed
                :foldopen
            }}}
            .      diff {{{
                :diffupdate
                :diffget
                :diffoff
                :diffpatch
                :diffput
                :diffsplit
                :diffthis
            }}}
        compilertags
            :make
            :compiler
            ----
            :cscope
            :cstag
            ----
            :dlist
            :dsearch
            :dsplit
        .      tags * {{{
                :tfirst
                :tjump
                :tlast
                :tprevious
                :trewind
                :tnext
                :tNext
                :tselect
        }}}
        .      debug {{{
            :breakadd
            :breakdel
            :breaklist
        }}}
        .      loops {{{
            :if
            :for
            :break
            :continue
            :else
            :elseif
            :endif
            :endfor
            :endfunction
            :endtry
            :endwhile
            :while
        }}}
        .      except {{{
            :catch
            :throw
            :try
            :finally
        }}}

            :colorscheme
            .      spell {{{
                :spelldump
                :spellgood
                :spellinfo
                :spellrepall
                :spellundo
                :spellwrong
            }}}

        grep
                :grep
                :grepadd
                :vimgrep
                :vimgrepadd
        jumpschanges
                :jumps
                :lcd
                :lchdir
        mark
                :mark
                :marks
        indent
                :retab
        undo
            :undo
            :undolist
            :wundo
        viminfo
            :wviminfo
            :rviminfo
                    :earlier
                    :later
            :filetype
            :delmarks
            :debug





                            :open



            :loadkeymap
            :ascii
            :behave
            :bmodified
            :change

            :center
            :changes
            :checkpath
            :checktime
            :confirm

            :cquit

            :debuggreedy
            :digraphs
            :display
                :djump
            :drop
            :echohl  #spec. hl used for follow. echo-arg.  ___count =1
                :  echohl Title
                :  echo "start is " . a:start
                :  echohl None
            :ex
            :exit
                :exusage
            :finish
            :fixdel
            :goto
            :gui
            :gvim


            :highlight
            :insert
            :ijump
            :ilist
            :intro
            :isearch
            :isplit
            :k
            :keepalt
            :keepmarks
            :keepjumps

            :list
            :language
            :lockmarks
            :lockvar
            :match
            :messages
            :mkexrc
            :mkspell
            :mkvimrc
            :mode
            :nbclose
            :nbkey
            :nbstart
            :noautocmd
            :number
            :options
            :ownsyntax
            :pclose
            :pedit
            :print
            :profdel
            :profile
            :promptfind
            :promptrepl
            :pop
            :popup
            :ppop
            :preserve
            :psearch
            :ptag
            :ptNext
            :ptfirst
            :ptjump
            :ptlast
            :ptnext
            :ptprevious
            :ptrewind
            :ptselect
            :read
            :recover
            :redo
            :redir
            :redraw
            :redrawstatus
            :resize
            :rundo
            :runtime
            :sNext
            :sandbox
            :sargument
            :sall
            :saveas
            :sbuffer
            :sbNext
            :sball
            :sbfirst
            :sblast
            :sbmodified
            :sbnext
            :sbprevious
            :sbrewind
            :scriptnames
            :scriptencoding
                :scscope
                :setglobal
                :setlocal
            :sfind
            :sfirst
            :simalt
            :sign
            :silent
            :sleep
            :slast
            :smagic
            :sniff
            :snomagic
            :stop
            :stag
            :startinsert
            :startgreplace
            :startreplace
            :stopinsert
            :stjump
            :stselect
            :sunhide
            :suspend
            :sview
            :swapname
            :syntax
            :syncbind
            :t
            :tabs
            :tab
            :tag
            :tags
            :tearoff
            :undojoin
            :hide
            :unhide
            :unlet
            :unlockvar
            :unsilent
            :update
            :vglobal
            :version
            :verbose
            :visual
            :viusage
            :view

            :winsize
            :wincmd
            :winpos
                    :wsverb

        }}}
        .       voptions {{{

                     https://www.shortcutfoo.com/blog/top-50-vim-configuration-options/
                    http://vimdoc.sourceforge.net/htmldoc/options.html


            .          write    #incl. autowrite {{{
                'autowrite'*******    'aw'      automatically write file if changed
                'autowriteall'    'awa'     as 'autowrite', but works with more commands
}}}
            .          backup * {{{
                'backup'      'bk'      keep backup file after overwriting a file    :se backup
                'backupext'   'bex'     extension used for the backup file    :se backupext=.bak
                'patchmode'   'pm'      keep the oldest version of a file    :se patchmode=.orig
                'writebackup'     'wb'      make a backup before overwriting a file
                'backupdir'   'bdir'    list of directories for the backup file    =backupfil skrivs annars som standard i WD
                'backupcopy'      'bkc'     make backup as a copy, don't rename the file
                'backupskip'      'bsk'     no backup for files that match these patterns
                'patchexpr'   'pex'     expression used to patch a file
            }}}
            'incsearch'   'is'      highlight match while typing search pattern
            'indentexpr'      'inde'    expression used to obtain the indent of a line
            'indentkeys'      'indk'    keys that trigger indenting with 'indentexpr'
            'infercase'   'inf'     adjust case of match for keyword completion
                'insertmode'      'im'      start the edit of a file in Insert mode
            .          keywordchars {{{
                'isfname'     'isf'     characters included in file names and pathnames
                'isident'     'isi'     characters included in identifiers
                'iskeyword'   'isk'     characters included in keywords
                'backspace'   'bs'      how backspace works at start of line   backspace=indent,eol,start  (t.ex.)
                'isprint'     'isp'     printable characters
            }}}
            .          compilemake * {{{
                'makeef'      'mef'     name of the errorfile for ":make"

                'makeprg'     'mp'      program to use for the ":make" command
            }}}
            .          textwrapformat {{{
                'textwidth'   'tw'      maximum width of text that is being inserted
                'wrap'              long lines wrap and continue on the next line
            }}}
            .          spelldict    #incl. thesaurus * {{{
                'spell'             enable spell checking
                'spellcapcheck'   'spc'     pattern to locate end of a sentence
                'spellfile'   'spf'     files where |zg| and |zw| store words
                'spelllang'   'spl'     language(s) to do spell checking for
                'spellsuggest'    'sps'     method(s) used to suggest spelling corrections
                'thesaurus'   'tsr'     list of thesaurus files for keyword completion
            }}}
            .          tabcomplet    #m.fl. former comlet.  |cmdline-completion| {{{
                'wildmode'    'wim'     mode for 'wildchar' command-line expansion
                'wildmenu'    'wmnu'    use menu for command line completion
                'suffixes'    'su'      suffixes that are ignored with multiple match
                'wildignore'      'wig'     files matching these patterns are not completed
                'wildignorecase'  'wic'     ignore case when completing file names
                'wildoptions'     'wop'     specifies how command line completion is done
            }}}
                'timeout'     'to'      time out on mappings and key codes
                'timeoutlen'      'tm'      time out time in milliseconds
                'ttimeout'          time out on mappings
                'ttimeoutlen'     'ttm'     time out time for key codes in milliseconds
            .          shellfilter    #kolla dessa om filtr. inte funkar ordentl. - s79 U.M.) {{{
                'shell'       'sh'      name of shell to use for external commands
                'shellcmdflag'    'shcf'    flag to shell to execute one command
                    'shellpipe'   'sp'      string to put output of ":make" in error file
                'shellquote'      'shq'     quote character(s) for around shell command
                'shellredir'      'srr'     string to put output of filter in a temp file
                'shellslash'      'ssl'     use forward slash for shell file names
                    'shelltemp'   'stmp'    whether to use a temp file for shell commands
                'shelltype'   'st'      Amiga: influences how to use a shell
                'shellxquote'     'sxq'     like 'shellquote', but include redirection
            }}}
                'smartcase'   'scs'     no ignore case when pattern has uppercase
                'smartindent'     'si'      smart autoindenting for C programs
                'smarttab'    'sta'     use 'shiftwidth' when inserting <Tab>
                'softtabstop'     'sts'     number of spaces that <Tab> uses while editing
            -- position/linenumber in file -- ****
            'number'      'nu'      print the line number in front of each line
            'ruler'       'ru'      show cursor line and column in the status line
            'numberwidth'     'nuw'     number of columns used for the line number
                'omnifunc'    'ofu'     function for filetype-specific completion
                'opendevice'      'odev'    allow reading/writing devices on MS-Windows
                'operatorfunc'    'opfunc'  function to be called for |g@| operator
                'osfiletype'      'oft'     operating system-specific filetype information
                'paragraphs'      'para'    nroff macros that separate paragraphs
                'paste'             allow pasting text
                'pastetoggle'     'pt'      key code that causes 'paste' to toggle

            -- sökväg och path --
            'path'        'pa'      list of directories searched with "gf" et.al.
            'isfname'     'isf'     characters included in file names and pathnames
                    |:find|     :fin[d]     find file in 'path' and edit it
                    |:sfind|    :sf[ind]    split current window and edit file in 'path'
                    |:tabfind|  :tabf[ind]  find file in 'path', edit it in a new tab page
                'preserveindent'  'pi'      preserve the indent structure when reindenting
            modeline
            'modeline'    'ml'      recognize modelines at start or end of file
            'modelines'   'mls'     number of lines checked for modelines
                'list'              show <Tab> and <EOL>
                'listchars'   'lcs'     characters for displaying in list mode
                'wrapmargin'      'wm'      chars from the right where wrapping starts

            .          scroll * {{{
                'scrollbind'      'scb'     scroll in window as other windows scroll
                'scrolloff'   'so'      minimum nr. of lines above and below cursor
                ----
                'scroll'      'scr'     lines to scroll with CTRL-U and CTRL-D
                'window'      'wi'      nr of lines to scroll for CTRL-F and CTRL-B
}}}
            .          modwrite {{{
                'modifiable'      'ma'      changes to the text are not possible
                'write'             writing to a file is allowed
            }}}
            .          splitwin {{{
                'splitbelow'      'sb'      new window from split is below the current one
                'splitright'      'spr'     new window is put right of the current one
                'winheight'   'wh'      minimum number of lines for the current window
                'winfixheight'    'wfh'     keep window height when opening/closing windows
                'winfixwidth'     'wfw'     keep window width when opening/closing windows
                'winminheight'    'wmh'     minimum number of lines for any window
                'winminwidth'     'wmw'     minimal number of columns for any window
                'winwidth'    'wiw'     minimal number of columns for current window
                'equalalways'     'ea'      windows are automatically made the same size
            }}}
            .          grepvimgrep {{{
                'grepprg'     'gp'      program to use for ":grep"
            }}}
                'autochdir'   'acd'     change directory to the file in the current window
                'autoread'    'ar'      autom. read file when changed outside of Vim
                'background'      'bg'      "dark" or "light", used for highlight colors
            'compatible'      'cp'      behave Vi-compatible as much as possible
            'complete'    'cpt'     specify how Insert mode completion works
            'completefunc'    'cfu'     function to be used for Insert mode completion
            'completeopt'     'cot'     options for Insert mode completion








                Short explanation of each option:       *option-list*
                'aleph'       'al'      ASCII code of the letter Aleph (Hebrew)
                'allowrevins'     'ari'     allow CTRL-_ in Insert and Command-line mode
                'altkeymap'   'akm'     for default second language (Farsi/Hebrew)
                'ambiwidth'   'ambw'    what to do with Unicode chars of ambiguous width
                'antialias'   'anti'    Mac OS X: use smooth, antialiased fonts
                'arabic'      'arab'    for Arabic as a default second language
                'arabicshape'     'arshape' do shaping for Arabic characters
                'autoindent'      'ai'      take indent for new line from previous line
                'balloondelay'    'bdlay'   delay in mS before a balloon may pop up
                'ballooneval'     'beval'   switch on balloon evaluation
                'balloonexpr'     'bexpr'   expression to show in balloon
                'binary'      'bin'     read/write/edit file in binary mode
                'bioskey'     'biosk'   MS-DOS: use bios calls for input characters
                'bomb'              prepend a Byte Order Mark to the file
            'breakat'     'brk'     characters that may cause a line break
                'browsedir'   'bsdir'   which directory to start browsing in
            -- buffers --
            'bufhidden'   'bh'      what to do when buffer is no longer in window
            'buflisted'   'bl'      whether the buffer shows up in the buffer list
                'buftype'     'bt'      special type of buffer
                'casemap'     'cmp'     specifies how case of letters is changed
                'cdpath'      'cd'      list of directories searched with ":cd"
                'cedit'             key used to open the command-line window
                'charconvert'     'ccv'     expression for character encoding conversion

                'cindent'     'cin'     do C program indenting
                'cinkeys'     'cink'    keys that trigger indent when 'cindent' is set
                'cinoptions'      'cino'    how to do indenting when 'cindent' is set
                'cinwords'    'cinw'    words where 'si' and 'cin' add an indent

                'clipboard'   'cb'      use the clipboard as the unnamed register

                'cmdheight'   'ch'      number of lines to use for the command-line
                'cmdwinheight'    'cwh'     height of the command-line window

                'colorcolumn'     'cc'      columns to highlight
                'columns'     'co'      number of columns in the display
                'comments'    'com'     patterns that can start a comment line
                'commentstring'   'cms'     template for comments; used for fold marker
                'concealcursor'   'cocu'    whether concealable text is hidden in cursor line
                'conceallevel'    'cole'    whether concealable text is shown or hidden 
                'confirm'     'cf'      ask what to do about unsaved/read-only files
                'conskey'     'consk'   get keys directly from console (MS-DOS only)
                'copyindent'      'ci'      make 'autoindent' use existing indent structure
                'cpoptions'   'cpo'     flags for Vi-compatible behavior
                'cryptmethod'     'cm'      type of encryption to use for file writing
                'cscopepathcomp'  'cspc'    how many components of the path to show
                'cscopeprg'       'csprg'   command to execute cscope
                'cscopequickfix'  'csqf'    use quickfix window for cscope results
                'cscopetag'       'cst'     use cscope for tag commands
                'cscopetagorder'  'csto'    determines ":cstag" search order
                'cscopeverbose'   'csverb'  give messages when adding a cscope database
                'cursorbind'      'crb'     move cursor in window as it moves in other windows
            'cursorcolumn'    'cuc'     highlight the screen column of the cursor
            'cursorline'      'cul'     highlight the screen line of the cursor
                'debug'             set to "msg" to see all error messages
                'define'      'def'     pattern to be used to find a macro definition
                'delcombine'      'deco'    delete combining characters on their own
            'dictionary'      'dict'    list of file names used for keyword completion
            'diff'              use diff mode for the current window
            'diffexpr'    'dex'     expression used to obtain a diff file
            'diffopt'     'dip'     options for using diff mode
            'digraph'     'dg'      enable the entering of digraphs in Insert mode

            'directory'   'dir'     list of directory names for the swap file
                'display'     'dy'      list of flags for how to display text
                'eadirection'     'ead'     in which direction 'equalalways' works
                'edcompatible'    'ed'      toggle flags of ":substitute" command
                'encoding'    'enc'     encoding used internally
                'endofline'   'eol'     write <EOL> for last line in file
                'equalprg'    'ep'      external program to use for "=" command
                'errorbells'      'eb'      ring the bell for error messages
                'errorfile'   'ef'      name of the errorfile for the QuickFix mode
                'errorformat'     'efm'     description of the lines in the error file
                'esckeys'     'ek'      recognize function keys in Insert mode
                'eventignore'     'ei'      autocommand events that are ignored
                'expandtab'   'et'      use spaces when <Tab> is inserted
                'exrc'        'ex'      read .vimrc and .exrc in the current directory
                'fileencoding'    'fenc'    file encoding for multi-byte text
                'fileencodings'   'fencs'   automatically detected character encodings
                'fileformat'      'ff'      file format used for file I/O
                'fileformats'     'ffs'     automatically detected values for 'fileformat'
            'filetype'    'ft'      type of file, used for autocommands
                'fillchars'   'fcs'     characters to use for displaying special items
                'fkmap'       'fk'      Farsi keyboard mapping
                'foldclose'   'fcl'     close a fold when the cursor leaves it
                'foldcolumn'      'fdc'     width of the column used to indicate folds
                'foldenable'      'fen'     set to display all folds open
                'foldexpr'    'fde'     expression used when 'foldmethod' is "expr"
                'foldignore'      'fdi'     ignore lines when 'foldmethod' is "indent"
                'foldlevel'   'fdl'     close folds with a level higher than this
                'foldlevelstart'  'fdls'    'foldlevel' when starting to edit a file
                'foldmarker'      'fmr'     markers used when 'foldmethod' is "marker"
                'foldmethod'      'fdm'     folding type
                'foldminlines'    'fml'     minimum number of lines for a fold to be closed
                'foldnestmax'     'fdn'     maximum fold depth
                'foldopen'    'fdo'     for which commands a fold will be opened
                'foldtext'    'fdt'     expression used to display for a closed fold
                'formatlistpat'   'flp'     pattern used to recognize a list header
                'formatoptions'   'fo'      how automatic formatting is to be done
                'formatprg'   'fp'      name of external program used with "gq" command
                'formatexpr'      'fex'     expression used with "gq" command
                'fsync'       'fs'      whether to invoke fsync() after file write
                'gdefault'    'gd'      the ":substitute" flag 'g' is default on
                'grepformat'      'gfm'     format of 'grepprg' output
                'guicursor'   'gcr'     GUI: settings for cursor shape and blinking
                'guifont'     'gfn'     GUI: Name(s) of font(s) to be used
                'guifontset'      'gfs'     GUI: Names of multi-byte fonts to be used
                'guifontwide'     'gfw'     list of font names for double-wide characters
                'guiheadroom'     'ghr'     GUI: pixels room for window decorations
                'guioptions'      'go'      GUI: Which components and options are used
                'guipty'            GUI: try to use a pseudo-tty for ":!" commands
                'guitablabel'     'gtl'     GUI: custom label for a tab page
                'guitabtooltip'   'gtt'     GUI: custom tooltip for a tab page
                'helpfile'    'hf'      full path name of the main help file
                'helpheight'      'hh'      minimum height of a new help window
                'helplang'    'hlg'     preferred help languages
                'hidden'      'hid'     don't unload buffer when it is YXXYabandon|ed
                'highlight'   'hl'      sets highlighting mode for various occasions
                'hlsearch'    'hls'     highlight matches with last search pattern
                'history'     'hi'      number of command-lines that are remembered
                'hkmap'       'hk'      Hebrew keyboard mapping
                'hkmapp'      'hkp'     phonetic Hebrew keyboard mapping
                'icon'              let Vim set the text of the window icon
                'iconstring'            string to use for the Vim icon text
                'ignorecase'      'ic'      ignore case in search patterns
                'imactivatekey'   'imak'    key that activates the X input method
                'imcmdline'   'imc'     use IM when starting to edit a command line
                'imdisable'   'imd'     do not use the IM in any mode
                'iminsert'    'imi'     use :lmap or IM in Insert mode
                'imsearch'    'ims'     use :lmap or IM when typing a search pattern
                'include'     'inc'     pattern to be used to find an include file
                'includeexpr'     'inex'    expression used to process an include line

                'joinspaces'      'js'      two spaces after a period with a join command
                'key'               encryption key
                'keymap'      'kmp'     name of a keyboard mapping
                'keymodel'    'km'      enable starting/stopping selection with keys
                'keywordprg'      'kp'      program to use for the "K" command
                'langmap'     'lmap'    alphabetic characters for other language mode
                'langmenu'    'lm'      language to be used for the menus
                'laststatus'      'ls'      tells when last window has status lines
                'lazyredraw'      'lz'      don't redraw while executing macros
                'linebreak'   'lbr'     wrap long lines at a blank
                'lines'             number of lines in the display
                'linespace'   'lsp'     number of pixel lines to use between characters
                'lisp'              automatic indenting for Lisp
                'lispwords'   'lw'      words that change how lisp indenting works

                'loadplugins'     'lpl'     load plugin scripts when starting up
                'macatsui'          Mac GUI: use ATSUI text drawing
            'magic'             changes special characters in search patterns

            'matchpairs'      'mps'     pairs of characters that "%" can match
                'matchtime'   'mat'     tenths of a second to show matching paren
                'maxcombine'      'mco'     maximum nr of combining characters displayed
                'maxfuncdepth'    'mfd'     maximum recursive depth for user functions
                'maxmapdepth'     'mmd'     maximum recursive depth for mapping
                'maxmem'      'mm'      maximum memory (in Kbyte) used for one buffer
                'maxmempattern'   'mmp'     maximum memory (in Kbyte) used for pattern search
                'maxmemtot'   'mmt'     maximum memory (in Kbyte) used for all buffers
                'menuitems'   'mis'     maximum number of items in a menu
                'mkspellmem'      'msm'     memory used before |:mkspell| compresses the tree
                'modified'    'mod'     buffer has been modified
                'more'              pause listings when the whole screen is filled
            -- mouse i gui mm --
            'mouse'             enable the use of mouse clicks
            'mousefocus'      'mousef'  keyboard focus follows the mouse
            'mousehide'   'mh'      hide mouse pointer while typing
            'mousemodel'      'mousem'  changes meaning of mouse buttons
            'mouseshape'      'mouses'  shape of the mouse pointer in different modes
            'mousetime'   'mouset'  max time between mouse double-click
            'selectmode'      'slm'     when to use Select mode instead of Visual mode
                'mzquantum'   'mzq'     the interval between polls for MzScheme threads
                'nrformats'   'nf'      number formats recognized for CTRL-A command

                'previewheight'   'pvh'     height of the preview window
                'previewwindow'   'pvw'     identifies the preview window
                'printdevice'     'pdev'    name of the printer to be used for :hardcopy
                'printencoding'   'penc'    encoding to be used for printing
                'printexpr'   'pexpr'   expression used to print PostScript for :hardcopy
                'printfont'   'pfn'     name of the font to be used for :hardcopy
                'printheader'     'pheader' format of the header used for :hardcopy
                'printmbcharset'  'pmbcs'   CJK character set to be used for :hardcopy
                'printmbfont'     'pmbfn'   font names to be used for CJK output of :hardcopy
                'printoptions'    'popt'    controls the format of :hardcopy output
                'pumheight'   'ph'      maximum height of the popup menu
                'quoteescape'     'qe'      escape characters used in a string
                'readonly'    'ro'      disallow writing the buffer
                'redrawtime'      'rdt'     timeout for 'hlsearch' and |:match| highlighting
                'relativenumber'  'rnu'     show relative line number in front of each line
                'remap'             allow mappings to work recursively
                'report'            threshold for reporting nr. of lines changed
                'restorescreen'   'rs'      Win32: restore screen when exiting
                'revins'      'ri'      inserting characters will work backwards
                'rightleft'   'rl'      window is right-to-left oriented
                'rightleftcmd'    'rlc'     commands for which editing works right-to-left
                'rulerformat'     'ruf'     custom format for the ruler
                'runtimepath'     'rtp'     list of directories used for runtime files
                'scrolljump'      'sj'      minimum number of lines to scroll
                'scrollopt'   'sbo'     how 'scrollbind' should behave
                'sections'    'sect'    nroff macros that separate sections
                'secure'            secure mode for reading .vimrc in current dir
                'selection'   'sel'     what type of selection to use
            'sessionoptions'  'ssop'    options for |:mksession|



                'shiftround'      'sr'      round indent to multiple of shiftwidth
                'shiftwidth'      'sw'      number of spaces to use for (auto)indent step
                'shortmess'   'shm'     list of flags, reduce length of messages
                'shortname'   'sn'      non-MS-DOS: Filenames assumed to be 8.3 chars
                'showbreak'   'sbr'     string to use at the start of wrapped lines
                'showcmd'     'sc'      show (partial) command in status line
                'showfulltag'     'sft'     show full tag pattern when completing tag
                'showmatch'   'sm'      briefly jump to matching bracket if insert one
                'showmode'    'smd'     message on status line to show current mode
                'showtabline'     'stal'    tells when the tab pages line is displayed
                'sidescroll'      'ss'      minimum number of columns to scroll horizontal
                'sidescrolloff'   'siso'    min. nr. of columns to left and right of cursor


                'startofline'     'sol'     commands move cursor to first non-blank in line
                'statusline'      'stl'     custom format for the status line
                'suffixesadd'     'sua'     suffixes added when searching for a file
                'swapfile'    'swf'     whether to use a swapfile for a buffer
                'swapsync'    'sws'     how to sync the swap file
                'switchbuf'   'swb'     sets behavior when switching to another buffer
                'synmaxcol'   'smc'     maximum column to find syntax items
                'syntax'      'syn'     syntax to be loaded for current buffer
                'tabstop'     'ts'      number of spaces that <Tab> in file uses
                'tabline'     'tal'     custom format for the console tab pages line
                'tabpagemax'      'tpm'     maximum number of tab pages for |-p| and "tab all"
                'tagbsearch'      'tbs'     use binary searching in tags files
            'taglength'   'tl'      number of significant characters for a tag
                'tagrelative'     'tr'      file names in tag file are relative
                'tags'        'tag'     list of file names used by the tag command
                'tagstack'    'tgst'    push tags onto the tag stack
                'term'              name of the terminal
            'termbidi'    'tbidi'   terminal takes care of bi-directionality
            'termencoding'    'tenc'    character encoding used by the terminal
                'terse'             shorten some messages
                            'textauto'    'ta'      obsolete, use 'fileformats'
                            'textmode'    'tx'      obsolete, use 'fileformat'


            'tildeop'     'top'     tilde command "~" behaves like an operator


                'title'             let Vim set the title of the window
                'titlelen'          percentage of 'columns' used for window title
                'titleold'          old title, restored when exiting
                'titlestring'           string to use for the Vim window title
                'toolbar'     'tb'      GUI: which items to show in the toolbar
                'toolbariconsize' 'tbis'    size of the toolbar icons (for GTK 2 only)
                'ttybuiltin'      'tbi'     use built-in termcap before external termcap
                'ttyfast'     'tf'      indicates a fast terminal connection
                'ttymouse'    'ttym'    type of mouse codes generated
                'ttyscroll'   'tsl'     maximum number of lines for a scroll
                'ttytype'     'tty'     alias for 'term'
            'undodir'     'udir'    where to store undo files
            'undofile'    'udf'     save undo information in a file
            'undolevels'      'ul'      maximum number of changes that can be undone
                'undoreload'      'ur'      max nr of lines to save for undo on a buffer reload
                'updatecount'     'uc'      after this many characters flush swap file
                'updatetime'      'ut'      after this many milliseconds flush swap file
            'verbose'     'vbs'     give informative messages
            'verbosefile'     'vfile'   file to write messages in
            'viewdir'     'vdir'    directory where to store files with :mkview
            'viewoptions'     'vop'     specifies what to save for :mkview
            'viminfo'     'vi'      use .viminfo file upon startup and exiting
            'virtualedit'     've'      when to use virtual editing
                'visualbell'      'vb'      use visual bell instead of beeping
                'warn'              warn for shell command when buffer was changed
                'weirdinvert'     'wiv'     for terminals that have weird inversion method
                'whichwrap'   'ww'      allow specified keys to cross line boundaries

                'wildchar'    'wc'      command-line character for wildcard expansion
                'wildcharm'   'wcm'     like 'wildchar' but also works when mapped


                'winaltkeys'      'wak'     when the windows system handles ALT keys
                'writeany'    'wa'      write to file with no need for "!" override
                'writedelay'      'wd'      delay this many msec for each char (for debug)

        }}}
        aucmd
        .       auevents {{{

            FileType            when the 'filetype' option has been set     __options
            BufNewFile          starting to edit a file that doesn't exist      __reading
            BufRead             starting to edit a new buffer, after reading the file       __reading
            BufWritePre         starting to write the whole buffer to a file        __writing
            BufWrite            starting to write the whole buffer to a file        __writing



            Name            triggered by 

                Reading
            BufReadPre          starting to edit a new buffer, before reading the file
            BufReadPost         starting to edit a new buffer, after reading the file
            BufReadCmd          before starting to edit a new buffer Cmd-event
            FileReadPre         before reading a file with a ":read" command
            FileReadPost        after reading a file with a ":read" command
            FileReadCmd         before reading a file with a ":read" command Cmd-event
            FilterReadPre       before reading a file from a filter command
            FilterReadPost      after reading a file from a filter command
             StdinReadPre       before reading from stdin into the buffer
             StdinReadPost      After reading from the stdin into the buffer

                Writing
             BufWritePost       after writing the whole buffer to a file
            BufWriteCmd         before writing the whole buffer to a file Cmd-event
            FileWritePre        starting to write part of a buffer to a file
            FileWritePost       after writing part of a buffer to a file
            FileWriteCmd        before writing part of a buffer to a file Cmd-event
             FileAppendPre      starting to append to a file
             FileAppendPost     after appending to a file
            FileAppendCmd       before appending to a file Cmd-event
            FilterWritePre      starting to write a file for a filter command or diff
            FilterWritePost     after writing a file for a filter command or diff

                Buffers
            BufAdd              just after adding a buffer to the buffer list
            BufCreate           just after adding a buffer to the buffer list
             BufDelete          before deleting a buffer from the buffer list
            BufWipeout          before completely deleting a buffer
            BufFilePre          before changing the name of the current buffer
            BufFilePost         after changing the name of the current buffer
            BufEnter            after entering a buffer
            BufLeave            before leaving to another buffer
            BufWinEnter         after a buffer is displayed in a window
            BufWinLeave         before a buffer is removed from a window
            BufUnload           before unloading a buffer
            BufHidden           just after a buffer has become hidden
            BufNew              just after creating a new buffer
            SwapExists          detected an existing swap file

                Options
            Syntax              when the 'syntax' option has been set
            EncodingChanged     after the 'encoding' option has been changed
            TermChanged         after the value of 'term' has changed

                Startup and exit
            VimEnter            after doing all the startup stuff
            GUIEnter            after starting the GUI successfully
            TermResponse        after the terminal response to t_RV is received
            VimLeavePre         before exiting Vim, before writing the viminfo file
            VimLeave            before exiting Vim, after writing the viminfo file

                Various
            FileChangedShell        Vim notices that a file changed since editing started
            FileChangedShellPost    After handling a file changed since editing started
            FileChangedRO           before making the first change to a read-only file
            ShellCmdPost        after executing a shell command
            ShellFilterPost     after filtering with a shell command
            FuncUndefined       a user function is used but it isn't defined
            SpellFileMissing    a spell file is used but it can't be found
            SourcePre           before sourcing a Vim script
            SourceCmd           before sourcing a Vim script Cmd-event
            VimResized          after the Vim window size changed
            FocusGained         Vim got input focus
            FocusLost           Vim lost input focus
            CursorHold          the user doesn't press a key for a while
            CursorHoldI         the user doesn't press a key for a while in Insert mode
            CursorMoved         the cursor was moved in Normal mode
            CursorMovedI        the cursor was moved in Insert mode
            WinEnter            after entering another window
            WinLeave            before leaving a window
            TabEnter            after entering another tab page
            TabLeave            before leaving a tab page
            CmdwinEnter         after entering the command-line window
            CmdwinLeave         before leaving the command-line window
            InsertEnter         starting Insert mode
            InsertChange        when typing <Insert> while in Insert or Replace mode
            InsertLeave         when leaving Insert mode
            ColorScheme         after loading a color scheme
            RemoteReply         a reply from a server Vim was received
            QuickFixCmdPre      before a quickfix command is run
            QuickFixCmdPost     after a quickfix command is run
            SessionLoadPost     after loading a session file
            MenuPopup           just before showing the popup menu
            User                to be used in combination with ":doautocmd"

        }}}
        abbrev
        .       vvars {{{

            v:beval_col
            v:beval_bufnr
            v:beval_lnum
            v:beval_text
            v:beval_winnr
            v:char
            v:charconvert_from
            v:charconvert_to
            v:cmdarg
            v:cmdbang
            v:count
            v:count1
            v:ctype
            v:dying
            v:errmsg
            v:exception
            v:fcs_reason
            v:fcs_choice
            v:fname_in
            v:fname_out
            v:fname_new
            v:fname_diff
            v:folddashes
            v:foldlevel
            v:foldend
            v:foldstart
            v:insertmode
            v:key
            v:lang
            v:lc_time
            v:lnum
            v:mouse_win
            v:mouse_lnum
            v:mouse_col
            v:oldfiles
            v:operator
            v:prevcount
            v:profiling
            v:progname
            v:register
            v:scrollstart
            v:servername
            v:searchforward
            v:shell_error
            v:statusmsg
            v:swapname
            v:swapchoice
            v:swapcommand
            v:termresponse
            v:this_session
            v:throwpoint
            v:val
            v:version
            v:warningmsg
            v:windowid

        }}}
        ftplugins *
        grepagvimgrep
        redprogrkod editsourcecode
        makecompile
        qfloclist
        sourcerecscript
        modeline
         convert        #txt2html,pdf
        menu


    Help(s15)
        :h i_CTRL-H
    Inställningar
    Speca/Ändra var Vim lägger Swapfilerna ****
        omnicompletion: tex
        omnicompletion: java
        några startinställningar
        kolla om option compatible är satt
        lista alla filer som sourcas när vim startas (inkl. vilken vimrc)
        Inställningar med if-sats
    grundinställn./tips för indentering programmering (shiftwidth mm)
    Installera Vim (vimbsd, vimwin, Vim8, Neovim)
        Kolla vilken version av vim som är installerad mm **
        vim8/n(eo)vim
    VIM SOM IDE (PYTHON, markdown/pandoc, Latex ) *****
    syntax colorhighlighting + Colorschemes
        Colorschemes
        Skapa egen colorscheme *******
    Rekommenderade plugins, plugin management(vundle m.fl.)
        HTML/CSS (inkl EMMET-VIM ****)
            https://raw.githubusercontent.com/mattn/emmet-vim/master/TUTORIAL   ****
        VUNDLE + YCM (installera o konfigurera)
        Plugin 'Valloric/YouCompleteMe'
            https://github.com/Valloric/YouCompleteMe/issues/662
        matchit.vim
        surround.vim
        commentary.vim
        textobj-entire
        unimpaired.vim  =skapar maps för bnext, qnext, tnext osv
        rails.vim
        bundler.vim  [snabbt kunna ställa in rätt mappar o filtyper för hela projekt (=path, find mm)**]
        textobj-laspat
        abolish.vim
    formatera text
    specialtecken  (escape m '\')
    Keynames / Tangentnamn i Vim**
    Mapkeys mm (ev till MAPS) ****
    mata in Specialtecken, visa Teckenkod + UNICODE/ASCII
    vims operatorer(operators) ****
    några grundtips/förhålln.sätt fr. pract. vim *
    'finkornighet'
    rep.punkt ***
    iao-ryp-xdcs-hjkl   ^ g^ g0   0 $ - + Ent  Bl Bs
    mata in flera: 50a- mm**
    R gR  (+r och gr)
    bwe c-fbdu HLM  zb zt zz  c-io   gg G   gm 5| 20%
    visual
    %
    J gJ
    v V c-v
    c-g   g c-g
    char.Case *
    te: ranges, radnummer, adresser (=för sökning, exkommandon mm) ****
    sök:  /?n //e+2,b-1   * #  g* g#   \c \C
        koden:
    ftFT ;,
    Red. bö/slut flera rader ****
    tab/indent  = c-dt c-i > < >> <<
    Redigera ord i insertläge
    (i_c-o)
    COMPLETION + CTRL-X MODE
        c-N  /  c-P    (+fler tryckningar för att bläddra i listan som visas)
            c-x c-k   c-p
        c-x c-s   c-p  = Spelling 
        ord från synonymordbok
            thesaurus i vim mm
        OMNICOMPLETION
    Redigera Kommandoraden
        tecken för k-radsredigering
        Commandline Completion******
    EXKOMMANDON FÖR YANK, PUT, JOIN, MOVE MM (kop. klipp o klistra från kraden)**
    flera kommandon på samma rad  (=komm | komm)
    Commandhistory window
    pausa vim (+skalkommandon mm)
    encryption (=kolla nere under 'editing other filetypes')
    gfgF cw-f cw-gf  c-io *******
    path, current directory; find
    backupfil ORIGINALFIL(PATCHMODE) *******
    oldfiles***** 'edithistory'
    ((gui filebrowser))
        vim-buffer till gvim ******
    redigera fil: öppna spara byt_fil/namn (edit, save, saveas, ändra filnamn mm)
    undoträdet ****
        undo till senaste filewrite(=rak linje utan grenar**)
        numrera ändringar (grenar och undoträdet) *******
        tidshopp **
    Spara fil som kräver rootpriv. (t.ex. /etc/hosts )
    View file / Readonly
    Recover from crash*
    filnamn sökväg:   %:h #:t :r :e  :p
    BUFFERS OCH ARGSLIST
        :ls, :files, :buffers  Modtecken --> (= +-= u%# ahx) ******
    Vimdiff, Diffsplit, 3]c
    'editing other filetypes' (win/mac,web/ftp,encryption,binary,zip/compressed)
        lin/win/mac
        filer på nätet (+se också netrw)
        encryption
        binary/binära filer
        packade/komprimerade filer
    stäng fönster/fil
    skriv ut fil/skriv ut del av fil**
    .   NETRW* {{{
        obs: Grundinställningar i vimrc för att Netrw ska funka
        hjälp netrw
        (inställningar)
        navigera netrw
          EX, SEX, VEX M.FL.
            .
        öppna mapp/fil
                    .
                lösenord mm
        redigera fil över nätverk (scp, ssh mm mm ***)
        sudda/skapa fil/mapp
        (läs/spara fil)
        bokmärken
        behandla/processa fil med progr. x ***
        fil/mapplista  visa/dölj
            .
        fil/mappinfo
        behandla/ange _ som x
        .lista på maps som använder märkta filer =lägg över markering till listorna ovan###
    }}}
    Öppna nytt fönster
     FÖNSTER, TABS, SPLIT WINDOWS
        Gå till fönster x (förra/(n)nästa) *******
        byt pos./flytta/rotera fönster(arrangering)
        Öppna(split)/stäng fönster + Ange pos./arr.
        Sätt storlek fönster
    .
    .
    ((gui blandat))
        fönsterpos
        gvim som editor för annat epost-program
        visa/dölj delar av gui
    BLOCK/TEXTOBJEKT
    MARKS
    FOLDS
    REGISTERS********
        "=  
    i_c-r c-r x  c-r c-p +
    c-a c-x
    RECORD MACRO *** (q mm)
        Redigera i flera filer
            .förklaring
        Record Macro**
    formatera text:  gq  =((equalprog)  ,,  rader förbi kanten,  TABELLER(TABLES/COLUMNS)
    justera/ställ upp(align+justify) text
        filtrera/sortera till blank rad**
        IDÉ FÖR :w !sh  =DÖP OM FILER I EN MAPP (fr. *.x till *.c) *****
        STARTA SKAL (???)
        Speciella escapesekvenserna (<args> för alla arguments t.ex. *** )
        .
        .
        .
        .
        .
                qargs.vim (substitution/qargs.vim):
        Redigera i flera filer (e =undvik att fel stoppar kommandot****)
            .förklaring
    Exempel
    (RADADRESSER)****  :r1,r2
    räkna ord, räkna tecken mm****
    VISA(print) RADER M MÖNSTER
     :normal
    REGEX
        Regex vim mm
    pausa vim + köra Bash-kommandon mm
    VIEWS/SESSIONS/VIMINFO
    Viminfo
        the Viminfo-string **
    Sessions
    View
    pipe input to vim / läs från stdin
    .
    .
    .
    .
    .
            vim -e -s svenskasynonymer.temp.txt < ~/scripts/vim/clean_svenskasynonymer.vimscript
            vim -e -s danskordlista.temp.txt < ~/scripts/vim/clean_danskordlista.vimscript
VIMSCRIPT**********
    VUNDLE / INSTALLERA PLUGINS
        DECAGON VUNDLE TUTORIALS (3st):
            v1 (installera vundle)
                redigera .vimrc-filen
            v2 (lägga till plugins med vundle)
            v3 (installera fler plugins; ta bort plugins)
        vimplugin management *****
    PLUGINS / POPULAR BEST VIM PLUGINS
        youcompleteme/Vimcompleteme ********
    .
    .
    .
    .
    .
    .
    .
        bash ***
        python ****
        c/cpp
        java
        xml **
        htmlcss
        javascript
        docbook
        lua
    ....
    Man
                qargs.vim (substitution/qargs.vim):
    ((.plocka))
   GENOMGÅNG/ANKISOURCEFRÅGOR (lista att lägga rätt mm)
    While editing a shell script or C program, you are using a command or function
    SESSIONS :)
   Plocka (först = bra lista)
  också plocka in
   lite extra från ed-genomgångarna att plocka in, vid tillfälle
   om colorschemes
    ##help-index - länkar, ämnen och sökord
    verrmess
          vpropflags(?) (amiga, arabic mm):

}}}

##VIM AUTOCOMMANDS {{{
    http://vimdoc.sourceforge.net/htmldoc/autocmd.html

___a_aucmd

    autocmd FileType text setlocal textwidth=78

    autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \  exe "normal! g`\"" |
        \ endif

    filtyper vim känner igen (=alla filerna i /usr/share/vim/vim74/ftplugin) {{{

         *
         *.txt
         *.html

        python
        postscr
        html
        css
        scheme
        javascript
        java
        lua
        text
        vim
        tex
        svg
        lisp
        markdown
        xml
        sql
        sh
        r
        php
        prolog
        c
        cpp
        ----
            haml
        clojure
        man
        json
        git
        a2ps
        pdf
        ant
        go
        diff
        conf
        hamster
        haskell
        help
        hgcommit
        hog
        hostconf
        hostsaccess
        htmldjango
        indent
        initex
        ishd
        jproperties
        grub
        less
        mail
        make
        manconf
        passwd
        perl6
        perl
        matlab
        readline
        ruby

        aap
        abap
        abaqus
        ada
        alsaconf
        arch
        art
        aspvbs
        automake
        bdf
        bst
        btm
        bzl
        calendar
        cdrdaoconf
        changelog
        ch
        cobol
        config
        context
        crm
        csc
        csh
        cs
        cucumber
        cvsrc
        debchangelog
        debcontrol
        denyhosts
        dictconf
        dictdconf
        dircolors
        docbk
        dockerfile
        dosbatch
        dosini
        dtd
        dtrace
        eiffel
        elinks
        erlang
        eruby
        eterm
        falcon
        fetchmail
        flexwiki
        fortran
        framescript
        fvwm
        gitcommit
        gitconfig
        gitrebase
        gitsendemail
        gpg
        gprof
        group
        jsp
        j
        kconfig
        kwt
        ld
        lftp
        libao
        limits
        liquid
        logcheck
        loginaccess
        logindefs
        logtalk.dict
        logtalk
        lprolog
        m4
        mailaliases
        mailcap
        mf
        modconf
        mplayerconf
        mp
        mrxvtrc
        msmessages
        muttrc
        nanorc
        netrc
        nsis
        objc
        ocaml
        occam
        pamconf
        pascal
        pinfo
        plaintex
        procmail
        protocols
        pyrex
        qf
        quake
        racc
        registry
        reva
        rhelp
        rmd
        rnc
        rnoweb
        rpl
        rrst
        rst
        sass
        screen
        scss
        sensors
        services
        setserial
        sgml
        sieve
        slpconf
        slpreg
        slpspi
        spec
        sshconfig
        sudoers
        sysctl
        systemd
        systemverilog
        tcl
        tcsh
        terminfo
        treetop
        tt2html
        udevconf
        udevperm
        udevrules
        updatedb
        vb
        verilog
        vhdl
        vroom
        xdefaults
        xf86conf
        xhtml
        xinetd
        xmodmap
        xsd
        xslt
        xs
        yaml
        zimbu
        zsh

    }}}

}}}
events för vim autocommands {{{
    http://vimdoc.sourceforge.net/htmldoc/autocmd.html

___a_aucmd_event


    FileType            when the 'filetype' option has been set     __options
    BufNewFile          starting to edit a file that doesn't exist      __reading
    BufRead             starting to edit a new buffer, after reading the file       __reading
    BufWritePre         starting to write the whole buffer to a file        __writing
    BufWrite            starting to write the whole buffer to a file        __writing




    Name            triggered by 

        Reading
    BufReadPre          starting to edit a new buffer, before reading the file
    BufReadPost         starting to edit a new buffer, after reading the file
    BufReadCmd          before starting to edit a new buffer Cmd-event
    FileReadPre         before reading a file with a ":read" command
    FileReadPost        after reading a file with a ":read" command
    FileReadCmd         before reading a file with a ":read" command Cmd-event
    FilterReadPre       before reading a file from a filter command
    FilterReadPost      after reading a file from a filter command
     StdinReadPre       before reading from stdin into the buffer
     StdinReadPost      After reading from the stdin into the buffer

        Writing
     BufWritePost       after writing the whole buffer to a file
    BufWriteCmd         before writing the whole buffer to a file Cmd-event
    FileWritePre        starting to write part of a buffer to a file
    FileWritePost       after writing part of a buffer to a file
    FileWriteCmd        before writing part of a buffer to a file Cmd-event
     FileAppendPre      starting to append to a file
     FileAppendPost     after appending to a file
    FileAppendCmd       before appending to a file Cmd-event
    FilterWritePre      starting to write a file for a filter command or diff
    FilterWritePost     after writing a file for a filter command or diff

        Buffers
    BufAdd              just after adding a buffer to the buffer list
    BufCreate           just after adding a buffer to the buffer list
     BufDelete          before deleting a buffer from the buffer list
    BufWipeout          before completely deleting a buffer
    BufFilePre          before changing the name of the current buffer
    BufFilePost         after changing the name of the current buffer
    BufEnter            after entering a buffer
    BufLeave            before leaving to another buffer
    BufWinEnter         after a buffer is displayed in a window
    BufWinLeave         before a buffer is removed from a window
    BufUnload           before unloading a buffer
    BufHidden           just after a buffer has become hidden
    BufNew              just after creating a new buffer
    SwapExists          detected an existing swap file

        Options
    Syntax              when the 'syntax' option has been set
    EncodingChanged     after the 'encoding' option has been changed
    TermChanged         after the value of 'term' has changed

        Startup and exit
    VimEnter            after doing all the startup stuff
    GUIEnter            after starting the GUI successfully
    TermResponse        after the terminal response to t_RV is received
    VimLeavePre         before exiting Vim, before writing the viminfo file
    VimLeave            before exiting Vim, after writing the viminfo file

        Various
    FileChangedShell        Vim notices that a file changed since editing started
    FileChangedShellPost    After handling a file changed since editing started
    FileChangedRO           before making the first change to a read-only file
    ShellCmdPost        after executing a shell command
    ShellFilterPost     after filtering with a shell command
    FuncUndefined       a user function is used but it isn't defined
    SpellFileMissing    a spell file is used but it can't be found
    SourcePre           before sourcing a Vim script
    SourceCmd           before sourcing a Vim script Cmd-event
    VimResized          after the Vim window size changed
    FocusGained         Vim got input focus
    FocusLost           Vim lost input focus
    CursorHold          the user doesn't press a key for a while
    CursorHoldI         the user doesn't press a key for a while in Insert mode
    CursorMoved         the cursor was moved in Normal mode
    CursorMovedI        the cursor was moved in Insert mode
    WinEnter            after entering another window
    WinLeave            before leaving a window
    TabEnter            after entering another tab page
    TabLeave            before leaving a tab page
    CmdwinEnter         after entering the command-line window
    CmdwinLeave         before leaving the command-line window
    InsertEnter         starting Insert mode
    InsertChange        when typing <Insert> while in Insert or Replace mode
    InsertLeave         when leaving Insert mode
    ColorScheme         after loading a color scheme
    RemoteReply         a reply from a server Vim was received
    QuickFixCmdPre      before a quickfix command is run
    QuickFixCmdPost     after a quickfix command is run
    SessionLoadPost     after loading a session file
    MenuPopup           just before showing the popup menu
    User                to be used in combination with ":doautocmd"


}}}
##EX_COMMANDS {{{

http://vimdoc.sourceforge.net/htmldoc/vimindex.html#ex-cmd-index

___a_excmd
        |:!|        :!      filter lines or execute an external command
        |:!!|       :!!     repeat last ":!" command
        |:#|        :#      same as ":number"
        |:&|        :&      repeat last ":substitute"
        |:star|     :*      execute contents of a register
        |:<|        :<      shift lines one 'shiftwidth' left
        |:=|        :=      print the cursor line number
        |:>|        :>      shift lines one 'shiftwidth' right
        |:@|        :@      execute contents of a register
        |:@@|       :@@     repeat the previous ":@"
        |:Next|     :N[ext]     go to previous file in the argument list
        |:Print|    :P[rint]    print lines
        |:X|        :X      ask for encryption key
        |:append|   :a[ppend]   append text
        |:abbreviate|   :ab[breviate]   enter abbreviation
        |:abclear|  :abc[lear]  remove all abbreviations
        |:aboveleft|    :abo[veleft]    make split window appear left or above
        |:all|      :al[l]      open a window for each file in the argument
                        list
        |:amenu|    :am[enu]    enter new menu item for all modes
        |:anoremenu|    :an[oremenu]    enter a new menu for all modes that will not
                        be remapped
        |:args|     :ar[gs]     print the argument list
        |:argadd|   :arga[dd]   add items to the argument list
        |:argdelete|    :argd[elete]    delete items from the argument list
        |:argedit|  :arge[dit]  add item to the argument list and edit it
        |:argdo|    :argdo      do a command on all items in the argument list
        |:argglobal|    :argg[lobal]    define the global argument list
        |:arglocal| :argl[ocal] define a local argument list
        |:argument| :argu[ment] go to specific file in the argument list
        |:ascii|    :as[cii]    print ascii value of character under the cursor
        |:autocmd|  :au[tocmd]  enter or show autocommands
        |:augroup|  :aug[roup]  select the autocommand group to use
        |:aunmenu|  :aun[menu]  remove menu for all modes
        |:buffer|   :b[uffer]   go to specific buffer in the buffer list
        |:bNext|    :bN[ext]    go to previous buffer in the buffer list
        |:ball|     :ba[ll]     open a window for each buffer in the buffer list
        |:badd|     :bad[d]     add buffer to the buffer list
        |:bdelete|  :bd[elete]  remove a buffer from the buffer list
        |:behave|   :be[have]   set mouse and selection behavior
        |:belowright|   :bel[owright]   make split window appear right or below
        |:bfirst|   :bf[irst]   go to first buffer in the buffer list
        |:blast|    :bl[ast]    go to last buffer in the buffer list
        |:bmodified|    :bm[odified]    go to next buffer in the buffer list that has
                        been modified
        |:bnext|    :bn[ext]    go to next buffer in the buffer list
        |:botright| :bo[tright] make split window appear at bottom or far right
        |:bprevious|    :bp[revious]    go to previous buffer in the buffer list
        |:brewind|  :br[ewind]  go to first buffer in the buffer list
        |:break|    :brea[k]    break out of while loop
        |:breakadd| :breaka[dd] add a debugger breakpoint
        |:breakdel| :breakd[el] delete a debugger breakpoint
        |:breaklist|    :breakl[ist]    list debugger breakpoints
        |:browse|   :bro[wse]   use file selection dialog
        |:bufdo|    :bufdo      execute command in each listed buffer
        |:buffers|  :buffers    list all files in the buffer list
        |:bunload|  :bun[load]  unload a specific buffer
        |:bwipeout| :bw[ipeout] really delete a buffer
        |:change|   :c[hange]   replace a line or series of lines
        |:cNext|    :cN[ext]    go to previous error
        |:cNfile|   :cNf[ile]   go to last error in previous file
        |:cabbrev|  :ca[bbrev]  like ":abbreviate" but for Command-line mode
        |:cabclear| :cabc[lear] clear all abbreviations for Command-line mode
        |:caddbuffer|   :cad[dbuffer]   add errors from buffer
        |:caddexpr| :cadde[xpr] add errors from expr
        |:caddfile| :caddf[ile] add error message to current quickfix list
        |:call|     :cal[l]     call a function
        |:catch|    :cat[ch]    part of a :try command
        |:cbuffer|  :cb[uffer]  parse error messages and jump to first error
        |:cc|       :cc     go to specific error
        |:cclose|   :ccl[ose]   close quickfix window
        |:cd|       :cd     change directory
        |:center|   :ce[nter]   format lines at the center
        |:cexpr|    :cex[pr]    read errors from expr and jump to first
        |:cfile|    :cf[ile]    read file with error messages and jump to first
        |:cfirst|   :cfir[st]   go to the specified error, default first one
        |:cgetbuffer|   :cgetb[uffer]   get errors from buffer
        |:cgetexpr| :cgete[xpr] get errors from expr
        |:cgetfile| :cg[etfile] read file with error messages
        |:changes|  :changes    print the change list
        |:chdir|    :chd[ir]    change directory
        |:checkpath|    :che[ckpath]    list included files
        |:checktime|    :checkt[ime]    check timestamp of loaded buffers
        |:clist|    :cl[ist]    list all errors
        |:clast|    :cla[st]    go to the specified error, default last one
        |:close|    :clo[se]    close current window
        |:cmap|     :cm[ap]     like ":map" but for Command-line mode
        |:cmapclear|    :cmapc[lear]    clear all mappings for Command-line mode
        |:cmenu|    :cme[nu]    add menu for Command-line mode
        |:cnext|    :cn[ext]    go to next error
        |:cnewer|   :cnew[er]   go to newer error list
        |:cnfile|   :cnf[ile]   go to first error in next file
        |:cnoremap| :cno[remap] like ":noremap" but for Command-line mode
        |:cnoreabbrev|  :cnorea[bbrev]  like ":noreabbrev" but for Command-line mode
        |:cnoremenu|    :cnoreme[nu]    like ":noremenu" but for Command-line mode
        |:copy|     :co[py]     copy lines
        |:colder|   :col[der]   go to older error list
        |:colorscheme|  :colo[rscheme]  load a specific color scheme
        |:command|  :com[mand]  create user-defined command
        |:comclear| :comc[lear] clear all user-defined commands
        |:compiler| :comp[iler] do settings for a specific compiler
        |:continue| :con[tinue] go back to :while
        |:confirm|  :conf[irm]  prompt user when confirmation required
        |:copen|    :cope[n]    open quickfix window
        |:cprevious|    :cp[revious]    go to previous error
        |:cpfile|   :cpf[ile]   go to last error in previous file
        |:cquit|    :cq[uit]    quit Vim with an error code
        |:crewind|  :cr[ewind]  go to the specified error, default first one
        |:cscope|   :cs[cope]       execute cscope command
        |:cstag|    :cst[ag]    use cscope to jump to a tag
        |:cunmap|   :cu[nmap]   like ":unmap" but for Command-line mode
        |:cunabbrev|    :cuna[bbrev]    like ":unabbrev" but for Command-line mode
        |:cunmenu|  :cunme[nu]  remove menu for Command-line mode
        |:cwindow|  :cw[indow]  open or close quickfix window
        |:delete|   :d[elete]   delete lines
        |:delmarks| :delm[arks] delete marks
        |:debug|    :deb[ug]    run a command in debugging mode
        |:debuggreedy|  :debugg[reedy]  read debug mode commands from normal input
        |:delcommand|   :delc[ommand]   delete user-defined command
        |:delfunction|  :delf[unction]  delete a user function
        |:diffupdate|   :dif[fupdate]   update 'diff' buffers
        |:diffget|  :diffg[et]  remove differences in current buffer
        |:diffoff|  :diffo[ff]  switch off diff mode
        |:diffpatch|    :diffp[atch]    apply a patch and show differences
        |:diffput|  :diffpu[t]  remove differences in other buffer
        |:diffsplit|    :diffs[plit]    show differences with another file
        |:diffthis| :diffthis   make current window a diff window
        |:digraphs| :dig[raphs] show or enter digraphs
        |:display|  :di[splay]  display registers
        |:djump|    :dj[ump]    jump to #define
        |:dl|       :dl     short for |:delete| with the 'l' flag
        |:dl|       :del[ete]l  short for |:delete| with the 'l' flag
        |:dlist|    :dli[st]    list #defines
        |:doautocmd|    :do[autocmd]    apply autocommands to current buffer
        |:doautoall|    :doautoa[ll]    apply autocommands for all loaded buffers
        |:dp|       :d[elete]p  short for |:delete| with the 'p' flag
        |:drop|     :dr[op]     jump to window editing file or edit file in
                        current window
        |:dsearch|  :ds[earch]  list one #define
        |:dsplit|   :dsp[lit]   split window and jump to #define
        |:edit|     :e[dit]     edit a file
        |:earlier|  :ea[rlier]  go to older change, undo
        |:echo|     :ec[ho]     echoes the result of expressions
        |:echoerr|  :echoe[rr]  like :echo, show like an error and use history
        |:echohl|   :echoh[l]   set highlighting for echo commands
        |:echomsg|  :echom[sg]  same as :echo, put message in history
        |:echon|    :echon      same as :echo, but without <EOL>
        |:else|     :el[se]     part of an :if command
        |:elseif|   :elsei[f]   part of an :if command
        |:emenu|    :em[enu]    execute a menu by name
        |:endif|    :en[dif]    end previous :if
        |:endfor|   :endfo[r]   end previous :for
        |:endfunction|  :endf[unction]  end of a user function
        |:endtry|   :endt[ry]   end previous :try
        |:endwhile| :endw[hile] end previous :while
        |:enew|     :ene[w]     edit a new, unnamed buffer
        |:ex|       :ex     same as ":edit"
        |:execute|  :exe[cute]  execute result of expressions
        |:exit|     :exi[t]     same as ":xit"
        |:exusage|  :exu[sage]  overview of Ex commands
        |:file|     :f[ile]     show or set the current file name
        |:files|    :files      list all files in the buffer list
|:filetype| :filet[ype] switch file type detection on/off      om :filetype=   , så är inte filtypen identifierad    :set filetype=fortran    ,,   #vim: syntax=make  =sätta syntaxfiltyp m modeline
Visa/Lista filtyper tillgängliga för syntaxfärgning ; kika i $VIMRUNTIME/syntax
        |:find|     :fin[d]     find file in 'path' and edit it
        |:finally|  :fina[lly]  part of a :try command
        |:finish|   :fini[sh]   quit sourcing a Vim script
        |:first|    :fir[st]    go to the first file in the argument list
        |:fixdel|   :fix[del]   set key code of <Del>
        |:fold|     :fo[ld]     create a fold
        |:foldclose|    :foldc[lose]    close folds
        |:folddoopen|   :foldd[oopen]   execute command on lines not in a closed fold
        |:folddoclosed| :folddoc[losed] execute command on lines in a closed fold
        |:foldopen| :foldo[pen] open folds
        |:for|      :for        for loop
        |:function| :fu[nction] define a user function
        |:global|   :g[lobal]   execute commands for matching lines
        |:goto|     :go[to]     go to byte in the buffer
        |:grep|     :gr[ep]     run 'grepprg' and jump to first match
        |:grepadd|  :grepa[dd]  like :grep, but append to current list
        |:gui|      :gu[i]      start the GUI
        |:gvim|     :gv[im]     start the GUI
        |:hardcopy| :ha[rdcopy] send text to the printer
        |:help|     :h[elp]     open a help window
        |:helpclose|    :helpc[lose]    close one help window
        |:helpfind| :helpf[ind] dialog to open a help window
        |:helpgrep| :helpg[rep] like ":grep" but searches help files
        |:helptags| :helpt[ags] generate help tags for a directory
        |:highlight|    :hi[ghlight]    specify highlighting methods
        |:hide|     :hid[e]     hide current buffer for a command
        |:history|  :his[tory]  print a history list
        |:insert|   :i[nsert]   insert text
        |:iabbrev|  :ia[bbrev]  like ":abbrev" but for Insert mode
        |:iabclear| :iabc[lear] like ":abclear" but for Insert mode
        |:if|       :if     execute commands when condition met
        |:ijump|    :ij[ump]    jump to definition of identifier
        |:ilist|    :il[ist]    list lines where identifier matches
        |:imap|     :im[ap]     like ":map" but for Insert mode
        |:imapclear|    :imapc[lear]    like ":mapclear" but for Insert mode
        |:imenu|    :ime[nu]    add menu for Insert mode
        |:inoremap| :ino[remap] like ":noremap" but for Insert mode
        |:inoreabbrev|  :inorea[bbrev]  like ":noreabbrev" but for Insert mode
        |:inoremenu|    :inoreme[nu]    like ":noremenu" but for Insert mode
        |:intro|    :int[ro]    print the introductory message
        |:isearch|  :is[earch]  list one line where identifier matches
        |:isplit|   :isp[lit]   split window and jump to definition of
                        identifier
        |:iunmap|   :iu[nmap]   like ":unmap" but for Insert mode
        |:iunabbrev|    :iuna[bbrev]    like ":unabbrev" but for Insert mode
        |:iunmenu|  :iunme[nu]  remove menu for Insert mode
        |:join|     :j[oin]     join lines
        |:jumps|    :ju[mps]    print the jump list
        |:k|        :k      set a mark
        |:keepalt|  :keepa[lt]  following command keeps the alternate file
        |:keepmarks|    :kee[pmarks]    following command keeps marks where they are
        |:keepjumps|    :keepj[umps]    following command keeps jumplist and marks
        |:keeppatterns| :keepp[atterns] following command keeps search pattern history
        |:lNext|    :lN[ext]    go to previous entry in location list
        |:lNfile|   :lNf[ile]   go to last entry in previous file
        |:list|     :l[ist]     print lines
        |:laddexpr| :lad[dexpr] add locations from expr
        |:laddbuffer|   :laddb[uffer]   add locations from buffer
        |:laddfile| :laddf[ile] add locations to current location list
        |:last|     :la[st]     go to the last file in the argument list
        |:language| :lan[guage] set the language (locale)
        |:later|    :lat[er]    go to newer change, redo
        |:lbuffer|  :lb[uffer]  parse locations and jump to first location
        |:lcd|      :lc[d]      change directory locally
        |:lchdir|   :lch[dir]   change directory locally
        |:lclose|   :lcl[ose]   close location window
        |:lcscope|  :lcs[cope]      like ":cscope" but uses location list
        |:left|     :le[ft]     left align lines
        |:leftabove|    :lefta[bove]    make split window appear left or above
        |:let|      :let        assign a value to a variable or option
        |:lexpr|    :lex[pr]    read locations from expr and jump to first
        |:lfile|    :lf[ile]    read file with locations and jump to first
        |:lfirst|   :lfir[st]   go to the specified location, default first one
        |:lgetbuffer|   :lgetb[uffer]   get locations from buffer
        |:lgetexpr| :lgete[xpr] get locations from expr
        |:lgetfile| :lg[etfile] read file with locations
        |:lgrep|    :lgr[ep]    run 'grepprg' and jump to first match
        |:lgrepadd| :lgrepa[dd] like :grep, but append to current list
        |:lhelpgrep|    :lh[elpgrep]    like ":helpgrep" but uses location list
        |:ll|       :ll     go to specific location
        |:llast|    :lla[st]    go to the specified location, default last one
        |:llist|    :lli[st]    list all locations
        |:lmake|    :lmak[e]    execute external command 'makeprg' and parse
                        error messages
        |:lmap|     :lm[ap]     like ":map!" but includes Lang-Arg mode
        |:lmapclear|    :lmapc[lear]    like ":mapclear!" but includes Lang-Arg mode
        |:lnext|    :lne[xt]    go to next location
        |:lnewer|   :lnew[er]   go to newer location list
        |:lnfile|   :lnf[ile]   go to first location in next file
        |:lnoremap| :ln[oremap] like ":noremap!" but includes Lang-Arg mode
        |:loadkeymap|   :loadk[eymap]   load the following keymaps until EOF
        |:loadview| :lo[adview] load view for current window from a file
        |:lockmarks|    :loc[kmarks]    following command keeps marks where they are
        |:lockvar|  :lockv[ar]  lock variables
        |:lolder|   :lol[der]   go to older location list
        |:lopen|    :lope[n]    open location window
        |:lprevious|    :lp[revious]    go to previous location
        |:lpfile|   :lpf[ile]   go to last location in previous file
        |:lrewind|  :lr[ewind]  go to the specified location, default first one
        |:ls|       :ls     list all buffers
        |:ltag|     :lt[ag]     jump to tag and add matching tags to the
                        location list
        |:lunmap|   :lu[nmap]   like ":unmap!" but includes Lang-Arg mode
        |:lua|      :lua        execute |Lua| command
        |:luado|    :luad[o]    execute Lua command for each line
        |:luafile|  :luaf[ile]  execute |Lua| script file
        |:lvimgrep| :lv[imgrep] search for pattern in files
        |:lvimgrepadd|  :lvimgrepa[dd]  like :vimgrep, but append to current list
        |:lwindow|  :lw[indow]  open or close location window
        |:move|     :m[ove]     move lines
        |:mark|     :ma[rk]     set a mark
        |:make|     :mak[e]     execute external command 'makeprg' and parse
                        error messages
        |:map|      :map        show or enter a mapping
        |:mapclear| :mapc[lear] clear all mappings for Normal and Visual mode
        |:marks|    :marks      list all marks
        |:match|    :mat[ch]    define a match to highlight
        |:menu|     :me[nu]     enter a new menu item
        |:menutranslate| :menut[ranslate] add a menu translation item
        |:messages| :mes[sages] view previously displayed messages
        |:mkexrc|   :mk[exrc]   write current mappings and settings to a file
        |:mksession|    :mks[ession]    write session info to a file
        |:mkspell|  :mksp[ell]  produce .spl spell file
        |:mkvimrc|  :mkv[imrc]  write current mappings and settings to a file
        |:mkview|   :mkvie[w]   write view of current window to a file
        |:mode|     :mod[e]     show or change the screen mode
        |:mzscheme| :mz[scheme] execute MzScheme command
        |:mzfile|   :mzf[ile]   execute MzScheme script file
        |:nbclose|  :nbc[lose]  close the current Netbeans session
        |:nbkey|    :nb[key]    pass a key to Netbeans
        |:nbstart|  :nbs[art]   start a new Netbeans session
        |:next|     :n[ext]     go to next file in the argument list
        |:new|      :new        create a new empty window
        |:nmap|     :nm[ap]     like ":map" but for Normal mode
        |:nmapclear|    :nmapc[lear]    clear all mappings for Normal mode
        |:nmenu|    :nme[nu]    add menu for Normal mode
        |:nnoremap| :nn[oremap] like ":noremap" but for Normal mode
        |:nnoremenu|    :nnoreme[nu]    like ":noremenu" but for Normal mode
        |:noautocmd|    :noa[utocmd]    following commands don't trigger autocommands
        |:noremap|  :no[remap]  enter a mapping that will not be remapped
        |:nohlsearch|   :noh[lsearch]   suspend 'hlsearch' highlighting
        |:noreabbrev|   :norea[bbrev]   enter an abbreviation that will not be
                        remapped
        |:noremenu| :noreme[nu] enter a menu that will not be remapped
        |:normal|   :norm[al]   execute Normal mode commands
        |:noswapfile|   :nos[wapfile]   following commands don't create a swap file
        |:number|   :nu[mber]   print lines with line number
        |:nunmap|   :nun[map]   like ":unmap" but for Normal mode
        |:nunmenu|  :nunme[nu]  remove menu for Normal mode
        |:oldfiles| :ol[dfiles] list files that have marks in the viminfo file
        |:open|     :o[pen]     start open mode (not implemented)
        |:omap|     :om[ap]     like ":map" but for Operator-pending mode
        |:omapclear|    :omapc[lear]    remove all mappings for Operator-pending mode
        |:omenu|    :ome[nu]    add menu for Operator-pending mode
        |:only|     :on[ly]     close all windows except the current one
        |:onoremap| :ono[remap] like ":noremap" but for Operator-pending mode
        |:onoremenu|    :onoreme[nu]    like ":noremenu" but for Operator-pending mode
        |:options|  :opt[ions]  open the options-window
        |:ounmap|   :ou[nmap]   like ":unmap" but for Operator-pending mode
        |:ounmenu|  :ounme[nu]  remove menu for Operator-pending mode
        |:ownsyntax|    :ow[nsyntax]    set new local syntax highlight for this window
        |:pclose|   :pc[lose]   close preview window
        |:pedit|    :ped[it]    edit file in the preview window
        |:perl|     :pe[rl]     execute Perl command
        |:print|    :p[rint]    print lines
        |:profdel|  :profd[el]  stop profiling a function or script
        |:profile|  :prof[ile]  profiling functions and scripts
        |:promptfind|   :pro[mptfind]   open GUI dialog for searching
        |:promptrepl|   :promptr[epl]   open GUI dialog for search/replace
        |:perldo|   :perld[o]   execute Perl command for each line
        |:pop|      :po[p]      jump to older entry in tag stack
        |:popup|    :popu[p]    popup a menu by name
        |:ppop|     :pp[op]     ":pop" in preview window
        |:preserve| :pre[serve] write all text to swap file
        |:previous| :prev[ious] go to previous file in argument list
        |:psearch|  :ps[earch]  like ":ijump" but shows match in preview window
        |:ptag|     :pt[ag]     show tag in preview window
        |:ptNext|   :ptN[ext]   |:tNext| in preview window
        |:ptfirst|  :ptf[irst]  |:trewind| in preview window
        |:ptjump|   :ptj[ump]   |:tjump| and show tag in preview window
        |:ptlast|   :ptl[ast]   |:tlast| in preview window
        |:ptnext|   :ptn[ext]   |:tnext| in preview window
        |:ptprevious|   :ptp[revious]   |:tprevious| in preview window
        |:ptrewind| :ptr[ewind] |:trewind| in preview window
        |:ptselect| :pts[elect] |:tselect| and show tag in preview window
        |:put|      :pu[t]      insert contents of register in the text
        |:pwd|      :pw[d]      print current directory
        |:py3|      :py3        execute Python 3 command
        |:python3|  :python3    same as :py3
        |:py3do|    :py3d[o]    execute Python 3 command for each line
        |:py3file|  :py3f[ile]  execute Python 3 script file
        |:python|   :py[thon]   execute Python command
        |:pydo|     :pyd[o]     execute Python command for each line
        |:pyfile|   :pyf[ile]   execute Python script file
        |:quit|     :q[uit]     quit current window (when one window quit Vim)
        |:quitall|  :quita[ll]  quit Vim
        |:qall|     :qa[ll]     quit Vim
        |:read|     :r[ead]     read file into the text
        |:recover|  :rec[over]  recover a file from a swap file
        |:redo|     :red[o]     redo one undone change
        |:redir|    :redi[r]    redirect messages to a file or register
        |:redraw|   :redr[aw]   force a redraw of the display
        |:redrawstatus| :redraws[tatus] force a redraw of the status line(s)
        |:registers|    :reg[isters]    display the contents of registers
        |:resize|   :res[ize]   change current window height
        |:retab|    :ret[ab]    change tab size
        |:return|   :retu[rn]   return from a user function
        |:rewind|   :rew[ind]   go to the first file in the argument list
        |:right|    :ri[ght]    right align text
        |:rightbelow|   :rightb[elow]   make split window appear right or below
        |:ruby|     :rub[y]     execute Ruby command
        |:rubydo|   :rubyd[o]   execute Ruby command for each line
        |:rubyfile| :rubyf[ile] execute Ruby script file
        |:rundo|    :rund[o]    read undo information from a file
|:runtime|  :ru[ntime]  source vim scripts in 'runtimepath'     :runtime syntax/colortest.vim
   :runtime! ftplugin/man.vim    gör så mansidor dyker upp i vimfönster (så inte vim måste emulera terminal mm)
        |:rviminfo| :rv[iminfo] read from viminfo file
        |:substitute|   :s[ubstitute]   find and replace text
        |:sNext|    :sN[ext]    split window and go to previous file in
                        argument list
        |:sandbox|  :san[dbox]  execute a command in the sandbox
        |:sargument|    :sa[rgument]    split window and go to specific file in
                        argument list
        |:sall|     :sal[l]     open a window for each file in argument list
        |:saveas|   :sav[eas]   save file under another name.
        |:sbuffer|  :sb[uffer]  split window and go to specific file in the
                        buffer list
        |:sbNext|   :sbN[ext]   split window and go to previous file in the
                        buffer list
        |:sball|    :sba[ll]    open a window for each file in the buffer list
        |:sbfirst|  :sbf[irst]  split window and go to first file in the
                        buffer list
        |:sblast|   :sbl[ast]   split window and go to last file in buffer
                        list
        |:sbmodified|   :sbm[odified]   split window and go to modified file in the
                        buffer list
        |:sbnext|   :sbn[ext]   split window and go to next file in the buffer
                        list
        |:sbprevious|   :sbp[revious]   split window and go to previous file in the
                        buffer list
        |:sbrewind| :sbr[ewind] split window and go to first file in the
                        buffer list
        |:scriptnames|  :scrip[tnames]  list names of all sourced Vim scripts
        |:scriptencoding| :scripte[ncoding] encoding used in sourced Vim script
        |:scscope|  :scs[cope]  split window and execute cscope command
        |:set|      :se[t]      show or set options
        |:setfiletype|  :setf[iletype]  set 'filetype', unless it was set already
        |:setglobal|    :setg[lobal]    show global values of options
        |:setlocal| :setl[ocal] show or set options locally
        |:sfind|    :sf[ind]    split current window and edit file in 'path'
        |:sfirst|   :sfir[st]   split window and go to first file in the
                        argument list
        |:shell|    :sh[ell]    escape to a shell
        |:simalt|   :sim[alt]   Win32 GUI: simulate Windows ALT key
        |:sign|     :sig[n]     manipulate signs
        |:silent|   :sil[ent]   run a command silently
        |:sleep|    :sl[eep]    do nothing for a few seconds
        |:slast|    :sla[st]    split window and go to last file in the
                        argument list
        |:smagic|   :sm[agic]   :substitute with 'magic'
        |:smap|     :smap       like ":map" but for Select mode
        |:smapclear|    :smapc[lear]    remove all mappings for Select mode
        |:smenu|    :sme[nu]    add menu for Select mode
        |:snext|    :sn[ext]    split window and go to next file in the
                        argument list
        |:sniff|    :sni[ff]    send request to sniff
        |:snomagic| :sno[magic] :substitute with 'nomagic'
        |:snoremap| :snor[emap] like ":noremap" but for Select mode
        |:snoremenu|    :snoreme[nu]    like ":noremenu" but for Select mode
        |:sort|     :sor[t]     sort lines
        |:source|   :so[urce]   read Vim or Ex commands from a file
        |:spelldump|    :spelld[ump]    split window and fill with all correct words
        |:spellgood|    :spe[llgood]    add good word for spelling
        |:spellinfo|    :spelli[nfo]    show info about loaded spell files
        |:spellrepall|  :spellr[epall]  replace all bad words like last |z=|
        |:spellundo|    :spellu[ndo]    remove good or bad word
        |:spellwrong|   :spellw[rong]   add spelling mistake
        |:split|    :sp[lit]    split current window
        |:sprevious|    :spr[evious]    split window and go to previous file in the
                        argument list
        |:srewind|  :sre[wind]  split window and go to first file in the
                        argument list
        |:stop|     :st[op]     suspend the editor or escape to a shell
        |:stag|     :sta[g]     split window and jump to a tag
        |:startinsert|  :star[tinsert]  start Insert mode
        |:startgreplace| :startg[replace] start Virtual Replace mode
        |:startreplace| :startr[eplace] start Replace mode
        |:stopinsert|   :stopi[nsert]   stop Insert mode
        |:stjump|   :stj[ump]   do ":tjump" and split window
        |:stselect| :sts[elect] do ":tselect" and split window
        |:sunhide|  :sun[hide]  same as ":unhide"
        |:sunmap|   :sunm[ap]   like ":unmap" but for Select mode
        |:sunmenu|  :sunme[nu]  remove menu for Select mode
        |:suspend|  :sus[pend]  same as ":stop"
        |:sview|    :sv[iew]    split window and edit file read-only
        |:swapname| :sw[apname] show the name of the current swap file
|:syntax|   :sy[ntax]   syntax highlighting        :syntax enable  :syntax on    :syntax off    :syntax manual  #om man bara vill ha färgsyntax för vissa filer/filtyper
((if &t_Co > 1
syntax enable
endif)) s44 vimusermanual
        |:syntime|  :synti[me]  measure syntax highlighting speed
        |:syncbind| :sync[bind] sync scroll binding
        |:t|        :t      same as ":copy"
        |:tNext|    :tN[ext]    jump to previous matching tag
        |:tabNext|  :tabN[ext]  go to previous tab page
        |:tabclose| :tabc[lose] close current tab page
        |:tabdo|    :tabdo      execute command in each tab page
        |:tabedit|  :tabe[dit]  edit a file in a new tab page
        |:tabfind|  :tabf[ind]  find file in 'path', edit it in a new tab page
        |:tabfirst| :tabfir[st] got to first tab page
        |:tablast|  :tabl[ast]  got to last tab page
        |:tabmove|  :tabm[ove]  move tab page to other position
        |:tabnew|   :tabnew     edit a file in a new tab page
        |:tabnext|  :tabn[ext]  go to next tab page
        |:tabonly|  :tabo[nly]  close all tab pages except the current one
        |:tabprevious|  :tabp[revious]  go to previous tab page
        |:tabrewind|    :tabr[ewind]    got to first tab page
        |:tabs|     :tabs       list the tab pages and what they contain
        |:tab|      :tab        create new tab when opening new window
        |:tag|      :ta[g]      jump to tag
        |:tags|     :tags       show the contents of the tag stack
        |:tcl|      :tc[l]      execute Tcl command
        |:tcldo|    :tcld[o]    execute Tcl command for each line
        |:tclfile|  :tclf[ile]  execute Tcl script file
        |:tearoff|  :te[aroff]  tear-off a menu
        |:tfirst|   :tf[irst]   jump to first matching tag
        |:throw|    :th[row]    throw an exception
        |:tjump|    :tj[ump]    like ":tselect", but jump directly when there
                        is only one match
        |:tlast|    :tl[ast]    jump to last matching tag
        |:tmenu|    :tm[enu]    define menu tooltip
        |:tnext|    :tn[ext]    jump to next matching tag
        |:topleft|  :to[pleft]  make split window appear at top or far left
        |:tprevious|    :tp[revious]    jump to previous matching tag
        |:trewind|  :tr[ewind]  jump to first matching tag
        |:try|      :try        execute commands, abort on error or exception
        |:tselect|  :ts[elect]  list matching tags and select one
        |:tunmenu|  :tu[nmenu]  remove menu tooltip
        |:undo|     :u[ndo]     undo last change(s)
        |:undojoin| :undoj[oin] join next change with previous undo block
        |:undolist| :undol[ist] list leafs of the undo tree
        |:unabbreviate| :una[bbreviate] remove abbreviation
        |:unhide|   :unh[ide]   open a window for each loaded file in the
                        buffer list
        |:unlet|    :unl[et]    delete variable
        |:unlockvar|    :unlo[ckvar]    unlock variables
        |:unmap|    :unm[ap]    remove mapping
        |:unmenu|   :unme[nu]   remove menu
        |:unsilent| :uns[ilent] run a command not silently
        |:update|   :up[date]   write buffer if modified
        |:vglobal|  :v[global]  execute commands for not matching lines
|:version|  :ve[rsion]  print version number and other info
        |:verbose|  :verb[ose]  execute command with 'verbose' set
        |:vertical| :vert[ical] make following command split vertically
        |:vimgrep|  :vim[grep]  search for pattern in files
        |:vimgrepadd|   :vimgrepa[dd]   like :vimgrep, but append to current list
        |:visual|   :vi[sual]   same as ":edit", but turns off "Ex" mode
        |:viusage|  :viu[sage]  overview of Normal mode commands
        |:view|     :vie[w]     edit a file read-only
        |:vmap|     :vm[ap]     like ":map" but for Visual+Select mode
        |:vmapclear|    :vmapc[lear]    remove all mappings for Visual+Select mode
        |:vmenu|    :vme[nu]    add menu for Visual+Select mode
        |:vnew|     :vne[w]     create a new empty window, vertically split
        |:vnoremap| :vn[oremap] like ":noremap" but for Visual+Select mode
        |:vnoremenu|    :vnoreme[nu]    like ":noremenu" but for Visual+Select mode
        |:vsplit|   :vs[plit]   split current window vertically
        |:vunmap|   :vu[nmap]   like ":unmap" but for Visual+Select mode
        |:vunmenu|  :vunme[nu]  remove menu for Visual+Select mode
        |:windo|    :windo      execute command in each window
        |:write|    :w[rite]    write to a file
        |:wNext|    :wN[ext]    write to a file and go to previous file in
                        argument list
        |:wall|     :wa[ll]     write all (changed) buffers
        |:while|    :wh[ile]    execute loop for as long as condition met
        |:winsize|  :wi[nsize]  get or set window size (obsolete)
   :wincmd  :winc[md]   execute a Window (CTRL-W) command
        |:winpos|   :winp[os]   get or set window position
        |:wnext|    :wn[ext]    write to a file and go to next file in
                        argument list
        |:wprevious|    :wp[revious]    write to a file and go to previous file in
                        argument list
        |:wq|       :wq     write to a file and quit window or Vim
        |:wqall|    :wqa[ll]    write all changed buffers and quit Vim
        |:wsverb|   :ws[verb]   pass the verb to workshop over IPC
        |:wundo|    :wu[ndo]    write undo information to a file
        |:wviminfo| :wv[iminfo] write to viminfo file
        |:xit|      :x[it]      write if buffer changed and quit window or Vim
        |:xall|     :xa[ll]     same as ":wqall"
        |:xmapclear|    :xmapc[lear]    remove all mappings for Visual mode
        |:xmap|     :xm[ap]     like ":map" but for Visual mode
        |:xmenu|    :xme[nu]    add menu for Visual mode
        |:xnoremap| :xn[oremap] like ":noremap" but for Visual mode
        |:xnoremenu|    :xnoreme[nu]    like ":noremenu" but for Visual mode
        |:xunmap|   :xu[nmap]   like ":unmap" but for Visual mode
        |:xunmenu|  :xunme[nu]  remove menu for Visual mode
        |:yank|     :y[ank]     yank lines into a register
        |:z|        :z      print some lines
        |:~|        :~      repeat last ":substitute"
        }}}
. (list of vim-functions(from doc-usr41) - ordered by function/area**) {{{

    String manipulation:                    *string-functions*
        nr2char()       get a character by its ASCII value
        char2nr()       get ASCII value of a character
        str2nr()        convert a string to a Number
        str2float()     convert a string to a Float
        printf()        format a string according to % items
        escape()        escape characters in a string with a '\'
        shellescape()       escape a string for use with a shell command
        fnameescape()       escape a file name for use with a Vim command
        tr()            translate characters from one set to another
        strtrans()      translate a string to make it printable
        tolower()       turn a string to lowercase
        toupper()       turn a string to uppercase
        match()         position where a pattern matches in a string
        matchend()      position where a pattern match ends in a string
        matchstr()      match of a pattern in a string
        matchlist()     like matchstr() and also return submatches
        stridx()        first index of a short string in a long string
        strridx()       last index of a short string in a long string
        strlen()        length of a string
        substitute()        substitute a pattern match with a string
        submatch()      get a specific match in a ":substitute"
        strpart()       get part of a string
        expand()        expand special keywords
        iconv()         convert text from one encoding to another
        byteidx()       byte index of a character in a string
        repeat()        repeat a string multiple times
        eval()          evaluate a string expression


    List manipulation:                  *list-functions*
        get()           get an item without error for wrong index
        len()           number of items in a List
        empty()         check if List is empty
        insert()        insert an item somewhere in a List
        add()           append an item to a List
        extend()        append a List to a List
        remove()        remove one or more items from a List
        copy()          make a shallow copy of a List
        deepcopy()      make a full copy of a List
        filter()        remove selected items from a List
        map()           change each List item
        sort()          sort a List
        reverse()       reverse the order of a List
        split()         split a String into a List
        join()          join List items into a String
        range()         return a List with a sequence of numbers
        string()        String representation of a List
        call()          call a function with List as arguments
        index()         index of a value in a List
        max()           maximum value in a List
        min()           minimum value in a List
        count()         count number of times a value appears in a List
        repeat()        repeat a List multiple times


    Dictionary manipulation:                *dict-functions*
        get()           get an entry without an error for a wrong key
        len()           number of entries in a Dictionary
        has_key()       check whether a key appears in a Dictionary
        empty()         check if Dictionary is empty
        remove()        remove an entry from a Dictionary
        extend()        add entries from one Dictionary to another
        filter()        remove selected entries from a Dictionary
        map()           change each Dictionary entry
        keys()          get List of Dictionary keys
        values()        get List of Dictionary values
        items()         get List of Dictionary key-value pairs
        copy()          make a shallow copy of a Dictionary
        deepcopy()      make a full copy of a Dictionary
        string()        String representation of a Dictionary
        max()           maximum value in a Dictionary
        min()           minimum value in a Dictionary
        count()         count number of times a value appears


    Floating point computation:             *float-functions*
        float2nr()      convert Float to Number
        abs()           absolute value (also works for Number)
        round()         round off
        ceil()          round up
        floor()         round down
        trunc()         remove value after decimal point
        log10()         logarithm to base 10
        pow()           value of x to the exponent y
        sqrt()          square root
        sin()           sine
        cos()           cosine
        tan()           tangent
        asin()          arc sine
        acos()          arc cosine
        atan()          arc tangent
        atan2()         arc tangent
        sinh()          hyperbolic sine
        cosh()          hyperbolic cosine
        tanh()          hyperbolic tangent


    Variables:                      *var-functions*
        type()          type of a variable
        islocked()      check if a variable is locked
        function()      get a Funcref for a function name
        getbufvar()     get a variable value from a specific buffer
        setbufvar()     set a variable in a specific buffer
        getwinvar()     get a variable from specific window
        gettabvar()     get a variable from specific tab page
        gettabwinvar()      get a variable from specific window & tab page
        setwinvar()     set a variable in a specific window
        settabvar()     set a variable in a specific tab page
        settabwinvar()      set a variable in a specific window & tab page
        garbagecollect()    possibly free memory


    Cursor and mark position:       *cursor-functions* *mark-functions*
        col()           column number of the cursor or a mark
        virtcol()       screen column of the cursor or a mark
        line()          line number of the cursor or mark
        wincol()        window column number of the cursor
        winline()       window line number of the cursor
        cursor()        position the cursor at a line/column
        getpos()        get position of cursor, mark, etc.
        setpos()        set position of cursor, mark, etc.
        byte2line()     get line number at a specific byte count
        line2byte()     byte count at a specific line
        diff_filler()       get the number of filler lines above a line


    Working with text in the current buffer:        *text-functions*
        getline()       get a line or list of lines from the buffer
        setline()       replace a line in the buffer
        append()        append line or list of lines in the buffer
        indent()        indent of a specific line
        cindent()       indent according to C indenting
        lispindent()        indent according to Lisp indenting
        nextnonblank()      find next non-blank line
        prevnonblank()      find previous non-blank line
        search()        find a match for a pattern
        searchpos()     find a match for a pattern
        searchpair()        find the other end of a start/skip/end
        searchpairpos()     find the other end of a start/skip/end
        searchdecl()        search for the declaration of a name


                        *system-functions* *file-functions*
    System functions and manipulation of files:
        glob()          expand wildcards
        globpath()      expand wildcards in a number of directories
        findfile()      find a file in a list of directories
        finddir()       find a directory in a list of directories
        resolve()       find out where a shortcut points to
        fnamemodify()       modify a file name
        pathshorten()       shorten directory names in a path
        simplify()      simplify a path without changing its meaning
        executable()        check if an executable program exists
        filereadable()      check if a file can be read
        filewritable()      check if a file can be written to
        getfperm()      get the permissions of a file
        getftype()      get the kind of a file
        isdirectory()       check if a directory exists
        getfsize()      get the size of a file
        getcwd()        get the current working directory
        haslocaldir()       check if current window used |:lcd|
        tempname()      get the name of a temporary file
        mkdir()         create a new directory
        delete()        delete a file
        rename()        rename a file
        system()        get the result of a shell command
        hostname()      name of the system
        readfile()      read a file into a List of lines
        writefile()     write a List of lines into a file


    Date and Time:              *date-functions* *time-functions*
        getftime()      get last modification time of a file
        localtime()     get current time in seconds
        strftime()      convert time to a string
        reltime()       get the current or elapsed time accurately
        reltimestr()        convert reltime() result to a string


                *buffer-functions* *window-functions* *arg-functions*
    Buffers, windows and the argument list:
        argc()          number of entries in the argument list
        argidx()        current position in the argument list
        argv()          get one entry from the argument list
        bufexists()     check if a buffer exists
        buflisted()     check if a buffer exists and is listed
        bufloaded()     check if a buffer exists and is loaded
        bufname()       get the name of a specific buffer
        bufnr()         get the buffer number of a specific buffer
        tabpagebuflist()    return List of buffers in a tab page
        tabpagenr()     get the number of a tab page
        tabpagewinnr()      like winnr() for a specified tab page
        winnr()         get the window number for the current window
        bufwinnr()      get the window number of a specific buffer
        winbufnr()      get the buffer number of a specific window
        getbufline()        get a list of lines from the specified buffer


    Command line:                   *command-line-functions*
        getcmdline()        get the current command line
        getcmdpos()     get position of the cursor in the command line
        setcmdpos()     set position of the cursor in the command line
        getcmdtype()        return the current command-line type


    Quickfix and location lists:            *quickfix-functions*
        getqflist()     list of quickfix errors
        setqflist()     modify a quickfix list
        getloclist()        list of location list items
        setloclist()        modify a location list


    Insert mode completion:             *completion-functions*
        complete()      set found matches
        complete_add()      add to found matches
        complete_check()    check if completion should be aborted
        pumvisible()        check if the popup menu is displayed


    Folding:                    *folding-functions*
        foldclosed()        check for a closed fold at a specific line
        foldclosedend()     like foldclosed() but return the last line
        foldlevel()     check for the fold level at a specific line
        foldtext()      generate the line displayed for a closed fold
        foldtextresult()    get the text displayed for a closed fold


    Syntax and highlighting:      *syntax-functions* *highlighting-functions*
        clearmatches()      clear all matches defined by |matchadd()| and
                    the |:match| commands
        getmatches()        get all matches defined by |matchadd()| and
                    the |:match| commands
        hlexists()      check if a highlight group exists
        hlID()          get ID of a highlight group
        synID()         get syntax ID at a specific position
        synIDattr()     get a specific attribute of a syntax ID
        synIDtrans()        get translated syntax ID
        synstack()      get list of syntax IDs at a specific position
        synconcealed()      get info about concealing
        diff_hlID()     get highlight ID for diff mode at a position
        matchadd()      define a pattern to highlight (a "match")
        matcharg()      get info about |:match| arguments
        matchdelete()       delete a match defined by |matchadd()| or a
                    |:match| command
        setmatches()        restore a list of matches saved by
                    |getmatches()|


    Spelling:                   *spell-functions*
        spellbadword()      locate badly spelled word at or after cursor
        spellsuggest()      return suggested spelling corrections
        soundfold()     return the sound-a-like equivalent of a word


    History:                    *history-functions*
        histadd()       add an item to a history
        histdel()       delete an item from a history
        histget()       get an item from a history
        histnr()        get highest index of a history list


    Interactive:                    *interactive-functions*
        browse()        put up a file requester
        browsedir()     put up a directory requester
        confirm()       let the user make a choice
        getchar()       get a character from the user
        getcharmod()        get modifiers for the last typed character
        feedkeys()      put characters in the typeahead queue
        input()         get a line from the user
        inputlist()     let the user pick an entry from a list
        inputsecret()       get a line from the user without showing it
        inputdialog()       get a line from the user in a dialog
        inputsave()     save and clear typeahead
        inputrestore()      restore typeahead


    GUI:                        *gui-functions*
        getfontname()       get name of current font being used
        getwinposx()        X position of the GUI Vim window
        getwinposy()        Y position of the GUI Vim window


    Vim server:                 *server-functions*
        serverlist()        return the list of server names
        remote_send()       send command characters to a Vim server
        remote_expr()       evaluate an expression in a Vim server
        server2client()     send a reply to a client of a Vim server
        remote_peek()       check if there is a reply from a Vim server
        remote_read()       read a reply from a Vim server
        foreground()        move the Vim window to the foreground
        remote_foreground() move the Vim server window to the foreground


    Window size and position:           *window-size-functions*
        winheight()     get height of a specific window
        winwidth()      get width of a specific window
        winrestcmd()        return command to restore window sizes
        winsaveview()       get view of current window
        winrestview()       restore saved view of current window


    Various:                    *various-functions*
        mode()          get current editing mode
        visualmode()        last visual mode used
        hasmapto()      check if a mapping exists
        mapcheck()      check if a matching mapping exists
        maparg()        get rhs of a mapping
        exists()        check if a variable, function, etc. exists
        has()           check if a feature is supported in Vim
        changenr()      return number of most recent change
        cscope_connection() check if a cscope connection exists
        did_filetype()      check if a FileType autocommand was used
        eventhandler()      check if invoked by an event handler
        getpid()        get process ID of Vim

        libcall()       call a function in an external library
        libcallnr()     idem, returning a number

        getreg()        get contents of a register
        getregtype()        get type of a register
        setreg()        set contents and type of a register

        taglist()       get list of matching tags
        tagfiles()      get a list of tags files

        mzeval()        evaluate |MzScheme| expression


}}}
##VIM_FUNCTIONS (nr2char(), toupper() m.fl.) {{{
    :h function-list

___a_funct

        4. Builtin Functions                    *functions*
        See |function-list| for a list grouped by what the function is used for.
        (Use CTRL-] on the function name to jump to the full explanation.)
    Funktioner listade efter Kategorier **** {{{
        String manipulation:                    *string-functions*
            nr2char()       get a character by its ASCII value
            char2nr()       get ASCII value of a character
            str2nr()        convert a string to a Number
            str2float()     convert a string to a Float
            printf()        format a string according to % items
            escape()        escape characters in a string with a '\'
            shellescape()       escape a string for use with a shell command
            fnameescape()       escape a file name for use with a Vim command
            tr()            translate characters from one set to another
            strtrans()      translate a string to make it printable
            tolower()       turn a string to lowercase
            toupper()       turn a string to uppercase
            match()         position where a pattern matches in a string
            matchend()      position where a pattern match ends in a string
            matchstr()      match of a pattern in a string
            matchlist()     like matchstr() and also return submatches
            stridx()        first index of a short string in a long string
            strridx()       last index of a short string in a long string
            strlen()        length of a string in bytes
            strchars()      length of a string in characters
            strwidth()      size of string when displayed
            strdisplaywidth()   size of string when displayed, deals with tabs
            substitute()        substitute a pattern match with a string
            submatch()      get a specific match in ":s" and substitute()
            strpart()       get part of a string
            expand()        expand special keywords
            iconv()         convert text from one encoding to another
            byteidx()       byte index of a character in a string
            byteidxcomp()       like byteidx() but count composing characters
            repeat()        repeat a string multiple times
            eval()          evaluate a string expression

        List manipulation:                  *list-functions*
            get()           get an item without error for wrong index
            len()           number of items in a List
            empty()         check if List is empty
            insert()        insert an item somewhere in a List
            add()           append an item to a List
            extend()        append a List to a List
            remove()        remove one or more items from a List
            copy()          make a shallow copy of a List
            deepcopy()      make a full copy of a List
            filter()        remove selected items from a List
            map()           change each List item
            sort()          sort a List
            reverse()       reverse the order of a List
            uniq()          remove copies of repeated adjacent items
            split()         split a String into a List
            join()          join List items into a String
            range()         return a List with a sequence of numbers
            string()        String representation of a List
            call()          call a function with List as arguments
            index()         index of a value in a List
            max()           maximum value in a List
            min()           minimum value in a List
            count()         count number of times a value appears in a List
            repeat()        repeat a List multiple times

        Dictionary manipulation:                *dict-functions*
            get()           get an entry without an error for a wrong key
            len()           number of entries in a Dictionary
            has_key()       check whether a key appears in a Dictionary
            empty()         check if Dictionary is empty
            remove()        remove an entry from a Dictionary
            extend()        add entries from one Dictionary to another
            filter()        remove selected entries from a Dictionary
            map()           change each Dictionary entry
            keys()          get List of Dictionary keys
            values()        get List of Dictionary values
            items()         get List of Dictionary key-value pairs
            copy()          make a shallow copy of a Dictionary
            deepcopy()      make a full copy of a Dictionary
            string()        String representation of a Dictionary
            max()           maximum value in a Dictionary
            min()           minimum value in a Dictionary
            count()         count number of times a value appears

        Floating point computation:             *float-functions*
            float2nr()      convert Float to Number
            abs()           absolute value (also works for Number)
            round()         round off
            ceil()          round up
            floor()         round down
            trunc()         remove value after decimal point
            fmod()          remainder of division
            exp()           exponential
            log()           natural logarithm (logarithm to base e)
            log10()         logarithm to base 10
            pow()           value of x to the exponent y
            sqrt()          square root
            sin()           sine
            cos()           cosine
            tan()           tangent
            asin()          arc sine
            acos()          arc cosine
            atan()          arc tangent
            atan2()         arc tangent
            sinh()          hyperbolic sine
            cosh()          hyperbolic cosine
            tanh()          hyperbolic tangent

        Other computation:                  *bitwise-function*
            and()           bitwise AND
            invert()        bitwise invert
            or()            bitwise OR
            xor()           bitwise XOR
            sha256()        SHA-256 hash

        Variables:                      *var-functions*
            type()          type of a variable
            islocked()      check if a variable is locked
            function()      get a Funcref for a function name
            getbufvar()     get a variable value from a specific buffer
            setbufvar()     set a variable in a specific buffer
            getwinvar()     get a variable from specific window
            gettabvar()     get a variable from specific tab page
            gettabwinvar()      get a variable from specific window & tab page
            setwinvar()     set a variable in a specific window
            settabvar()     set a variable in a specific tab page
            settabwinvar()      set a variable in a specific window & tab page
            garbagecollect()    possibly free memory

        Cursor and mark position:       *cursor-functions* *mark-functions*
            col()           column number of the cursor or a mark
            virtcol()       screen column of the cursor or a mark
            line()          line number of the cursor or mark
            wincol()        window column number of the cursor
            winline()       window line number of the cursor
            cursor()        position the cursor at a line/column
            screencol()     get screen column of the cursor
            screenrow()     get screen row of the cursor
            getcurpos()     get position of the cursor
            getpos()        get position of cursor, mark, etc.
            setpos()        set position of cursor, mark, etc.
            byte2line()     get line number at a specific byte count
            line2byte()     byte count at a specific line
            diff_filler()       get the number of filler lines above a line
            screenattr()        get attribute at a screen line/row
            screenchar()        get character code at a screen line/row

        Working with text in the current buffer:        *text-functions*
            getline()       get a line or list of lines from the buffer
            setline()       replace a line in the buffer
            append()        append line or list of lines in the buffer
            indent()        indent of a specific line
            cindent()       indent according to C indenting
            lispindent()        indent according to Lisp indenting
            nextnonblank()      find next non-blank line
            prevnonblank()      find previous non-blank line
            search()        find a match for a pattern
            searchpos()     find a match for a pattern
            searchpair()        find the other end of a start/skip/end
            searchpairpos()     find the other end of a start/skip/end
            searchdecl()        search for the declaration of a name

                            *system-functions* *file-functions*
        System functions and manipulation of files:
            glob()          expand wildcards
            globpath()      expand wildcards in a number of directories
            findfile()      find a file in a list of directories
            finddir()       find a directory in a list of directories
            resolve()       find out where a shortcut points to
            fnamemodify()       modify a file name
            pathshorten()       shorten directory names in a path
            simplify()      simplify a path without changing its meaning
            executable()        check if an executable program exists
            exepath()       full path of an executable program
            filereadable()      check if a file can be read
            filewritable()      check if a file can be written to
            getfperm()      get the permissions of a file
            getftype()      get the kind of a file
            isdirectory()       check if a directory exists
            getfsize()      get the size of a file
            getcwd()        get the current working directory
            haslocaldir()       check if current window used |:lcd|
            tempname()      get the name of a temporary file
            mkdir()         create a new directory
            delete()        delete a file
            rename()        rename a file
            system()        get the result of a shell command as a string
            systemlist()        get the result of a shell command as a list
            hostname()      name of the system
            readfile()      read a file into a List of lines
            writefile()     write a List of lines into a file

        Date and Time:              *date-functions* *time-functions*
            getftime()      get last modification time of a file
            localtime()     get current time in seconds
            strftime()      convert time to a string
            reltime()       get the current or elapsed time accurately
            reltimestr()        convert reltime() result to a string

                    *buffer-functions* *window-functions* *arg-functions*
        Buffers, windows and the argument list:
            argc()          number of entries in the argument list
            argidx()        current position in the argument list
            arglistid()     get id of the argument list
            argv()          get one entry from the argument list
            bufexists()     check if a buffer exists
            buflisted()     check if a buffer exists and is listed
            bufloaded()     check if a buffer exists and is loaded
            bufname()       get the name of a specific buffer
            bufnr()         get the buffer number of a specific buffer
            tabpagebuflist()    return List of buffers in a tab page
            tabpagenr()     get the number of a tab page
            tabpagewinnr()      like winnr() for a specified tab page
            winnr()         get the window number for the current window
            bufwinnr()      get the window number of a specific buffer
            winbufnr()      get the buffer number of a specific window
            getbufline()        get a list of lines from the specified buffer

        Command line:                   *command-line-functions*
            getcmdline()        get the current command line
            getcmdpos()     get position of the cursor in the command line
            setcmdpos()     set position of the cursor in the command line
            getcmdtype()        return the current command-line type
            getcmdwintype()     return the current command-line window type

        Quickfix and location lists:            *quickfix-functions*
            getqflist()     list of quickfix errors
            setqflist()     modify a quickfix list
            getloclist()        list of location list items
            setloclist()        modify a location list

        Insert mode completion:             *completion-functions*
            complete()      set found matches
            complete_add()      add to found matches
            complete_check()    check if completion should be aborted
            pumvisible()        check if the popup menu is displayed

        Folding:                    *folding-functions*
            foldclosed()        check for a closed fold at a specific line
            foldclosedend()     like foldclosed() but return the last line
            foldlevel()     check for the fold level at a specific line
            foldtext()      generate the line displayed for a closed fold
            foldtextresult()    get the text displayed for a closed fold

        Syntax and highlighting:      *syntax-functions* *highlighting-functions*
            clearmatches()      clear all matches defined by |matchadd()| and
                        the |:match| commands
            getmatches()        get all matches defined by |matchadd()| and
                        the |:match| commands
            hlexists()      check if a highlight group exists
            hlID()          get ID of a highlight group
            synID()         get syntax ID at a specific position
            synIDattr()     get a specific attribute of a syntax ID
            synIDtrans()        get translated syntax ID
            synstack()      get list of syntax IDs at a specific position
            synconcealed()      get info about concealing
            diff_hlID()     get highlight ID for diff mode at a position
            matchadd()      define a pattern to highlight (a "match")
            matchaddpos()       define a list of positions to highlight
            matcharg()      get info about |:match| arguments
            matchdelete()       delete a match defined by |matchadd()| or a
                        |:match| command
            setmatches()        restore a list of matches saved by
                        |getmatches()|

        Spelling:                   *spell-functions*
            spellbadword()      locate badly spelled word at or after cursor
            spellsuggest()      return suggested spelling corrections
            soundfold()     return the sound-a-like equivalent of a word

        History:                    *history-functions*
            histadd()       add an item to a history
            histdel()       delete an item from a history
            histget()       get an item from a history
            histnr()        get highest index of a history list

        Interactive:                    *interactive-functions*
            browse()        put up a file requester
            browsedir()     put up a directory requester
            confirm()       let the user make a choice
            getchar()       get a character from the user
            getcharmod()        get modifiers for the last typed character
            feedkeys()      put characters in the typeahead queue
            input()         get a line from the user
            inputlist()     let the user pick an entry from a list
            inputsecret()       get a line from the user without showing it
            inputdialog()       get a line from the user in a dialog
            inputsave()     save and clear typeahead
            inputrestore()      restore typeahead

        GUI:                        *gui-functions*
            getfontname()       get name of current font being used
            getwinposx()        X position of the GUI Vim window
            getwinposy()        Y position of the GUI Vim window

        Vim server:                 *server-functions*
            serverlist()        return the list of server names
            remote_send()       send command characters to a Vim server
            remote_expr()       evaluate an expression in a Vim server
            server2client()     send a reply to a client of a Vim server
            remote_peek()       check if there is a reply from a Vim server
            remote_read()       read a reply from a Vim server
            foreground()        move the Vim window to the foreground
            remote_foreground() move the Vim server window to the foreground

        Window size and position:           *window-size-functions*
            winheight()     get height of a specific window
            winwidth()      get width of a specific window
            winrestcmd()        return command to restore window sizes
            winsaveview()       get view of current window
            winrestview()       restore saved view of current window

        Mappings:                   *mapping-functions*
            hasmapto()      check if a mapping exists
            mapcheck()      check if a matching mapping exists
            maparg()        get rhs of a mapping
            wildmenumode()      check if the wildmode is active

        Various:                    *various-functions*
            mode()          get current editing mode
            visualmode()        last visual mode used
            exists()        check if a variable, function, etc. exists
            has()           check if a feature is supported in Vim
            changenr()      return number of most recent change
            cscope_connection() check if a cscope connection exists
            did_filetype()      check if a FileType autocommand was used
            eventhandler()      check if invoked by an event handler
            getpid()        get process ID of Vim

            libcall()       call a function in an external library
            libcallnr()     idem, returning a number

            undofile()      get the name of the undo file
            undotree()      return the state of the undo tree

            getreg()        get contents of a register
            getregtype()        get type of a register
            setreg()        set contents and type of a register

            shiftwidth()        effective value of 'shiftwidth'

            taglist()       get list of matching tags
            tagfiles()      get a list of tags files

            luaeval()       evaluate Lua expression
            mzeval()        evaluate |MzScheme| expression
            py3eval()       evaluate Python expression (|+python3|)
            pyeval()        evaluate Python expression (|+python|)
    }}}

        *41.7*  Defining a function
        Vim enables you to define your own functions.  The basic function declaration begins as follows:
            :function {name}({var1}, {var2}, ...)
            :  {body}
            :endfunction

        expand( {expr} [, {flag}])  String  expand special keywords in {expr} {{{

            expand({expr} [, {flag}])               *expand()*
                    Expand wildcards and the following special keywords in {expr}.
                    The result is a String.  'wildignorecase' applies.

                    When there are several matches, they are separated by <NL>
                    characters.  [Note: in version 5.0 a space was used, which
                    caused problems when a file name contains a space]

                    If the expansion fails, the result is an empty string.  A name
                    for a non-existing file is not included.

                    When {expr} starts with '%', '#' or '<', the expansion is done
                    like for the |cmdline-special| variables with their associated
                    modifiers.  Here is a short overview:

                        %       current file name
                        #       alternate file name
                        #n      alternate file name n
                        <cfile>     file name under the cursor
                        <afile>     autocmd file name
                        <abuf>      autocmd buffer number (as a String!)
                        <amatch>    autocmd matched name
                        <sfile>     sourced script file name
                        <slnum>     sourced script file line number
                        <cword>     word under the cursor
                        <cWORD>     WORD under the cursor
                        <client>    the {clientid} of the last received message |server2client()|
                    Modifiers:
                        :p      expand to full path
                        :h      head (last path component removed)
                        :t      tail (last path component only)
                        :r      root (one extension removed)
                        :e      extension only


                    Example:
                        :let &tags = expand("%:p:h") . "/tags"
                    Note that when expanding a string that starts with '%', '#' or '<', any following text is ignored.  This does NOT work:
                        :let doesntwork = expand("%:h.bak")
                    Use this:
                        :let doeswork = expand("%:h") . ".bak"

                    Also note that expanding "<cfile>" and others only returns the
                    referenced file name without further expansion.  If "<cfile>"
                    is "~/.cshrc", you need to do another expand() to have the
                    "~/" expanded into the path of the home directory:
                        :echo expand(expand("<cfile>"))

                    There cannot be white space between the variables and the
                    following modifier.  The |fnamemodify()| function can be used
                    to modify normal file names.

                    When using '%' or '#', and the current or alternate file name
                    is not defined, an empty string is used.  Using "%:p" in a
                    buffer with no name, results in the current directory, with a
                    '/' added.

                    When {expr} does not start with '%', '#' or '<', it is
                    expanded like a file name is expanded on the command line.
                    'suffixes' and 'wildignore' are used, unless the optional
                    {flag} argument is given and it is non-zero.  Names for
                    non-existing files are included.  The "**" item can be used to
                    search in a directory tree.  For example, to find all "README"
                    files in the current directory and below:
                        :echo expand("**/README")

                    Expand() can also be used to expand variables and environment
                    variables that are only known in a shell.  But this can be
                    slow, because a shell must be started.  See |expr-env-expand|.
                    The expanded variable is still handled like a list of file
                    names.  When an environment variable cannot be expanded, it is
                    left unchanged.  Thus ":echo expand('$FOOBAR')" results in
                    "$FOOBAR".

                    See |glob()| for finding existing files.  See |system()| for
                    getting the raw output of an external command.

        }}}
        glob( {expr} [, {flag}])    String  expand file wildcards in {expr}
        system( {expr} [, {input}]) String  output of shell command/filter {expr}
        shellescape( {string} [, {special}]) String escape {string} for use as shell command argument


        Alfabetisk Lista Funktioner {{{
        USAGE               RESULT  DESCRIPTION 
        abs( {expr})            Float or Number  absolute value of {expr}
        acos( {expr})           Float   arc cosine of {expr}
        add( {list}, {item})        List    append {item} to |List| {list}
        append( {lnum}, {string})   Number  append {string} below line {lnum}
        append( {lnum}, {list})     Number  append lines {list} below line {lnum}
        argc()              Number  number of files in the argument list
        argidx()            Number  current index in the argument list
        argv( {nr})         String  {nr} entry of the argument list
        argv( )             List    the argument list
        asin( {expr})           Float   arc sine of {expr}
        atan( {expr})           Float   arc tangent of {expr}
        atan2( {expr}, {expr})      Float   arc tangent of {expr1} / {expr2}
        browse( {save}, {title}, {initdir}, {default})
                        String  put up a file requester
        browsedir( {title}, {initdir})  String  put up a directory requester
        bufexists( {expr})      Number  TRUE if buffer {expr} exists
        buflisted( {expr})      Number  TRUE if buffer {expr} is listed
        bufloaded( {expr})      Number  TRUE if buffer {expr} is loaded
        bufname( {expr})        String  Name of the buffer {expr}
        bufnr( {expr})          Number  Number of the buffer {expr}
        bufwinnr( {expr})       Number  window number of buffer {expr}
        byte2line( {byte})      Number  line number at byte count {byte}
        byteidx( {expr}, {nr})      Number  byte index of {nr}'th char in {expr}
        call( {func}, {arglist} [, {dict}])
                        any call {func} with arguments {arglist}
        ceil( {expr})           Float   round {expr} up
        changenr()          Number  current change number
        char2nr( {expr})        Number  ASCII value of first char in {expr}
        cindent( {lnum})        Number  C indent for line {lnum}
        clearmatches()          none    clear all matches
        col( {expr})            Number  column nr of cursor or mark
        complete( {startcol}, {matches}) none   set Insert mode completion
        complete_add( {expr})       Number  add completion match
        complete_check()        Number  check for key typed during completion
        confirm( {msg} [, {choices} [, {default} [, {type}]]])
                        Number  number of choice picked by user
        copy( {expr})           any make a shallow copy of {expr}
        cos( {expr})            Float   cosine of {expr}
        cosh( {expr})           Float   hyperbolic cosine of {expr}
        count( {list}, {expr} [, {start} [, {ic}]])
                        Number   count how many {expr} are in {list}
        cscope_connection( [{num} , {dbpath} [, {prepend}]])
                        Number  checks existence of cscope connection
        cursor( {lnum}, {col} [, {coladd}])
                        Number  move cursor to {lnum}, {col}, {coladd}
        cursor( {list})         Number  move cursor to position in {list}
        deepcopy( {expr})       any make a full copy of {expr}
        delete( {fname})        Number  delete file {fname}
        did_filetype()          Number  TRUE if FileType autocommand event used
        diff_filler( {lnum})        Number  diff filler lines about {lnum}
        diff_hlID( {lnum}, {col})   Number  diff highlighting at {lnum}/{col}
        empty( {expr})          Number  TRUE if {expr} is empty
        escape( {string}, {chars})  String  escape {chars} in {string} with '\'
        eval( {string})         any evaluate {string} into its value
        eventhandler( )         Number  TRUE if inside an event handler
        executable( {expr})     Number  1 if executable {expr} exists
        exists( {expr})         Number  TRUE if {expr} exists
        extend( {expr1}, {expr2} [, {expr3}])
                        List/Dict insert items of {expr2} into {expr1}
        exp( {expr})            Float   exponential of {expr}
        feedkeys( {string} [, {mode}])  Number  add key sequence to typeahead buffer
        filereadable( {file})       Number  TRUE if {file} is a readable file
        filewritable( {file})       Number  TRUE if {file} is a writable file
        filter( {expr}, {string})   List/Dict  remove items from {expr} where
                            {string} is 0
        finddir( {name}[, {path}[, {count}]])
                        String  find directory {name} in {path}
        findfile( {name}[, {path}[, {count}]])
                        String  find file {name} in {path}
        float2nr( {expr})       Number  convert Float {expr} to a Number
        floor( {expr})          Float   round {expr} down
        fmod( {expr1}, {expr2})     Float   remainder of {expr1} / {expr2}
        fnameescape( {fname})       String  escape special characters in {fname}
        fnamemodify( {fname}, {mods})   String  modify file name
        foldclosed( {lnum})     Number  first line of fold at {lnum} if closed
        foldclosedend( {lnum})      Number  last line of fold at {lnum} if closed
        foldlevel( {lnum})      Number  fold level at {lnum}
        foldtext( )         String  line displayed for closed fold
        foldtextresult( {lnum})     String  text for closed fold at {lnum}
        foreground( )           Number  bring the Vim window to the foreground
        function( {name})       Funcref reference to function {name}
        garbagecollect( [at_exit])  none    free memory, breaking cyclic references
        get( {list}, {idx} [, {def}])   any get item {idx} from {list} or {def}
        get( {dict}, {key} [, {def}])   any get item {key} from {dict} or {def}
        getbufline( {expr}, {lnum} [, {end}])
                        List    lines {lnum} to {end} of buffer {expr}
        getbufvar( {expr}, {varname})   any variable {varname} in buffer {expr}
        getchar( [expr])        Number  get one character from the user
        getcharmod( )           Number  modifiers for the last typed character
        getcmdline()            String  return the current command-line
        getcmdpos()         Number  return cursor position in command-line
        getcmdtype()            String  return the current command-line type
        getcwd()            String  the current working directory
        getfperm( {fname})      String  file permissions of file {fname}
        getfsize( {fname})      Number  size in bytes of file {fname}
        getfontname( [{name}])      String  name of font being used
        getftime( {fname})      Number  last modification time of file
        getftype( {fname})      String  description of type of file {fname}
        getline( {lnum})        String  line {lnum} of current buffer
        getline( {lnum}, {end})     List    lines {lnum} to {end} of current buffer
        getloclist( {nr})       List    list of location list items
        getmatches()            List    list of current matches
        getpid()            Number  process ID of Vim
        getpos( {expr})         List    position of cursor, mark, etc.
        getqflist()         List    list of quickfix items
        getreg( [{regname} [, 1]])  String  contents of register
        getregtype( [{regname}])    String  type of register
        gettabvar( {nr}, {varname}) any variable {varname} in tab {nr}
        gettabwinvar( {tabnr}, {winnr}, {name})
                        any {name} in {winnr} in tab page {tabnr}
        getwinposx()            Number  X coord in pixels of GUI Vim window
        getwinposy()            Number  Y coord in pixels of GUI Vim window
        getwinvar( {nr}, {varname}) any variable {varname} in window {nr}
        globpath( {path}, {expr} [, {flag}])
                        String  do glob({expr}) for all dirs in {path}
        has( {feature})         Number  TRUE if feature {feature} supported
        has_key( {dict}, {key})     Number  TRUE if {dict} has entry {key}
        haslocaldir()           Number  TRUE if current window executed |:lcd|
        hasmapto( {what} [, {mode} [, {abbr}]])
                        Number  TRUE if mapping to {what} exists
        histadd( {history},{item})  String  add an item to a history
        histdel( {history} [, {item}])  String  remove an item from a history
        histget( {history} [, {index}]) String  get the item {index} from a history
        histnr( {history})      Number  highest index of a history
        hlexists( {name})       Number  TRUE if highlight group {name} exists
        hlID( {name})           Number  syntax ID of highlight group {name}
        hostname()          String  name of the machine Vim is running on
        iconv( {expr}, {from}, {to})    String  convert encoding of {expr}
        indent( {lnum})         Number  indent of line {lnum}
        index( {list}, {expr} [, {start} [, {ic}]])
                        Number  index in {list} where {expr} appears
        input( {prompt} [, {text} [, {completion}]])
                        String  get input from the user
        inputdialog( {p} [, {t} [, {c}]]) String  like input() but in a GUI dialog
        inputlist( {textlist})      Number  let the user pick from a choice list
        inputrestore()          Number  restore typeahead
        inputsave()         Number  save and clear typeahead
        inputsecret( {prompt} [, {text}]) String  like input() but hiding the text
        insert( {list}, {item} [, {idx}]) List  insert {item} in {list} [before {idx}]
        isdirectory( {directory})   Number  TRUE if {directory} is a directory
        islocked( {expr})       Number  TRUE if {expr} is locked
        items( {dict})          List    key-value pairs in {dict}
        join( {list} [, {sep}])     String  join {list} items into one String
        keys( {dict})           List    keys in {dict}
        len( {expr})            Number  the length of {expr}
        libcall( {lib}, {func}, {arg})  String  call {func} in library {lib} with {arg}
        libcallnr( {lib}, {func}, {arg})  Number  idem, but return a Number
        line( {expr})           Number  line nr of cursor, last line or mark
        line2byte( {lnum})      Number  byte count of line {lnum}
        lispindent( {lnum})     Number  Lisp indent for line {lnum}
        localtime()         Number  current time
        log( {expr})            Float   natural logarithm (base e) of {expr}
        log10( {expr})          Float   logarithm of Float {expr} to base 10
        map( {expr}, {string})      List/Dict  change each item in {expr} to {expr}
        maparg( {name}[, {mode} [, {abbr} [, {dict}]]])
                        String  rhs of mapping {name} in mode {mode}
        mapcheck( {name}[, {mode} [, {abbr}]])
                        String  check for mappings matching {name}
        match( {expr}, {pat}[, {start}[, {count}]])
                        Number  position where {pat} matches in {expr}
        matchadd( {group}, {pattern}[, {priority}[, {id}]])
                        Number  highlight {pattern} with {group}
        matcharg( {nr})         List    arguments of |:match|
        matchdelete( {id})      Number  delete match identified by {id}
        matchend( {expr}, {pat}[, {start}[, {count}]])
                        Number  position where {pat} ends in {expr}
        matchlist( {expr}, {pat}[, {start}[, {count}]])
                        List    match and submatches of {pat} in {expr}
        matchstr( {expr}, {pat}[, {start}[, {count}]])
                        String  {count}'th match of {pat} in {expr}
        max( {list})            Number  maximum value of items in {list}
        min( {list})            Number  minimum value of items in {list}
        mkdir( {name} [, {path} [, {prot}]])
                        Number  create directory {name}
        mode( [expr])           String  current editing mode
        mzeval( {expr})         any evaluate |MzScheme| expression
        nextnonblank( {lnum})       Number  line nr of non-blank line >= {lnum}
        nr2char( {expr})        String  single char with ASCII value {expr}
        pathshorten( {expr})        String  shorten directory names in a path
        pow( {x}, {y})          Float   {x} to the power of {y}
        prevnonblank( {lnum})       Number  line nr of non-blank line <= {lnum}
        printf( {fmt}, {expr1}...)  String  format text
        pumvisible()            Number  whether popup menu is visible
        range( {expr} [, {max} [, {stride}]])
                        List    items from {expr} to {max}
        readfile( {fname} [, {binary} [, {max}]])
                        List    get list of lines from file {fname}
        reltime( [{start} [, {end}]])   List    get time value
        reltimestr( {time})     String  turn time value into a String
        remote_expr( {server}, {string} [, {idvar}])
                        String  send expression
        remote_foreground( {server})    Number  bring Vim server to the foreground
        remote_peek( {serverid} [, {retvar}])
                        Number  check for reply string
        remote_read( {serverid})    String  read reply string
        remote_send( {server}, {string} [, {idvar}])
                        String  send key sequence
        remove( {list}, {idx} [, {end}])  any   remove items {idx}-{end} from {list}
        remove( {dict}, {key})      any remove entry {key} from {dict}
        rename( {from}, {to})       Number  rename (move) file from {from} to {to}
        repeat( {expr}, {count})    String  repeat {expr} {count} times
        resolve( {filename})        String  get filename a shortcut points to
        reverse( {list})        List    reverse {list} in-place
        round( {expr})          Float   round off {expr}
        search( {pattern} [, {flags} [, {stopline} [, {timeout}]]])
                        Number  search for {pattern}
        searchdecl( {name} [, {global} [, {thisblock}]])
                        Number  search for variable declaration
        searchpair( {start}, {middle}, {end} [, {flags} [, {skip} [...]]])
                        Number  search for other end of start/end pair
        searchpairpos( {start}, {middle}, {end} [, {flags} [, {skip} [...]]])
                        List    search for other end of start/end pair
        searchpos( {pattern} [, {flags} [, {stopline} [, {timeout}]]])
                        List    search for {pattern}
        server2client( {clientid}, {string})
                        Number  send reply string
        serverlist()            String  get a list of available servers
        setbufvar( {expr}, {varname}, {val})    set {varname} in buffer {expr} to {val}
        setcmdpos( {pos})       Number  set cursor position in command-line
        setline( {lnum}, {line})    Number  set line {lnum} to {line}
        setloclist( {nr}, {list}[, {action}])
                        Number  modify location list using {list}
        setmatches( {list})     Number  restore a list of matches
        setpos( {expr}, {list})     Number  set the {expr} position to {list}
        setqflist( {list}[, {action}])  Number  modify quickfix list using {list}
        setreg( {n}, {v}[, {opt}])  Number  set register to value and type
        settabvar( {nr}, {varname}, {val})  set {varname} in tab page {nr} to {val}
        settabwinvar( {tabnr}, {winnr}, {varname}, {val})    set {varname} in window
                            {winnr} in tab page {tabnr} to {val}
        setwinvar( {nr}, {varname}, {val})  set {varname} in window {nr} to {val}
        simplify( {filename})       String  simplify filename as much as possible
        sin( {expr})            Float   sine of {expr}
        sinh( {expr})           Float   hyperbolic sine of {expr}
        sort( {list} [, {func}])    List    sort {list}, using {func} to compare
        soundfold( {word})      String  sound-fold {word}
        spellbadword()          String  badly spelled word at cursor
        spellsuggest( {word} [, {max} [, {capital}]])
                        List    spelling suggestions
        split( {expr} [, {pat} [, {keepempty}]])
                        List    make |List| from {pat} separated {expr}
        sqrt( {expr})           Float   square root of {expr}
        str2float( {expr})      Float   convert String to Float
        str2nr( {expr} [, {base}])  Number  convert String to Number
        strchars( {expr})       Number  character length of the String {expr}
        strdisplaywidth( {expr} [, {col}]) Number display length of the String {expr}
        strftime( {format}[, {time}])   String  time in specified format
        stridx( {haystack}, {needle}[, {start}])
                        Number  index of {needle} in {haystack}
        string( {expr})         String  String representation of {expr} value
        strlen( {expr})         Number  length of the String {expr}
        strpart( {src}, {start}[, {len}])
                        String  {len} characters of {src} at {start}
        strridx( {haystack}, {needle} [, {start}])
                        Number  last index of {needle} in {haystack}
        strtrans( {expr})       String  translate string to make it printable
        strwidth( {expr})       Number  display cell length of the String {expr}
        submatch( {nr})         String  specific match in ":substitute"
        substitute( {expr}, {pat}, {sub}, {flags})
                        String  all {pat} in {expr} replaced with {sub}
        synID( {lnum}, {col}, {trans})  Number  syntax ID at {lnum} and {col}
        synIDattr( {synID}, {what} [, {mode}])
                        String  attribute {what} of syntax ID {synID}
        synIDtrans( {synID})        Number  translated syntax ID of {synID}
        synconcealed( {lnum}, {col})    List    info about concealing
        synstack( {lnum}, {col})    List    stack of syntax IDs at {lnum} and {col}
        tabpagebuflist( [{arg}])    List    list of buffer numbers in tab page
        tabpagenr( [{arg}])     Number  number of current or last tab page
        tabpagewinnr( {tabarg}[, {arg}])
                        Number  number of current window in tab page
        taglist( {expr})        List    list of tags matching {expr}
        tagfiles()          List    tags files used
        tempname()          String  name for a temporary file
        tan( {expr})            Float   tangent of {expr}
        tanh( {expr})           Float   hyperbolic tangent of {expr}
        tolower( {expr})        String  the String {expr} switched to lowercase
        toupper( {expr})        String  the String {expr} switched to uppercase
        tr( {src}, {fromstr}, {tostr})  String  translate chars of {src} in {fromstr}
                            to chars in {tostr}
        trunc( {expr})          Float   truncate Float {expr}
        type( {name})           Number  type of variable {name}
        undofile( {name})       String  undo file name for {name}
        undotree()          List    undo file tree
        values( {dict})         List    values in {dict}
        virtcol( {expr})        Number  screen column of cursor or mark
        visualmode( [expr])     String  last visual mode used
        winbufnr( {nr})         Number  buffer number of window {nr}
        wincol()            Number  window column of the cursor
        winheight( {nr})        Number  height of window {nr}
        winline()           Number  window line of the cursor
        winnr( [{expr}])        Number  number of current window
        winrestcmd()            String  returns command to restore window sizes
        winrestview( {dict})        none    restore view of current window
        winsaveview()           Dict    save view of current window
        winwidth( {nr})         Number  width of window {nr}
        writefile( {list}, {fname} [, {binary}])
                        Number  write list of lines to file {fname}
        }}}
        Längre Förklaringar Funktioner {{{

        abs({expr})                         *abs()*
                Return the absolute value of {expr}.  When {expr} evaluates to
                a |Float| abs() returns a |Float|.  When {expr} can be
                converted to a |Number| abs() returns a |Number|.  Otherwise
                abs() gives an error message and returns -1.
                Examples:
                    echo abs(1.456)
                    1.456 
                    echo abs(-5.456)
                    5.456 
                    echo abs(-4)
                    4
                {only available when compiled with the |+float| feature}



        acos({expr})                            *acos()*
                Return the arc cosine of {expr} measured in radians, as a
                |Float| in the range of [0, pi].
                {expr} must evaluate to a |Float| or a |Number| in the range
                [-1, 1].
                Examples:
                    :echo acos(0)
                    1.570796
                    :echo acos(-0.5)
                    2.094395
                {only available when compiled with the |+float| feature}



        add({list}, {expr})                 *add()*
                Append the item {expr} to |List| {list}.  Returns the
                resulting |List|.  Examples:
                    :let alist = add([1, 2, 3], item)
                    :call add(mylist, "woodstock")
                Note that when {expr} is a |List| it is appended as a single
                item.  Use |extend()| to concatenate |Lists|.
                Use |insert()| to add an item at another position.



        append({lnum}, {expr})                  *append()*
                When {expr} is a |List|: Append each item of the |List| as a
                text line below line {lnum} in the current buffer.
                Otherwise append {expr} as one text line below line {lnum} in
                the current buffer.
                {lnum} can be zero to insert a line before the first one.
                Returns 1 for failure ({lnum} out of range or out of memory),
                0 for success.  Example:
                    :let failed = append(line('$'), "# THE END")
                    :let failed = append(0, ["Chapter 1", "the beginning"])


                                    *argc()*
        argc()      The result is the number of files in the argument list of the
                current window.  See |arglist|.


                                    *argidx()*
        argidx()    The result is the current index in the argument list.  0 is
                the first file.  argc() - 1 is the last one.  See |arglist|.


                                    *argv()*
        argv([{nr}])    The result is the {nr}th file in the argument list of the
                current window.  See |arglist|.  "argv(0)" is the first one.
                Example:
            :let i = 0
            :while i < argc()
            :  let f = escape(fnameescape(argv(i)), '.')
            :  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
            :  let i = i + 1
            :endwhile
                Without the {nr} argument a |List| with the whole |arglist| is
                returned.


        asin({expr})                        *asin()*
                Return the arc sine of {expr} measured in radians, as a |Float|
                in the range of [-pi/2, pi/2].
                {expr} must evaluate to a |Float| or a |Number| in the range
                [-1, 1].
                Examples:
                    :echo asin(0.8)
                    0.927295
                    :echo asin(-0.5)
                    -0.523599
                {only available when compiled with the |+float| feature}



        atan({expr})                        *atan()*
                Return the principal value of the arc tangent of {expr}, in
                the range [-pi/2, +pi/2] radians, as a |Float|.
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo atan(100)
                    1.560797
                    :echo atan(-4.01)
                    -1.326405
                {only available when compiled with the |+float| feature}



        atan2({expr1}, {expr2})                 *atan2()*
                Return the arc tangent of {expr1} / {expr2}, measured in
                radians, as a |Float| in the range [-pi, pi].
                {expr1} and {expr2} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo atan2(-1, 1)
                    -0.785398
                    :echo atan2(1, -1)
                    2.356194
                {only available when compiled with the |+float| feature}



                                    *browse()*
        browse({save}, {title}, {initdir}, {default})
                Put up a file requester.  This only works when "has("browse")"
                returns non-zero (only in some GUI versions).
                The input fields are:
                    {save}  when non-zero, select file to write
                    {title} title for the requester
                    {initdir}   directory to start browsing in
                    {default}   default file name
                When the "Cancel" button is hit, something went wrong, or
                browsing is not possible, an empty string is returned.


                                    *browsedir()*
        browsedir({title}, {initdir})
                Put up a directory requester.  This only works when
                "has("browse")" returns non-zero (only in some GUI versions).
                On systems where a directory browser is not supported a file
                browser is used.  In that case: select a file in the directory
                to be used.
                The input fields are:
                    {title} title for the requester
                    {initdir}   directory to start browsing in
                When the "Cancel" button is hit, something went wrong, or
                browsing is not possible, an empty string is returned.


        bufexists({expr})                   *bufexists()*
                The result is a Number, which is non-zero if a buffer called
                {expr} exists.
                If the {expr} argument is a number, buffer numbers are used.
                If the {expr} argument is a string it must match a buffer name
                exactly.  The name can be:
                - Relative to the current directory.
                - A full path.
                - The name of a buffer with 'buftype' set to "nofile".
                - A URL name.
                Unlisted buffers will be found.
                Note that help files are listed by their short name in the
                output of |:buffers|, but bufexists() requires using their
                long name to be able to find them.
                bufexists() may report a buffer exists, but to use the name
                with a |:buffer| command you may need to use |expand()|.  Esp
                for MS-Windows 8.3 names in the form "c:\DOCUME~1"
                Use "bufexists(0)" to test for the existence of an alternate
                file name.

                                    *buffer_exists()*
                Obsolete name: buffer_exists().


        buflisted({expr})                   *buflisted()*
                The result is a Number, which is non-zero if a buffer called
                {expr} exists and is listed (has the 'buflisted' option set).
                The {expr} argument is used like with |bufexists()|.


        bufloaded({expr})                   *bufloaded()*
                The result is a Number, which is non-zero if a buffer called
                {expr} exists and is loaded (shown in a window or hidden).
                The {expr} argument is used like with |bufexists()|.


        bufname({expr})                     *bufname()*
                The result is the name of a buffer, as it is displayed by the
                ":ls" command.
                If {expr} is a Number, that buffer number's name is given.
                Number zero is the alternate buffer for the current window.
                If {expr} is a String, it is used as a |file-pattern| to match
                with the buffer names.  This is always done like 'magic' is
                set and 'cpoptions' is empty.  When there is more than one
                match an empty string is returned.
                "" or "%" can be used for the current buffer, "#" for the
                alternate buffer.
                A full match is preferred, otherwise a match at the start, end
                or middle of the buffer name is accepted.  If you only want a
                full match then put "^" at the start and "$" at the end of the
                pattern.
                Listed buffers are found first.  If there is a single match
                with a listed buffer, that one is returned.  Next unlisted
                buffers are searched for.
                If the {expr} is a String, but you want to use it as a buffer
                number, force it to be a Number by adding zero to it:
                    :echo bufname("3" + 0)
                If the buffer doesn't exist, or doesn't have a name, an empty
                string is returned.
            bufname("#")        alternate buffer name
            bufname(3)      name of buffer 3
            bufname("%")        name of current buffer
            bufname("file2")    name of buffer where "file2" matches.

                                    *buffer_name()*
                Obsolete name: buffer_name().


                                    *bufnr()*
        bufnr({expr} [, {create}])
                The result is the number of a buffer, as it is displayed by
                the ":ls" command.  For the use of {expr}, see |bufname()|
                above.
                If the buffer doesn't exist, -1 is returned.  Or, if the
                {create} argument is present and not zero, a new, unlisted,
                buffer is created and its number is returned.
                bufnr("$") is the last buffer:
            :let last_buffer = bufnr("$")
                The result is a Number, which is the highest buffer number
                of existing buffers.  Note that not all buffers with a smaller
                number necessarily exist, because ":bwipeout" may have removed
                them.  Use bufexists() to test for the existence of a buffer.

                                    *buffer_number()*
                Obsolete name: buffer_number().

                                    *last_buffer_nr()*
                Obsolete name for bufnr("$"): last_buffer_nr().


        bufwinnr({expr})                    *bufwinnr()*
                The result is a Number, which is the number of the first
                window associated with buffer {expr}.  For the use of {expr},
                see |bufname()| above.  If buffer {expr} doesn't exist or
                there is no such window, -1 is returned.  Example:

            echo "A window containing buffer 1 is " . (bufwinnr(1))

                The number can be used with |CTRL-W_w| and ":wincmd w"
                |:wincmd|.
                Only deals with the current tab page.



        byte2line({byte})                   *byte2line()*
                Return the line number that contains the character at byte
                count {byte} in the current buffer.  This includes the
                end-of-line character, depending on the 'fileformat' option
                for the current buffer.  The first character has byte count
                one.
                Also see |line2byte()|, |go| and |:goto|.
                {not available when compiled without the |+byte_offset|
                feature}


        byteidx({expr}, {nr})                   *byteidx()*
                Return byte index of the {nr}'th character in the string
                {expr}.  Use zero for the first character, it returns zero.
                This function is only useful when there are multibyte
                characters, otherwise the returned value is equal to {nr}.
                Composing characters are counted as a separate character.
                Example :
                    echo matchstr(str, ".", byteidx(str, 3))
                will display the fourth character.  Another way to do the
                same:
                    let s = strpart(str, byteidx(str, 3))
                    echo strpart(s, 0, byteidx(s, 1))
                If there are less than {nr} characters -1 is returned.
                If there are exactly {nr} characters the length of the string
                is returned.


        call({func}, {arglist} [, {dict}])          *call()* *E699*
                Call function {func} with the items in |List| {arglist} as
                arguments.
                {func} can either be a |Funcref| or the name of a function.
                a:firstline and a:lastline are set to the cursor line.
                Returns the return value of the called function.
                {dict} is for functions with the "dict" attribute.  It will be
                used to set the local variable "self". |Dictionary-function|


        ceil({expr})                            *ceil()*
                Return the smallest integral value greater than or equal to
                {expr} as a |Float| (round up).
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    echo ceil(1.456)
                    2.0 
                    echo ceil(-5.456)
                    -5.0 
                    echo ceil(4.0)
                    4.0
                {only available when compiled with the |+float| feature}


        changenr()                      *changenr()*
                Return the number of the most recent change.  This is the same
                number as what is displayed with |:undolist| and can be used
                with the |:undo| command.
                When a change was made it is the number of that change.  After
                redo it is the number of the redone change.  After undo it is
                one less than the number of the undone change.


        char2nr({expr})                     *char2nr()*
                Return number value of the first char in {expr}.  Examples:
                    char2nr(" ")        returns 32
                    char2nr("ABC")      returns 65
                The current 'encoding' is used.  Example for "utf-8":
                    char2nr("á")        returns 225
                    char2nr("á"[0])     returns 195
                |nr2char()| does the opposite.


        cindent({lnum})                     *cindent()*
                Get the amount of indent for line {lnum} according the C
                indenting rules, as with 'cindent'.
                The indent is counted in spaces, the value of 'tabstop' is
                relevant.  {lnum} is used just like in |getline()|.
                When {lnum} is invalid or Vim was not compiled the |+cindent|
                feature, -1 is returned.
                See |C-indenting|.


        clearmatches()                      *clearmatches()*
                Clears all matches previously defined by |matchadd()| and the
                |:match| commands.


                                    *col()*
        col({expr}) The result is a Number, which is the byte index of the column
                position given with {expr}.  The accepted positions are:
                    .       the cursor position
                    $       the end of the cursor line (the result is the
                        number of characters in the cursor line plus one)
                    'x      position of mark x (if the mark is not set, 0 is
                        returned)
                Additionally {expr} can be [lnum, col]: a |List| with the line
                and column number. Most useful when the column is "$", to get
                the last column of a specific line.  When "lnum" or "col" is
                out of range then col() returns zero.
                To get the line number use |line()|.  To get both use
                |getpos()|.
                For the screen column position use |virtcol()|.
                Note that only marks in the current file can be used.
                Examples:
                    col(".")        column of cursor
                    col("$")        length of cursor line plus one
                    col("'t")       column of mark t
                    col("'" . markname) column of mark markname
                The first column is 1.  0 is returned for an error.
                For an uppercase mark the column may actually be in another
                buffer.
                For the cursor position, when 'virtualedit' is active, the
                column is one higher if the cursor is after the end of the
                line.  This can be used to obtain the column in Insert mode:
                    :imap <F2> <C-O>:let save_ve = &ve<CR>
                        \<C-O>:set ve=all<CR>
                        \<C-O>:echo col(".") . "\n" <Bar>
                        \let &ve = save_ve<CR>



        complete({startcol}, {matches})         *complete()* *E785*
                Set the matches for Insert mode completion.
                Can only be used in Insert mode.  You need to use a mapping
                with CTRL-R = |i_CTRL-R|.  It does not work after CTRL-O or
                with an expression mapping.
                {startcol} is the byte offset in the line where the completed
                text start.  The text up to the cursor is the original text
                that will be replaced by the matches.  Use col('.') for an
                empty string.  "col('.') - 1" will replace one character by a
                match.
                {matches} must be a |List|.  Each |List| item is one match.
                See |complete-items| for the kind of items that are possible.
                Note that the after calling this function you need to avoid
                inserting anything that would cause completion to stop.
                The match can be selected with CTRL-N and CTRL-P as usual with
                Insert mode completion.  The popup menu will appear if
                specified, see |ins-completion-menu|.
                Example:
            inoremap <F5> <C-R>=ListMonths()<CR>

            func! ListMonths()
              call complete(col('.'), ['January', 'February', 'March',
                \ 'April', 'May', 'June', 'July', 'August', 'September',
                \ 'October', 'November', 'December'])
              return ''
            endfunc
                This isn't very useful, but it shows how it works.  Note that
                an empty string is returned to avoid a zero being inserted.


        complete_add({expr})                *complete_add()*
                Add {expr} to the list of matches.  Only to be used by the
                function specified with the 'completefunc' option.
                Returns 0 for failure (empty string or out of memory),
                1 when the match was added, 2 when the match was already in
                the list.
                See |complete-functions| for an explanation of {expr}.  It is
                the same as one item in the list that 'omnifunc' would return.


        complete_check()                *complete_check()*
                Check for a key typed while looking for completion matches.
                This is to be used when looking for matches takes some time.
                Returns non-zero when searching for matches is to be aborted,
                zero otherwise.
                Only to be used by the function specified with the
                'completefunc' option.


                                *confirm()*
        confirm({msg} [, {choices} [, {default} [, {type}]]])
                Confirm() offers the user a dialog, from which a choice can be
                made.  It returns the number of the choice.  For the first
                choice this is 1.
                Note: confirm() is only supported when compiled with dialog
                support, see |+dialog_con| and |+dialog_gui|.

                {msg} is displayed in a |dialog| with {choices} as the
                alternatives.  When {choices} is missing or empty, "&OK" is
                used (and translated).
                {msg} is a String, use '\n' to include a newline.  Only on
                some systems the string is wrapped when it doesn't fit.

                {choices} is a String, with the individual choices separated
                by '\n', e.g.
                    confirm("Save changes?", "&Yes\n&No\n&Cancel")
                The letter after the '&' is the shortcut key for that choice.
                Thus you can type 'c' to select "Cancel".  The shortcut does
                not need to be the first letter:
                    confirm("file has been modified", "&Save\nSave &All")
                For the console, the first letter of each choice is used as
                the default shortcut key.

                The optional {default} argument is the number of the choice
                that is made if the user hits <CR>.  Use 1 to make the first
                choice the default one.  Use 0 to not set a default.  If
                {default} is omitted, 1 is used.

                The optional {type} argument gives the type of dialog.  This
                is only used for the icon of the GTK, Mac, Motif and Win32
                GUI.  It can be one of these values: "Error", "Question",
                "Info", "Warning" or "Generic".  Only the first character is
                relevant.  When {type} is omitted, "Generic" is used.

                If the user aborts the dialog by pressing <Esc>, CTRL-C,
                or another valid interrupt key, confirm() returns 0.

                An example:
           :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
           :if choice == 0
           :    echo "make up your mind!"
           :elseif choice == 3
           :    echo "tasteful"
           :else
           :    echo "I prefer bananas myself."
           :endif
                In a GUI dialog, buttons are used.  The layout of the buttons
                depends on the 'v' flag in 'guioptions'.  If it is included,
                the buttons are always put vertically.  Otherwise,  confirm()
                tries to put the buttons in one horizontal line.  If they
                don't fit, a vertical layout is used anyway.  For some systems
                the horizontal layout is always used.


                                    *copy()*
        copy({expr})    Make a copy of {expr}.  For Numbers and Strings this isn't
                different from using {expr} directly.
                When {expr} is a |List| a shallow copy is created.  This means
                that the original |List| can be changed without changing the
                copy, and vice versa.  But the items are identical, thus
                changing an item changes the contents of both |Lists|.  Also
                see |deepcopy()|.


        cos({expr})                     *cos()*
                Return the cosine of {expr}, measured in radians, as a |Float|.
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo cos(100)
                    0.862319
                    :echo cos(-4.01)
                    -0.646043
                {only available when compiled with the |+float| feature}



        cosh({expr})                        *cosh()*
                Return the hyperbolic cosine of {expr} as a |Float| in the range
                [1, inf].
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo cosh(0.5)
                    1.127626
                    :echo cosh(-0.5)
                    -1.127626
                {only available when compiled with the |+float| feature}



        count({comp}, {expr} [, {ic} [, {start}]])          *count()*
                Return the number of times an item with value {expr} appears
                in |List| or |Dictionary| {comp}.
                If {start} is given then start with the item with this index.
                {start} can only be used with a |List|.
                When {ic} is given and it's non-zero then case is ignored.



                                    *cscope_connection()*
        cscope_connection([{num} , {dbpath} [, {prepend}]])
                Checks for the existence of a |cscope| connection.  If no
                parameters are specified, then the function returns:
                    0, if cscope was not available (not compiled in), or
                       if there are no cscope connections;
                    1, if there is at least one cscope connection.

                If parameters are specified, then the value of {num}
                determines how existence of a cscope connection is checked:

                {num}   Description of existence check
                -----   ------------------------------
                0   Same as no parameters (e.g., "cscope_connection()").
                1   Ignore {prepend}, and use partial string matches for
                    {dbpath}.
                2   Ignore {prepend}, and use exact string matches for
                    {dbpath}.
                3   Use {prepend}, use partial string matches for both
                    {dbpath} and {prepend}.
                4   Use {prepend}, use exact string matches for both
                    {dbpath} and {prepend}.

                Note: All string comparisons are case sensitive!

                Examples.  Suppose we had the following (from ":cs show"):

          # pid    database name            prepend path
          0 27664  cscope.out               /usr/local

                Invocation                  Return Val 
                ----------                  ----------
                cscope_connection()                 1
                cscope_connection(1, "out")             1
                cscope_connection(2, "out")             0
                cscope_connection(3, "out")             0
                cscope_connection(3, "out", "local")            1
                cscope_connection(4, "out")             0
                cscope_connection(4, "out", "local")            0
                cscope_connection(4, "cscope.out", "/usr/local")    1


        cursor({lnum}, {col} [, {off}])             *cursor()*
        cursor({list})
                Positions the cursor at the column (byte count) {col} in the
                line {lnum}.  The first column is one.
                When there is one argument {list} this is used as a |List|
                with two or three items {lnum}, {col} and {off}.  This is like
                the return value of |getpos()|, but without the first item.
                Does not change the jumplist.
                If {lnum} is greater than the number of lines in the buffer,
                the cursor will be positioned at the last line in the buffer.
                If {lnum} is zero, the cursor will stay in the current line.
                If {col} is greater than the number of bytes in the line,
                the cursor will be positioned at the last character in the
                line.
                If {col} is zero, the cursor will stay in the current column.
                When 'virtualedit' is used {off} specifies the offset in
                screen columns from the start of the character.  E.g., a
                position within a <Tab> or after the last character.
                Returns 0 when the position could be set, -1 otherwise.



        deepcopy({expr}[, {noref}])             *deepcopy()* *E698*
                Make a copy of {expr}.  For Numbers and Strings this isn't
                different from using {expr} directly.
                When {expr} is a |List| a full copy is created.  This means
                that the original |List| can be changed without changing the
                copy, and vice versa.  When an item is a |List|, a copy for it
                is made, recursively.  Thus changing an item in the copy does
                not change the contents of the original |List|.
                When {noref} is omitted or zero a contained |List| or
                |Dictionary| is only copied once.  All references point to
                this single copy.  With {noref} set to 1 every occurrence of a
                |List| or |Dictionary| results in a new copy.  This also means
                that a cyclic reference causes deepcopy() to fail.

                                        *E724*
                Nesting is possible up to 100 levels.  When there is an item
                that refers back to a higher level making a deep copy with
                {noref} set to 1 will fail.
                Also see |copy()|.


        delete({fname})                         *delete()*
                Deletes the file by the name {fname}.  The result is a Number,
                which is 0 if the file was deleted successfully, and non-zero
                when the deletion failed.
                Use |remove()| to delete an item from a |List|.


                                    *did_filetype()*
        did_filetype()  Returns non-zero when autocommands are being executed and the
                FileType event has been triggered at least once.  Can be used
                to avoid triggering the FileType event again in the scripts
                that detect the file type. |FileType|
                When editing another file, the counter is reset, thus this
                really checks if the FileType event has been triggered for the
                current buffer.  This allows an autocommand that starts
                editing another buffer to set 'filetype' and load a syntax
                file.


        diff_filler({lnum})                 *diff_filler()*
                Returns the number of filler lines above line {lnum}.
                These are the lines that were inserted at this point in
                another diff'ed window.  These filler lines are shown in the
                display but don't exist in the buffer.
                {lnum} is used like with |getline()|.  Thus "." is the current
                line, "'m" mark m, etc.
                Returns 0 if the current window is not in diff mode.


        diff_hlID({lnum}, {col})                *diff_hlID()*
                Returns the highlight ID for diff mode at line {lnum} column
                {col} (byte index).  When the current line does not have a
                diff change zero is returned.
                {lnum} is used like with |getline()|.  Thus "." is the current
                line, "'m" mark m, etc.
                {col} is 1 for the leftmost column, {lnum} is 1 for the first
                line.
                The highlight ID can be used with |synIDattr()| to obtain
                syntax information about the highlighting.


        empty({expr})                       *empty()*
                Return the Number 1 if {expr} is empty, zero otherwise.
                A |List| or |Dictionary| is empty when it does not have any
                items.  A Number is empty when its value is zero.
                For a long |List| this is much faster than comparing the
                length with zero.


        escape({string}, {chars})               *escape()*
                Escape the characters in {chars} that occur in {string} with a
                backslash.  Example:
                    :echo escape('c:\program files\vim', ' \')
                results in:
                    c:\\program\ files\\vim
                Also see |shellescape()|.


                                    *eval()*
        eval({string})  Evaluate {string} and return the result.  Especially useful to
                turn the result of |string()| back into the original value.
                This works for Numbers, Floats, Strings and composites of
                them.  Also works for |Funcref|s that refer to existing
                functions.


        eventhandler()                      *eventhandler()*
                Returns 1 when inside an event handler.  That is that Vim got
                interrupted while waiting for the user to type a character,
                e.g., when dropping a file on Vim.  This means interactive
                commands cannot be used.  Otherwise zero is returned.


        executable({expr})                  *executable()*
                This function checks if an executable with the name {expr}
                exists.  {expr} must be the name of the program without any
                arguments.
                executable() uses the value of $PATH and/or the normal

                searchpath for programs.        *PATHEXT*
                On MS-DOS and MS-Windows the ".exe", ".bat", etc. can
                optionally be included.  Then the extensions in $PATHEXT are
                tried.  Thus if "foo.exe" does not exist, "foo.exe.bat" can be
                found.  If $PATHEXT is not set then ".exe;.com;.bat;.cmd" is
                used.  A dot by itself can be used in $PATHEXT to try using
                the name without an extension.  When 'shell' looks like a
                Unix shell, then the name is also tried without adding an
                extension.
                On MS-DOS and MS-Windows it only checks if the file exists and
                is not a directory, not if it's really executable.
                On MS-Windows an executable in the same directory as Vim is
                always found.  Since this directory is added to $PATH it
                should also work to execute it |win32-PATH|.
                The result is a Number:
                    1   exists
                    0   does not exist
                    -1  not implemented on this system


                                    *exists()*
        exists({expr})  The result is a Number, which is non-zero if {expr} is
                defined, zero otherwise.  The {expr} argument is a string,
                which contains one of these:
                    &option-name    Vim option (only checks if it exists,
                            not if it really works)
                    +option-name    Vim option that works.
                    $ENVNAME    environment variable (could also be
                            done by comparing with an empty
                            string)
                    *funcname   built-in function (see |functions|)
                            or user defined function (see
                            |user-functions|).
                    varname     internal variable (see
                            |internal-variables|).  Also works
                            for |curly-braces-names|, |Dictionary|
                            entries, |List| items, etc.  Beware
                            that evaluating an index may cause an
                            error message for an invalid
                            expression.  E.g.:
                               :let l = [1, 2, 3]
                               :echo exists("l[5]")
                               0
                               :echo exists("l[xx]")
                               E121: Undefined variable: xx
                               0
                    :cmdname    Ex command: built-in command, user
                            command or command modifier |:command|.
                            Returns:
                            1  for match with start of a command
                            2  full match with a command
                            3  matches several user commands
                            To check for a supported command
                            always check the return value to be 2.
                    :2match     The |:2match| command.
                    :3match     The |:3match| command.
                    #event      autocommand defined for this event
                    #event#pattern  autocommand defined for this event and
                            pattern (the pattern is taken
                            literally and compared to the
                            autocommand patterns character by
                            character)
                    #group      autocommand group exists
                    #group#event    autocommand defined for this group and
                            event.
                    #group#event#pattern
                            autocommand defined for this group,
                            event and pattern.
                    ##event     autocommand for this event is
                            supported.
                For checking for a supported feature use |has()|.

                Examples:
                    exists("&shortname")
                    exists("$HOSTNAME")
                    exists("*strftime")
                    exists("*s:MyFunc")
                    exists("bufcount")
                    exists(":Make")
                    exists("#CursorHold")
                    exists("#BufReadPre#*.gz")
                    exists("#filetypeindent")
                    exists("#filetypeindent#FileType")
                    exists("#filetypeindent#FileType#*")
                    exists("##ColorScheme")
                There must be no space between the symbol (&/$/*/#) and the
                name.
                There must be no extra characters after the name, although in
                a few cases this is ignored.  That may become more strict in
                the future, thus don't count on it!
                Working example:
                    exists(":make")
                NOT working example:
                    exists(":make install")

                Note that the argument must be a string, not the name of the
                variable itself.  For example:
                    exists(bufcount)
                This doesn't check for existence of the "bufcount" variable,
                but gets the value of "bufcount", and checks if that exists.


        exp({expr})                     *exp()*
                Return the exponential of {expr} as a |Float| in the range
                [0, inf].
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo exp(2)
                    7.389056
                    :echo exp(-1)
                    0.367879
                {only available when compiled with the |+float| feature}





        extend({expr1}, {expr2} [, {expr3}])            *extend()*
                {expr1} and {expr2} must be both |Lists| or both
                |Dictionaries|.

                If they are |Lists|: Append {expr2} to {expr1}.
                If {expr3} is given insert the items of {expr2} before item
                {expr3} in {expr1}.  When {expr3} is zero insert before the
                first item.  When {expr3} is equal to len({expr1}) then
                {expr2} is appended.
                Examples:
                    :echo sort(extend(mylist, [7, 5]))
                    :call extend(mylist, [2, 3], 1)
                When {expr1} is the same List as {expr2} then the number of
                items copied is equal to the original length of the List.
                E.g., when {expr3} is 1 you get N new copies of the first item
                (where N is the original length of the List).
                Use |add()| to concatenate one item to a list.  To concatenate
                two lists into a new list use the + operator:
                    :let newlist = [1, 2, 3] + [4, 5]

                If they are YXXYDictionaries|:
                Add all entries from {expr2} to {expr1}.
                If a key exists in both {expr1} and {expr2} then {expr3} is
                used to decide what to do:
                {expr3} = "keep": keep the value of {expr1}
                {expr3} = "force": use the value of {expr2}

                {expr3} = "error": give an error message        *E737*
                When {expr3} is omitted then "force" is assumed.

                {expr1} is changed when {expr2} is not empty.  If necessary
                make a copy of {expr1} first.
                {expr2} remains unchanged.
                Returns {expr1}.



        feedkeys({string} [, {mode}])               *feedkeys()*
                Characters in {string} are queued for processing as if they
                come from a mapping or were typed by the user.  They are added
                to the end of the typeahead buffer, thus if a mapping is still
                being executed these characters come after them.
                The function does not wait for processing of keys contained in
                {string}.
                To include special keys into {string}, use double-quotes
                and "\..." notation |expr-quote|. For example,
                feedkeys("\<CR>") simulates pressing of the <Enter> key. But
                feedkeys('\<CR>') pushes 5 characters.
                If {mode} is absent, keys are remapped.
                {mode} is a String, which can contain these character flags:
                'm' Remap keys. This is default.
                'n' Do not remap keys.
                't' Handle keys as if typed; otherwise they are handled as
                    if coming from a mapping.  This matters for undo,
                    opening folds, etc.
                Return value is always 0.


        filereadable({file})                    *filereadable()*
                The result is a Number, which is TRUE when a file with the
                name {file} exists, and can be read.  If {file} doesn't exist,
                or is a directory, the result is FALSE.  {file} is any
                expression, which is used as a String.
                If you don't care about the file being readable you can use
                |glob()|.

                                    *file_readable()*
                Obsolete name: file_readable().



        filewritable({file})                    *filewritable()*
                The result is a Number, which is 1 when a file with the
                name {file} exists, and can be written.  If {file} doesn't
                exist, or is not writable, the result is 0.  If {file} is a
                directory, and we can write to it, the result is 2.



        filter({expr}, {string})                    *filter()*
                {expr} must be a |List| or a |Dictionary|.
                For each item in {expr} evaluate {string} and when the result
                is zero remove the item from the |List| or |Dictionary|.
                Inside {string} |v:val| has the value of the current item.
                For a |Dictionary| |v:key| has the key of the current item.
                Examples:
                    :call filter(mylist, 'v:val !~ "OLD"')
                Removes the items where "OLD" appears.
                    :call filter(mydict, 'v:key >= 8')
                Removes the items with a key below 8.
                    :call filter(var, 0)
                Removes all the items, thus clears the |List| or |Dictionary|.

                Note that {string} is the result of expression and is then
                used as an expression again.  Often it is good to use a
                |literal-string| to avoid having to double backslashes.

                The operation is done in-place.  If you want a |List| or
                |Dictionary| to remain unmodified make a copy first:
                    :let l = filter(copy(mylist), 'v:val =~ "KEEP"')

                Returns {expr}, the |List| or |Dictionary| that was filtered.
                When an error is encountered while evaluating {string} no
                further items in {expr} are processed.



        finddir({name}[, {path}[, {count}]])                *finddir()*
                Find directory {name} in {path}.  Supports both downwards and
                upwards recursive directory searches.  See |file-searching|
                for the syntax of {path}.
                Returns the path of the first found match.  When the found
                directory is below the current directory a relative path is
                returned.  Otherwise a full path is returned.
                If {path} is omitted or empty then 'path' is used.
                If the optional {count} is given, find {count}'s occurrence of
                {name} in {path} instead of the first one.
                When {count} is negative return all the matches in a |List|.
                This is quite similar to the ex-command |:find|.
                {only available when compiled with the |+file_in_path|
                feature}


        findfile({name}[, {path}[, {count}]])               *findfile()*
                Just like |finddir()|, but find a file instead of a directory.
                Uses 'suffixesadd'.
                Example:
                    :echo findfile("tags.vim", ".;")
                Searches from the directory of the current file upwards until
                it finds the file "tags.vim".


        float2nr({expr})                    *float2nr()*
                Convert {expr} to a Number by omitting the part after the
                decimal point.
                {expr} must evaluate to a |Float| or a Number.
                When the value of {expr} is out of range for a |Number| the
                result is truncated to 0x7fffffff or -0x7fffffff.  NaN results
                in -0x80000000.
                Examples:
                    echo float2nr(3.95)
                    3 
                    echo float2nr(-23.45)
                    -23 
                    echo float2nr(1.0e100)
                    2147483647 
                    echo float2nr(-1.0e150)
                    -2147483647 
                    echo float2nr(1.0e-100)
                    0
                {only available when compiled with the |+float| feature}



        floor({expr})                           *floor()*
                Return the largest integral value less than or equal to
                {expr} as a |Float| (round down).
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    echo floor(1.856)
                    1.0 
                    echo floor(-5.456)
                    -6.0 
                    echo floor(4.0)
                    4.0
                {only available when compiled with the |+float| feature}



        fmod({expr1}, {expr2})                  *fmod()*
                Return the remainder of {expr1} / {expr2}, even if the
                division is not representable.  Returns {expr1} - i * {expr2}
                for some integer i such that if {expr2} is non-zero, the
                result has the same sign as {expr1} and magnitude less than
                the magnitude of {expr2}.  If {expr2} is zero, the value
                returned is zero.  The value returned is a |Float|.
                {expr1} and {expr2} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo fmod(12.33, 1.22)
                    0.13
                    :echo fmod(-12.33, 1.22)
                    -0.13
                {only available when compiled with |+float| feature}



        fnameescape({string})                   *fnameescape()*
                Escape {string} for use as file name command argument.  All
                characters that have a special meaning, such as '%' and '|'
                are escaped with a backslash.
                For most systems the characters escaped are
                " \t\n*?[{`$\\%#'\"|!<".  For systems where a backslash
                appears in a filename, it depends on the value of 'isfname'.
                A leading '+' and '>' is also escaped (special after |:edit|
                and |:write|).  And a "-" by itself (special after |:cd|).
                Example:
                    :let fname = '+some str%nge|name'
                    :exe "edit " . fnameescape(fname)
                results in executing:
                    edit \+some\ str\%nge\|name


        fnamemodify({fname}, {mods})                *fnamemodify()*
                Modify file name {fname} according to {mods}.  {mods} is a
                string of characters like it is used for file names on the
                command line.  See |filename-modifiers|.
                Example:
                    :echo fnamemodify("main.c", ":p:h")
                results in:
                    /home/mool/vim/vim/src
                Note: Environment variables don't work in {fname}, use
                |expand()| first then.


        foldclosed({lnum})                  *foldclosed()*
                The result is a Number.  If the line {lnum} is in a closed
                fold, the result is the number of the first line in that fold.
                If the line {lnum} is not in a closed fold, -1 is returned.


        foldclosedend({lnum})                   *foldclosedend()*
                The result is a Number.  If the line {lnum} is in a closed
                fold, the result is the number of the last line in that fold.
                If the line {lnum} is not in a closed fold, -1 is returned.


        foldlevel({lnum})                   *foldlevel()*
                The result is a Number, which is the foldlevel of line {lnum}
                in the current buffer.  For nested folds the deepest level is
                returned.  If there is no fold at line {lnum}, zero is
                returned.  It doesn't matter if the folds are open or closed.
                When used while updating folds (from 'foldexpr') -1 is
                returned for lines where folds are still to be updated and the
                foldlevel is unknown.  As a special case the level of the
                previous line is usually available.


                                    *foldtext()*
        foldtext()  Returns a String, to be displayed for a closed fold.  This is
                the default function used for the 'foldtext' option and should
                only be called from evaluating 'foldtext'.  It uses the
                |v:foldstart|, |v:foldend| and |v:folddashes| variables.
                The returned string looks like this:
                    +-- 45 lines: abcdef
                The number of dashes depends on the foldlevel.  The "45" is
                the number of lines in the fold.  "abcdef" is the text in the
                first non-blank line of the fold.  Leading white space, "//"
                or "/*" and the text from the 'foldmarker' and 'commentstring'
                options is removed.
                {not available when compiled without the |+folding| feature}


        foldtextresult({lnum})                  *foldtextresult()*
                Returns the text that is displayed for the closed fold at line
                {lnum}.  Evaluates 'foldtext' in the appropriate context.
                When there is no closed fold at {lnum} an empty string is
                returned.
                {lnum} is used like with |getline()|.  Thus "." is the current
                line, "'m" mark m, etc.
                Useful when exporting folded text, e.g., to HTML.
                {not available when compiled without the |+folding| feature}


                                    *foreground()*
        foreground()    Move the Vim window to the foreground.  Useful when sent from
                a client to a Vim server. |remote_send()|
                On Win32 systems this might not work, the OS does not always
                allow a window to bring itself to the foreground.  Use
                |remote_foreground()| instead.
                {only in the Win32, Athena, Motif and GTK GUI versions and the
                Win32 console version}



        function({name})                    *function()* *E700*
                Return a |Funcref| variable that refers to function {name}.
                {name} can be a user defined function or an internal function.



        garbagecollect([at_exit])               *garbagecollect()*
                Cleanup unused |Lists| and |Dictionaries| that have circular
                references.  There is hardly ever a need to invoke this
                function, as it is automatically done when Vim runs out of
                memory or is waiting for the user to press a key after
                'updatetime'.  Items without circular references are always
                freed when they become unused.
                This is useful if you have deleted a very big |List| and/or
                |Dictionary| with circular references in a script that runs
                for a long time.
                When the optional "at_exit" argument is one, garbage
                collection will also be done when exiting Vim, if it wasn't
                done before.  This is useful when checking for memory leaks.


        get({list}, {idx} [, {default}])            *get()*
                Get item {idx} from |List| {list}.  When this item is not
                available return {default}.  Return zero when {default} is
                omitted.
        get({dict}, {key} [, {default}])
                Get item with key {key} from |Dictionary| {dict}.  When this
                item is not available return {default}.  Return zero when
                {default} is omitted.


                                    *getbufline()*
        getbufline({expr}, {lnum} [, {end}])
                Return a |List| with the lines starting from {lnum} to {end}
                (inclusive) in the buffer {expr}.  If {end} is omitted, a
                |List| with only the line {lnum} is returned.

                For the use of {expr}, see |bufname()| above.

                For {lnum} and {end} "$" can be used for the last line of the
                buffer.  Otherwise a number must be used.

                When {lnum} is smaller than 1 or bigger than the number of
                lines in the buffer, an empty |List| is returned.

                When {end} is greater than the number of lines in the buffer,
                it is treated as {end} is set to the number of lines in the
                buffer.  When {end} is before {lnum} an empty |List| is
                returned.

                This function works only for loaded buffers.  For unloaded and
                non-existing buffers, an empty |List| is returned.

                Example:
                    :let lines = getbufline(bufnr("myfile"), 1, "$")


        getbufvar({expr}, {varname})                *getbufvar()*
                The result is the value of option or local buffer variable
                {varname} in buffer {expr}.  Note that the name without "b:"
                must be used.
                When {varname} is empty returns a dictionary with all the
                buffer-local variables.
                This also works for a global or buffer-local option, but it
                doesn't work for a global variable, window-local variable or
                window-local option.
                For the use of {expr}, see |bufname()| above.
                When the buffer or variable doesn't exist an empty string is
                returned, there is no error message.
                Examples:
                    :let bufmodified = getbufvar(1, "&mod")
                    :echo "todo myvar = " . getbufvar("todo", "myvar")


        getchar([expr])                     *getchar()*
                Get a single character from the user or input stream.
                If [expr] is omitted, wait until a character is available.
                If [expr] is 0, only get a character when one is available.
                    Return zero otherwise.
                If [expr] is 1, only check if a character is available, it is
                    not consumed.  Return zero if no character available.

                Without {expr} and when {expr} is 0 a whole character or
                special key is returned.  If it is an 8-bit character, the
                result is a number.  Use nr2char() to convert it to a String.
                Otherwise a String is returned with the encoded character.
                For a special key it's a sequence of bytes starting with 0x80
                (decimal: 128).  This is the same value as the string
                "\<Key>", e.g., "\<Left>".  The returned value is also a
                String when a modifier (shift, control, alt) was used that is
                not included in the character.

                When {expr} is 1 only the first byte is returned.  For a
                one-byte character it is the character itself as a number.
                Use nr2char() to convert it to a String.

                When the user clicks a mouse button, the mouse event will be
                returned.  The position can then be found in |v:mouse_col|,
                |v:mouse_lnum| and |v:mouse_win|.  This example positions the
                mouse as it would normally happen:
                    let c = getchar()
                    if c == "\<LeftMouse>" && v:mouse_win > 0
                      exe v:mouse_win . "wincmd w"
                      exe v:mouse_lnum
                      exe "normal " . v:mouse_col . "|"
                    endif

                There is no prompt, you will somehow have to make clear to the
                user that a character has to be typed.
                There is no mapping for the character.
                Key codes are replaced, thus when the user presses the <Del>
                key you get the code for the <Del> key, not the raw character
                sequence.  Examples:
                    getchar() == "\<Del>"
                    getchar() == "\<S-Left>"
                This example redefines "f" to ignore case:
                    :nmap f :call FindChar()<CR>
                    :function FindChar()
                    :  let c = nr2char(getchar())
                    :  while col('.') < col('$') - 1
                    :    normal l
                    :    if getline('.')[col('.') - 1] ==? c
                    :      break
                    :    endif
                    :  endwhile
                    :endfunction


        getcharmod()                        *getcharmod()*
                The result is a Number which is the state of the modifiers for
                the last obtained character with getchar() or in another way.
                These values are added together:
                    2   shift
                    4   control
                    8   alt (meta)
                    16  mouse double click
                    32  mouse triple click
                    64  mouse quadruple click
                    128 Macintosh only: command
                Only the modifiers that have not been included in the
                character itself are obtained.  Thus Shift-a results in "A"
                without a modifier.


        getcmdline()                        *getcmdline()*
                Return the current command-line.  Only works when the command
                line is being edited, thus requires use of |c_CTRL-\_e| or
                |c_CTRL-R_=|.
                Example:
                    :cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
                Also see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.


        getcmdpos()                     *getcmdpos()*
                Return the position of the cursor in the command line as a
                byte count.  The first column is 1.
                Only works when editing the command line, thus requires use of
                |c_CTRL-\_e| or |c_CTRL-R_=|.  Returns 0 otherwise.
                Also see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.


        getcmdtype()                        *getcmdtype()*
                Return the current command-line type. Possible return values
                are:
                    :   normal Ex command
                    >   debug mode command |debug-mode|
                    /   forward search command
                    ?   backward search command
                    @   |input()| command
                    -   |:insert| or |:append| command
                Only works when editing the command line, thus requires use of
                |c_CTRL-\_e| or |c_CTRL-R_=|.  Returns an empty string
                otherwise.
                Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.


                                    *getcwd()*
        getcwd()    The result is a String, which is the name of the current
                working directory.


        getfsize({fname})                   *getfsize()*
                The result is a Number, which is the size in bytes of the
                given file {fname}.
                If {fname} is a directory, 0 is returned.
                If the file {fname} can't be found, -1 is returned.
                If the size of {fname} is too big to fit in a Number then -2
                is returned.


        getfontname([{name}])                   *getfontname()*
                Without an argument returns the name of the normal font being
                used.  Like what is used for the Normal highlight group
                |hl-Normal|.
                With an argument a check is done whether {name} is a valid
                font name.  If not then an empty string is returned.
                Otherwise the actual font name is returned, or {name} if the
                GUI does not support obtaining the real name.
                Only works when the GUI is running, thus not in your vimrc or
                gvimrc file.  Use the |GUIEnter| autocommand to use this
                function just after the GUI has started.
                Note that the GTK 2 GUI accepts any font name, thus checking
                for a valid name does not work.


        getfperm({fname})                   *getfperm()*
                The result is a String, which is the read, write, and execute
                permissions of the given file {fname}.
                If {fname} does not exist or its directory cannot be read, an
                empty string is returned.
                The result is of the form "rwxrwxrwx", where each group of
                "rwx" flags represent, in turn, the permissions of the owner
                of the file, the group the file belongs to, and other users.
                If a user does not have a given permission the flag for this
                is replaced with the string "-".  Example:
                    :echo getfperm("/etc/passwd")
                This will hopefully (from a security point of view) display
                the string "rw-r--r--" or even "rw-------".


        getftime({fname})                   *getftime()*
                The result is a Number, which is the last modification time of
                the given file {fname}.  The value is measured as seconds
                since 1st Jan 1970, and may be passed to strftime().  See also
                |localtime()| and |strftime()|.
                If the file {fname} can't be found -1 is returned.


        getftype({fname})                   *getftype()*
                The result is a String, which is a description of the kind of
                file of the given file {fname}.
                If {fname} does not exist an empty string is returned.
                Here is a table over different kinds of files and their
                results:
                    Normal file     "file"
                    Directory       "dir"
                    Symbolic link       "link"
                    Block device        "bdev"
                    Character device    "cdev"
                    Socket          "socket"
                    FIFO            "fifo"
                    All other       "other"
                Example:
                    getftype("/home")
                Note that a type such as "link" will only be returned on
                systems that support it.  On some systems only "dir" and
                "file" are returned.


                                    *getline()*
        getline({lnum} [, {end}])
                Without {end} the result is a String, which is line {lnum}
                from the current buffer.  Example:
                    getline(1)
                When {lnum} is a String that doesn't start with a
                digit, line() is called to translate the String into a Number.
                To get the line under the cursor:
                    getline(".")
                When {lnum} is smaller than 1 or bigger than the number of
                lines in the buffer, an empty string is returned.

                When {end} is given the result is a |List| where each item is
                a line from the current buffer in the range {lnum} to {end},
                including line {end}.
                {end} is used in the same way as {lnum}.
                Non-existing lines are silently omitted.
                When {end} is before {lnum} an empty |List| is returned.
                Example:
                    :let start = line('.')
                    :let end = search("^$") - 1
                    :let lines = getline(start, end)

                To get lines from another buffer see |getbufline()|


        getloclist({nr})                    *getloclist()*
                Returns a list with all the entries in the location list for
                window {nr}. When {nr} is zero the current window is used.
                For a location list window, the displayed location list is
                returned.  For an invalid window number {nr}, an empty list is
                returned. Otherwise, same as |getqflist()|.


        getmatches()                        *getmatches()*
                Returns a |List| with all matches previously defined by
                |matchadd()| and the |:match| commands.  |getmatches()| is
                useful in combination with |setmatches()|, as |setmatches()|
                can restore a list of matches saved by |getmatches()|.
                Example:
                    :echo getmatches()
                    [{'group': 'MyGroup1', 'pattern': 'TODO',
                    'priority': 10, 'id': 1}, {'group': 'MyGroup2',
                    'pattern': 'FIXME', 'priority': 10, 'id': 2}]
                    :let m = getmatches()
                    :call clearmatches()
                    :echo getmatches()
                    []
                    :call setmatches(m)
                    :echo getmatches()
                    [{'group': 'MyGroup1', 'pattern': 'TODO',
                    'priority': 10, 'id': 1}, {'group': 'MyGroup2',
                    'pattern': 'FIXME', 'priority': 10, 'id': 2}]
                    :unlet m



        getqflist()                     *getqflist()*
                Returns a list with all the current quickfix errors.  Each
                list item is a dictionary with these entries:
                    bufnr   number of buffer that has the file name, use
                        bufname() to get the name
                    lnum    line number in the buffer (first line is 1)
                    col column number (first column is 1)
                    vcol    non-zero: "col" is visual column
                        zero: "col" is byte index
                    nr  error number
                    pattern search pattern used to locate the error
                    text    description of the error
                    type    type of the error, 'E', '1', etc.
                    valid   non-zero: recognized error message

                When there is no error list or it's empty an empty list is
                returned. Quickfix list entries with non-existing buffer
                number are returned with "bufnr" set to zero.

                Useful application: Find pattern matches in multiple files and
                do something with them:
                    :vimgrep /theword/jg *.c
                    :for d in getqflist()
                    :   echo bufname(d.bufnr) ':' d.lnum '=' d.text
                    :endfor



        getreg([{regname} [, 1]])               *getreg()*
                The result is a String, which is the contents of register
                {regname}.  Example:
                    :let cliptext = getreg('*')
                getreg('=') returns the last evaluated value of the expression
                register.  (For use in maps.)
                getreg('=', 1) returns the expression itself, so that it can
                be restored with |setreg()|.  For other registers the extra
                argument is ignored, thus you can always give it.
                If {regname} is not specified, |v:register| is used.



        getregtype([{regname}])                 *getregtype()*
                The result is a String, which is type of register {regname}.
                The value will be one of:
                    "v"         for |characterwise| text
                    "V"         for |linewise| text
                    "<CTRL-V>{width}"   for |blockwise-visual| text
                    0           for an empty or unknown register
                <CTRL-V> is one character with value 0x16.
                If {regname} is not specified, |v:register| is used.


        gettabvar({tabnr}, {varname})               *gettabvar()*
                Get the value of a tab-local variable {varname} in tab page
                {tabnr}. |t:var|
                Tabs are numbered starting with one.
                Note that the name without "t:" must be used.


        gettabwinvar({tabnr}, {winnr}, {varname})       *gettabwinvar()*
                Get the value of window-local variable {varname} in window
                {winnr} in tab page {tabnr}.
                When {varname} starts with "&" get the value of a window-local
                option.
                Tabs are numbered starting with one.  For the current tabpage
                use |getwinvar()|.
                When {winnr} is zero the current window is used.
                This also works for a global option, buffer-local option and
                window-local option, but it doesn't work for a global variable
                or buffer-local variable.
                When {varname} is empty a dictionary with all window-local
                variables is returned.
                Note that {varname} must be the name without "w:".
                Examples:
                    :let list_is_on = gettabwinvar(1, 2, '&list')
                    :echo "myvar = " . gettabwinvar(3, 1, 'myvar')


                                    *getwinposx()*
        getwinposx()    The result is a Number, which is the X coordinate in pixels of
                the left hand side of the GUI Vim window.  The result will be
                -1 if the information is not available.


                                    *getwinposy()*
        getwinposy()    The result is a Number, which is the Y coordinate in pixels of
                the top of the GUI Vim window.  The result will be -1 if the
                information is not available.


        getwinvar({winnr}, {varname})               *getwinvar()*
                Like |gettabwinvar()| for the current tabpage.
                Examples:
                    :let list_is_on = getwinvar(2, '&list')
                    :echo "myvar = " . getwinvar(1, 'myvar')


        glob({expr} [, {flag}])                 *glob()*
                Expand the file wildcards in {expr}.  See |wildcards| for the
                use of special characters.
                The result is a String.
                When there are several matches, they are separated by <NL>
                characters.
                Unless the optional {flag} argument is given and is non-zero,
                the 'suffixes' and 'wildignore' options apply: Names matching
                one of the patterns in 'wildignore' will be skipped and
                'suffixes' affect the ordering of matches.
                'wildignorecase' always applies.
                If the expansion fails, the result is an empty string.
                A name for a non-existing file is not included.

                For most systems backticks can be used to get files names from
                any external command.  Example:
                    :let tagfiles = glob("`find . -name tags -print`")
                    :let &tags = substitute(tagfiles, "\n", ",", "g")
                The result of the program inside the backticks should be one
                item per line.  Spaces inside an item are allowed.

                See |expand()| for expanding special Vim variables.  See
                |system()| for getting the raw output of an external command.


        globpath({path}, {expr} [, {flag}])         *globpath()*
                Perform glob() on all directories in {path} and concatenate
                the results.  Example:
                    :echo globpath(&rtp, "syntax/c.vim")
                {path} is a comma-separated list of directory names.  Each
                directory name is prepended to {expr} and expanded like with
                |glob()|.  A path separator is inserted when needed.
                To add a comma inside a directory name escape it with a
                backslash.  Note that on MS-Windows a directory may have a
                trailing backslash, remove it if you put a comma after it.
                If the expansion fails for one of the directories, there is no
                error message.
                Unless the optional {flag} argument is given and is non-zero,
                the 'suffixes' and 'wildignore' options apply: Names matching
                one of the patterns in 'wildignore' will be skipped and
                'suffixes' affect the ordering of matches.

                The "**" item can be used to search in a directory tree.
                For example, to find all "README.txt" files in the directories
                in 'runtimepath' and below:
                    :echo globpath(&rtp, "**/README.txt")
                Upwards search and limiting the depth of "**" is not
                supported, thus using 'path' will not always work properly.


                                    *has()*
        has({feature})  The result is a Number, which is 1 if the feature {feature} is
                supported, zero otherwise.  The {feature} argument is a
                string.  See |feature-list| below.
                Also see |exists()|.



        has_key({dict}, {key})                  *has_key()*
                The result is a Number, which is 1 if |Dictionary| {dict} has
                an entry with key {key}.  Zero otherwise.


        haslocaldir()                       *haslocaldir()*
                The result is a Number, which is 1 when the current
                window has set a local path via |:lcd|, and 0 otherwise.


        hasmapto({what} [, {mode} [, {abbr}]])          *hasmapto()*
                The result is a Number, which is 1 if there is a mapping that
                contains {what} in somewhere in the rhs (what it is mapped to)
                and this mapping exists in one of the modes indicated by
                {mode}.
                When {abbr} is there and it is non-zero use abbreviations
                instead of mappings.  Don't forget to specify Insert and/or
                Command-line mode.
                Both the global mappings and the mappings local to the current
                buffer are checked for a match.
                If no matching mapping is found 0 is returned.
                The following characters are recognized in {mode}:
                    n   Normal mode
                    v   Visual mode
                    o   Operator-pending mode
                    i   Insert mode
                    l   Language-Argument ("r", "f", "t", etc.)
                    c   Command-line mode
                When {mode} is omitted, "nvo" is used.

                This function is useful to check if a mapping already exists
                to a function in a Vim script.  Example:
                    :if !hasmapto('\ABCdoit')
                    :   map <Leader>d \ABCdoit
                    :endif
                This installs the mapping to "\ABCdoit" only if there isn't
                already a mapping to "\ABCdoit".


        histadd({history}, {item})              *histadd()*
                Add the String {item} to the history {history} which can be

                one of:                 *hist-names*
                    "cmd"    or ":"   command line history
                    "search" or "/"   search pattern history
                    "expr"   or "="   typed expression history
                    "input"  or "@"   input line history
                If {item} does already exist in the history, it will be
                shifted to become the newest entry.
                The result is a Number: 1 if the operation was successful,
                otherwise 0 is returned.

                Example:
                    :call histadd("input", strftime("%Y %b %d"))
                    :let date=input("Enter date: ")
                This function is not available in the |sandbox|.


        histdel({history} [, {item}])               *histdel()*
                Clear {history}, i.e. delete all its entries.  See |hist-names|
                for the possible values of {history}.

                If the parameter {item} evaluates to a String, it is used as a
                regular expression.  All entries matching that expression will
                be removed from the history (if there are any).
                Upper/lowercase must match, unless "\c" is used |/\c|.
                If {item} evaluates to a Number, it will be interpreted as
                an index, see |:history-indexing|.  The respective entry will
                be removed if it exists.

                The result is a Number: 1 for a successful operation,
                otherwise 0 is returned.

                Examples:
                Clear expression register history:
                    :call histdel("expr")

                Remove all entries starting with "*" from the search history:
                    :call histdel("/", '^\*')

                The following three are equivalent:
                    :call histdel("search", histnr("search"))
                    :call histdel("search", -1)
                    :call histdel("search", '^'.histget("search", -1).'$')

                To delete the last search pattern and use the last-but-one for
                the "n" command and 'hlsearch':
                    :call histdel("search", -1)
                    :let @/ = histget("search", -1)


        histget({history} [, {index}])              *histget()*
                The result is a String, the entry with Number {index} from
                {history}.  See |hist-names| for the possible values of
                {history}, and |:history-indexing| for {index}.  If there is
                no such entry, an empty String is returned.  When {index} is
                omitted, the most recent item from the history is used.

                Examples:
                Redo the second last search from history.
                    :execute '/' . histget("search", -2)

                Define an Ex command ":H {num}" that supports re-execution of
                the {num}th entry from the output of |:history|.
                    :command -nargs=1 H execute histget("cmd", 0+<args>)


        histnr({history})                   *histnr()*
                The result is the Number of the current entry in {history}.
                See |hist-names| for the possible values of {history}.
                If an error occurred, -1 is returned.

                Example:
                    :let inp_index = histnr("expr")


        hlexists({name})                    *hlexists()*
                The result is a Number, which is non-zero if a highlight group
                called {name} exists.  This is when the group has been
                defined in some way.  Not necessarily when highlighting has
                been defined for it, it may also have been used for a syntax
                item.

                                    *highlight_exists()*
                Obsolete name: highlight_exists().


                                    *hlID()*
        hlID({name})    The result is a Number, which is the ID of the highlight group
                with name {name}.  When the highlight group doesn't exist,
                zero is returned.
                This can be used to retrieve information about the highlight
                group.  For example, to get the background color of the
                "Comment" group:
            :echo synIDattr(synIDtrans(hlID("Comment")), "bg")

                                    *highlightID()*
                Obsolete name: highlightID().


        hostname()                      *hostname()*
                The result is a String, which is the name of the machine on
                which Vim is currently running.  Machine names greater than
                256 characters long are truncated.


        iconv({expr}, {from}, {to})             *iconv()*
                The result is a String, which is the text {expr} converted
                from encoding {from} to encoding {to}.
                When the conversion completely fails an empty string is
                returned.  When some characters could not be converted they
                are replaced with "?".
                The encoding names are whatever the iconv() library function
                can accept, see ":!man 3 iconv".
                Most conversions require Vim to be compiled with the |+iconv|
                feature.  Otherwise only UTF-8 to latin1 conversion and back
                can be done.
                This can be used to display messages with special characters,
                no matter what 'encoding' is set to.  Write the message in
                UTF-8 and use:
                    echo iconv(utf8_str, "utf-8", &enc)
                Note that Vim uses UTF-8 for all Unicode encodings, conversion
                from/to UCS-2 is automatically changed to use UTF-8.  You
                cannot use UCS-2 in a string anyway, because of the NUL bytes.
                {only available when compiled with the |+multi_byte| feature}


                                    *indent()*
        indent({lnum})  The result is a Number, which is indent of line {lnum} in the
                current buffer.  The indent is counted in spaces, the value
                of 'tabstop' is relevant.  {lnum} is used just like in
                |getline()|.
                When {lnum} is invalid -1 is returned.



        index({list}, {expr} [, {start} [, {ic}]])          *index()*
                Return the lowest index in |List| {list} where the item has a
                value equal to {expr}.  There is no automatic conversion, so
                the String "4" is different from the Number 4.  And the number
                4 is different from the Float 4.0.  The value of 'ignorecase'
                is not used here, case always matters.
                If {start} is given then start looking at the item with index
                {start} (may be negative for an item relative to the end).
                When {ic} is given and it is non-zero, ignore case.  Otherwise
                case must match.
                -1 is returned when {expr} is not found in {list}.
                Example:
                    :let idx = index(words, "the")
                    :if index(numbers, 123) >= 0



        input({prompt} [, {text} [, {completion}]])     *input()*
                The result is a String, which is whatever the user typed on
                the command-line.  The {prompt} argument is either a prompt
                string, or a blank string (for no prompt).  A '\n' can be used
                in the prompt to start a new line.
                The highlighting set with |:echohl| is used for the prompt.
                The input is entered just like a command-line, with the same
                editing commands and mappings.  There is a separate history
                for lines typed for input().
                Example:
                    :if input("Coffee or beer? ") == "beer"
                    :  echo "Cheers!"
                    :endif

                If the optional {text} argument is present and not empty, this
                is used for the default reply, as if the user typed this.
                Example:
                    :let color = input("Color? ", "white")

                The optional {completion} argument specifies the type of
                completion supported for the input.  Without it completion is
                not performed.  The supported completion types are the same as
                that can be supplied to a user-defined command using the
                "-complete=" argument.  Refer to |:command-completion| for
                more information.  Example:
                    let fname = input("File: ", "", "file")

                NOTE: This function must not be used in a startup file, for
                the versions that only run in GUI mode (e.g., the Win32 GUI).
                Note: When input() is called from within a mapping it will
                consume remaining characters from that mapping, because a
                mapping is handled like the characters were typed.
                Use |inputsave()| before input() and |inputrestore()|
                after input() to avoid that.  Another solution is to avoid
                that further characters follow in the mapping, e.g., by using
                |:execute| or |:normal|.

                Example with a mapping:
                    :nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
                    :function GetFoo()
                    :  call inputsave()
                    :  let g:Foo = input("enter search pattern: ")
                    :  call inputrestore()
                    :endfunction


        inputdialog({prompt} [, {text} [, {cancelreturn}]])     *inputdialog()*
                Like |input()|, but when the GUI is running and text dialogs
                are supported, a dialog window pops up to input the text.
                Example:
                    :let n = inputdialog("value for shiftwidth", &sw)
                    :if n != ""
                    :  let &sw = n
                    :endif
                When the dialog is cancelled {cancelreturn} is returned.  When
                omitted an empty string is returned.
                Hitting <Enter> works like pressing the OK button.  Hitting
                <Esc> works like pressing the Cancel button.
                NOTE: Command-line completion is not supported.


        inputlist({textlist})                   *inputlist()*
                {textlist} must be a |List| of strings.  This |List| is
                displayed, one string per line.  The user will be prompted to
                enter a number, which is returned.
                The user can also select an item by clicking on it with the
                mouse.  For the first string 0 is returned.  When clicking
                above the first item a negative number is returned.  When
                clicking on the prompt one more than the length of {textlist}
                is returned.
                Make sure {textlist} has less than 'lines' entries, otherwise
                it won't work.  It's a good idea to put the entry number at
                the start of the string.  And put a prompt in the first item.
                Example:
                    let color = inputlist(['Select color:', '1. red',
                        \ '2. green', '3. blue'])


        inputrestore()                      *inputrestore()*
                Restore typeahead that was saved with a previous |inputsave()|.
                Should be called the same number of times inputsave() is
                called.  Calling it more often is harmless though.
                Returns 1 when there is nothing to restore, 0 otherwise.


        inputsave()                     *inputsave()*
                Preserve typeahead (also from mappings) and clear it, so that
                a following prompt gets input from the user.  Should be
                followed by a matching inputrestore() after the prompt.  Can
                be used several times, in which case there must be just as
                many inputrestore() calls.
                Returns 1 when out of memory, 0 otherwise.


        inputsecret({prompt} [, {text}])            *inputsecret()*
                This function acts much like the |input()| function with but
                two exceptions:
                a) the user's response will be displayed as a sequence of
                asterisks ("*") thereby keeping the entry secret, and
                b) the user's response will not be recorded on the input
                |history| stack.
                The result is a String, which is whatever the user actually
                typed on the command-line in response to the issued prompt.
                NOTE: Command-line completion is not supported.


        insert({list}, {item} [, {idx}])            *insert()*
                Insert {item} at the start of |List| {list}.
                If {idx} is specified insert {item} before the item with index
                {idx}.  If {idx} is zero it goes before the first item, just
                like omitting {idx}.  A negative {idx} is also possible, see
                |list-index|.  -1 inserts just before the last item.
                Returns the resulting |List|.  Examples:
                    :let mylist = insert([2, 3, 5], 1)
                    :call insert(mylist, 4, -1)
                    :call insert(mylist, 6, len(mylist))
                The last example can be done simpler with |add()|.
                Note that when {item} is a |List| it is inserted as a single
                item.  Use |extend()| to concatenate |Lists|.


        isdirectory({directory})                *isdirectory()*
                The result is a Number, which is non-zero when a directory
                with the name {directory} exists.  If {directory} doesn't
                exist, or isn't a directory, the result is FALSE.  {directory}
                is any expression, which is used as a String.


        islocked({expr})                    *islocked()* *E786*
                The result is a Number, which is non-zero when {expr} is the
                name of a locked variable.
                {expr} must be the name of a variable, |List| item or
                |Dictionary| entry, not the variable itself!  Example:
                    :let alist = [0, ['a', 'b'], 2, 3]
                    :lockvar 1 alist
                    :echo islocked('alist')     " 1
                    :echo islocked('alist[1]')  " 0

                When {expr} is a variable that does not exist you get an error
                message.  Use |exists()| to check for existence.


        items({dict})                       *items()*
                Return a |List| with all the key-value pairs of {dict}.  Each
                |List| item is a list with two items: the key of a {dict}
                entry and the value of this entry.  The |List| is in arbitrary
                order.



        join({list} [, {sep}])                  *join()*
                Join the items in {list} together into one String.
                When {sep} is specified it is put in between the items.  If
                {sep} is omitted a single space is used.
                Note that {sep} is not added at the end.  You might want to
                add it there too:
                    let lines = join(mylist, "\n") . "\n"
                String items are used as-is.  |Lists| and |Dictionaries| are
                converted into a string like with |string()|.
                The opposite function is |split()|.


        keys({dict})                        *keys()*
                Return a |List| with all the keys of {dict}.  The |List| is in
                arbitrary order.


                                    *len()* *E701*
        len({expr}) The result is a Number, which is the length of the argument.
                When {expr} is a String or a Number the length in bytes is
                used, as with |strlen()|.
                When {expr} is a |List| the number of items in the |List| is
                returned.
                When {expr} is a |Dictionary| the number of entries in the
                |Dictionary| is returned.
                Otherwise an error is given.


                                *libcall()* *E364* *E368*
        libcall({libname}, {funcname}, {argument})
                Call function {funcname} in the run-time library {libname}
                with single argument {argument}.
                This is useful to call functions in a library that you
                especially made to be used with Vim.  Since only one argument
                is possible, calling standard library functions is rather
                limited.
                The result is the String returned by the function.  If the
                function returns NULL, this will appear as an empty string ""
                to Vim.
                If the function returns a number, use libcallnr()!
                If {argument} is a number, it is passed to the function as an
                int; if {argument} is a string, it is passed as a
                null-terminated string.
                This function will fail in |restricted-mode|.

                libcall() allows you to write your own 'plug-in' extensions to
                Vim without having to recompile the program.  It is NOT a
                means to call system functions!  If you try to do so Vim will
                very probably crash.

                For Win32, the functions you write must be placed in a DLL
                and use the normal C calling convention (NOT Pascal which is
                used in Windows System DLLs).  The function must take exactly
                one parameter, either a character pointer or a long integer,
                and must return a character pointer or NULL.  The character
                pointer returned must point to memory that will remain valid
                after the function has returned (e.g. in static data in the
                DLL).  If it points to allocated memory, that memory will
                leak away.  Using a static buffer in the function should work,
                it's then freed when the DLL is unloaded.

                WARNING: If the function returns a non-valid pointer, Vim may
                crash!  This also happens if the function returns a number,
                because Vim thinks it's a pointer.
                For Win32 systems, {libname} should be the filename of the DLL
                without the ".DLL" suffix.  A full path is only required if
                the DLL is not in the usual places.
                For Unix: When compiling your own plugins, remember that the
                object code must be compiled as position-independent ('PIC').
                {only in Win32 and some Unix versions, when the |+libcall|
                feature is present}
                Examples:
                    :echo libcall("libc.so", "getenv", "HOME")


                                    *libcallnr()*
        libcallnr({libname}, {funcname}, {argument})
                Just like |libcall()|, but used for a function that returns an
                int instead of a string.
                {only in Win32 on some Unix versions, when the |+libcall|
                feature is present}
                Examples:
                    :echo libcallnr("/usr/lib/libc.so", "getpid", "")
                    :call libcallnr("libc.so", "printf", "Hello World!\n")
                    :call libcallnr("libc.so", "sleep", 10)


                                    *line()*
        line({expr})    The result is a Number, which is the line number of the file
                position given with {expr}.  The accepted positions are:
                    .       the cursor position
                    $       the last line in the current buffer
                    'x      position of mark x (if the mark is not set, 0 is
                        returned)
                    w0      first line visible in current window
                    w$      last line visible in current window
                    v       In Visual mode: the start of the Visual area (the
                        cursor is the end).  When not in Visual mode
                        returns the cursor position.  Differs from |'<| in
                        that it's updated right away.
                Note that a mark in another file can be used.  The line number
                then applies to another buffer.
                To get the column number use |col()|.  To get both use
                |getpos()|.
                Examples:
                    line(".")       line number of the cursor
                    line("'t")      line number of mark t
                    line("'" . marker)  line number of mark marker

                                    *last-position-jump*
                This autocommand jumps to the last known position in a file
                just after opening it, if the '"' mark is set:
            :au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif


        line2byte({lnum})                   *line2byte()*
                Return the byte count from the start of the buffer for line
                {lnum}.  This includes the end-of-line character, depending on
                the 'fileformat' option for the current buffer.  The first
                line returns 1.
                This can also be used to get the byte count for the line just
                below the last line:
                    line2byte(line("$") + 1)
                This is the file size plus one.
                When {lnum} is invalid, or the |+byte_offset| feature has been
                disabled at compile time, -1 is returned.
                Also see |byte2line()|, |go| and |:goto|.


        lispindent({lnum})                  *lispindent()*
                Get the amount of indent for line {lnum} according the lisp
                indenting rules, as with 'lisp'.
                The indent is counted in spaces, the value of 'tabstop' is
                relevant.  {lnum} is used just like in |getline()|.
                When {lnum} is invalid or Vim was not compiled the
                |+lispindent| feature, -1 is returned.


        localtime()                     *localtime()*
                Return the current time, measured as seconds since 1st Jan
                1970.  See also |strftime()| and |getftime()|.



        log({expr})                     *log()*
                Return the natural logarithm (base e) of {expr} as a |Float|.
                {expr} must evaluate to a |Float| or a |Number| in the range
                (0, inf].
                Examples:
                    :echo log(10)
                    2.302585
                    :echo log(exp(5))
                    5.0
                {only available when compiled with the |+float| feature}



        log10({expr})                       *log10()*
                Return the logarithm of Float {expr} to base 10 as a |Float|.
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo log10(1000)
                    3.0
                    :echo log10(0.01)
                    -2.0
                {only available when compiled with the |+float| feature}


        map({expr}, {string})                   *map()*
                {expr} must be a |List| or a |Dictionary|.
                Replace each item in {expr} with the result of evaluating
                {string}.
                Inside {string} |v:val| has the value of the current item.
                For a |Dictionary| |v:key| has the key of the current item
                and for a |List| |v:key| has the index of the current item.
                Example:
                    :call map(mylist, '"> " . v:val . " <"')
                This puts "> " before and " <" after each item in "mylist".

                Note that {string} is the result of an expression and is then
                used as an expression again.  Often it is good to use a
                |literal-string| to avoid having to double backslashes.  You
                still have to double '' quotes

                The operation is done in-place.  If you want a |List| or
                |Dictionary| to remain unmodified make a copy first:
                    :let tlist = map(copy(mylist), ' & . "\t"')

                Returns {expr}, the |List| or |Dictionary| that was filtered.
                When an error is encountered while evaluating {string} no
                further items in {expr} are processed.



        maparg({name}[, {mode} [, {abbr} [, {dict}]]])          *maparg()*
                When {dict} is omitted or zero: Return the rhs of mapping
                {name} in mode {mode}.  The returned String has special
                characters translated like in the output of the ":map" command
                listing.

                When there is no mapping for {name}, an empty String is
                returned.

                The {name} can have special key names, like in the ":map"
                command.

                {mode} can be one of these strings:
                    "n" Normal
                    "v" Visual (including Select)
                    "o" Operator-pending
                    "i" Insert
                    "c" Cmd-line
                    "s" Select
                    "x" Visual
                    "l" langmap |language-mapping|
                    ""  Normal, Visual and Operator-pending
                When {mode} is omitted, the modes for "" are used.

                When {abbr} is there and it is non-zero use abbreviations
                instead of mappings.

                When {dict} is there and it is non-zero return a dictionary
                containing all the information of the mapping with the
                following items:
                  "lhs"      The {lhs} of the mapping.
                  "rhs"      The {rhs} of the mapping as typed.
                  "silent"   1 for a |:map-silent| mapping, else 0.
                  "noremap"  1 if the {rhs} of the mapping is not remappable.
                  "expr"     1 for an expression mapping (|:map-<expr>|).
                  "buffer"   1 for a buffer local mapping (|:map-local|).
                  "mode"     Modes for which the mapping is defined. In
                         addition to the modes mentioned above, these
                         characters will be used:
                         " "     Normal, Visual and Operator-pending
                         "!"     Insert and Commandline mode
                             (|mapmode-ic|)
                  "sid"      The script local ID, used for <sid> mappings
                         (|<SID>|).

                The mappings local to the current buffer are checked first,
                then the global mappings.
                This function can be used to map a key even when it's already
                mapped, and have it do the original mapping too.  Sketch:
                    exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')



        mapcheck({name}[, {mode} [, {abbr}]])           *mapcheck()*
                Check if there is a mapping that matches with {name} in mode
                {mode}.  See |maparg()| for {mode} and special names in
                {name}.
                When {abbr} is there and it is non-zero use abbreviations
                instead of mappings.
                A match happens with a mapping that starts with {name} and
                with a mapping which is equal to the start of {name}.

                    matches mapping "a" "ab"    "abc" 
                   mapcheck("a")    yes yes  yes
                   mapcheck("abc")  yes yes  yes
                   mapcheck("ax")   yes no   no
                   mapcheck("b")    no  no   no

                The difference with maparg() is that mapcheck() finds a
                mapping that matches with {name}, while maparg() only finds a
                mapping for {name} exactly.
                When there is no mapping that starts with {name}, an empty
                String is returned.  If there is one, the rhs of that mapping
                is returned.  If there are several mappings that start with
                {name}, the rhs of one of them is returned.
                The mappings local to the current buffer are checked first,
                then the global mappings.
                This function can be used to check if a mapping can be added
                without being ambiguous.  Example:
            :if mapcheck("_vv") == ""
            :   map _vv :set guifont=7x13<CR>
            :endif
                This avoids adding the "_vv" mapping when there already is a
                mapping for "_v" or for "_vvv".


        match({expr}, {pat}[, {start}[, {count}]])          *match()*
                When {expr} is a |List| then this returns the index of the
                first item where {pat} matches.  Each item is used as a
                String, |Lists| and |Dictionaries| are used as echoed.
                Otherwise, {expr} is used as a String.  The result is a
                Number, which gives the index (byte offset) in {expr} where
                {pat} matches.
                A match at the first character or |List| item returns zero.
                If there is no match -1 is returned.
                Example:
                    :echo match("testing", "ing")   " results in 4
                    :echo match([1, 'x'], '\a') " results in 1
                See |string-match| for how {pat} is used.

                                        *strpbrk()*
                Vim doesn't have a strpbrk() function.  But you can do:
                    :let sepidx = match(line, '[.,;: \t]')

                                        *strcasestr()*
                Vim doesn't have a strcasestr() function.  But you can add
                "\c" to the pattern to ignore case:
                    :let idx = match(haystack, '\cneedle')

                If {start} is given, the search starts from byte index
                {start} in a String or item {start} in a |List|.
                The result, however, is still the index counted from the
                first character/item.  Example:
                    :echo match("testing", "ing", 2)
                result is again "4".
                    :echo match("testing", "ing", 4)
                result is again "4".
                    :echo match("testing", "t", 2)
                result is "3".
                For a String, if {start} > 0 then it is like the string starts
                {start} bytes later, thus "^" will match at {start}.  Except
                when {count} is given, then it's like matches before the
                {start} byte are ignored (this is a bit complicated to keep it
                backwards compatible).
                For a String, if {start} < 0, it will be set to 0.  For a list
                the index is counted from the end.
                If {start} is out of range ({start} > strlen({expr}) for a
                String or {start} > len({expr}) for a |List|) -1 is returned.

                When {count} is given use the {count}'th match.  When a match
                is found in a String the search for the next one starts one
                character further.  Thus this example results in 1:
                    echo match("testing", "..", 0, 2)
                In a |List| the search continues in the next item.
                Note that when {count} is added the way {start} works changes,
                see above.

                See |pattern| for the patterns that are accepted.
                The 'ignorecase' option is used to set the ignore-caseness of
                the pattern.  'smartcase' is NOT used.  The matching is always
                done like 'magic' is set and 'cpoptions' is empty.


                            *matchadd()* *E798* *E799* *E801*
        matchadd({group}, {pattern}[, {priority}[, {id}]])
                Defines a pattern to be highlighted in the current window (a
                "match").  It will be highlighted with {group}.  Returns an
                identification number (ID), which can be used to delete the
                match using |matchdelete()|.

                The optional {priority} argument assigns a priority to the
                match.  A match with a high priority will have its
                highlighting overrule that of a match with a lower priority.
                A priority is specified as an integer (negative numbers are no
                exception).  If the {priority} argument is not specified, the
                default priority is 10.  The priority of 'hlsearch' is zero,
                hence all matches with a priority greater than zero will
                overrule it.  Syntax highlighting (see 'syntax') is a separate
                mechanism, and regardless of the chosen priority a match will
                always overrule syntax highlighting.

                The optional {id} argument allows the request for a specific
                match ID.  If a specified ID is already taken, an error
                message will appear and the match will not be added.  An ID
                is specified as a positive integer (zero excluded).  IDs 1, 2
                and 3 are reserved for |:match|, |:2match| and |:3match|,
                respectively.  If the {id} argument is not specified,
                |matchadd()| automatically chooses a free ID.

                The number of matches is not limited, as it is the case with
                the |:match| commands.

                Example:
                    :highlight MyGroup ctermbg=green guibg=green
                    :let m = matchadd("MyGroup", "TODO")
                Deletion of the pattern:
                    :call matchdelete(m)

                A list of matches defined by |matchadd()| and |:match| are
                available from |getmatches()|.  All matches can be deleted in
                one operation by |clearmatches()|.


        matcharg({nr})                          *matcharg()*
                Selects the {nr} match item, as set with a |:match|,
                |:2match| or |:3match| command.
                Return a |List| with two elements:
                    The name of the highlight group used
                    The pattern used.
                When {nr} is not 1, 2 or 3 returns an empty |List|.
                When there is no match item set returns ['', ''].
                This is useful to save and restore a |:match|.
                Highlighting matches using the |:match| commands are limited
                to three matches. |matchadd()| does not have this limitation.


        matchdelete({id})                  *matchdelete()* *E802* *E803*
                Deletes a match with ID {id} previously defined by |matchadd()|
                or one of the |:match| commands.  Returns 0 if successful,
                otherwise -1.  See example for |matchadd()|.  All matches can
                be deleted in one operation by |clearmatches()|.


        matchend({expr}, {pat}[, {start}[, {count}]])           *matchend()*
                Same as |match()|, but return the index of first character
                after the match.  Example:
                    :echo matchend("testing", "ing")
                results in "7".

                                    *strspn()* *strcspn()*
                Vim doesn't have a strspn() or strcspn() function, but you can
                do it with matchend():
                    :let span = matchend(line, '[a-zA-Z]')
                    :let span = matchend(line, '[^a-zA-Z]')
                Except that -1 is returned when there are no matches.

                The {start}, if given, has the same meaning as for |match()|.
                    :echo matchend("testing", "ing", 2)
                results in "7".
                    :echo matchend("testing", "ing", 5)
                result is "-1".
                When {expr} is a |List| the result is equal to |match()|.


        matchlist({expr}, {pat}[, {start}[, {count}]])          *matchlist()*
                Same as |match()|, but return a |List|.  The first item in the
                list is the matched string, same as what matchstr() would
                return.  Following items are submatches, like "\1", "\2", etc.
                in |:substitute|.  When an optional submatch didn't match an
                empty string is used.  Example:
                    echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
                Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
                When there is no match an empty list is returned.


        matchstr({expr}, {pat}[, {start}[, {count}]])           *matchstr()*
                Same as |match()|, but return the matched string.  Example:
                    :echo matchstr("testing", "ing")
                results in "ing".
                When there is no match "" is returned.
                The {start}, if given, has the same meaning as for |match()|.
                    :echo matchstr("testing", "ing", 2)
                results in "ing".
                    :echo matchstr("testing", "ing", 5)
                result is "".
                When {expr} is a |List| then the matching item is returned.
                The type isn't changed, it's not necessarily a String.


                                    *max()*
        max({list}) Return the maximum value of all items in {list}.
                If {list} is not a list or one of the items in {list} cannot
                be used as a Number this results in an error.
                An empty |List| results in zero.


                                    *min()*
        min({list}) Return the minimum value of all items in {list}.
                If {list} is not a list or one of the items in {list} cannot
                be used as a Number this results in an error.
                An empty |List| results in zero.


                                    *mkdir()* *E739*
        mkdir({name} [, {path} [, {prot}]])
                Create directory {name}.
                If {path} is "p" then intermediate directories are created as
                necessary.  Otherwise it must be "".
                If {prot} is given it is used to set the protection bits of
                the new directory.  The default is 0755 (rwxr-xr-x: r/w for
                the user readable for others).  Use 0700 to make it unreadable
                for others.  This is only used for the last part of {name}.
                Thus if you create /tmp/foo/bar then /tmp/foo will be created
                with 0755.
                Example:
                    :call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
                This function is not available in the |sandbox|.
                Not available on all systems.  To check use:
                    :if exists("*mkdir")


                                    *mode()*
        mode([expr])    Return a string that indicates the current mode.
                If [expr] is supplied and it evaluates to a non-zero Number or
                a non-empty String (|non-zero-arg|), then the full mode is
                returned, otherwise only the first letter is returned.  Note
                that " " and "0" are also non-empty strings.

                    n   Normal
                    no  Operator-pending
                    v   Visual by character
                    V   Visual by line
                    CTRL-V  Visual blockwise
                    s   Select by character
                    S   Select by line
                    CTRL-S  Select blockwise
                    i   Insert
                    R   Replace |R|
                    Rv  Virtual Replace |gR|
                    c   Command-line
                    cv  Vim Ex mode |gQ|
                    ce  Normal Ex mode |Q|
                    r   Hit-enter prompt
                    rm  The -- more -- prompt
                    r?  A |:confirm| query of some sort
                    !   Shell or external command is executing
                This is useful in the 'statusline' option or when used
                with |remote_expr()| In most other places it always returns
                "c" or "n".
                Also see |visualmode()|.


        mzeval({expr})                          *mzeval()*
                Evaluate MzScheme expression {expr} and return its result
                convert to Vim data structures.
                Numbers and strings are returned as they are.
                Pairs (including lists and improper lists) and vectors are
                returned as Vim |Lists|.
                Hash tables are represented as Vim |Dictionary| type with keys
                converted to strings.
                All other types are converted to string with display function.
                Examples:
                    :mz (define l (list 1 2 3))
                    :mz (define h (make-hash)) (hash-set! h "list" l)
                    :echo mzeval("l")
                    :echo mzeval("h")

                {only available when compiled with the |+mzscheme| feature}


        nextnonblank({lnum})                    *nextnonblank()*
                Return the line number of the first line at or below {lnum}
                that is not blank.  Example:
                    if getline(nextnonblank(1)) =~ "Java"
                When {lnum} is invalid or there is no non-blank line at or
                below it, zero is returned.
                See also |prevnonblank()|.


        nr2char({expr})                     *nr2char()*
                Return a string with a single character, which has the number
                value {expr}.  Examples:
                    nr2char(64)     returns "@"
                    nr2char(32)     returns " "
                The current 'encoding' is used.  Example for "utf-8":
                    nr2char(300)        returns I with bow character
                Note that a NUL character in the file is specified with
                nr2char(10), because NULs are represented with newline
                characters.  nr2char(0) is a real NUL and terminates the
                string, thus results in an empty string.


                                    *getpid()*
        getpid()    Return a Number which is the process ID of the Vim process.
                On Unix and MS-Windows this is a unique number, until Vim
                exits.  On MS-DOS it's always zero.


                                    *getpos()*
        getpos({expr})  Get the position for {expr}.  For possible values of {expr}
                see |line()|.
                The result is a |List| with four numbers:
                    [bufnum, lnum, col, off]
                "bufnum" is zero, unless a mark like '0 or 'A is used, then it
                is the buffer number of the mark.
                "lnum" and "col" are the position in the buffer.  The first
                column is 1.
                The "off" number is zero, unless 'virtualedit' is used.  Then
                it is the offset in screen columns from the start of the
                character.  E.g., a position within a <Tab> or after the last
                character.
                This can be used to save and restore the cursor position:
                    let save_cursor = getpos(".")
                    MoveTheCursorAround
                    call setpos('.', save_cursor)
                Also see |setpos()|.


        pathshorten({expr})                 *pathshorten()*
                Shorten directory names in the path {expr} and return the
                result.  The tail, the file name, is kept as-is.  The other
                components in the path are reduced to single letters.  Leading
                '~' and '.' characters are kept.  Example:
                    :echo pathshorten('~/.vim/autoload/myfile.vim')
                    ~/.v/a/myfile.vim 
                It doesn't matter if the path exists or not.


        pow({x}, {y})                       *pow()*
                Return the power of {x} to the exponent {y} as a |Float|.
                {x} and {y} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo pow(3, 3)
                    27.0
                    :echo pow(2, 16)
                    65536.0
                    :echo pow(32, 0.20)
                    2.0
                {only available when compiled with the |+float| feature}


        prevnonblank({lnum})                    *prevnonblank()*
                Return the line number of the first line at or above {lnum}
                that is not blank.  Example:
                    let ind = indent(prevnonblank(v:lnum - 1))
                When {lnum} is invalid or there is no non-blank line at or
                above it, zero is returned.
                Also see |nextnonblank()|.



        printf({fmt}, {expr1} ...)              *printf()*
                Return a String with {fmt}, where "%" items are replaced by
                the formatted form of their respective arguments.  Example:
                    printf("%4d: E%d %.30s", lnum, errno, msg)
                May result in:
                    "  99: E42 asdfasdfasdfasdfasdfasdfasdfas" 

                Often used items are:
                  %s    string
                  %6s   string right-aligned in 6 bytes
                  %.9s  string truncated to 9 bytes
                  %c    single byte
                  %d    decimal number
                  %5d   decimal number padded with spaces to 5 characters
                  %x    hex number
                  %04x  hex number padded with zeros to at least 4 characters
                  %X    hex number using upper case letters
                  %o    octal number
                  %f    floating point number in the form 123.456
                  %e    floating point number in the form 1.234e3
                  %E    floating point number in the form 1.234E3
                  %g    floating point number, as %f or %e depending on value
                  %G    floating point number, as %f or %E depending on value
                  %%    the % character itself

                Conversion specifications start with '%' and end with the
                conversion type.  All other characters are copied unchanged to
                the result.

                The "%" starts a conversion specification.  The following
                arguments appear in sequence:

                    %  [flags]  [field-width]  [.precision]  type

                flags
                    Zero or more of the following flags:

                    #         The value should be converted to an "alternate
                          form".  For c, d, and s conversions, this option
                          has no effect.  For o conversions, the precision
                          of the number is increased to force the first
                          character of the output string to a zero (except
                          if a zero value is printed with an explicit
                          precision of zero).
                          For x and X conversions, a non-zero result has
                          the string "0x" (or "0X" for X conversions)
                          prepended to it.

                    0 (zero)  Zero padding.  For all conversions the converted
                          value is padded on the left with zeros rather
                          than blanks.  If a precision is given with a
                          numeric conversion (d, o, x, and X), the 0 flag
                          is ignored.

                    -         A negative field width flag; the converted value
                          is to be left adjusted on the field boundary.
                          The converted value is padded on the right with
                          blanks, rather than on the left with blanks or
                          zeros.  A - overrides a 0 if both are given.

                    '' '' (space)  A blank should be left before a positive
                          number produced by a signed conversion (d).

                    +         A sign must always be placed before a number
                          produced by a signed conversion.  A + overrides
                          a space if both are used.

                field-width
                    An optional decimal digit string specifying a minimum
                    field width.  If the converted value has fewer bytes
                    than the field width, it will be padded with spaces on
                    the left (or right, if the left-adjustment flag has
                    been given) to fill out the field width.

                .precision
                    An optional precision, in the form of a period '.'
                    followed by an optional digit string.  If the digit
                    string is omitted, the precision is taken as zero.
                    This gives the minimum number of digits to appear for
                    d, o, x, and X conversions, or the maximum number of
                    bytes to be printed from a string for s conversions.
                    For floating point it is the number of digits after
                    the decimal point.

                type
                    A character that specifies the type of conversion to
                    be applied, see below.

                A field width or precision, or both, may be indicated by an
                asterisk '*' instead of a digit string.  In this case, a
                Number argument supplies the field width or precision.  A
                negative field width is treated as a left adjustment flag
                followed by a positive field width; a negative precision is
                treated as though it were missing.  Example:
                    :echo printf("%d: %.*s", nr, width, line)
                This limits the length of the text used from "line" to
                "width" bytes.

                The conversion specifiers and their meanings are:


                        *printf-d* *printf-o* *printf-x* *printf-X*
                doxX    The Number argument is converted to signed decimal
                    (d), unsigned octal (o), or unsigned hexadecimal (x
                    and X) notation.  The letters "abcdef" are used for
                    x conversions; the letters "ABCDEF" are used for X
                    conversions.
                    The precision, if any, gives the minimum number of
                    digits that must appear; if the converted value
                    requires fewer digits, it is padded on the left with
                    zeros.
                    In no case does a non-existent or small field width
                    cause truncation of a numeric field; if the result of
                    a conversion is wider than the field width, the field
                    is expanded to contain the conversion result.


                                    *printf-c*
                c   The Number argument is converted to a byte, and the
                    resulting character is written.


                                    *printf-s*
                s   The text of the String argument is used.  If a
                    precision is specified, no more bytes than the number
                    specified are used.


                                    *printf-f* *E807*
                f   The Float argument is converted into a string of the 
                    form 123.456.  The precision specifies the number of
                    digits after the decimal point.  When the precision is
                    zero the decimal point is omitted.  When the precision
                    is not specified 6 is used.  A really big number
                    (out of range or dividing by zero) results in "inf".
                    "0.0 / 0.0" results in "nan".
                    Example:
                        echo printf("%.2f", 12.115)
                        12.12
                    Note that roundoff depends on the system libraries.
                    Use |round()| when in doubt.


                                    *printf-e* *printf-E*
                e E The Float argument is converted into a string of the
                    form 1.234e+03 or 1.234E+03 when using 'E'.  The
                    precision specifies the number of digits after the
                    decimal point, like with 'f'.


                                    *printf-g* *printf-G*
                g G The Float argument is converted like with 'f' if the
                    value is between 0.001 (inclusive) and 10000000.0
                    (exclusive).  Otherwise 'e' is used for 'g' and 'E'
                    for 'G'.  When no precision is specified superfluous
                    zeroes and '+' signs are removed, except for the zero
                    immediately after the decimal point.  Thus 10000000.0
                    results in 1.0e7.


                                    *printf-%*
                %   A '%' is written.  No argument is converted.  The
                    complete conversion specification is "%%".

                When a Number argument is expected a String argument is also
                accepted and automatically converted.
                When a Float or String argument is expected a Number argument
                is also accepted and automatically converted.
                Any other argument type results in an error message.


                                    *E766* *E767*
                The number of {exprN} arguments must exactly match the number
                of "%" items.  If there are not sufficient or too many
                arguments an error is given.  Up to 18 arguments can be used.



        pumvisible()                        *pumvisible()*
                Returns non-zero when the popup menu is visible, zero
                otherwise.  See |ins-completion-menu|.
                This can be used to avoid some things that would remove the
                popup menu.


                                    *E726* *E727*

        range({expr} [, {max} [, {stride}]])                *range()*
                Returns a |List| with Numbers:
                - If only {expr} is specified: [0, 1, ..., {expr} - 1]
                - If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
                - If {stride} is specified: [{expr}, {expr} + {stride}, ...,
                  {max}] (increasing {expr} with {stride} each time, not
                  producing a value past {max}).
                When the maximum is one before the start the result is an
                empty list.  When the maximum is more than one before the
                start this is an error.
                Examples:
                    range(4)        " [0, 1, 2, 3]
                    range(2, 4)     " [2, 3, 4]
                    range(2, 9, 3)      " [2, 5, 8]
                    range(2, -2, -1)    " [2, 1, 0, -1, -2]
                    range(0)        " []
                    range(2, 0)     " error!


                                    *readfile()*
        readfile({fname} [, {binary} [, {max}]])
                Read file {fname} and return a |List|, each line of the file
                as an item.  Lines broken at NL characters.  Macintosh files
                separated with CR will result in a single long line (unless a
                NL appears somewhere).
                All NUL characters are replaced with a NL character.
                When {binary} is equal to "b" binary mode is used:
                - When the last line ends in a NL an extra empty list item is
                  added.
                - No CR characters are removed.
                Otherwise:
                - CR characters that appear before a NL are removed.
                - Whether the last line ends in a NL or not does not matter.
                - When 'encoding' is Unicode any UTF-8 byte order mark is
                  removed from the text.
                When {max} is given this specifies the maximum number of lines
                to be read.  Useful if you only want to check the first ten
                lines of a file:
                    :for line in readfile(fname, '', 10)
                    :  if line =~ 'Date' | echo line | endif
                    :endfor
                When {max} is negative -{max} lines from the end of the file
                are returned, or as many as there are.
                When {max} is zero the result is an empty list.
                Note that without {max} the whole file is read into memory.
                Also note that there is no recognition of encoding.  Read a
                file into a buffer if you need to.
                When the file can't be opened an error message is given and
                the result is an empty list.
                Also see |writefile()|.


        reltime([{start} [, {end}]])                *reltime()*
                Return an item that represents a time value.  The format of
                the item depends on the system.  It can be passed to
                |reltimestr()| to convert it to a string.
                Without an argument it returns the current time.
                With one argument is returns the time passed since the time
                specified in the argument.
                With two arguments it returns the time passed between {start}
                and {end}.
                The {start} and {end} arguments must be values returned by
                reltime().
                {only available when compiled with the |+reltime| feature}


        reltimestr({time})              *reltimestr()*
                Return a String that represents the time value of {time}.
                This is the number of seconds, a dot and the number of
                microseconds.  Example:
                    let start = reltime()
                    call MyFunction()
                    echo reltimestr(reltime(start))
                Note that overhead for the commands will be added to the time.
                The accuracy depends on the system.
                Leading spaces are used to make the string align nicely.  You
                can use split() to remove it.
                    echo split(reltimestr(reltime(start)))[0]
                Also see |profiling|.
                {only available when compiled with the |+reltime| feature}


                                    *remote_expr()* *E449*
        remote_expr({server}, {string} [, {idvar}])
                Send the {string} to {server}.  The string is sent as an
                expression and the result is returned after evaluation.
                The result must be a String or a |List|.  A |List| is turned
                into a String by joining the items with a line break in
                between (not at the end), like with join(expr, "\n").
                If {idvar} is present, it is taken as the name of a
                variable and a {serverid} for later use with
                remote_read() is stored there.
                See also |clientserver| |RemoteReply|.
                This function is not available in the |sandbox|.
                {only available when compiled with the |+clientserver| feature}
                Note: Any errors will cause a local error message to be issued
                and the result will be the empty string.
                Examples:
                    :echo remote_expr("gvim", "2+2")
                    :echo remote_expr("gvim1", "b:current_syntax")



        remote_foreground({server})             *remote_foreground()*
                Move the Vim server with the name {server} to the foreground.
                This works like:
                    remote_expr({server}, "foreground()")
                Except that on Win32 systems the client does the work, to work
                around the problem that the OS doesn't always allow the server
                to bring itself to the foreground.
                Note: This does not restore the window if it was minimized,
                like foreground() does.
                This function is not available in the |sandbox|.
                {only in the Win32, Athena, Motif and GTK GUI versions and the
                Win32 console version}



        remote_peek({serverid} [, {retvar}])        *remote_peek()*
                Returns a positive number if there are available strings
                from {serverid}.  Copies any reply string into the variable
                {retvar} if specified.  {retvar} must be a string with the
                name of a variable.
                Returns zero if none are available.
                Returns -1 if something is wrong.
                See also |clientserver|.
                This function is not available in the |sandbox|.
                {only available when compiled with the |+clientserver| feature}
                Examples:
                    :let repl = ""
                    :echo "PEEK: ".remote_peek(id, "repl").": ".repl


        remote_read({serverid})             *remote_read()*
                Return the oldest available reply from {serverid} and consume
                it.  It blocks until a reply is available.
                See also |clientserver|.
                This function is not available in the |sandbox|.
                {only available when compiled with the |+clientserver| feature}
                Example:
                    :echo remote_read(id)


                                    *remote_send()* *E241*
        remote_send({server}, {string} [, {idvar}])
                Send the {string} to {server}.  The string is sent as input
                keys and the function returns immediately.  At the Vim server
                the keys are not mapped |:map|.
                If {idvar} is present, it is taken as the name of a variable
                and a {serverid} for later use with remote_read() is stored
                there.
                See also |clientserver| |RemoteReply|.
                This function is not available in the |sandbox|.
                {only available when compiled with the |+clientserver| feature}
                Note: Any errors will be reported in the server and may mess
                up the display.
                Examples:
                :echo remote_send("gvim", ":DropAndReply ".file, "serverid").
                 \ remote_read(serverid)

                :autocmd NONE RemoteReply *
                 \ echo remote_read(expand("<amatch>"))
                :echo remote_send("gvim", ":sleep 10 | echo ".
                 \ 'server2client(expand("<client>"), "HELLO")<CR>')


        remove({list}, {idx} [, {end}])             *remove()*
                Without {end}: Remove the item at {idx} from |List| {list} and
                return the item.
                With {end}: Remove items from {idx} to {end} (inclusive) and
                return a List with these items.  When {idx} points to the same
                item as {end} a list with one item is returned.  When {end}
                points to an item before {idx} this is an error.
                See |list-index| for possible values of {idx} and {end}.
                Example:
                    :echo "last item: " . remove(mylist, -1)
                    :call remove(mylist, 0, 9)
        remove({dict}, {key})
                Remove the entry from {dict} with key {key}.  Example:
                    :echo "removed " . remove(dict, "one")
                If there is no {key} in {dict} this is an error.

                Use |delete()| to remove a file.


        rename({from}, {to})                    *rename()*
                Rename the file by the name {from} to the name {to}.  This
                should also work to move files across file systems.  The
                result is a Number, which is 0 if the file was renamed
                successfully, and non-zero when the renaming failed.
                NOTE: If {to} exists it is overwritten without warning.
                This function is not available in the |sandbox|.


        repeat({expr}, {count})                 *repeat()*
                Repeat {expr} {count} times and return the concatenated
                result.  Example:
                    :let separator = repeat('-', 80)
                When {count} is zero or negative the result is empty.
                When {expr} is a |List| the result is {expr} concatenated
                {count} times.  Example:
                    :let longlist = repeat(['a', 'b'], 3)
                Results in ['a', 'b', 'a', 'b', 'a', 'b'].



        resolve({filename})                 *resolve()* *E655*
                On MS-Windows, when {filename} is a shortcut (a .lnk file),
                returns the path the shortcut points to in a simplified form.
                On Unix, repeat resolving symbolic links in all path
                components of {filename} and return the simplified result.
                To cope with link cycles, resolving of symbolic links is
                stopped after 100 iterations.
                On other systems, return the simplified {filename}.
                The simplification step is done as by |simplify()|.
                resolve() keeps a leading path component specifying the
                current directory (provided the result is still a relative
                path name) and also keeps a trailing path separator.


                                    *reverse()*
        reverse({list}) Reverse the order of items in {list} in-place.  Returns
                {list}.
                If you want a list to remain unmodified make a copy first:
                    :let revlist = reverse(copy(mylist))


        round({expr})                           *round()*
                Round off {expr} to the nearest integral value and return it
                as a |Float|.  If {expr} lies halfway between two integral
                values, then use the larger one (away from zero).
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    echo round(0.456)
                    0.0 
                    echo round(4.5)
                    5.0
                    echo round(-4.5)
                    -5.0
                {only available when compiled with the |+float| feature}



        search({pattern} [, {flags} [, {stopline} [, {timeout}]]])  *search()*
                Search for regexp pattern {pattern}.  The search starts at the
                cursor position (you can use |cursor()| to set it).

                {flags} is a String, which can contain these character flags:
                'b' search backward instead of forward
                'c' accept a match at the cursor position
                'e' move to the End of the match
                'n' do Not move the cursor
                'p' return number of matching sub-pattern (see below)
                's' set the '' mark at the previous location of the cursor
                'w' wrap around the end of the file
                'W' don't wrap around the end of the file
                If neither 'w' or 'W' is given, the 'wrapscan' option applies.

                If the 's' flag is supplied, the '' mark is set, only if the
                cursor is moved. The 's' flag cannot be combined with the 'n'
                flag.

                'ignorecase', 'smartcase' and 'magic' are used.

                When the {stopline} argument is given then the search stops
                after searching this line.  This is useful to restrict the
                search to a range of lines.  Examples:
                    let match = search('(', 'b', line("w0"))
                    let end = search('END', '', line("w$"))
                When {stopline} is used and it is not zero this also implies
                that the search does not wrap around the end of the file.
                A zero value is equal to not giving the argument.

                When the {timeout} argument is given the search stops when
                more than this many milli seconds have passed.  Thus when
                {timeout} is 500 the search stops after half a second.
                The value must not be negative.  A zero value is like not
                giving the argument.
                {only available when compiled with the |+reltime| feature}

                If there is no match a 0 is returned and the cursor doesn't
                move.  No error message is given.
                When a match has been found its line number is returned.

                                    *search()-sub-match*
                With the 'p' flag the returned value is one more than the
                first sub-match in \(\).  One if none of them matched but the
                whole pattern did match.
                To get the column number too use |searchpos()|.

                The cursor will be positioned at the match, unless the 'n'
                flag is used.

                Example (goes over all files in the argument list):
                    :let n = 1
                    :while n <= argc()      " loop over all files in arglist
                    :  exe "argument " . n
                    :  " start at the last char in the file and wrap for the
                    :  " first search to find match at start of file
                    :  normal G$
                    :  let flags = "w"
                    :  while search("foo", flags) > 0
                    :    s/foo/bar/g
                    :    let flags = "W"
                    :  endwhile
                    :  update           " write the file if modified
                    :  let n = n + 1
                    :endwhile

                Example for using some flags:
                    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
                This will search for the keywords "if", "else", and "endif"
                under or after the cursor.  Because of the 'p' flag, it
                returns 1, 2, or 3 depending on which keyword is found, or 0
                if the search fails.  With the cursor on the first word of the
                line:
                    if (foo == 0) | let foo = foo + 1 | endif 
                the function returns 1.  Without the 'c' flag, the function
                finds the "endif" and returns 3.  The same thing happens
                without the 'e' flag if the cursor is on the "f" of "if".
                The 'n' flag tells the function not to move the cursor.



        searchdecl({name} [, {global} [, {thisblock}]])         *searchdecl()*
                Search for the declaration of {name}.

                With a non-zero {global} argument it works like |gD|, find
                first match in the file.  Otherwise it works like |gd|, find
                first match in the function.

                With a non-zero {thisblock} argument matches in a {} block
                that ends before the cursor position are ignored.  Avoids
                finding variable declarations only valid in another scope.

                Moves the cursor to the found match.
                Returns zero for success, non-zero for failure.
                Example:
                    if searchdecl('myvar') == 0
                       echo getline('.')
                    endif


                                    *searchpair()*
        searchpair({start}, {middle}, {end} [, {flags} [, {skip}
                        [, {stopline} [, {timeout}]]]])
                Search for the match of a nested start-end pair.  This can be
                used to find the "endif" that matches an "if", while other
                if/endif pairs in between are ignored.
                The search starts at the cursor.  The default is to search
                forward, include 'b' in {flags} to search backward.
                If a match is found, the cursor is positioned at it and the
                line number is returned.  If no match is found 0 or -1 is
                returned and the cursor doesn't move.  No error message is
                given.

                {start}, {middle} and {end} are patterns, see |pattern|.  They
                must not contain \( \) pairs.  Use of \%( \) is allowed.  When
                {middle} is not empty, it is found when searching from either
                direction, but only when not in a nested start-end pair.  A
                typical use is:
                    searchpair('\<if\>', '\<else\>', '\<endif\>')
                By leaving {middle} empty the "else" is skipped.

                {flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
                |search()|.  Additionally:
                'r' Repeat until no more matches found; will find the
                    outer pair.  Implies the 'W' flag.
                'm' Return number of matches instead of line number with
                    the match; will be > 1 when 'r' is used.
                Note: it's nearly always a good idea to use the 'W' flag, to
                avoid wrapping around the end of the file.

                When a match for {start}, {middle} or {end} is found, the
                {skip} expression is evaluated with the cursor positioned on
                the start of the match.  It should return non-zero if this
                match is to be skipped.  E.g., because it is inside a comment
                or a string.
                When {skip} is omitted or empty, every match is accepted.
                When evaluating {skip} causes an error the search is aborted
                and -1 returned.

                For {stopline} and {timeout} see |search()|.

                The value of 'ignorecase' is used.  'magic' is ignored, the
                patterns are used like it's on.

                The search starts exactly at the cursor.  A match with
                {start}, {middle} or {end} at the next character, in the
                direction of searching, is the first one found.  Example:
                    if 1
                      if 2
                      endif 2
                    endif 1
                When starting at the "if 2", with the cursor on the "i", and
                searching forwards, the "endif 2" is found.  When starting on
                the character just before the "if 2", the "endif 1" will be
                found.  That's because the "if 2" will be found first, and
                then this is considered to be a nested if/endif from "if 2" to
                "endif 2".
                When searching backwards and {end} is more than one character,
                it may be useful to put "\zs" at the end of the pattern, so
                that when the cursor is inside a match with the end it finds
                the matching start.

                Example, to find the "endif" command in a Vim script:

            :echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
                    \ 'getline(".") =~ "^\\s*\""')

                The cursor must be at or after the "if" for which a match is
                to be found.  Note that single-quote strings are used to avoid
                having to double the backslashes.  The skip expression only
                catches comments at the start of a line, not after a command.
                Also, a word "en" or "if" halfway a line is considered a
                match.
                Another example, to search for the matching "{" of a "}":

            :echo searchpair('{', '', '}', 'bW')

                This works when the cursor is at or before the "}" for which a
                match is to be found.  To reject matches that syntax
                highlighting recognized as strings:

            :echo searchpair('{', '', '}', 'bW',
                 \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')


                                    *searchpairpos()*
        searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
                        [, {stopline} [, {timeout}]]]])
                Same as |searchpair()|, but returns a |List| with the line and
                column position of the match. The first element of the |List|
                is the line number and the second element is the byte index of
                the column position of the match.  If no match is found,
                returns [0, 0].

                    :let [lnum,col] = searchpairpos('{', '', '}', 'n')

                See |match-parens| for a bigger and more useful example.


        searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])   *searchpos()*
                Same as |search()|, but returns a |List| with the line and
                column position of the match. The first element of the |List|
                is the line number and the second element is the byte index of
                the column position of the match. If no match is found,
                returns [0, 0].
                Example:
            :let [lnum, col] = searchpos('mypattern', 'n')

                When the 'p' flag is given then there is an extra item with
                the sub-pattern match number |search()-sub-match|.  Example:
            :let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
                In this example "submatch" is 2 when a lowercase letter is
                found |/\l|, 3 when an uppercase letter is found |/\u|.


        server2client( {clientid}, {string})            *server2client()*
                Send a reply string to {clientid}.  The most recent {clientid}
                that sent a string can be retrieved with expand("<client>").
                {only available when compiled with the |+clientserver| feature}
                Note:
                This id has to be stored before the next command can be
                received.  I.e. before returning from the received command and
                before calling any commands that waits for input.
                See also |clientserver|.
                Example:
                    :echo server2client(expand("<client>"), "HELLO")


        serverlist()                    *serverlist()*
                Return a list of available server names, one per line.
                When there are no servers or the information is not available
                an empty string is returned.  See also |clientserver|.
                {only available when compiled with the |+clientserver| feature}
                Example:
                    :echo serverlist()


        setbufvar({expr}, {varname}, {val})         *setbufvar()*
                Set option or local variable {varname} in buffer {expr} to
                {val}.
                This also works for a global or local window option, but it
                doesn't work for a global or local window variable.
                For a local window option the global value is unchanged.
                For the use of {expr}, see |bufname()| above.
                Note that the variable name without "b:" must be used.
                Examples:
                    :call setbufvar(1, "&mod", 1)
                    :call setbufvar("todo", "myvar", "foobar")
                This function is not available in the |sandbox|.


        setcmdpos({pos})                    *setcmdpos()*
                Set the cursor position in the command line to byte position
                {pos}.  The first position is 1.
                Use |getcmdpos()| to obtain the current position.
                Only works while editing the command line, thus you must use
                |c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
                |c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
                set after the command line is set to the expression.  For
                |c_CTRL-R_=| it is set after evaluating the expression but
                before inserting the resulting text.
                When the number is too big the cursor is put at the end of the
                line.  A number smaller than one has undefined results.
                Returns 0 when successful, 1 when not editing the command
                line.


        setline({lnum}, {text})                 *setline()*
                Set line {lnum} of the current buffer to {text}.
                {lnum} is used like with |getline()|.
                When {lnum} is just below the last line the {text} will be
                added as a new line.
                If this succeeds, 0 is returned.  If this fails (most likely
                because {lnum} is invalid) 1 is returned.  Example:
                    :call setline(5, strftime("%c"))
                When {text} is a |List| then line {lnum} and following lines
                will be set to the items in the list.  Example:
                    :call setline(5, ['aaa', 'bbb', 'ccc'])
                This is equivalent to:
                    :for [n, l] in [[5, 6, 7], ['aaa', 'bbb', 'ccc']]
                    :  call setline(n, l)
                    :endfor
                Note: The '[ and '] marks are not set.


        setloclist({nr}, {list} [, {action}])           *setloclist()*
                Create or replace or add to the location list for window {nr}.
                When {nr} is zero the current window is used. For a location
                list window, the displayed location list is modified.  For an
                invalid window number {nr}, -1 is returned.
                Otherwise, same as |setqflist()|.
                Also see |location-list|.


        setmatches({list})                  *setmatches()*
                Restores a list of matches saved by |getmatches()|.  Returns 0
                if successful, otherwise -1.  All current matches are cleared
                before the list is restored.  See example for |getmatches()|.


                                    *setpos()*
        setpos({expr}, {list})
                Set the position for {expr}.  Possible values:
                    .   the cursor
                    'x  mark x

                {list} must be a |List| with four numbers:
                    [bufnum, lnum, col, off]

                "bufnum" is the buffer number.  Zero can be used for the
                current buffer.  Setting the cursor is only possible for
                the current buffer.  To set a mark in another buffer you can
                use the |bufnr()| function to turn a file name into a buffer
                number.
                Does not change the jumplist.

                "lnum" and "col" are the position in the buffer.  The first
                column is 1.  Use a zero "lnum" to delete a mark.  If "col" is
                smaller than 1 then 1 is used.

                The "off" number is only used when 'virtualedit' is set. Then
                it is the offset in screen columns from the start of the
                character.  E.g., a position within a <Tab> or after the last
                character.

                Returns 0 when the position could be set, -1 otherwise.
                An error message is given if {expr} is invalid.

                Also see |getpos()|

                This does not restore the preferred column for moving
                vertically.  See |winrestview()| for that.



        setqflist({list} [, {action}])              *setqflist()*
                Create or replace or add to the quickfix list using the items
                in {list}.  Each item in {list} is a dictionary.
                Non-dictionary items in {list} are ignored.  Each dictionary
                item can contain the following entries:

                    bufnr   buffer number; must be the number of a valid
                        buffer
                    filename    name of a file; only used when "bufnr" is not
                        present or it is invalid.
                    lnum    line number in the file
                    pattern search pattern used to locate the error
                    col     column number
                    vcol    when non-zero: "col" is visual column
                        when zero: "col" is byte index
                    nr      error number
                    text    description of the error
                    type    single-character error type, 'E', 'W', etc.

                The "col", "vcol", "nr", "type" and "text" entries are
                optional.  Either "lnum" or "pattern" entry can be used to
                locate a matching error line.
                If the "filename" and "bufnr" entries are not present or
                neither the "lnum" or "pattern" entries are present, then the
                item will not be handled as an error line.
                If both "pattern" and "lnum" are present then "pattern" will
                be used.
                If you supply an empty {list}, the quickfix list will be
                cleared.
                Note that the list is not exactly the same as what
                |getqflist()| returns.

                If {action} is set to 'a', then the items from {list} are
                added to the existing quickfix list. If there is no existing
                list, then a new list is created. If {action} is set to 'r',
                then the items from the current quickfix list are replaced
                with the items from {list}. If {action} is not present or is
                set to '' '', then a new list is created.

                Returns zero for success, -1 for failure.

                This function can be used to create a quickfix list
                independent of the 'errorformat' setting.  Use a command like
                ":cc 1" to jump to the first position.



                                    *setreg()*
        setreg({regname}, {value} [,{options}])
                Set the register {regname} to {value}.
                If {options} contains "a" or {regname} is upper case,
                then the value is appended.
                {options} can also contain a register type specification:
                    "c" or "v"        |characterwise| mode
                    "l" or "V"        |linewise| mode
                    "b" or "<CTRL-V>" |blockwise-visual| mode
                If a number immediately follows "b" or "<CTRL-V>" then this is
                used as the width of the selection - if it is not specified
                then the width of the block is set to the number of characters
                in the longest line (counting a <Tab> as 1 character).

                If {options} contains no register settings, then the default
                is to use character mode unless {value} ends in a <NL>.
                Setting the '=' register is not possible.
                Returns zero for success, non-zero for failure.

                Examples:
                    :call setreg(v:register, @*)
                    :call setreg('*', @%, 'ac')
                    :call setreg('a', "1\n2\n3", 'b5')

                This example shows using the functions to save and restore a
                register.
                    :let var_a = getreg('a', 1)
                    :let var_amode = getregtype('a')
                        ....
                    :call setreg('a', var_a, var_amode)

                You can also change the type of a register by appending
                nothing:
                    :call setreg('a', '', 'al')


        settabvar({tabnr}, {varname}, {val})            *settabvar()*
                Set tab-local variable {varname} to {val} in tab page {tabnr}.
                |t:var|
                Note that the variable name without "t:" must be used.
                Tabs are numbered starting with one.
                Vim briefly goes to the tab page {tabnr}, this may trigger
                TabLeave and TabEnter autocommands.
                This function is not available in the |sandbox|.


        settabwinvar({tabnr}, {winnr}, {varname}, {val})    *settabwinvar()*
                Set option or local variable {varname} in window {winnr} to
                {val}.
                Tabs are numbered starting with one.  For the current tabpage
                use |setwinvar()|.
                When {winnr} is zero the current window is used.
                This also works for a global or local buffer option, but it
                doesn't work for a global or local buffer variable.
                For a local buffer option the global value is unchanged.
                Note that the variable name without "w:" must be used.
                Vim briefly goes to the tab page {tabnr}, this may trigger
                TabLeave and TabEnter autocommands.
                Examples:
                    :call settabwinvar(1, 1, "&list", 0)
                    :call settabwinvar(3, 2, "myvar", "foobar")
                This function is not available in the |sandbox|.


        setwinvar({nr}, {varname}, {val})           *setwinvar()*
                Like |settabwinvar()| for the current tab page.
                Examples:
                    :call setwinvar(1, "&list", 0)
                    :call setwinvar(2, "myvar", "foobar")


        shellescape({string} [, {special}])         *shellescape()*
                Escape {string} for use as a shell command argument.
                On MS-Windows and MS-DOS, when 'shellslash' is not set, it
                will enclose {string} in double quotes and double all double
                quotes within {string}.
                For other systems, it will enclose {string} in single quotes
                and replace all "'"' with "'\''"'.
                When the {special} argument is present and it's a non-zero
                Number or a non-empty String (|non-zero-arg|), then special
                items such as "!", "%", "#" and "<cword>" will be preceded by
                a backslash.  This backslash will be removed again by the |:!|
                command.
                The "!" character will be escaped (again with a |non-zero-arg|
                {special}) when 'shell' contains "csh" in the tail.  That is
                because for csh and tcsh "!" is used for history replacement
                even when inside single quotes.
                The <NL> character is also escaped.  With a |non-zero-arg|
                {special} and 'shell' containing "csh" in the tail it's
                escaped a second time.
                Example of use with a |:!| command:
                    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
                This results in a directory listing for the file under the
                cursor.  Example of use with YXXYsystem()|:
                    :call system("chmod +w -- " . shellescape(expand("%")))



        simplify({filename})                    *simplify()*
                Simplify the file name as much as possible without changing
                the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
                Unix) are not resolved.  If the first path component in
                {filename} designates the current directory, this will be
                valid for the result as well.  A trailing path separator is
                not removed either.
                Example:
                    simplify("./dir/.././/file/") == "./file/"
                Note: The combination "dir/.." is only removed if "dir" is
                a searchable directory or does not exist.  On Unix, it is also
                removed when "dir" is a symbolic link within the same
                directory.  In order to resolve all the involved symbolic
                links before simplifying the path name, use |resolve()|.



        sin({expr})                     *sin()*
                Return the sine of {expr}, measured in radians, as a |Float|.
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo sin(100)
                    -0.506366
                    :echo sin(-4.01)
                    0.763301
                {only available when compiled with the |+float| feature}



        sinh({expr})                        *sinh()*
                Return the hyperbolic sine of {expr} as a |Float| in the range
                [-inf, inf].
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo sinh(0.5)
                    0.521095
                    :echo sinh(-0.9)
                    -1.026517
                {only available when compiled with the |+float| feature}



        sort({list} [, {func}])                 *sort()* *E702*
                Sort the items in {list} in-place.  Returns {list}.  If you
                want a list to remain unmodified make a copy first:
                    :let sortedlist = sort(copy(mylist))
                Uses the string representation of each item to sort on.
                Numbers sort after Strings, |Lists| after Numbers.
                For sorting text in the current buffer use |:sort|.
                When {func} is given and it is one then case is ignored.
                When {func} is a |Funcref| or a function name, this function
                is called to compare items.  The function is invoked with two
                items as argument and must return zero if they are equal, 1 or
                bigger if the first one sorts after the second one, -1 or
                smaller if the first one sorts before the second one.
                Example:
                    func MyCompare(i1, i2)
                       return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
                    endfunc
                    let sortedlist = sort(mylist, "MyCompare")
                A shorter compare version for this specific simple case, which
                ignores overflow:
                    func MyCompare(i1, i2)
                       return a:i1 - a:i2
                    endfunc


                                    *soundfold()*
        soundfold({word})
                Return the sound-folded equivalent of {word}.  Uses the first
                language in 'spelllang' for the current window that supports
                soundfolding.  'spell' must be set.  When no sound folding is
                possible the {word} is returned unmodified.
                This can be used for making spelling suggestions.  Note that
                the method can be quite slow.


                                    *spellbadword()*
        spellbadword([{sentence}])
                Without argument: The result is the badly spelled word under
                or after the cursor.  The cursor is moved to the start of the
                bad word.  When no bad word is found in the cursor line the
                result is an empty string and the cursor doesn't move.

                With argument: The result is the first word in {sentence} that
                is badly spelled.  If there are no spelling mistakes the
                result is an empty string.

                The return value is a list with two items:
                - The badly spelled word or an empty string.
                - The type of the spelling error:
                    "bad"       spelling mistake
                    "rare"      rare word
                    "local"     word only valid in another region
                    "caps"      word should start with Capital
                Example:
                    echo spellbadword("the quik brown fox")
                    ['quik', 'bad'] 

                The spelling information for the current window is used.  The
                'spell' option must be set and the value of 'spelllang' is
                used.


                                    *spellsuggest()*
        spellsuggest({word} [, {max} [, {capital}]])
                Return a |List| with spelling suggestions to replace {word}.
                When {max} is given up to this number of suggestions are
                returned.  Otherwise up to 25 suggestions are returned.

                When the {capital} argument is given and it's non-zero only
                suggestions with a leading capital will be given.  Use this
                after a match with 'spellcapcheck'.

                {word} can be a badly spelled word followed by other text.
                This allows for joining two words that were split.  The
                suggestions also include the following text, thus you can
                replace a line.

                {word} may also be a good word.  Similar words will then be
                returned.  {word} itself is not included in the suggestions,
                although it may appear capitalized.

                The spelling information for the current window is used.  The
                'spell' option must be set and the values of 'spelllang' and
                'spellsuggest' are used.



        split({expr} [, {pattern} [, {keepempty}]])         *split()*
                Make a |List| out of {expr}.  When {pattern} is omitted or
                empty each white-separated sequence of characters becomes an
                item.
                Otherwise the string is split where {pattern} matches,
                removing the matched characters.
                When the first or last item is empty it is omitted, unless the
                {keepempty} argument is given and it's non-zero.
                Other empty items are kept when {pattern} matches at least one
                character or when {keepempty} is non-zero.
                Example:
                    :let words = split(getline('.'), '\W\+')
                To split a string in individual characters:
                    :for c in split(mystring, '\zs')
                If you want to keep the separator you can also use '\zs':
                    :echo split('abc:def:ghi', ':\zs')
                    ['abc:', 'def:', 'ghi'] 
                Splitting a table where the first element can be empty:
                    :let items = split(line, ':', 1)
                The opposite function is |join()|.



        sqrt({expr})                        *sqrt()*
                Return the non-negative square root of Float {expr} as a
                |Float|.
                {expr} must evaluate to a |Float| or a |Number|.  When {expr}
                is negative the result is NaN (Not a Number).
                Examples:
                    :echo sqrt(100)
                    10.0
                    :echo sqrt(-4.01)
                    nan
                "nan" may be different, it depends on system libraries.
                {only available when compiled with the |+float| feature}



        str2float( {expr})                  *str2float()*
                Convert String {expr} to a Float.  This mostly works the same
                as when using a floating point number in an expression, see
                |floating-point-format|.  But it's a bit more permissive.
                E.g., "1e40" is accepted, while in an expression you need to
                write "1.0e40".
                Text after the number is silently ignored.
                The decimal point is always '.', no matter what the locale is
                set to.  A comma ends the number: "12,345.67" is converted to
                12.0.  You can strip out thousands separators with
                YXXYsubstitute()|:
                    let f = str2float(substitute(text, ',', '', 'g'))
                {only available when compiled with the |+float| feature}



        str2nr( {expr} [, {base}])              *str2nr()*
                Convert string {expr} to a number.
                {base} is the conversion base, it can be 8, 10 or 16.
                When {base} is omitted base 10 is used.  This also means that
                a leading zero doesn't cause octal conversion to be used, as
                with the default String to Number conversion.
                When {base} is 16 a leading "0x" or "0X" is ignored.  With a
                different base the result will be zero.
                Text after the number is silently ignored.



        strchars({expr})                    *strchars()*
                The result is a Number, which is the number of characters
                String {expr} occupies.  Composing characters are counted
                separately.
                Also see |strlen()|, |strdisplaywidth()| and |strwidth()|.


        strdisplaywidth({expr}[, {col}])            *strdisplaywidth()*
                The result is a Number, which is the number of display cells
                String {expr} occupies on the screen.
                When {col} is omitted zero is used.  Otherwise it is the
                screen column where to start.  This matters for Tab
                characters.
                The option settings of the current window are used.  This
                matters for anything that's displayed differently, such as
                'tabstop' and 'display'.
                When {expr} contains characters with East Asian Width Class
                Ambiguous, this function's return value depends on 'ambiwidth'.
                Also see |strlen()|, |strwidth()| and |strchars()|.


        strftime({format} [, {time}])               *strftime()*
                The result is a String, which is a formatted date and time, as
                specified by the {format} string.  The given {time} is used,
                or the current time if no time is given.  The accepted
                {format} depends on your system, thus this is not portable!
                See the manual page of the C function strftime() for the
                format.  The maximum length of the result is 80 characters.
                See also |localtime()| and |getftime()|.
                The language can be changed with the |:language| command.
                Examples:
                  :echo strftime("%c")         Sun Apr 27 11:49:23 1997
                  :echo strftime("%Y %b %d %X")    1997 Apr 27 11:53:25
                  :echo strftime("%y%m%d %T")      970427 11:53:55
                  :echo strftime("%H:%M")      11:55
                  :echo strftime("%c", getftime("file.c"))
                                   Show mod time of file.c.
                Not available on all systems.  To check use:
                    :if exists("*strftime")


        stridx({haystack}, {needle} [, {start}])        *stridx()*
                The result is a Number, which gives the byte index in
                {haystack} of the first occurrence of the String {needle}.
                If {start} is specified, the search starts at index {start}.
                This can be used to find a second match:
                    :let colon1 = stridx(line, ":")
                    :let colon2 = stridx(line, ":", colon1 + 1)
                The search is done case-sensitive.
                For pattern searches use |match()|.
                -1 is returned if the {needle} does not occur in {haystack}.
                See also |strridx()|.
                Examples:
                  :echo stridx("An Example", "Example")      3
                  :echo stridx("Starting point", "Start")    0
                  :echo stridx("Starting point", "start")   -1

                                *strstr()* *strchr()*
                stridx() works similar to the C function strstr().  When used
                with a single character it works similar to strchr().


                                    *string()*
        string({expr})  Return {expr} converted to a String.  If {expr} is a Number,
                Float, String or a composition of them, then the result can be
                parsed back with |eval()|.
                    {expr} type result 
                    String      'string'
                    Number      123
                    Float       123.123456 or 1.123456e8
                    Funcref     function('name')
                    List        [item, item]
                    Dictionary  {key: value, key: value}
                Note that in String values the '' character is doubled.
                Also see |strtrans()|.


                                    *strlen()*
        strlen({expr})  The result is a Number, which is the length of the String
                {expr} in bytes.
                If you want to count the number of multi-byte characters (not
                counting composing characters) use something like this:

                    :let len = strlen(substitute(str, ".", "x", "g"))

                If the argument is a Number it is first converted to a String.
                For other types an error is given.
                Also see |len()|, |strchars()|, |strdisplaywidth()| and
                |strwidth()|.


        strpart({src}, {start}[, {len}])            *strpart()*
                The result is a String, which is part of {src}, starting from
                byte {start}, with the byte length {len}.
                When non-existing bytes are included, this doesn't result in
                an error, the bytes are simply omitted.
                If {len} is missing, the copy continues from {start} till the
                end of the {src}.
                    strpart("abcdefg", 3, 2)    == "de"
                    strpart("abcdefg", -2, 4)   == "ab"
                    strpart("abcdefg", 5, 4)    == "fg"
                    strpart("abcdefg", 3)       == "defg"
                Note: To get the first character, {start} must be 0.  For
                example, to get three bytes under and after the cursor:
                    strpart(getline("."), col(".") - 1, 3)


        strridx({haystack}, {needle} [, {start}])           *strridx()*
                The result is a Number, which gives the byte index in
                {haystack} of the last occurrence of the String {needle}.
                When {start} is specified, matches beyond this index are
                ignored.  This can be used to find a match before a previous
                match:
                    :let lastcomma = strridx(line, ",")
                    :let comma2 = strridx(line, ",", lastcomma - 1)
                The search is done case-sensitive.
                For pattern searches use |match()|.
                -1 is returned if the {needle} does not occur in {haystack}.
                If the {needle} is empty the length of {haystack} is returned.
                See also |stridx()|.  Examples:
                  :echo strridx("an angry armadillo", "an")      3

                                    *strrchr()*
                When used with a single character it works similar to the C
                function strrchr().


        strtrans({expr})                    *strtrans()*
                The result is a String, which is {expr} with all unprintable
                characters translated into printable characters |'isprint'|.
                Like they are shown in a window.  Example:
                    echo strtrans(@a)
                This displays a newline in register a as "^@" instead of
                starting a new line.


        strwidth({expr})                    *strwidth()*
                The result is a Number, which is the number of display cells
                String {expr} occupies.  A Tab character is counted as one
                cell, alternatively use |strdisplaywidth()|.
                When {expr} contains characters with East Asian Width Class
                Ambiguous, this function's return value depends on 'ambiwidth'.
                Also see |strlen()|, |strdisplaywidth()| and |strchars()|.


        submatch({nr})                      *submatch()*
                Only for an expression in a |:substitute| command.  Returns
                the {nr}'th submatch of the matched text.  When {nr} is 0
                the whole matched text is returned.
                Example:
                    :s/\d\+/\=submatch(0) + 1/
                This finds the first number in the line and adds one to it.
                A line break is included as a newline character.


        substitute({expr}, {pat}, {sub}, {flags})       *substitute()*
                The result is a String, which is a copy of {expr}, in which
                the first match of {pat} is replaced with {sub}.  This works
                like the ":substitute" command (without any flags).  But the
                matching with {pat} is always done like the 'magic' option is
                set and 'cpoptions' is empty (to make scripts portable).
                'ignorecase' is still relevant.  'smartcase' is not used.
                See |string-match| for how {pat} is used.
                And a "~" in {sub} is not replaced with the previous {sub}.
                Note that some codes in {sub} have a special meaning
                |sub-replace-special|.  For example, to replace something with
                "\n" (two characters), use "\\\\n" or '\\n'.
                When {pat} does not match in {expr}, {expr} is returned
                unmodified.
                When {flags} is "g", all matches of {pat} in {expr} are
                replaced.  Otherwise {flags} should be "".
                Example:
                    :let &path = substitute(&path, ",\\=[^,]*$", "", "")
                This removes the last component of the 'path' option.
                    :echo substitute("testing", ".*", "\\U\\0", "")
                results in "TESTING".


        synID({lnum}, {col}, {trans})               *synID()*
                The result is a Number, which is the syntax ID at the position
                {lnum} and {col} in the current window.
                The syntax ID can be used with |synIDattr()| and
                |synIDtrans()| to obtain syntax information about text.

                {col} is 1 for the leftmost column, {lnum} is 1 for the first
                line.  'synmaxcol' applies, in a longer line zero is returned.

                When {trans} is non-zero, transparent items are reduced to the
                item that they reveal.  This is useful when wanting to know
                the effective color.  When {trans} is zero, the transparent
                item is returned.  This is useful when wanting to know which
                syntax item is effective (e.g. inside parens).
                Warning: This function can be very slow.  Best speed is
                obtained by going through the file in forward direction.

                Example (echoes the name of the syntax item under the cursor):
                    :echo synIDattr(synID(line("."), col("."), 1), "name")



        synIDattr({synID}, {what} [, {mode}])           *synIDattr()*
                The result is a String, which is the {what} attribute of
                syntax ID {synID}.  This can be used to obtain information
                about a syntax item.
                {mode} can be "gui", "cterm" or "term", to get the attributes
                for that mode.  When {mode} is omitted, or an invalid value is
                used, the attributes for the currently active highlighting are
                used (GUI, cterm or term).
                Use synIDtrans() to follow linked highlight groups.
                {what}      result
                "name"      the name of the syntax item
                "fg"        foreground color (GUI: color name used to set
                        the color, cterm: color number as a string,
                        term: empty string)
                "bg"        background color (as with "fg")
                "font"      font name (only available in the GUI)
                        |highlight-font|
                "sp"        special color (as with "fg") |highlight-guisp|
                "fg#"       like "fg", but for the GUI and the GUI is
                        running the name in "#RRGGBB" form
                "bg#"       like "fg#" for "bg"
                "sp#"       like "fg#" for "sp"
                "bold"      "1" if bold
                "italic"    "1" if italic
                "reverse"   "1" if reverse
                "inverse"   "1" if inverse (= reverse)
                "standout"  "1" if standout
                "underline" "1" if underlined
                "undercurl" "1" if undercurled

                Example (echoes the color of the syntax item under the
                cursor):
            :echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")


        synIDtrans({synID})                 *synIDtrans()*
                The result is a Number, which is the translated syntax ID of
                {synID}.  This is the syntax group ID of what is being used to
                highlight the character.  Highlight links given with
                ":highlight link" are followed.


        synconcealed({lnum}, {col})             *synconcealed()*
                The result is a List. The first item in the list is 0 if the
                character at the position {lnum} and {col} is not part of a
                concealable region, 1 if it is. The second item in the list is
                a string. If the first item is 1, the second item contains the
                text which will be displayed in place of the concealed text,
                depending on the current setting of 'conceallevel'. The third
                and final item in the list is a unique number representing the
                specific syntax region matched. This allows detection of the
                beginning of a new concealable region if there are two
                consecutive regions with the same replacement character.
                For an example use see $VIMRUNTIME/syntax/2html.vim .



        synstack({lnum}, {col})                 *synstack()*
                Return a |List|, which is the stack of syntax items at the
                position {lnum} and {col} in the current window.  Each item in
                the List is an ID like what |synID()| returns.
                The first item in the List is the outer region, following are
                items contained in that one.  The last one is what |synID()|
                returns, unless not the whole item is highlighted or it is a
                transparent item.
                This function is useful for debugging a syntax file.
                Example that shows the syntax stack under the cursor:
                    for id in synstack(line("."), col("."))
                       echo synIDattr(id, "name")
                    endfor
                When the position specified with {lnum} and {col} is invalid
                nothing is returned.  The position just after the last
                character in a line and the first column in an empty line are
                valid positions.


        system({expr} [, {input}])              *system()* *E677*
                Get the output of the shell command {expr}.
                When {input} is given, this string is written to a file and
                passed as stdin to the command.  The string is written as-is,
                you need to take care of using the correct line separators
                yourself.  Pipes are not used.
                Note: Use |shellescape()| to escape special characters in a
                command argument.  Newlines in {expr} may cause the command to
                fail.  The characters in 'shellquote' and 'shellxquote' may
                also cause trouble.
                This is not to be used for interactive commands.

                The result is a String.  Example:
                    :let files = system("ls " .  shellescape(expand('%:h')))

                To make the result more system-independent, the shell output
                is filtered to replace <CR> with <NL> for Macintosh, and
                <CR><NL> with <NL> for DOS-like systems.
                The command executed is constructed using several options:
            'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
                ({tmp} is an automatically generated file name).
                For Unix and OS/2 braces are put around {expr} to allow for
                concatenated commands.

                The command will be executed in "cooked" mode, so that a
                CTRL-C will interrupt the command (on Unix at least).

                The resulting error code can be found in |v:shell_error|.
                This function will fail in |restricted-mode|.

                Note that any wrong value in the options mentioned above may
                make the function fail.  It has also been reported to fail
                when using a security agent application.
                Unlike ":!cmd" there is no automatic check for changed files.
                Use |:checktime| to force a check.



        tabpagebuflist([{arg}])                 *tabpagebuflist()*
                The result is a |List|, where each item is the number of the
                buffer associated with each window in the current tab page.
                {arg} specifies the number of tab page to be used.  When
                omitted the current tab page is used.
                When {arg} is invalid the number zero is returned.
                To get a list of all buffers in all tabs use this:
                    tablist = []
                    for i in range(tabpagenr('$'))
                       call extend(tablist, tabpagebuflist(i + 1))
                    endfor
                Note that a buffer may appear in more than one window.



        tabpagenr([{arg}])                  *tabpagenr()*
                The result is a Number, which is the number of the current
                tab page.  The first tab page has number 1.
                When the optional argument is "$", the number of the last tab
                page is returned (the tab page count).
                The number can be used with the |:tab| command.



        tabpagewinnr({tabarg}, [{arg}])             *tabpagewinnr()*
                Like |winnr()| but for tab page {tabarg}.
                {tabarg} specifies the number of tab page to be used.
                {arg} is used like with YXXYwinnr()|:
                - When omitted the current window number is returned.  This is
                  the window which will be used when going to this tab page.
                - When "$" the number of windows is returned.
                - When "#" the previous window nr is returned.
                Useful examples:
                    tabpagewinnr(1)     " current window of tab page 1
                    tabpagewinnr(4, '$')    " number of windows in tab page 4
                When {tabarg} is invalid zero is returned.


                                    *tagfiles()*
        tagfiles()  Returns a |List| with the file names used to search for tags
                for the current buffer.  This is the 'tags' option expanded.



        taglist({expr})                         *taglist()*
                Returns a list of tags matching the regular expression {expr}.
                Each list item is a dictionary with at least the following
                entries:
                    name        Name of the tag.
                    filename    Name of the file where the tag is
                            defined.  It is either relative to the
                            current directory or a full path.
                    cmd     Ex command used to locate the tag in
                            the file.
                    kind        Type of the tag.  The value for this
                            entry depends on the language specific
                            kind values.  Only available when
                            using a tags file generated by
                            Exuberant ctags or hdrtag.
                    static      A file specific tag.  Refer to
                            |static-tag| for more information.
                More entries may be present, depending on the content of the
                tags file: access, implementation, inherits and signature.
                Refer to the ctags documentation for information about these
                fields.  For C code the fields "struct", "class" and "enum"
                may appear, they give the name of the entity the tag is
                contained in.

                The ex-command 'cmd' can be either an ex search pattern, a
                line number or a line number followed by a byte number.

                If there are no matching tags, then an empty list is returned.

                To get an exact tag match, the anchors '^' and '$' should be
                used in {expr}.  Refer to |tag-regexp| for more information
                about the tag search regular expression pattern.

                Refer to |'tags'| for information about how the tags file is
                located by Vim. Refer to |tags-file-format| for the format of
                the tags file generated by the different ctags tools.


        tempname()                  *tempname()* *temp-file-name*
                The result is a String, which is the name of a file that
                doesn't exist.  It can be used for a temporary file.  The name
                is different for at least 26 consecutive calls.  Example:
                    :let tmpfile = tempname()
                    :exe "redir > " . tmpfile
                For Unix, the file will be in a private directory |tempfile|.
                For MS-Windows forward slashes are used when the 'shellslash'
                option is set or when 'shellcmdflag' starts with '-'.



        tan({expr})                     *tan()*
                Return the tangent of {expr}, measured in radians, as a |Float|
                in the range [-inf, inf].
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo tan(10)
                    0.648361
                    :echo tan(-4.01)
                    -1.181502
                {only available when compiled with the |+float| feature}



        tanh({expr})                        *tanh()*
                Return the hyperbolic tangent of {expr} as a |Float| in the
                range [-1, 1].
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    :echo tanh(0.5)
                    0.462117
                    :echo tanh(-1)
                    -0.761594
                {only available when compiled with the |+float| feature}



        tolower({expr})                     *tolower()*
                The result is a copy of the String given, with all uppercase
                characters turned into lowercase (just like applying |gu| to
                the string).


        toupper({expr})                     *toupper()*
                The result is a copy of the String given, with all lowercase
                characters turned into uppercase (just like applying |gU| to
                the string).


        tr({src}, {fromstr}, {tostr})               *tr()*
                The result is a copy of the {src} string with all characters
                which appear in {fromstr} replaced by the character in that
                position in the {tostr} string.  Thus the first character in
                {fromstr} is translated into the first character in {tostr}
                and so on.  Exactly like the unix "tr" command.
                This code also deals with multibyte characters properly.

                Examples:
                    echo tr("hello there", "ht", "HT")
                returns "Hello THere"
                    echo tr("<blob>", "<>", "{}")
                returns "{blob}"


        trunc({expr})                           *trunc()*
                Return the largest integral value with magnitude less than or
                equal to {expr} as a |Float| (truncate towards zero).
                {expr} must evaluate to a |Float| or a |Number|.
                Examples:
                    echo trunc(1.456)
                    1.0 
                    echo trunc(-5.456)
                    -5.0 
                    echo trunc(4.0)
                    4.0
                {only available when compiled with the |+float| feature}


                                    *type()*
        type({expr})    The result is a Number, depending on the type of {expr}:
                    Number:     0
                    String:     1
                    Funcref:    2
                    List:       3
                    Dictionary: 4
                    Float:      5
                To avoid the magic numbers it should be used this way:
                    :if type(myvar) == type(0)
                    :if type(myvar) == type("")
                    :if type(myvar) == type(function("tr"))
                    :if type(myvar) == type([])
                    :if type(myvar) == type({})
                    :if type(myvar) == type(0.0)


        undofile({name})                    *undofile()*
                Return the name of the undo file that would be used for a file
                with name {name} when writing.  This uses the 'undodir'
                option, finding directories that exist.  It does not check if
                the undo file exists.
                {name} is always expanded to the full path, since that is what
                is used internally.
                Useful in combination with |:wundo| and |:rundo|.
                When compiled without the +persistent_undo option this always
                returns an empty string.


        undotree()                      *undotree()*
                Return the current state of the undo tree in a dictionary with
                the following items:
                  "seq_last"    The highest undo sequence number used.
                  "seq_cur" The sequence number of the current position in
                        the undo tree.  This differs from "seq_last"
                        when some changes were undone.
                  "time_cur"    Time last used for |:earlier| and related
                        commands.  Use |strftime()| to convert to
                        something readable.
                  "save_last"   Number of the last file write.  Zero when no
                        write yet.
                  "save_cur"    Number of the current position in the undo
                        tree.  
                  "synced"  Non-zero when the last undo block was synced.
                        This happens when waiting from input from the
                        user.  See |undo-blocks|.
                  "entries" A list of dictionaries with information about
                        undo blocks.

                The first item in the "entries" list is the oldest undo item.
                Each List item is a Dictionary with these items:
                  "seq"     Undo sequence number.  Same as what appears in
                        |:undolist|.
                  "time"    Timestamp when the change happened.  Use
                        |strftime()| to convert to something readable.
                  "newhead" Only appears in the item that is the last one
                        that was added.  This marks the last change
                        and where further changes will be added.
                  "curhead" Only appears in the item that is the last one
                        that was undone.  This marks the current
                        position in the undo tree, the block that will
                        be used by a redo command.  When nothing was
                        undone after the last change this item will
                        not appear anywhere.
                  "save"    Only appears on the last block before a file
                        write.  The number is the write count.  The
                        first write has number 1, the last one the
                        "save_last" mentioned above.
                  "alt"     Alternate entry.  This is again a List of undo
                        blocks.  Each item may again have an "alt"
                        item.


        values({dict})                      *values()*
                Return a |List| with all the values of {dict}.  The |List| is
                in arbitrary order.



        virtcol({expr})                     *virtcol()*
                The result is a Number, which is the screen column of the file
                position given with {expr}.  That is, the last screen position
                occupied by the character at that position, when the screen
                would be of unlimited width.  When there is a <Tab> at the
                position, the returned Number will be the column at the end of
                the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
                set to 8, it returns 8.
                For the byte position use |col()|.
                For the use of {expr} see |col()|.
                When 'virtualedit' is used {expr} can be [lnum, col, off], where
                "off" is the offset in screen columns from the start of the
                character.  E.g., a position within a <Tab> or after the last
                character.
                When Virtual editing is active in the current mode, a position
                beyond the end of the line can be returned. |'virtualedit'|
                The accepted positions are:
                    .       the cursor position
                    $       the end of the cursor line (the result is the
                        number of displayed characters in the cursor line
                        plus one)
                    'x      position of mark x (if the mark is not set, 0 is
                        returned)
                Note that only marks in the current file can be used.
                Examples:
          virtcol(".")     with text "foo^Lbar", with cursor on the "^L", returns 5
          virtcol("$")     with text "foo^Lbar", returns 9
          virtcol("'t")    with text "    there", with 't at 'h', returns 6
                The first column is 1.  0 is returned for an error.
                A more advanced example that echoes the maximum length of
                all lines:
                    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))



        visualmode([expr])                      *visualmode()*
                The result is a String, which describes the last Visual mode
                used in the current buffer.  Initially it returns an empty
                string, but once Visual mode has been used, it returns "v",
                "V", or "<CTRL-V>" (a single CTRL-V character) for
                character-wise, line-wise, or block-wise Visual mode
                respectively.
                Example:
                    :exe "normal " . visualmode()
                This enters the same Visual mode as before.  It is also useful
                in scripts if you wish to act differently depending on the
                Visual mode that was used.
                If Visual mode is active, use |mode()| to get the Visual mode
                (e.g., in a |:vmap|).

                                    *non-zero-arg*
                If [expr] is supplied and it evaluates to a non-zero Number or
                a non-empty String, then the Visual mode will be cleared and
                the old value is returned.  Note that " " and "0" are also
                non-empty strings, thus cause the mode to be cleared.  A List,
                Dictionary or Float is not a Number or String, thus does not
                cause the mode to be cleared.


                                    *winbufnr()*
        winbufnr({nr})  The result is a Number, which is the number of the buffer
                associated with window {nr}.  When {nr} is zero, the number of
                the buffer in the current window is returned.  When window
                {nr} doesn't exist, -1 is returned.
                Example:
          :echo "The file in the current window is " . bufname(winbufnr(0))


                                    *wincol()*
        wincol()    The result is a Number, which is the virtual column of the
                cursor in the window.  This is counting screen cells from the
                left side of the window.  The leftmost column is one.


        winheight({nr})                     *winheight()*
                The result is a Number, which is the height of window {nr}.
                When {nr} is zero, the height of the current window is
                returned.  When window {nr} doesn't exist, -1 is returned.
                An existing window always has a height of zero or more.
                Examples:
          :echo "The current window has " . winheight(0) . " lines."


                                    *winline()*
        winline()   The result is a Number, which is the screen line of the cursor
                in the window.  This is counting screen lines from the top of
                the window.  The first line is one.
                If the cursor was moved the view on the file will be updated
                first, this may cause a scroll.


                                    *winnr()*
        winnr([{arg}])  The result is a Number, which is the number of the current
                window.  The top window has number 1.
                When the optional argument is "$", the number of the
                last window is returned (the window count).
                When the optional argument is "#", the number of the last
                accessed window is returned (where |CTRL-W_p| goes to).
                If there is no previous window or it is in another tab page 0
                is returned.
                The number can be used with |CTRL-W_w| and ":wincmd w"
                |:wincmd|.
                Also see |tabpagewinnr()|.


                                    *winrestcmd()*
        winrestcmd()    Returns a sequence of |:resize| commands that should restore
                the current window sizes.  Only works properly when no windows
                are opened or closed and the current window and tab page is
                unchanged.
                Example:
                    :let cmd = winrestcmd()
                    :call MessWithWindowSizes()
                    :exe cmd


                                    *winrestview()*
        winrestview({dict})
                Uses the |Dictionary| returned by |winsaveview()| to restore
                the view of the current window.
                If you have changed the values the result is unpredictable.
                If the window size changed the result won't be the same.


                                    *winsaveview()*
        winsaveview()   Returns a |Dictionary| that contains information to restore
                the view of the current window.  Use |winrestview()| to
                restore the view.
                This is useful if you have a mapping that jumps around in the
                buffer and you want to go back to the original view.
                This does not save fold information.  Use the 'foldenable'
                option to temporarily switch off folding, so that folds are
                not opened when moving around.
                The return value includes:
                    lnum        cursor line number
                    col     cursor column
                    coladd      cursor column offset for 'virtualedit'
                    curswant    column for vertical movement
                    topline     first line in the window
                    topfill     filler lines, only in diff mode
                    leftcol     first column displayed
                    skipcol     columns skipped
                Note that no option values are saved.



        winwidth({nr})                      *winwidth()*
                The result is a Number, which is the width of window {nr}.
                When {nr} is zero, the width of the current window is
                returned.  When window {nr} doesn't exist, -1 is returned.
                An existing window always has a width of zero or more.
                Examples:
          :echo "The current window has " . winwidth(0) . " columns."
          :if winwidth(0) <= 50
          :  exe "normal 50\<C-W>|"
          :endif


                                    *writefile()*
        writefile({list}, {fname} [, {binary}])
                Write |List| {list} to file {fname}.  Each list item is
                separated with a NL.  Each list item must be a String or
                Number.
                When {binary} is equal to "b" binary mode is used: There will
                not be a NL after the last list item.  An empty item at the
                end does cause the last line in the file to end in a NL.
                All NL characters are replaced with a NUL character.
                Inserting CR characters needs to be done before passing {list}
                to writefile().
                An existing file is overwritten, if possible.
                When the write fails -1 is returned, otherwise 0.  There is an
                error message if the file can't be created or when writing
                fails.
                Also see |readfile()|.
                To copy a file byte for byte:
                    :let fl = readfile("foo", "b")
                    :call writefile(fl, "foocopy", "b")
        }}}



}}} 
##VIM OPTIONS {{{

         https://www.shortcutfoo.com/blog/top-50-vim-configuration-options/
        http://vimdoc.sourceforge.net/htmldoc/options.html

    Leta upp och sätt Option för någon funktion******* ; sök på |options|(:h options), el kör :options *******
    Visa info för en option i :option-fönstret*** ; Enter=in, Enter/C-o=tillbaks
    Ändra värde på option när inne i :option-fönstret* ; Enter//r+nyttvärde och Enter, för options m värden
    SÄTT TILLBAKS OPTION TILL SITT GRUNDVÄRDE ; :set iskeyword&
    visa värde på option som har värde (t.ex. textwidth)  ;  :set textwidth  :set textwidth?   :set textwidth=<Tab>
    oooo
    :h options
    :options   =option-fönstret: visar fönster m options + korta förkl. ******
        tryck enter på option (t.ex. noic) du vill ändra till
        +tryck enter på optionname för att gå till fullständiga beskrivningen i help ******
    |option-list|
    :set option / nooption
    :set option!   ********
    :setlocal option
    OPTIONS:SET AND HANDLE {{{
        :set textwidth      =textwidth tar eg. ett värde; utan värde visas värdet
        |:options|  :opt[ions]        open a new window to view and set
        |:set|      :se[t]            show all modified options

        |:set|      :se[t] all        show all non-termcap options
        |:set|      :se[t] termcap        show all termcap options
        :set        :se[t] {option}       set boolean option (switch it on), show string or number option
        |:set|      :se[t] no{option}     reset boolean option (switch it off)
        |:set|      :se[t] inv{option}    invert boolean option
        |:set|      :se[t] {option}={value}   set string/number option to {value}
        |:set|      :se[t] {option}+={value}  append {value} to string option, add
                              {value} to number option
        |:set|      :se[t] {option}-={value}  remove {value} to string option,
                              subtract {value} from number option
        |:set|      :se[t] {option}?      show value of {option}
        |:set|      :se[t] {option}&      reset {option} to its default value

        :setlocal   :setl[ocal]       like ":set" but set the local value for options that have one
        |:setglobal|    :setg[lobal]          like ":set" but set the global value
                              of a local option

        |:fix|      :fix[del]         set value of 't_kD' according to
                              value of 't_kb'
                              options, grouped by functionality,
                              a one line explanation and links to
                              the help
        }}}
    :h 'option'

    -------
    oooo
-- VANLIGA --
-- matches (parenteser mm) --
:set showmatch
:set matchtime=15
-- tabs och indentering
set tabstop=4    " size of a hard tabstop
set shiftwidth=4    " size of an "indent"
set softtabstop=4    " a combination of spaces and tabs are used to simulate tab stops at a width other than the (hard)tabstop
autoindent  #nästa rad startas med samma indrag som förra
:set ic/ignorecase
'wrapscan'    'ws'      searches wrap around the end of the file
:set hlsearch       HIGHLIGHTING VID /-SÖKNINGAR
:set nohlsearch     ÅTERSTÄLL EN HIGHLIGHTING EFTER /-SÖKNING **********
incsearch
history=50
:set ruler
:set list   #visar tabs som ^I
visa tabs med fler tecken (än grundläget 'list') ; 'listchars'
showcmd  #visar normallägeskommandon medan man skriver dem
filetype plugin indent on  #slår på de första tre inställningarna
:se iskeyword=@,48-57,_,192-255,- ~   #specar vilka tecken som räknas som att ett ord kan bestå av    ,,  lägg till - till iskeyword-tecknen ; :set iskeyword+=-  ,,  ta bort tecken från iskeyword-listan ; .se iskeyword-=_   @=alla alfab. tecken,, 48-57 =ascii för siffrorna, 
:set cmdheight=3
-
nowrap
sidescroll=10
:set whichwrap=b,s   b,s,<,>  b,s,<,>,[,]   #sök på :h 'whichwrap' för att se de olika möjliga värdena
:set nocompatible
:set backspace=indent,eol,start    #var i insertmode tillåtet att sudda tecknet innan markören

-- spara filer --
'autowrite'*******    'aw'      automatically write file if changed
'autowriteall'    'awa'     as 'autowrite', but works with more commands
-- backup --
'backup'      'bk'      keep backup file after overwriting a file    :se backup
'backupext'   'bex'     extension used for the backup file    :se backupext=.bak
'patchmode'   'pm'      keep the oldest version of a file    :se patchmode=.orig
'writebackup'     'wb'      make a backup before overwriting a file
'backupdir'   'bdir'    list of directories for the backup file    =backupfil skrivs annars som standard i WD
    'backupcopy'      'bkc'     make backup as a copy, don't rename the file
    'backupskip'      'bsk'     no backup for files that match these patterns
    'patchexpr'   'pex'     expression used to patch a file
-- rullning av skärmen --
'scrollbind'      'scb'     scroll in window as other windows scroll
'scrolloff'   'so'      minimum nr. of lines above and below cursor
'scroll'      'scr'     lines to scroll with CTRL-U and CTRL-D
-- readonly / kunna redigera fil --
'modifiable'      'ma'      changes to the text are not possible
'write'             writing to a file is allowed
-- splits --
'splitbelow'      'sb'      new window from split is below the current one
'splitright'      'spr'     new window is put right of the current one
'winheight'   'wh'      minimum number of lines for the current window
'winfixheight'    'wfh'     keep window height when opening/closing windows
'winfixwidth'     'wfw'     keep window width when opening/closing windows
'winminheight'    'wmh'     minimum number of lines for any window
'winminwidth'     'wmw'     minimal number of columns for any window
'winwidth'    'wiw'     minimal number of columns for current window
'equalalways'     'ea'      windows are automatically made the same size
    vertical splits
-- grep/vimgrep --
'grepprg'     'gp'      program to use for ":grep"

    Short explanation of each option:       *option-list*
    'aleph'       'al'      ASCII code of the letter Aleph (Hebrew)
    'allowrevins'     'ari'     allow CTRL-_ in Insert and Command-line mode
    'altkeymap'   'akm'     for default second language (Farsi/Hebrew)
    'ambiwidth'   'ambw'    what to do with Unicode chars of ambiguous width
    'antialias'   'anti'    Mac OS X: use smooth, antialiased fonts
    'autochdir'   'acd'     change directory to the file in the current window
    'arabic'      'arab'    for Arabic as a default second language
    'arabicshape'     'arshape' do shaping for Arabic characters
    'autoindent'      'ai'      take indent for new line from previous line
    'autoread'    'ar'      autom. read file when changed outside of Vim
    'background'      'bg'      "dark" or "light", used for highlight colors
    'balloondelay'    'bdlay'   delay in mS before a balloon may pop up
    'ballooneval'     'beval'   switch on balloon evaluation
    'balloonexpr'     'bexpr'   expression to show in balloon
    'binary'      'bin'     read/write/edit file in binary mode
    'bioskey'     'biosk'   MS-DOS: use bios calls for input characters
    'bomb'              prepend a Byte Order Mark to the file
    'breakat'     'brk'     characters that may cause a line break
    'browsedir'   'bsdir'   which directory to start browsing in
-- buffers --
'bufhidden'   'bh'      what to do when buffer is no longer in window
'buflisted'   'bl'      whether the buffer shows up in the buffer list
    'buftype'     'bt'      special type of buffer
    'casemap'     'cmp'     specifies how case of letters is changed
    'cdpath'      'cd'      list of directories searched with ":cd"
    'cedit'             key used to open the command-line window
    'charconvert'     'ccv'     expression for character encoding conversion
    'cindent'     'cin'     do C program indenting
    'cinkeys'     'cink'    keys that trigger indent when 'cindent' is set
    'cinoptions'      'cino'    how to do indenting when 'cindent' is set
    'cinwords'    'cinw'    words where 'si' and 'cin' add an indent
    'clipboard'   'cb'      use the clipboard as the unnamed register
    'cmdheight'   'ch'      number of lines to use for the command-line
    'cmdwinheight'    'cwh'     height of the command-line window
    'colorcolumn'     'cc'      columns to highlight
    'columns'     'co'      number of columns in the display
    'comments'    'com'     patterns that can start a comment line
    'commentstring'   'cms'     template for comments; used for fold marker
    'compatible'      'cp'      behave Vi-compatible as much as possible
    'complete'    'cpt'     specify how Insert mode completion works
    'completefunc'    'cfu'     function to be used for Insert mode completion
    'completeopt'     'cot'     options for Insert mode completion
    'concealcursor'   'cocu'    whether concealable text is hidden in cursor line
    'conceallevel'    'cole'    whether concealable text is shown or hidden 
    'confirm'     'cf'      ask what to do about unsaved/read-only files
    'conskey'     'consk'   get keys directly from console (MS-DOS only)
    'copyindent'      'ci'      make 'autoindent' use existing indent structure
    'cpoptions'   'cpo'     flags for Vi-compatible behavior
    'cryptmethod'     'cm'      type of encryption to use for file writing
    'cscopepathcomp'  'cspc'    how many components of the path to show
    'cscopeprg'       'csprg'   command to execute cscope
    'cscopequickfix'  'csqf'    use quickfix window for cscope results
    'cscopetag'       'cst'     use cscope for tag commands
    'cscopetagorder'  'csto'    determines ":cstag" search order
    'cscopeverbose'   'csverb'  give messages when adding a cscope database
    'cursorbind'      'crb'     move cursor in window as it moves in other windows
    'cursorcolumn'    'cuc'     highlight the screen column of the cursor
    'cursorline'      'cul'     highlight the screen line of the cursor
    'debug'             set to "msg" to see all error messages
    'define'      'def'     pattern to be used to find a macro definition
    'delcombine'      'deco'    delete combining characters on their own
    'dictionary'      'dict'    list of file names used for keyword completion
    'diff'              use diff mode for the current window
    'diffexpr'    'dex'     expression used to obtain a diff file
    'diffopt'     'dip'     options for using diff mode
    'digraph'     'dg'      enable the entering of digraphs in Insert mode
    'directory'   'dir'     list of directory names for the swap file
    'display'     'dy'      list of flags for how to display text
    'eadirection'     'ead'     in which direction 'equalalways' works
    'edcompatible'    'ed'      toggle flags of ":substitute" command
    'encoding'    'enc'     encoding used internally
    'endofline'   'eol'     write <EOL> for last line in file
    'equalprg'    'ep'      external program to use for "=" command
    'errorbells'      'eb'      ring the bell for error messages
    'errorfile'   'ef'      name of the errorfile for the QuickFix mode
    'errorformat'     'efm'     description of the lines in the error file
    'esckeys'     'ek'      recognize function keys in Insert mode
    'eventignore'     'ei'      autocommand events that are ignored
    'expandtab'   'et'      use spaces when <Tab> is inserted
    'exrc'        'ex'      read .vimrc and .exrc in the current directory
    'fileencoding'    'fenc'    file encoding for multi-byte text
    'fileencodings'   'fencs'   automatically detected character encodings
    'fileformat'      'ff'      file format used for file I/O
    'fileformats'     'ffs'     automatically detected values for 'fileformat'
    'filetype'    'ft'      type of file, used for autocommands
    'fillchars'   'fcs'     characters to use for displaying special items
    'fkmap'       'fk'      Farsi keyboard mapping
    'foldclose'   'fcl'     close a fold when the cursor leaves it
    'foldcolumn'      'fdc'     width of the column used to indicate folds
    'foldenable'      'fen'     set to display all folds open
    'foldexpr'    'fde'     expression used when 'foldmethod' is "expr"
    'foldignore'      'fdi'     ignore lines when 'foldmethod' is "indent"
    'foldlevel'   'fdl'     close folds with a level higher than this
    'foldlevelstart'  'fdls'    'foldlevel' when starting to edit a file
    'foldmarker'      'fmr'     markers used when 'foldmethod' is "marker"
    'foldmethod'      'fdm'     folding type
    'foldminlines'    'fml'     minimum number of lines for a fold to be closed
    'foldnestmax'     'fdn'     maximum fold depth
    'foldopen'    'fdo'     for which commands a fold will be opened
    'foldtext'    'fdt'     expression used to display for a closed fold
    'formatlistpat'   'flp'     pattern used to recognize a list header
    'formatoptions'   'fo'      how automatic formatting is to be done
    'formatprg'   'fp'      name of external program used with "gq" command
    'formatexpr'      'fex'     expression used with "gq" command
    'fsync'       'fs'      whether to invoke fsync() after file write
    'gdefault'    'gd'      the ":substitute" flag 'g' is default on
    'grepformat'      'gfm'     format of 'grepprg' output
    'guicursor'   'gcr'     GUI: settings for cursor shape and blinking
    'guifont'     'gfn'     GUI: Name(s) of font(s) to be used
    'guifontset'      'gfs'     GUI: Names of multi-byte fonts to be used
    'guifontwide'     'gfw'     list of font names for double-wide characters
    'guiheadroom'     'ghr'     GUI: pixels room for window decorations
    'guioptions'      'go'      GUI: Which components and options are used
    'guipty'            GUI: try to use a pseudo-tty for ":!" commands
    'guitablabel'     'gtl'     GUI: custom label for a tab page
    'guitabtooltip'   'gtt'     GUI: custom tooltip for a tab page
    'helpfile'    'hf'      full path name of the main help file
    'helpheight'      'hh'      minimum height of a new help window
    'helplang'    'hlg'     preferred help languages
    'hidden'      'hid'     don't unload buffer when it is YXXYabandon|ed
    'highlight'   'hl'      sets highlighting mode for various occasions
    'hlsearch'    'hls'     highlight matches with last search pattern
    'history'     'hi'      number of command-lines that are remembered
    'hkmap'       'hk'      Hebrew keyboard mapping
    'hkmapp'      'hkp'     phonetic Hebrew keyboard mapping
    'icon'              let Vim set the text of the window icon
    'iconstring'            string to use for the Vim icon text
    'ignorecase'      'ic'      ignore case in search patterns
    'imactivatekey'   'imak'    key that activates the X input method
    'imcmdline'   'imc'     use IM when starting to edit a command line
    'imdisable'   'imd'     do not use the IM in any mode
    'iminsert'    'imi'     use :lmap or IM in Insert mode
    'imsearch'    'ims'     use :lmap or IM when typing a search pattern
    'include'     'inc'     pattern to be used to find an include file
    'includeexpr'     'inex'    expression used to process an include line
    'incsearch'   'is'      highlight match while typing search pattern
    'indentexpr'      'inde'    expression used to obtain the indent of a line
    'indentkeys'      'indk'    keys that trigger indenting with 'indentexpr'
    'infercase'   'inf'     adjust case of match for keyword completion
    'insertmode'      'im'      start the edit of a file in Insert mode
-- tecken --
'isfname'     'isf'     characters included in file names and pathnames
'isident'     'isi'     characters included in identifiers
'iskeyword'   'isk'     characters included in keywords
'backspace'   'bs'      how backspace works at start of line   backspace=indent,eol,start  (t.ex.)
    'isprint'     'isp'     printable characters
    'joinspaces'      'js'      two spaces after a period with a join command
    'key'               encryption key
    'keymap'      'kmp'     name of a keyboard mapping
    'keymodel'    'km'      enable starting/stopping selection with keys
    'keywordprg'      'kp'      program to use for the "K" command
    'langmap'     'lmap'    alphabetic characters for other language mode
    'langmenu'    'lm'      language to be used for the menus
    'laststatus'      'ls'      tells when last window has status lines
    'lazyredraw'      'lz'      don't redraw while executing macros
    'linebreak'   'lbr'     wrap long lines at a blank
    'lines'             number of lines in the display
    'linespace'   'lsp'     number of pixel lines to use between characters
    'lisp'              automatic indenting for Lisp
    'lispwords'   'lw'      words that change how lisp indenting works
    'list'              show <Tab> and <EOL>
    'listchars'   'lcs'     characters for displaying in list mode
    'loadplugins'     'lpl'     load plugin scripts when starting up
    'macatsui'          Mac GUI: use ATSUI text drawing
    'magic'             changes special characters in search patterns
    'makeef'      'mef'     name of the errorfile for ":make"
    'makeprg'     'mp'      program to use for the ":make" command
'matchpairs'      'mps'     pairs of characters that "%" can match
    'matchtime'   'mat'     tenths of a second to show matching paren
    'maxcombine'      'mco'     maximum nr of combining characters displayed
    'maxfuncdepth'    'mfd'     maximum recursive depth for user functions
    'maxmapdepth'     'mmd'     maximum recursive depth for mapping
    'maxmem'      'mm'      maximum memory (in Kbyte) used for one buffer
    'maxmempattern'   'mmp'     maximum memory (in Kbyte) used for pattern search
    'maxmemtot'   'mmt'     maximum memory (in Kbyte) used for all buffers
    'menuitems'   'mis'     maximum number of items in a menu
    'mkspellmem'      'msm'     memory used before |:mkspell| compresses the tree
-- modeline --
'modeline'    'ml'      recognize modelines at start or end of file
'modelines'   'mls'     number of lines checked for modelines
    'modified'    'mod'     buffer has been modified
    'more'              pause listings when the whole screen is filled
-- mouse i gui mm --
'mouse'             enable the use of mouse clicks
'mousefocus'      'mousef'  keyboard focus follows the mouse
'mousehide'   'mh'      hide mouse pointer while typing
'mousemodel'      'mousem'  changes meaning of mouse buttons
'mouseshape'      'mouses'  shape of the mouse pointer in different modes
'mousetime'   'mouset'  max time between mouse double-click
'selectmode'      'slm'     when to use Select mode instead of Visual mode
    'mzquantum'   'mzq'     the interval between polls for MzScheme threads
    'nrformats'   'nf'      number formats recognized for CTRL-A command
-- position/linenumber in file -- ****
'number'      'nu'      print the line number in front of each line
'ruler'       'ru'      show cursor line and column in the status line
'numberwidth'     'nuw'     number of columns used for the line number
    'omnifunc'    'ofu'     function for filetype-specific completion
    'opendevice'      'odev'    allow reading/writing devices on MS-Windows
    'operatorfunc'    'opfunc'  function to be called for |g@| operator
    'osfiletype'      'oft'     operating system-specific filetype information
    'paragraphs'      'para'    nroff macros that separate paragraphs
    'paste'             allow pasting text
    'pastetoggle'     'pt'      key code that causes 'paste' to toggle
-- sökväg och path --
'path'        'pa'      list of directories searched with "gf" et.al.
'isfname'     'isf'     characters included in file names and pathnames
        |:find|     :fin[d]     find file in 'path' and edit it
        |:sfind|    :sf[ind]    split current window and edit file in 'path'
        |:tabfind|  :tabf[ind]  find file in 'path', edit it in a new tab page
    'preserveindent'  'pi'      preserve the indent structure when reindenting
    'previewheight'   'pvh'     height of the preview window
    'previewwindow'   'pvw'     identifies the preview window
    'printdevice'     'pdev'    name of the printer to be used for :hardcopy
    'printencoding'   'penc'    encoding to be used for printing
    'printexpr'   'pexpr'   expression used to print PostScript for :hardcopy
    'printfont'   'pfn'     name of the font to be used for :hardcopy
    'printheader'     'pheader' format of the header used for :hardcopy
    'printmbcharset'  'pmbcs'   CJK character set to be used for :hardcopy
    'printmbfont'     'pmbfn'   font names to be used for CJK output of :hardcopy
    'printoptions'    'popt'    controls the format of :hardcopy output
    'pumheight'   'ph'      maximum height of the popup menu
    'quoteescape'     'qe'      escape characters used in a string
    'readonly'    'ro'      disallow writing the buffer
    'redrawtime'      'rdt'     timeout for 'hlsearch' and |:match| highlighting
    'relativenumber'  'rnu'     show relative line number in front of each line
    'remap'             allow mappings to work recursively
    'report'            threshold for reporting nr. of lines changed
    'restorescreen'   'rs'      Win32: restore screen when exiting
    'revins'      'ri'      inserting characters will work backwards
    'rightleft'   'rl'      window is right-to-left oriented
    'rightleftcmd'    'rlc'     commands for which editing works right-to-left
    'rulerformat'     'ruf'     custom format for the ruler
    'runtimepath'     'rtp'     list of directories used for runtime files
    'scrolljump'      'sj'      minimum number of lines to scroll
    'scrollopt'   'sbo'     how 'scrollbind' should behave
    'sections'    'sect'    nroff macros that separate sections
    'secure'            secure mode for reading .vimrc in current dir
    'selection'   'sel'     what type of selection to use
    'sessionoptions'  'ssop'    options for |:mksession|
-- unix shell command filtering -- (=kolla dessa options om filtreringen inte funkar riktigt som den ska - s79 U.M.)
'shell'       'sh'      name of shell to use for external commands
'shellcmdflag'    'shcf'    flag to shell to execute one command
    'shellpipe'   'sp'      string to put output of ":make" in error file
'shellquote'      'shq'     quote character(s) for around shell command
'shellredir'      'srr'     string to put output of filter in a temp file
'shellslash'      'ssl'     use forward slash for shell file names
    'shelltemp'   'stmp'    whether to use a temp file for shell commands
'shelltype'   'st'      Amiga: influences how to use a shell
'shellxquote'     'sxq'     like 'shellquote', but include redirection
    'shiftround'      'sr'      round indent to multiple of shiftwidth
    'shiftwidth'      'sw'      number of spaces to use for (auto)indent step
    'shortmess'   'shm'     list of flags, reduce length of messages
    'shortname'   'sn'      non-MS-DOS: Filenames assumed to be 8.3 chars
    'showbreak'   'sbr'     string to use at the start of wrapped lines
    'showcmd'     'sc'      show (partial) command in status line
    'showfulltag'     'sft'     show full tag pattern when completing tag
    'showmatch'   'sm'      briefly jump to matching bracket if insert one
    'showmode'    'smd'     message on status line to show current mode
    'showtabline'     'stal'    tells when the tab pages line is displayed
    'sidescroll'      'ss'      minimum number of columns to scroll horizontal
    'sidescrolloff'   'siso'    min. nr. of columns to left and right of cursor
    'smartcase'   'scs'     no ignore case when pattern has uppercase
    'smartindent'     'si'      smart autoindenting for C programs
    'smarttab'    'sta'     use 'shiftwidth' when inserting <Tab>
    'softtabstop'     'sts'     number of spaces that <Tab> uses while editing
    'spell'             enable spell checking
    'spellcapcheck'   'spc'     pattern to locate end of a sentence
    'spellfile'   'spf'     files where |zg| and |zw| store words
    'spelllang'   'spl'     language(s) to do spell checking for
    'spellsuggest'    'sps'     method(s) used to suggest spelling corrections
    'startofline'     'sol'     commands move cursor to first non-blank in line
    'statusline'      'stl'     custom format for the status line
    'suffixesadd'     'sua'     suffixes added when searching for a file
    'swapfile'    'swf'     whether to use a swapfile for a buffer
    'swapsync'    'sws'     how to sync the swap file
    'switchbuf'   'swb'     sets behavior when switching to another buffer
    'synmaxcol'   'smc'     maximum column to find syntax items
    'syntax'      'syn'     syntax to be loaded for current buffer
    'tabstop'     'ts'      number of spaces that <Tab> in file uses
    'tabline'     'tal'     custom format for the console tab pages line
    'tabpagemax'      'tpm'     maximum number of tab pages for |-p| and "tab all"
    'tagbsearch'      'tbs'     use binary searching in tags files
    'taglength'   'tl'      number of significant characters for a tag
    'tagrelative'     'tr'      file names in tag file are relative
    'tags'        'tag'     list of file names used by the tag command
    'tagstack'    'tgst'    push tags onto the tag stack
    'term'              name of the terminal
    'termbidi'    'tbidi'   terminal takes care of bi-directionality
    'termencoding'    'tenc'    character encoding used by the terminal
    'terse'             shorten some messages
    'textauto'    'ta'      obsolete, use 'fileformats'
    'textmode'    'tx'      obsolete, use 'fileformat'
-- textformatting -- (=gqap mm)
'textwidth'   'tw'      maximum width of text that is being inserted
    'thesaurus'   'tsr'     list of thesaurus files for keyword completion
'tildeop'     'top'     tilde command "~" behaves like an operator
    'timeout'     'to'      time out on mappings and key codes
    'timeoutlen'      'tm'      time out time in milliseconds
    'title'             let Vim set the title of the window
    'titlelen'          percentage of 'columns' used for window title
    'titleold'          old title, restored when exiting
    'titlestring'           string to use for the Vim window title
    'toolbar'     'tb'      GUI: which items to show in the toolbar
    'toolbariconsize' 'tbis'    size of the toolbar icons (for GTK 2 only)
    'ttimeout'          time out on mappings
    'ttimeoutlen'     'ttm'     time out time for key codes in milliseconds
    'ttybuiltin'      'tbi'     use built-in termcap before external termcap
    'ttyfast'     'tf'      indicates a fast terminal connection
    'ttymouse'    'ttym'    type of mouse codes generated
    'ttyscroll'   'tsl'     maximum number of lines for a scroll
    'ttytype'     'tty'     alias for 'term'
    'undodir'     'udir'    where to store undo files
    'undofile'    'udf'     save undo information in a file
    'undolevels'      'ul'      maximum number of changes that can be undone
    'undoreload'      'ur'      max nr of lines to save for undo on a buffer reload
    'updatecount'     'uc'      after this many characters flush swap file
    'updatetime'      'ut'      after this many milliseconds flush swap file
    'verbose'     'vbs'     give informative messages
    'verbosefile'     'vfile'   file to write messages in
    'viewdir'     'vdir'    directory where to store files with :mkview
    'viewoptions'     'vop'     specifies what to save for :mkview
    'viminfo'     'vi'      use .viminfo file upon startup and exiting
    'virtualedit'     've'      when to use virtual editing
    'visualbell'      'vb'      use visual bell instead of beeping
    'warn'              warn for shell command when buffer was changed
    'weirdinvert'     'wiv'     for terminals that have weird inversion method
    'whichwrap'   'ww'      allow specified keys to cross line boundaries
    'wildchar'    'wc'      command-line character for wildcard expansion
    'wildcharm'   'wcm'     like 'wildchar' but also works when mapped
-- Tab mm-completion --  |cmdline-completion|
'wildmode'    'wim'     mode for 'wildchar' command-line expansion
'wildmenu'    'wmnu'    use menu for command line completion
'suffixes'    'su'      suffixes that are ignored with multiple match
'wildignore'      'wig'     files matching these patterns are not completed
    'wildignorecase'  'wic'     ignore case when completing file names
    'wildoptions'     'wop'     specifies how command line completion is done
    'winaltkeys'      'wak'     when the windows system handles ALT keys
    'window'      'wi'      nr of lines to scroll for CTRL-F and CTRL-B
    'wrap'              long lines wrap and continue on the next line
    'wrapmargin'      'wm'      chars from the right where wrapping starts
    'writeany'    'wa'      write to file with no need for "!" override
    'writedelay'      'wd'      delay this many msec for each char (for debug)

   }}}

##VIM_VARIABLES (v:beval m.fl.): {{{


            |buffer-variable|    b:   Local to the current buffer.
            |window-variable|    w:   Local to the current window.
            |tabpage-variable|   t:   Local to the current tab page.
            |global-variable|    g:   Global.

            |local-variable|     l:   Local to a function.
            |script-variable|    s:   Local to a |:source|'ed Vim script.
            |function-argument|  a:   Function argument (only inside a function).   ********
            |vim-variable|       v:   Global, predefined by Vim.

        pickout
            g:netrw_list_hide   a-kommandot i netrw

            v:oldfiles
            g:netrw_keepdir

        plocka vimvariabler från {{{
            predefined vim variables:           *vim-variable* *v:var*


                                *v:beval_col* *beval_col-variable*
            v:beval_col The number of the column, over which the mouse pointer is.
                    This is the byte index in the |v:beval_lnum| line.
                    Only valid while evaluating the 'balloonexpr' option.


                                *v:beval_bufnr* *beval_bufnr-variable*
            v:beval_bufnr   The number of the buffer, over which the mouse pointer is. Only
                    valid while evaluating the 'balloonexpr' option.


                                *v:beval_lnum* *beval_lnum-variable*
            v:beval_lnum    The number of the line, over which the mouse pointer is. Only
                    valid while evaluating the 'balloonexpr' option.


                                *v:beval_text* *beval_text-variable*
            v:beval_text    The text under or after the mouse pointer.  Usually a word as
                    it is useful for debugging a C program.  'iskeyword' applies,
                    but a dot and "->" before the position is included.  When on a
                    ']' the text before it is used, including the matching '[' and
                    word before it.  When on a Visual area within one line the
                    highlighted text is used.
                    Only valid while evaluating the 'balloonexpr' option.


                                *v:beval_winnr* *beval_winnr-variable*
            v:beval_winnr   The number of the window, over which the mouse pointer is. Only
                    valid while evaluating the 'balloonexpr' option.  The first
                    window has number zero (unlike most other places where a
                    window gets a number).


                                *v:char* *char-variable*
            v:char      Argument for evaluating 'formatexpr' and used for the typed
                    character when using <expr> in an abbreviation |:map-<expr>|.


                        *v:charconvert_from* *charconvert_from-variable*
            v:charconvert_from
                    The name of the character encoding of a file to be converted.
                    Only valid while evaluating the 'charconvert' option.


                        *v:charconvert_to* *charconvert_to-variable*
            v:charconvert_to
                    The name of the character encoding of a file after conversion.
                    Only valid while evaluating the 'charconvert' option.


                                *v:cmdarg* *cmdarg-variable*
            v:cmdarg    This variable is used for two purposes:
                    1. The extra arguments given to a file read/write command.
                       Currently these are "++enc=" and "++ff=".  This variable is
                       set before an autocommand event for a file read/write
                       command is triggered.  There is a leading space to make it
                       possible to append this variable directly after the
                       read/write command.  Note: The "+cmd" argument isn't
                       included here, because it will be executed anyway.
                    2. When printing a PostScript file with ":hardcopy" this is
                       the argument for the ":hardcopy" command.  This can be used
                       in 'printexpr'.


                                *v:cmdbang* *cmdbang-variable*
            v:cmdbang   Set like v:cmdarg for a file read/write command.  When a "!"
                    was used the value is 1, otherwise it is 0.  Note that this
                    can only be used in autocommands.  For user commands |<bang>|
                    can be used.


                                *v:count* *count-variable*
            v:count     The count given for the last Normal mode command.  Can be used
                    to get the count before a mapping.  Read-only.  Example:
                :map _x :<C-U>echo "the count is " . v:count<CR>
                    Note: The <C-U> is required to remove the line range that you
                    get when typing ':' after a count.
                    When there are two counts, as in "3d2w", they are multiplied,
                    just like what happens in the command, "d6w" for the example.
                    Also used for evaluating the 'formatexpr' option.
                    "count" also works, for backwards compatibility.


                                *v:count1* *count1-variable*
            v:count1    Just like "v:count", but defaults to one when no count is
                    used.


                                    *v:ctype* *ctype-variable*
            v:ctype     The current locale setting for characters of the runtime
                    environment.  This allows Vim scripts to be aware of the
                    current locale encoding.  Technical: it's the value of
                    LC_CTYPE.  When not using a locale the value is "C".
                    This variable can not be set directly, use the |:language|
                    command.
                    See |multi-lang|.


                                *v:dying* *dying-variable*
            v:dying     Normally zero.  When a deadly signal is caught it's set to
                    one.  When multiple signals are caught the number increases.
                    Can be used in an autocommand to check if Vim didn't
                    terminate normally. {only works on Unix}
                    Example:
                :au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
                    Note: if another deadly signal is caught when v:dying is one,
                    VimLeave autocommands will not be executed.


                                *v:errmsg* *errmsg-variable*
            v:errmsg    Last given error message.  It's allowed to set this variable.
                    Example:
                :let v:errmsg = ""
                :silent! next
                :if v:errmsg != ""
                :  ... handle error
                    "errmsg" also works, for backwards compatibility.


                                *v:exception* *exception-variable*
            v:exception The value of the exception most recently caught and not
                    finished.  See also |v:throwpoint| and |throw-variables|.
                    Example:
                :try
                :  throw "oops"
                :catch /.*/
                :  echo "caught" v:exception
                :endtry
                    Output: "caught oops".


                                *v:fcs_reason* *fcs_reason-variable*
            v:fcs_reason    The reason why the |FileChangedShell| event was triggered.
                    Can be used in an autocommand to decide what to do and/or what
                    to set v:fcs_choice to.  Possible values:
                        deleted     file no longer exists
                        conflict    file contents, mode or timestamp was
                                changed and buffer is modified
                        changed     file contents has changed
                        mode        mode of file changed
                        time        only file timestamp changed


                                *v:fcs_choice* *fcs_choice-variable*
            v:fcs_choice    What should happen after a |FileChangedShell| event was
                    triggered.  Can be used in an autocommand to tell Vim what to
                    do with the affected buffer:
                        reload      Reload the buffer (does not work if
                                the file was deleted).
                        ask     Ask the user what to do, as if there
                                was no autocommand.  Except that when
                                only the timestamp changed nothing
                                will happen.
                        <empty>     Nothing, the autocommand should do
                                everything that needs to be done.
                    The default is empty.  If another (invalid) value is used then
                    Vim behaves like it is empty, there is no warning message.


                                *v:fname_in* *fname_in-variable*
            v:fname_in  The name of the input file.  Valid while evaluating:
                        option      used for 
                        'charconvert'   file to be converted
                        'diffexpr'  original file
                        'patchexpr' original file
                        'printexpr' file to be printed
                    And set to the swap file name for |SwapExists|.


                                *v:fname_out* *fname_out-variable*
            v:fname_out The name of the output file.  Only valid while
                    evaluating:
                        option      used for 
                        'charconvert'   resulting converted file (*)
                        'diffexpr'  output of diff
                        'patchexpr' resulting patched file
                    (*) When doing conversion for a write command (e.g., ":w
                    file") it will be equal to v:fname_in.  When doing conversion
                    for a read command (e.g., ":e file") it will be a temporary
                    file and different from v:fname_in.


                                *v:fname_new* *fname_new-variable*
            v:fname_new The name of the new version of the file.  Only valid while
                    evaluating 'diffexpr'.


                                *v:fname_diff* *fname_diff-variable*
            v:fname_diff    The name of the diff (patch) file.  Only valid while
                    evaluating 'patchexpr'.


                                *v:folddashes* *folddashes-variable*
            v:folddashes    Used for 'foldtext': dashes representing foldlevel of a closed
                    fold.
                    Read-only in the |sandbox|. |fold-foldtext|


                                *v:foldlevel* *foldlevel-variable*
            v:foldlevel Used for 'foldtext': foldlevel of closed fold.
                    Read-only in the |sandbox|. |fold-foldtext|


                                *v:foldend* *foldend-variable*
            v:foldend   Used for 'foldtext': last line of closed fold.
                    Read-only in the |sandbox|. |fold-foldtext|


                                *v:foldstart* *foldstart-variable*
            v:foldstart Used for 'foldtext': first line of closed fold.
                    Read-only in the |sandbox|. |fold-foldtext|


                                *v:insertmode* *insertmode-variable*
            v:insertmode    Used for the |InsertEnter| and |InsertChange| autocommand
                    events.  Values:
                        i   Insert mode
                        r   Replace mode
                        v   Virtual Replace mode


                                    *v:key* *key-variable*
            v:key       Key of the current item of a |Dictionary|.  Only valid while
                    evaluating the expression used with |map()| and |filter()|.
                    Read-only.


                                    *v:lang* *lang-variable*
            v:lang      The current locale setting for messages of the runtime
                    environment.  This allows Vim scripts to be aware of the
                    current language.  Technical: it's the value of LC_MESSAGES.
                    The value is system dependent.
                    This variable can not be set directly, use the |:language|
                    command.
                    It can be different from |v:ctype| when messages are desired
                    in a different language than what is used for character
                    encoding.  See |multi-lang|.


                                    *v:lc_time* *lc_time-variable*
            v:lc_time   The current locale setting for time messages of the runtime
                    environment.  This allows Vim scripts to be aware of the
                    current language.  Technical: it's the value of LC_TIME.
                    This variable can not be set directly, use the |:language|
                    command.  See |multi-lang|.


                                    *v:lnum* *lnum-variable*
            v:lnum      Line number for the 'foldexpr' |fold-expr|, 'formatexpr' and
                    'indentexpr' expressions, tab page number for 'guitablabel'
                    and 'guitabtooltip'.  Only valid while one of these
                    expressions is being evaluated.  Read-only when in the
                    |sandbox|.


                                *v:mouse_win* *mouse_win-variable*
            v:mouse_win Window number for a mouse click obtained with |getchar()|.
                    First window has number 1, like with |winnr()|.  The value is
                    zero when there was no mouse button click.


                                *v:mouse_lnum* *mouse_lnum-variable*
            v:mouse_lnum    Line number for a mouse click obtained with |getchar()|.
                    This is the text line number, not the screen line number.  The
                    value is zero when there was no mouse button click.


                                *v:mouse_col* *mouse_col-variable*
            v:mouse_col Column number for a mouse click obtained with |getchar()|.
                    This is the screen column number, like with |virtcol()|.  The
                    value is zero when there was no mouse button click.


                                *v:oldfiles* *oldfiles-variable*
            v:oldfiles  List of file names that is loaded from the |viminfo| file on
                    startup.  These are the files that Vim remembers marks for.
                    The length of the List is limited by the ' argument of the
                    'viminfo' option (default is 100).
                    Also see |:oldfiles| and |c_#<|.
                    The List can be modified, but this has no effect on what is
                    stored in the |viminfo| file later.  If you use values other
                    than String this will cause trouble.
                    {only when compiled with the |+viminfo| feature}


                                *v:operator* *operator-variable*
            v:operator  The last operator given in Normal mode.  This is a single
                    character except for commands starting with <g> or <z>,
                    in which case it is two characters.  Best used alongside
                    |v:prevcount| and |v:register|.  Useful if you want to cancel
                    Operator-pending mode and then use the operator, e.g.:
                        :omap O <Esc>:call MyMotion(v:operator)<CR>
                    The value remains set until another operator is entered, thus
                    don't expect it to be empty.
                    v:operator is not set for |:delete|, |:yank| or other Ex
                    commands.
                    Read-only.


                                *v:prevcount* *prevcount-variable*
            v:prevcount The count given for the last but one Normal mode command.
                    This is the v:count value of the previous command.  Useful if
                    you want to cancel Visual or Operator-pending mode and then
                    use the count, e.g.:
                        :vmap % <Esc>:call MyFilter(v:prevcount)<CR>
                    Read-only.


                                *v:profiling* *profiling-variable*
            v:profiling Normally zero.  Set to one after using ":profile start".
                    See |profiling|.


                                *v:progname* *progname-variable*
            v:progname  Contains the name (with path removed) with which Vim was
                    invoked.  Allows you to do special initialisations for "view",
                    "evim" etc., or any other name you might symlink to Vim.
                    Read-only.


                                *v:register* *register-variable*
            v:register  The name of the register in effect for the current normal mode
                    command.  If none is supplied it is the default register.
                    Also see |getreg()| and |setreg()|


                                *v:scrollstart* *scrollstart-variable*
            v:scrollstart   String describing the script or function that caused the
                    screen to scroll up.  It's only set when it is empty, thus the
                    first reason is remembered.  It is set to "Unknown" for a
                    typed command.
                    This can be used to find out why your script causes the
                    hit-enter prompt.


                                *v:servername* *servername-variable*
            v:servername    The resulting registered |x11-clientserver| name if any.
                    Read-only.



            v:searchforward         *v:searchforward* *searchforward-variable*
                    Search direction:  1 after a forward search, 0 after a
                    backward search.  It is reset to forward when directly setting
                    the last search pattern, see |quote/|.
                    Note that the value is restored when returning from a
                    function. |function-search-undo|.
                    Read-write.


                                *v:shell_error* *shell_error-variable*
            v:shell_error   Result of the last shell command.  When non-zero, the last
                    shell command had an error.  When zero, there was no problem.
                    This only works when the shell returns the error code to Vim.
                    The value -1 is often used when the command could not be
                    executed.  Read-only.
                    Example:
                :!mv foo bar
                :if v:shell_error
                :  echo 'could not rename "foo" to "bar"!'
                :endif
                    "shell_error" also works, for backwards compatibility.


                                *v:statusmsg* *statusmsg-variable*
            v:statusmsg Last given status message.  It's allowed to set this variable.


                                *v:swapname* *swapname-variable*
            v:swapname  Only valid when executing |SwapExists| autocommands: Name of
                    the swap file found.  Read-only.


                                *v:swapchoice* *swapchoice-variable*
            v:swapchoice    |SwapExists| autocommands can set this to the selected choice
                    for handling an existing swap file:
                        'o' Open read-only
                        'e' Edit anyway
                        'r' Recover
                        'd' Delete swapfile
                        'q' Quit
                        'a' Abort
                    The value should be a single-character string.  An empty value
                    results in the user being asked, as would happen when there is
                    no SwapExists autocommand.  The default is empty.


                                *v:swapcommand* *swapcommand-variable*
            v:swapcommand   Normal mode command to be executed after a file has been
                    opened.  Can be used for a |SwapExists| autocommand to have
                    another Vim open the file and jump to the right place.  For
                    example, when jumping to a tag the value is ":tag tagname\r".
                    For ":edit +cmd file" the value is ":cmd\r".


                            *v:termresponse* *termresponse-variable*
            v:termresponse  The escape sequence returned by the terminal for the |t_RV|
                    termcap entry.  It is set when Vim receives an escape sequence
                    that starts with ESC [ or CSI and ends in a 'c', with only
                    digits, ';' and '.' in between.
                    When this option is set, the TermResponse autocommand event is
                    fired, so that you can react to the response from the
                    terminal.
                    The response from a new xterm is: "<Esc>[ Pp ; Pv ; Pc c".  Pp
                    is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the
                    patch level (since this was introduced in patch 95, it's
                    always 95 or bigger).  Pc is always zero.
                    {only when compiled with |+termresponse| feature}


                            *v:this_session* *this_session-variable*
            v:this_session  Full filename of the last loaded or saved session file.  See
                    |:mksession|.  It is allowed to set this variable.  When no
                    session file has been saved, this variable is empty.
                    "this_session" also works, for backwards compatibility.


                                *v:throwpoint* *throwpoint-variable*
            v:throwpoint    The point where the exception most recently caught and not
                    finished was thrown.  Not set when commands are typed.  See
                    also |v:exception| and |throw-variables|.
                    Example:
                :try
                :  throw "oops"
                :catch /.*/
                :  echo "Exception from" v:throwpoint
                :endtry
                    Output: "Exception from test.vim, line 2"


                                    *v:val* *val-variable*
            v:val       Value of the current item of a |List| or |Dictionary|.  Only
                    valid while evaluating the expression used with |map()| and
                    |filter()|.  Read-only.


                                *v:version* *version-variable*
            v:version   Version number of Vim: Major version number times 100 plus
                    minor version number.  Version 5.0 is 500.  Version 5.1 (5.01)
                    is 501.  Read-only.  "version" also works, for backwards
                    compatibility.
                    Use |has()| to check if a certain patch was included, e.g.:
                        if has("patch123")
                    Note that patch numbers are specific to the version, thus both
                    version 5.0 and 5.1 may have a patch 123, but these are
                    completely different.


                                *v:warningmsg* *warningmsg-variable*
            v:warningmsg    Last given warning message.  It's allowed to set this variable.


                                *v:windowid* *windowid-variable*
            v:windowid  When any X11 based GUI is running or when running in a
                    terminal and Vim connects to the X server (|-X|) this will be
                    set to the window ID.
                    When an MS-Windows GUI is running this will be set to the
                    window handle.
                    Otherwise the value is zero.
                    Note: for windows inside Vim use |winnr()|.
            ]"']]'
        }}}

        }}}
##Vim errormessages {{{
    E37: No write since last change (use ! to override) ~
    :h E37
}}}
##VIM_PROPERTYFLAGS(?) (amiga, arabic mm): {{{

        all_builtin_terms   Compiled with all builtin terminals enabled.
        amiga           Amiga version of Vim.
        arabic          Compiled with Arabic support |Arabic|.
        arp         Compiled with ARP support (Amiga).
        autocmd         Compiled with autocommand support. |autocommand|
        balloon_eval        Compiled with |balloon-eval| support.
        balloon_multiline   GUI supports multiline balloons.
        beos            BeOS version of Vim.
        browse          Compiled with |:browse| support, and browse() will
                    work.
        builtin_terms       Compiled with some builtin terminals.
        byte_offset     Compiled with support for 'o' in 'statusline'
        cindent         Compiled with 'cindent' support.
        clientserver        Compiled with remote invocation support |clientserver|.
        clipboard       Compiled with 'clipboard' support.
        cmdline_compl       Compiled with |cmdline-completion| support.
        cmdline_hist        Compiled with |cmdline-history| support.
        cmdline_info        Compiled with 'showcmd' and 'ruler' support.
        comments        Compiled with |'comments'| support.
        compatible      Compiled to be very Vi compatible.
        cryptv          Compiled with encryption support |encryption|.
        cscope          Compiled with |cscope| support.
        debug           Compiled with "DEBUG" defined.
        dialog_con      Compiled with console dialog support.
        dialog_gui      Compiled with GUI dialog support.
        diff            Compiled with |vimdiff| and 'diff' support.
        digraphs        Compiled with support for digraphs.
        dnd         Compiled with support for the "~ register |quote_~|.
        dos16           16 bits DOS version of Vim.
        dos32           32 bits DOS (DJGPP) version of Vim.
        ebcdic          Compiled on a machine with ebcdic character set.
        emacs_tags      Compiled with support for Emacs tags.
        eval            Compiled with expression evaluation support.  Always
                    true, of course!
        ex_extra        Compiled with extra Ex commands |+ex_extra|.
        extra_search        Compiled with support for |'incsearch'| and
                    |'hlsearch'|
        farsi           Compiled with Farsi support |farsi|.
        file_in_path        Compiled with support for |gf| and |<cfile>|
        filterpipe      When 'shelltemp' is off pipes are used for shell
                    read/write/filter commands
        find_in_path        Compiled with support for include file searches
                    |+find_in_path|.
        float           Compiled with support for |Float|.
        fname_case      Case in file names matters (for Amiga, MS-DOS, and
                    Windows this is not present).
        folding         Compiled with |folding| support.
        footer          Compiled with GUI footer support. |gui-footer|
        fork            Compiled to use fork()/exec() instead of system().
        gettext         Compiled with message translation |multi-lang|
        gui         Compiled with GUI enabled.
        gui_athena      Compiled with Athena GUI.
        gui_gnome       Compiled with Gnome support (gui_gtk is also defined).
        gui_gtk         Compiled with GTK+ GUI (any version).
        gui_gtk2        Compiled with GTK+ 2 GUI (gui_gtk is also defined).
        gui_mac         Compiled with Macintosh GUI.
        gui_motif       Compiled with Motif GUI.
        gui_photon      Compiled with Photon GUI.
        gui_running     Vim is running in the GUI, or it will start soon.
        gui_win32       Compiled with MS Windows Win32 GUI.
        gui_win32s      idem, and Win32s system being used (Windows 3.1)
        hangul_input        Compiled with Hangul input support. |hangul|
        iconv           Can use iconv() for conversion.
        insert_expand       Compiled with support for CTRL-X expansion commands in
                    Insert mode.
        jumplist        Compiled with |jumplist| support.
        keymap          Compiled with 'keymap' support.
        langmap         Compiled with 'langmap' support.
        libcall         Compiled with |libcall()| support.
        linebreak       Compiled with 'linebreak', 'breakat' and 'showbreak'
                    support.
        lispindent      Compiled with support for lisp indenting.
        listcmds        Compiled with commands for the buffer list |:files|
                    and the argument list |arglist|.
        localmap        Compiled with local mappings and abbr. |:map-local|
        lua         Compiled with Lua interface |Lua|.
        mac         Macintosh version of Vim.
        macunix         Macintosh version of Vim, using Unix files (OS-X).
        menu            Compiled with support for |:menu|.
        mksession       Compiled with support for |:mksession|.
        modify_fname        Compiled with file name modifiers. |filename-modifiers|
        mouse           Compiled with support mouse.
        mouse_dec       Compiled with support for Dec terminal mouse.
        mouse_gpm       Compiled with support for gpm (Linux console mouse)
        mouse_netterm       Compiled with support for netterm mouse.
        mouse_pterm     Compiled with support for qnx pterm mouse.
        mouse_sysmouse      Compiled with support for sysmouse (*BSD console mouse)
        mouse_xterm     Compiled with support for xterm mouse.
        mouseshape      Compiled with support for 'mouseshape'.
        multi_byte      Compiled with support for 'encoding'
        multi_byte_encoding 'encoding' is set to a multi-byte encoding.
        multi_byte_ime      Compiled with support for IME input method.
        multi_lang      Compiled with support for multiple languages.
        mzscheme        Compiled with MzScheme interface |mzscheme|.
        netbeans_enabled    Compiled with support for |netbeans| and connected.
        netbeans_intg       Compiled with support for |netbeans|.
        ole         Compiled with OLE automation support for Win32.
        os2         OS/2 version of Vim.
        osfiletype      Compiled with support for osfiletypes |+osfiletype|
        path_extra      Compiled with up/downwards search in 'path' and 'tags'
        perl            Compiled with Perl interface.
        persistent_undo     Compiled with support for persistent undo history.
        postscript      Compiled with PostScript file printing.
        printer         Compiled with |:hardcopy| support.
        profile         Compiled with |:profile| support.
        python          Compiled with Python interface.
        qnx         QNX version of Vim.
        quickfix        Compiled with |quickfix| support.
        reltime         Compiled with |reltime()| support.
        rightleft       Compiled with 'rightleft' support.
        ruby            Compiled with Ruby interface |ruby|.
        scrollbind      Compiled with 'scrollbind' support.
        showcmd         Compiled with 'showcmd' support.
        signs           Compiled with |:sign| support.
        smartindent     Compiled with 'smartindent' support.
        sniff           Compiled with SNiFF interface support.
        spell           Compiled with spell checking support |spell|.
        startuptime     Compiled with |--startuptime| support.
        statusline      Compiled with support for 'statusline', 'rulerformat'
                    and special formats of 'titlestring' and 'iconstring'.
        sun_workshop        Compiled with support for Sun |workshop|.
        syntax          Compiled with syntax highlighting support |syntax|.
        syntax_items        There are active syntax highlighting items for the
                    current buffer.
        system          Compiled to use system() instead of fork()/exec().
        tag_binary      Compiled with binary searching in tags files
                    |tag-binary-search|.
        tag_old_static      Compiled with support for old static tags
                    |tag-old-static|.
        tag_any_white       Compiled with support for any white characters in tags
                    files |tag-any-white|.
        tcl         Compiled with Tcl interface.
        terminfo        Compiled with terminfo instead of termcap.
        termresponse        Compiled with support for |t_RV| and |v:termresponse|.
        textobjects     Compiled with support for |text-objects|.
        tgetent         Compiled with tgetent support, able to use a termcap
                    or terminfo file.
        title           Compiled with window title support |'title'|.
        toolbar         Compiled with support for |gui-toolbar|.
        unix            Unix version of Vim.
        user_commands       User-defined commands.
        vertsplit       Compiled with vertically split windows |:vsplit|.
        vim_starting        True while initial source'ing takes place. |startup|
        viminfo         Compiled with viminfo support.
        virtualedit     Compiled with 'virtualedit' option.
        visual          Compiled with Visual mode.
        visualextra     Compiled with extra Visual mode commands.
                    |blockwise-operators|.
        vms         VMS version of Vim.
        vreplace        Compiled with |gR| and |gr| commands.
        wildignore      Compiled with 'wildignore' option.
        wildmenu        Compiled with 'wildmenu' option.
        win16           Win16 version of Vim (MS-Windows 3.1).
        win32           Win32 version of Vim (MS-Windows 95 and later, 32 or
                    64 bits)
        win32unix       Win32 version of Vim, using Unix files (Cygwin)
        win64           Win64 version of Vim (MS-Windows 64 bit).
        win95           Win32 version for MS-Windows 95/98/ME.
        winaltkeys      Compiled with 'winaltkeys' option.
        windows         Compiled with support for more than one window.
        writebackup     Compiled with 'writebackup' default on.
        xfontset        Compiled with X fontset support |xfontset|.
        xim         Compiled with X input method support |xim|.
        xsmp            Compiled with X session management support.
        xsmp_interact       Compiled with interactive X session management support.
        xterm_clipboard     Compiled with support for xterm clipboard.
        xterm_save      Compiled with support for saving and restoring the
                    xterm screen.
        x11         Compiled with X11 support.
        }}}

}}}

Doks/Resources/searches  #Including VimCasts {{{
___Doks
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/
----
  vim uman =notes 1[!]
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/practvim.txt
    ~/Dropbox/rsc/samples/code/vim/practvim-functionsplusaucommands1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/modvim.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zz_vimtips_2REF-CHECKLIST.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/lvimscrhard.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vimscr-ibmtuts.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vdocs-bashsupport.txt
----
~/Dropbox/rsc/data/lists/ref/comp/vimpickouts21end-uman_pract_exfs-man.txt
    ~/Dropbox/rsc/data/lists/learnqna/vanki/DECK.vimuman2of2.patch.txt
    ~/Dropbox/rsc/data/lists/learnqna/vanki/vimpickouts21end-uman_pract_exfs-man.txt
    ~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/vim2021.twothirds.tagged/DECK.vimuman2of2.patch.txt
    ~/Dropbox/rsc/aubooks/comp/vimuserman.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/Man2021plus-01uman.usr41.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-Usr41.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/Man2021plus-02refman.eval.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-Eval.txt
    ~/Dropbox/rsc/Doks/Comp/vimdoc8/rman-uman-files.index.txt
----
 ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zz_vimoutliner.txt


https://www.vimonlineeditor.com/
Vim Fzf (=fuzzy finder)
--
https://stackoverflow.com/questions/12287276/mapping-keys-on-numerical-keypad __ __ [****]

https://learnvim.irian.to/
https://learnvim.irian.to/vimscript/vimscript_basic_data_types

https://devhints.io/vimscript  #vimscript cheatsheet
    https://devhints.io/vim-diff

https://blog.neverinstall.com/neovim-on-browser/

https://neovim.io/doc/user/luaref.html
  https://neovim.io/doc/user/lua.html
  https://mattermost.com/blog/turning-neovim-into-a-full-fledged-code-editor-with-lua/ [**]

exempelkod/exempelprogram {{{

    3 exempelfiler:
        Stora Exempelrc-filen (+hitta fler **)
         pinkjuice xml
        'next colorscheme'
        Learning Vimscript the Hard Way

        +ftplugin/man.vim
         macros/less.sh mm
    +MEDAN KOLLAR VIMREFMAN + PRACT/HARDW: REF. TILL KOD/FILER *.VIM (=FTPLUGIN, AUTOLOAD MM****) I VIM74-MAPPEN ****

        TODO: PLOCKA NER DE FLESTA/INTRESSANTASTE
        SÅ KAN BÖRJA KOLLA AV NYCKELORD OCH TECKEN UR KODEN
        NÄR SLUTLÄRIN VIMREFMANS, USR41 + VIMSCRHARD_ULTIM-2019 *******
    https://github.com/tpope/vim-unimpaired/blob/master/plugin/unimpaired.vim
    https://github.com/tpope/vim-surround/blob/master/plugin/surround.vim
    https://github.com/bronson/vim-visual-star-search/blob/master/plugin/visual-star-search.vim
    https://github.com/kana/vim-textobj-entire
    https://github.com/tmhedberg/matchit/blob/master/plugin/matchit.vim
     https://github.com/kana/vim-textobj-lastpat
    https://github.com/tpope/vim-abolish/blob/master/plugin/abolish.vim
                https://github.com/hashrocket/dotmatrix
    https://github.com/tpope/vim-repeat/blob/master/autoload/repeat.vim         ************
    ----
    https://github.com/Olical/vim-enmasse
    https://github.com/mileszs/ack.vim
    https://github.com/Numkil/ag.nvim
    https://github.com/stoeffel/.dotfiles/blob/master/vim/visual-at.vim  #=fr. drew neills 'practical vim'

    +? =ev studera netrw ??


    keepjumps:
        :let lnum = line(".")
        :keepjumps normal gg
        :call SetLastChange()
        :keepjumps exe "normal " . lnum . "G"


    inoremap <Left>  <C-G>U<Left>
    inoremap <Right> <C-G>U<Right>
    inoremap <expr> <Home> col('.') == match(getline('.'), '\S') + 1 ?
     \ repeat('<C-G>U<Left>', col('.') - 1) :
     \ (col('.') < match(getline('.'), '\S') ?
     \     repeat('<C-G>U<Right>', match(getline('.'), '\S') + 0) :
     \     repeat('<C-G>U<Left>', col('.') - 1 - match(getline('.'), '\S')))
    inoremap <expr> <End> repeat('<C-G>U<Right>', col('$') - col('.'))
    inoremap ( ()<C-G>U<Left>


    smartab:
    function! CleverTab()
        if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
            return "\<Tab>"
        else
            return "\<C-N>"
        endif
    endfunction
    inoremap <Tab> <C-R>=CleverTab()<CR>


    :h insert   'An example that completes the names of the months:'
    (=egna compl.funktioner för c-x c-u mm *****)


    function! MyBalloonExpr()       #=i options.txt


    syntaxcomplete plugin provides basic completion for all other filetypes.  It
    does this by populating the omni completion list with the text Vim already
    knows how to color highlight.  It can be used for any filetype and provides a
    minimal language-sensitive completion.

    To enable syntax code completion you can run: >
        setlocal omnifunc=syntaxcomplete#Complete

    You can automate this by placing the following in your |.vimrc| (after any
    ":filetype" command): >
        if has("autocmd") && exists("+omnifunc")
        autocmd Filetype *
                \   if &omnifunc == "" |
                \       setlocal omnifunc=syntaxcomplete#Complete |
                \   endif
        endif


}}}
https://github.com/chrisbra/matchit/blob/master/doc/matchit.txt
https://github.com/andymass/vim-matchup
-- +Catonmat =more plugins **(!!) {{{
  https://catonmat.net/vim-plugins-matchit-vim
  https://catonmat.net/vim-plugins-surround-vim
  https://catonmat.net/vim-plugins-repeat-vim
  https://catonmat.net/vim-plugins-a-vim
  https://catonmat.net/vim-plugins-snipmate-vim
  search: ultisnips
  https://catonmat.net/top-10-vim-shortcuts
  https://catonmat.net/vim-plugins
  https://catonmat.net/linux-and-vim-notes
  https://catonmat.net/vim-plugins-ragtag-allml-vim
  https://catonmat.net/vim-plugins-nerdtree-vim
    https://catonmat.net/archive
  https://www.vimfromscratch.com/articles/vim-matched-pairs
}}}

    call vundle#begin()  #=TODO: Check up on[!!]

        Example Vimrcs
            https://spf13.com/post/perfect-vimrc-vim-config-file/
            pinkjuice
            drew neill(?/*/!)

~/Dropbox/rsc/tmpl/skeletons/function.vim

=work up from highest(=oldest) to lowest (=newest):
    http://vimcasts.org/episodes/page/8/  #=1-8
    http://vimcasts.org/blog/page/6/      #=1-6

TODO PRE VIMDOC POCKET 2021****:
    collate all files indexed in
    ~/dropbox-legacy/vim/doc/intro.txt
    from dropbox-legacy/vim/doc   (+if necess(!!): in same order as original (!!!!!))

          ~/Empire/Doks/Comp/vim/vim-power-of-g.pdf
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zz_vimtips_2REF-CHECKLIST.txt
[[ ~/Empire/Doks/Comp/editor/vim/ ]]
        ~/Empire/Doks/Comp/vim/vimtips.pdf          #TODO(!!): convert to txt + convert to vankiquestions-list (+pick through (and set (??)))
        ~/Empire/Doks/Comp/vim/vimbook-OPL.pdf
        ----
        ~/Empire/Doks/Comp/vim/vimantecknOLD.pdf
        ~/Empire/Doks/Comp/vim/vimqrc.pdf
                ~/Empire/Doks/Comp/vim/vim_user_manual.pdf

ibm vim-tuts {{{

~/Dropbox/rsc/Doks/phone.fmt35/todo/vimscr-ibmtuts.txt

    https://developer.ibm.com/articles/l-vim-script-1/
    https://developer.ibm.com/tutorials/l-vim-script-2/
    https://developer.ibm.com/tutorials/l-vim-script-3/
    https://developer.ibm.com/tutorials/l-vim-script-4/
    https://developer.ibm.com/tutorials/l-vim-script-5/
        https://developer.ibm.com/tutorials/au-customize_vi/
}}}

LITT INDEX VIM.LEGACY {{{
    mark_litt

        . {{{
        https://books.google.se/books?id=_1cnCgAAQBAJ&pg=PA387&lpg=PA387&dq=is+it+possible+to+search+in+the+vim+registers&source=bl&ots=V7zINatjA-&sig=-LANeeDYEM3ufPIn216gLCVdfLo&hl=sv&sa=X&ved=0ahUKEwjx1N7uvujWAhUBMJoKHcTEANk4ChDoAQgmMAA#v=onepage&q=is%20it%20possible%20to%20search%20in%20the%20vim%20registers&f=false
        }}}
        . {{{
        https://www.amazon.com/Wicked-Cool-Vim-Vi-Improved-ebook/dp/B00LP6MLOG/ref=pd_sim_351_2?_encoding=UTF8&psc=1&refRID=DRENN423FEQMM1NZRZXE
        }}}

                https://www.amazon.com/Vi-iMproved-VIM-Steve-Oualline/dp/0735710015

        PRACTICALVIM:  =Dokumentera alla anteckningar från genomgången  {{{
            evince ~/Dropbox/PRACTICAL_VIM.pdf &
        }}}
    ------
        vimbook opl {{{
            evince ~/Documents/vimbook-OPL.pdf &
        }}}
        vim recipes(bram) {{{
            ~/Dropbox/vim-recipes.pdf
        }}}

        vimTips {{{
            evince ~/Dropbox/vimtips.pdf &      *********************************
        }}}
        vimdoc tips
        vim powerofg {{{
            evince ~/Dropbox/vim-power-of-g.pdf &
        }}}
        vimuserman quickref-listS {{{
        }}}
        VIMDOC VIMSCRIPT {{{
            evince ~/Dropbox/vimdoc--VIMSCRIPT.pdf &
        }}}
    VIM FUNCTIONS + ExCommands
     Make Commands + Menus (uman sista)
    VIMPLUGINS WITH PYTHON
        vim referencemanual {{{
            vim reference manual
        }}}
        vim bashsupport {{{
            Vim Bash Support documentation {{{
                evince ~/Dropbox/vim_bashsupport.pdf &
                        http://lug.fh-swf.de/vim/vim-bash/bashsupport.html
                1.  Usage with GUI
                    |bashsupport-usage-gvim|
                1.1 Menu 'Comments'
                    |bashsupport-comments|
                1.1.1 Append aligned comments
                    |bashsupport-aligned-comm|
                1.1.2 Adjust end-of-line comments
                    |bashsupport-comm-realign|
                1.1.3 Comment/uncomment
                    |bashsupport-comm-toggle|
                1.1.4 Frame comments, file header, ...
                    |bashsupport-comm-templates|
                1.1.5 Comment/uncomment with echo
                    |bashsupport-comm-echo|
                1.1.6 KEYWORD + comment
                    |bashsupport-comm-keywords|
                1.2 Menu 'Statements'
                    |bashsupport-statements|
                1.2.1 Normal mode, insert mode
                    |bashsupport-stat-norm-ins|
                1.2.2 Visual mode
                    |bashsupport-stat-visual|
                1.3 Menus'Tests' ... 'Shopts'
                    |bashsupport-tests|
                1.4 Menu 'PatternMatching'
                    |bashsupport-pattern|
                1.5 Menu 'I/O-Redir'
                    |bashsupport-io-redir|
                1.6 Menu 'Snippets'
                    |bashsupport-snippets|
                1.6.1 Code Snippets
                    |bashsupport-codesnippets|
                1.6.2 Edit Templates
                    |bashsupport-templates-edit|
                1.7 Menu 'Run'
                    |bashsupport-run|
                1.7.1 Save and run
                    |bashsupport-run-script|
                1.7.2 Script command line arguments
                    |bashsupport-cmdline-args|
                1.7.3 Bash command line arguments
                    |bashsupport-bash-cmdline-args|
                1.7.4 Save and check syntax
                    |bashsupport-syntax-check|
                1.7.4.1 Error format
                    |bashsupport-errorformat|
                1.7.4.2 Syntax check options
                    |bashsupport-syntax-check-options|
                1.7.5 Start debugger
                    |bashsupport-debugger|
                1.7.6 Hardcopy
                    |bashsupport-hardcopy|
                1.7.7 Xterm size
                    |bashsupport-xterm|
                1.7.8 Output redirection
                    |bashsupport-output|
                1.8 Menu 'Help'
                    |bashsupport-help|
                2. Usage without GUI
                    |bashsupport-usage-vim|
                3. Hot keys
                    |bashsupport-hotkeys|
                4. Customization and configuration
                    |bashsupport-customization|
                4.1 Files
                    |bashsupport-custom-files|
                4.2 Global variables
                    |bashsupport-custom-variables|
                4.3 The root menu
                    |bashsupport-custom-root|
                4.4 System-wide installation
                    |bashsupport-system-wide|
                5. Template files and tags
                    |bashsupport-templates|
                5.1 Template files
                    |bashsupport-templates-files|
                5.2 Macros
                    |bashsupport-templates-macros|
                5.2.1 Formats for date and time
                    |bashsupport-templates-date|
                5.3 Templates
                    |bashsupport-templates-names|
                5.3.1 Template definition
                    |bashsupport-templates-definition|
                5.3.1 Template names
                    |bashsupport-templates-names|
                5.3.2 The jump tags <+text+> etc.
                    |bashsupport-templates-jumptags|
                5.3.3 Command Ctrl-j
                    |bashsupport-Ctrl-j|
                5.4 Additional filenames with filetype 'sh'
                    |bashsupport-also-bash|
                6. Bash dictionary
                    |bashsupport-dictionary|
                7. Additional Mappings
                    |bashsupport-ad-mappings|
                8. Windows particularities
                    |bashsupport-windows|
                9. TROUBLESHOOTING
                    |bashsupport-troubleshooting|
                10. Release Notes
                    |bashsupport-release-notes|
                How to add this help file to Vim's help
                    |add-local-help|
            }}}
    Hotkeys för Vim Bashmode {{{
            evince ~/Dropbox/vim-bash_hotkeys.pdf &
        bash-support.vim

    HOT KEYS
    . 
    Key mappings for Vim and gVim.
    Plug-in: http://vim.sourceforge.net
    Fritz Mehner (mehner.fritz@fh-swf.de)
    (i) insert mode, (n) normal mode, (v) visual mode

    Bash
        \bps    parameter substitution (list)
        \bsp    special parameters (list)
        \ben    environment (list)
        \bbu    builtins (list)
        \bse    set options (list)
        \bso    shopts (list)
    Comments
        [n] \cl     end-of-line comment
        [n] \cj     adjust end-of-line comments
        \cs     set end-of-line comment col.
        [n] \cc     code → comment
        [n] \cu     uncomment code
        \cfr        frame comment
        \cfu        function description
        \ch     file header
        \cd     date
        \ct     date & time
        \css        script sections
        \ckc        keyword comments
        \cma        plug-in macros
        \ce     echo " actual line "
        \cr     remove echo from actual line
    . 
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i, v)
    (n, i, v)
    (n)
    (n, i, v)
    (n, i, v)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)
    (n, i, v)

    Statements
        \sc     case in ... esac
        \sei        elif then
        \sf     for in do done
        \sfo        for ((...)) do done
        \si     if then fi
        \sie        if then else fi
        \ss     select in do done
        \su     until do done
        \sw     while do done
        \sfu        function
        \se     echo -e ""
        \sp     printf "%s"
        \sae        array element $.[.]
        \saa        arr. elem.s (all) $.[@]
        \sas        arr. elem.s (1 word) $.[*]
        \ssa        subarray $.[@]::
        \san        no. of arr. elem.s $.[@]
        \sai        list of indices $.[*]
    Tests
        \ta     arithmetic tests (n, i)
        \tfp        file permissions (n, i)
        \tft        file types (n, i)
        \tfc        file characteristics (n, i)
        \ts     string comparisons (n, i)
        \toe        option is enabled (n, i)
        \tvs        variables has been set (n, i)
        \tfd        file descr. refers to a terminal (n, i)
        \tm         string matches regexp (n, i)
    IO-Redirection
        \ior        IO-redirections (list) (n, i)
        \ioh        here-document (n, i)
    Pattern Matching
        pzo     zero or one, ?( | )
        pzm     zero or more, *( | )
        pom     one or more, +( | )
        peo     exactly one, @( | )
        pae     anything except, !( | )
        ppc     POSIX classes
        pbr     $BASH_REMATCH[0 . . . 3]
    Snippets
        \nr     read code snippet
        \nv     view code snippet
        \nw     write code snippet
        \ne     edit code snippet
        \ntl    edit templates
        \ntr    reread templates
        \nts    choose style
    Run
        \rr     update file, run script (n, i, v 1 )
        \ra     set script cmd. line arguments (n, i)
        \rba        set Bash cmd. line arguments (n, i)
        \rc     update file, check syntax (n, i)
        \rco        syntax check options (n, i)
        \rd     start debugger (n, i)
        \re     make script executable/not exec. 1 (n, i)
        \rh     hardcopy buffer (n, i, v)
        \rs     plug-in settings (n, i)
        \rx     set xterm size (n, i)
        \ro         change output destination (n, i)
    Help
        \hb     display the Bash manual
        \hh     help (Bash builtins)
        \hm     show manual (cmd. line utilities)
        \hp         help (plug-in)
    . 
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n, i, v)
    (n, i)
    (n, i)
    (n, i)
    (n, i)
    (n,i)
    (n,i)
    (n,i)
    (n,i)
    }}}
        }}}
        c-programming in vim {{{
            http://www.alexeyshmalko.com/2014/using-vim-as-c-cpp-ide/
            http://stackoverflow.com/questions/4237817/help-with-configuring-vim-for-c
            http://www.thegeekstuff.com/2009/01/tutorial-make-vim-as-your-cc-ide-using-cvim-plugin
            http://www.vim.org/scripts/script.php?script_id=213

        evince ~/Dropbox/cprogramming-invim.pdf &

        }}}

        (vim quickref-card) {{{
            ~/Dropbox/vim-recipes.pdf
        }}}
        hacking vim {{{
            evince ~/Dropbox/Hacking\ Vim.pdf &
        }}}
    ProVim

    VIMCASTS.ORG ******** {{{
            http://vimcasts.org/
            http://vimcasts.org/training/

            http://vimcasts.org/categories/
            Appearances
                5 articles
            autocommands
                5 screencasts
            colorschemes
                1 screencast, 2 articles
            Commandline mode
                3 screencasts
            Copy and Paste
                7 screencasts, 3 articles
            Customizing Vim
                6 screencasts, 2 articles
            Editing text
                15 screencasts
            Essays
                6 articles
            Ex commands
                8 screencasts
            Expression register
                3 screencasts
            External commands
                2 screencasts, 2 articles
            File explorers
                1 screencast, 1 article
            folding
                2 screencasts
            Formatting text
                4 screencasts
            git
                6 screencasts, 3 articles
            Insert mode
                6 screencasts
            Managing your workspace
                5 screencasts, 1 article
            meta
                15 articles
            Navigating a document
                3 screencasts, 1 article
            Navigating a project
                5 screencasts
            Neovim
                2 articles
            Opening files
                3 screencasts
            plaintext
                4 screencasts
            plugins
                17 screencasts, 5 articles
            Practical Vim
                9 articles
            registers
                10 screencasts, 3 articles
            Regular expressions
                7 screencasts
            Repetition
                6 screencasts
            ruby
                1 screencast, 2 articles
            search
                7 screencasts
            substitution
                4 screencasts
            Text objects
                1 screencast, 2 articles
            The argument list
                5 screencasts, 2 articles
            undo
                3 screencasts, 1 article
            vimdiff
                3 screencasts
            vimgrep
                4 screencasts, 2 articles
            Vimscript
                5 screencasts
            Visual mode
                8 screencasts
            Whitespace
                6 screencasts
            workflow
                7 screencasts
    }}}
        vim wikisupport {{{
            https://github.com/vimwiki/vimwiki

            index {{{
                Text objects
                ah . . . . . . . . . . . . . . . . . A header with leading empty lines
                ih . . . . . . . . . . Inner header without leading empty lines
                vah . . . . . . . . . . . . . . . . . . . . . . . Select header with contents
                dah . . . . . . . . . . . . . . . . . . . . . . Delete header with contents
                yah . . . . . . . . . . . . . . . . . . . . . Change header with contents
                VimWiki REFERENCE CARD

                Open wiki
                n\ww . . . . . . . . . . . . . . . . . Open index file of the n-th wiki
                n\wt . . . . . . . . . . . . . . . . . . . . . . . . . Open index file in a tab
                \ws . . . . . . . . . . . . . . . . . . . List and select available wikies
                Local mappings
                Enter . . . . . . . . . . . . . . . . . . . . . . Follow/Create WikiWord
                Shift+Enter . . . . . . . Split and follow/create WikiWord
                Ctrl+Enter Vertical split and follow/create WikiWord
                Backspace . . . . . . . . . . . . Go back to previous WikiWord
                Tab . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Find next WikiWord
                Shift-Tab . . . . . . . . . . . . . . . . . . Find previous WikiWord
                \wd . . . . . . . . . . . . . . . . . . . . . . Delete WikiWord you are in
                \wr . . . . . . . . . . . . . . . . . . . . Rename WikiWord you are in
                Ctrl-Space . . . . . . . . . . . . . . . . . . . Toggle list item on/off
                = . . . . . . . . . . . . . . . . . . . . . . . . . . Add or create header level
                - . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Remove header level
                Internal Links
                TextText . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . WikiWord
                !TextText . . . . . . . . . . . . . . . . . . . . . . . . . . Not a WikiWord
                [[Text text]] . . . . . . . . . . . . . . . . . . . . . Link with spaces
                [[Text text | Text]] . . . . . . . . . Link with description
                External links
                plain link: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . http://site/
                link with description . . . . [http://site/ home page]
                plain link to image . . . . . . . . . . . . http://site/pic.jpg
                link to local image . . . . . . . . . . . . . [[images/pic.jpg]] 1
                double bracketed link . . . . . [[http://site/pic.jpg]]
                link with description . . . . . . . . . . . . . [[http:|comment]]
                link with alternate text . . . . . . . . . . [[http:|comment|]]
                link to local file . . . . . . . . . . . . [[file://C:/book.pdf]]
                Syntax
                *text* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . bold text
                text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . italic text
                ~~text~~ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . strikeout text
                ^text^ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . super script
                ,,text,, . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . sub script
                `code` . . . . . . . . . . . . . . . . . . . . . . . . . . .text without syntax
                4 Spaces text . . . . . . . . . . . . . . . . . . . . . . blockquote text
                ---- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . horizontal line
                <!-- text --> . . . . . . . comment: not shown in HTML
                = text = . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . header
                == text == . . . . . . . . . . . . . . . . . . . . . . . . . . . . header
                === text === . . . . . . . . . . . . . . . . . . . . . . . . . header
                ==== text ==== . . . . . . . . . . . . . . . . . . . . . . . header
                ===== text ===== . . . . . . . . . . . . . . . . . . . . . header
                ====== text ====== . . . . . . . . . . . . . . . . . . header
                level
                level
                level
                level
                level
                level
                links with some style:
                with alternate text:
                [[http:|cool|width:150px; height:120px;]]
                without alternate text:
                [[http:||width:150px; height:120px;]]
                thumnail links:
                [http://site/pic.jpg http://site/thumb.jpg]
                [[http://site/pic.jpg|http://site/thumb.jpg]]
                1
                2
                3
                4
                5
                6
                Lists
                Indent list items with at least one space.
                * item . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . bulleted list
                # item . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . numbered list
                term:: definition . . . . . . . . . . . . . . . . . . . definition list
                Paragraphs and Preformatted text
                <br> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . new line
                Paragraphs start from column one, no indentation and
                are divide by a blank line. If the line starts from whites-
                pace and is not a list it is ”preformatted” text.
                Tables
                || . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Separator of cells
                |--+--+--| . . . . . . . . . . . . . . . . . . . . . . . . .Heading separator
                Alt+Left . . . . . . . . . . . . . . . . . . . . . . . . . . . Shift column left
                Alt+Right . . . . . . . . . . . . . . . . . . . . . . . . .Shift column right
                Tab / Shift+Tab . . . Jump to the next / previous cell
                An indented table is centered in HTML.
                Folding/Outline
                zM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . close all folds
                zr . . . . . . . . . . . . . . . . . . . . . . . . . . . . reduce folding one level
                zR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . open all folds
                Folding on list items should work properly only if all of
                them are indented using current shiftwidth.
                Global commands
                :VimwikiGoHome . . . . . . . . . . Open index of current wiki
                :VimwikiTabGoHome . . . Open current index in new tab
                :VimwikiUISelect . . . Open index of the selected wiki
                Local commands
                :VimwikiFollowWord . . . . . . . . Follow/create WikiWord
                :VimwikiSplitWord . .Split & follow/create WikiWord
                :VimwikiVSplitWord Split vertical & follow WikiWord
                :VimwikiGoBackWord . . . To WikiWord you came from
                :VimwikiNextWord . . . . . . . . . . . . . . Find next WikiWord
                :VimwikiPrevWord . . . . . . . . . . Find previous WikiWord
                :VimwikiDeleteWord . . . . Delete WikiWord you are in
                :VimwikiRenameWord . . Rename WikiWord you are in
                :Vimwiki2HTML . . Convert current WikiPage to HTML
                :VimwikiAll2HTML . . Convert all WikiPages to HTML
                :VimwikiToggleListItem . . . . . Toggle list item on/off
                :VimwikiTableMoveColumnLeft . . . . . Shift column left
                :VimwikiTableMoveColumnRight . . Shift column right
                This card may be freely distributed under the terms of the GNU
                1
                Path to image relative to: vimwiki-option-path html
                general public licence
            }}}
            evince ~/Downloads/vimwiki_quickreference.pdf &
        }}}

        markdown** {{{
            https://github.com/plasticboy/vim-markdown
            https://github.com/suan/vim-instant-markdown
            http://stackoverflow.com/questions/10964681/enabling-markdown-highlighting-in-vim
            https://news.ycombinator.com/item?id=10271028
        }}}


        vim usermanual {{{
            evince ~/Dropbox/vim_user_manual.pdf &

            skipped hittills vid genomgång (se mer så fort möjl.):
            Editing formatted text - s126 pcpdf vim u.m. (virtual replacemode, mm)
            Repeating (s135++ pcpdf)  [gv, C-a/C-x, {{{
                :argdo %s/\<x_cnt\>/x_counter/ge | update     +argdo, windo, bufdo, tabdo

                använda fil m viminstruktioner som skript (=se också mer egna dictionaryskripten******)
                for file in *.txt; do
                    vim -e -s $file < change.vim
                    lpr -r tempfile
                done

                ls | vim -

                köra vimfil som skript på en fil. Obs! normalmodekommandon**
                    vim -s script file.txt

                "spela in" 'vimfil som skript'-fil, med -w (och -W = from scratch/börja om***)
                    vim -w script file.txt
            }}}
            sökkommandon och mönster/patterns(regexes) s139+***** [\c m.fl., wrap(scan), OFFSETS(/x/e-2, /x/b+4, ?end?-2) {{{
                ??????????
                A related item is "\&". This requires that both alternatives match in the same place. The resulting match uses the last alternative. Example: >
                /forever\&...

                /"[^"]*"

                /\a      Finds alphabetic characters.
                few more of these:
                item

                \d
                \D
                \x
                \X
                \s
                \S
                \l
                \L
                \u
                \U
                Note:
                Using
                range
                These
                match
                This is equal to using "/[a-zA-Z]".
                matches

                digit
                non-digit
                hex digit
                non-hex digit
                white space
                non-white characters
                lowercase alpha
                non-lowercase alpha
                uppercase alpha
                non-uppercase alpha
                equivalent ~

                [0-9]
                [^0-9]
                [0-9a-fA-F]
                [^0-9a-fA-F]
                [
                ]
                [^
                ]
                [a-z]
                [^a-z]
                [A-Z]
                [^A-Z]





                item
                \i
                \I
                \k
                \K
                \p
                \P
                \f
                \F
                matches
                identifier characters
                like \i, excluding digits
                keyword characters
                like \k, excluding digits
                printable characters
                like \p, excluding digits
                file name characters
                like \f, excluding digits
                option ~
                'isident'
                'iskeyword'
                'isprint'
                'isfname'




                /the\_s\+word
                "\_." matches any character or a line break.
            }}}
            folding, s147
            MOVING THROUGH PROGRAMS, s154
            EDITING PROGRAMS(=compiling mm), s163
            The Gui, s173
            the Undo tree, s177**** (earlier/later, timetraveling, 

            s180 - Making new commands (mapping******, s186 Autocommands, s189 Ignoring events
            s190-224 - ******WRITING A VIM SCRIPT
            s225 add new menus
            s231 using filetypes
            234 - your own syntax highlighting
                lang 245
                install 251
        }}}
        VIM REFERENCE MANUAL
         usr_41 *
        VIMSCRIPT THEHARDWAY {{{
            http://learnvimscriptthehardway.stevelosh.com/
              ~/Dropbox/lvimscrhard.pdf
            gvim ~/Dropbox/anteckningardel1_ocr-vimscriptthehardway.txt
        }}}
        evince ~/Dropbox/vim-buffers.pdf &

}}}

    https://vim.help/41-write-a-vim-script
    ~/Dropbox/rsc/aubooks/comp/vimuserman.pdf
     ~/Empire/Doks/Comp/editor/vim/PRACTICAL_VIM.pdf
     ~/Empire/Doks/Comp/editor/vim/lvimscrhard.pdf ~/Empire/Doks/Comp/vim/lvimscrhard.txt ~/Empire/Doks/Comp/vim/lvimscrhard_def20.txt
     ~/Empire/Doks/Comp/editor/vim/vimlang-ibmtuts_5parts.txt
        ~/Dropbox/rsc/Doks/phone.fmt35/todo/vimscr-ibmtuts.txt
     ~/Empire/Doks/Comp/vim/modvim.pdf
    ----
    http://vimcasts.org/episodes/show-invisibles/
     http://vimcasts.org/episodes/page/8/  #=episode 1 and forward(!) (newest episodes =page 1)

    https://www.linuxlinks.com/excellent-free-books-learn-vim/
    https://www.linuxlinks.com/excellent-free-books-learn-viml/


        https://www.youtube.com/watch?v=E-ZbrtoSuzw     #going mouseless with vim, tmux and hotkeys

TODO: MODERN VIM (DREW NEILL); ULTISNIPS**; FUGITIVE; NERDTREE??

        thesaurus {{{
            https://www.thegeekstuff.com/2008/12/vi-and-vim-editor-3-steps-to-enable-thesaurus-option/ (******(!!) 2020start++ (**))
        $ vim /home/jsmith/mythesaurus.txt
        important,valuable,substantial,significant  #or separ. by spaces
            set thesaurus+=/home/jsmith/mythesaurus.txt
        }}}

https://duckduckgo.com/?q=vim+text+file+autocomplete+suggestions&t=newext&atb=v332-1&ia=web
https://linuxhint.com/vim_auto_complete/
https://lual.dev/blog/how-to-use-autocompletion-in-vim/
    https://github.com/cwfoo/vim-text-omnicomplete  *******
https://vim.fandom.com/wiki/Autocomplete_with_TAB_when_typing_words
    https://vi.stackexchange.com/questions/24683/how-to-enable-autocomplete-for-writing-in-english
            https://www.slant.co/topics/3999/~best-semantic-autocompletion-plugins-for-vim


https://www.vim.org/scripts/script.php?script_id=365
https://vim.fandom.com/wiki/Mapping_keys_in_Vim_-_Tutorial_(Part_3)
  https://gist.github.com/manasthakur/5afd3166a14bbadc1dc0f42d070bd746    #creating your own ag.vim
  https://thoughtbot.com/blog/faster-grepping-in-vim

https://www.vim.org/scripts/script.php?script_id=3130

  vim for writers
    ------
    https://leanpub.com/anidecalledvim      #100 kr (*****)
     https://leanpub.com/boostyourcodingfuwithvscodeandvim  ****
    https://leanpub.com/painless_vim
        https://github.com/vim-scripts/grep.vim
    https://vim.fandom.com/wiki/Using_vim_as_calculator
https://blog.mikecordell.com/2015/01/27/better-fuzzy-search-with-ctrl-p-in-vim.html     #ag + fuzzy search(**)
                    https://github.com/ctrlpvim/ctrlp.vim
        https://www.reddit.com/r/vim/comments/6w2hkx/best_fuzzy_search_that_isnt_youcompleteme/
https://www.quora.com/Why-are-tools-like-Vim-and-Emacs-still-used-for-coding-I-know-these-programs-DO-allow-some-features-but-is-the-trade-off-really-worth-it

}}}

rsc/tools: modelines (**) {{{
vim: fdm=indent:fdl=1:
  vim: fdm=marker           vim: set fdm=marker
  Vim: Indents as Spaces ****         tabstop, softtabstop, shiftwidth, expandtab(!!)  (+ :retab  :%retab)
  vim: noai:ts=8:
  vim: filetype=help expandtab textwidth=78 tabstop=8 norightleft foldenable foldlevel=0 :
  vim: textwidth=78 nowrap tabstop=8 shiftwidth=4 softtabstop=4 noexpandtab
  vim: filetype=help
  vim: set fo+=n :
}}}
translate-shell {{{
  https://duckduckgo.com/?q=translate+shell+vim&t=newext&atb=v369-1&ia=web
  https://github.com/echuraev/translate-shell.vim
  https://github.com/echuraev/translate-shell.vim/blob/master/doc/trans.txt
  +See More: ~/.vimrc [****]
}}}
==== PROJECT/TODO = 'VIM: THE EXPRESSION REGISTER' [****] {{{
https://duckduckgo.com/?q=vim+%5C%3D+evaluate&t=newext&atb=v369-5&ia=web
  https://unix.stackexchange.com/questions/8101/how-to-insert-the-result-of-a-command-into-the-text-in-vim
  https://vimdoc.sourceforge.net/htmldoc/change.html#quote=
  search 2: vim expression register
  https://stackoverflow.com/questions/7027741/what-is-the-purpose-of-the-expression-register
  https://vi.stackexchange.com/questions/25638/using-the-expression-register-in-vim
    http://vimcasts.org/episodes/simple-calculations-with-vims-expression-register/
  http://vimcasts.org/episodes/evaluating-scripts-with-vims-expression-register/
    https://vim.fandom.com/wiki/Evaluate_an_expression_in_any_mode
}}}
--
lang.colors(**!) +lang-codes {{{
            new: palenight theme
    good general scheme:
        srcery (**)
TODO: SCOUR THE VIMRC-FILE 1 + PICK OUT (AND TEST MORE) GOOD COL.SCHEMES FOR DIFF. LANGS(!!)


    cl                  clojure
    supercollider       supercollider
    vb                  starbasic/lo-basic/visual basic
    sml                 standard ml

    csound

    txt:  ron**
        code to extract**: d, javascript, Python, java
    ----
    supercollider {{{
        pablo  gotham  neonwave
        slate  evening koehler
        Industry **
        oceandeep
    }}}
        sh|bash:  . {{{
            ron **
          murphy*,  industry**!,  pablo|votl_dark***!, 
          torte
                lettuce(!|??)
             cobalt2(=nice blue, white, green)
          solarized||bluedrake (=nice subdued blue**)
            darkblue    herokudok(=nice lightblue pastel(??(!)))
        --
        monochrome(*(*))
        }}}
     javascript:  . {{{
         vo_dark(=nice!(!)),  industry|votl_dark|pablo(!)(!)
                lettuce(??)
          tomorrownight-bright(=very good baseline**)
            onedark(=hm, a bit nice), herokudok(=hm, bit nice blue pastel(!!))
         monochrome[!!]
         --
         slate(=nice mellow grey(??))
         --
         birdsofparadise(=nice mellow basic brown)
          cobalt2(=nice basic blue, white and green)
        colorsbox-stblue[=nice cold wintery feel],  scooby(!*)
     }}}
      greasemonkey  onedark
    html, css
    sql:  atom,  ron,  industry, evening,  pablo, torte
      cobalt2, slate  herokudok, vo_dark, votl_dark
    python: molokai_dark  darkblue ****,  votl_dark[!!(!!)]  tomorrownight-bright (**) {{{
        set syntax=python | colors tomorrownight-bright
    }}}
    clojure
        industry **
            srcery
        darkslategray  darkblue
        cobalt2
        elflord
         onedark
    ocaml / sml
        srcery, molokai_dark
    ruby
         molokai
       cobalt2, gotham(+votl_dark)
         lettuce
    dlang: Molokai  Industry  evening  Elda   birdsofparadise  zenburn   abbot
      lilypond:   {{{
          murphy, onedark/japanesque(=purple), bluedrake,  industry
          tomorrownight-bright,  birdsofparadise,  colorsbox-stblue
          srcery
          base...
          elflord(!!)(=dark, good contrast, bright notes  koehler*(=same)
            [magicwb  =quirky**(*)]  navajo(=really easy to see cursor-pos.)    shadesofamber
          darkslategray(!)  onedark(=nice pastel purple)  evening
        torte[!(!)]  pablo(!)@   ron[=good, but maybe a bit boring(!)]
        tomorrownight-bright(!)!!!!  industry[!!(!)]   |tomorrownight-blue   turbo[!(**)]
        colorsbox-stblue
          bluedrake cobalt2  solarized*(*)
      }}}
    vimscript:  ron** {{{
        solarized[!!]
          tomorrownight-bright
            elflord,  bluedrake(=very blue)
                slate(=good basic)  torte
          lettuce(hm, =interesting neon blue(!!))
            onedark(=interesting subdued colors)
        turbo[(!)]
        magicwb(=fun crazy pastel(!))
         celticsaway[!]
        darkslategray(=nice icemint)
    }}}
    vim-help
        onedark, darkblue|scooby  colorsbox-stblue(?)
    lua:  industry [***(*)] {{{
    }}}
    rlang:  ron *  cobalt2* {{{
        japanesque(**(!))  cobalt2(** (=blue + green))
            industry**(*),  onedark(!)  koehler   murphy((!))
        monochrome,  (tomorrownight-bright|votl_dark)
            solarized*(*)   turbo
        birdsofparadise,  oceandeep
            lettuce
        srcery(=green strings)
    }}}
    basic||vb:  torte | srcery  (+funkar suver. m. många av standardfärgerna(**)) {{{
        votl_dark**[=vb****], tomorrownight-bright*, solarized*, industry* 
        ,  birdsofparadise(*),
        japanesque*, colorsbox-stblue(*)   ron(*)    pablo[*]   scooby
    }}}
    powershell[.ps1 syntax=powershell]:  oceandeep |celticsaway[!]  |darkslategray  warriors-away|[tomorrownight-blue|scooby*] {{{
        evening*, desert**(*!)(||zenburn
        otaku(!)|   japanesque()  khaki(*(*))|colorsbox-greenish   celticsaway(*)|morning
            shadesofamber
    }}}
    scheme|guile:  vo_dark(?) {{{
        lettuce,  industry(!), koehler*
        oceandeep
         vo_dark**
         screry, votl_dark**(!)
        onedark
          scooby,   torte*  desert(*),  evening**()
    }}}
    elixir:  bluedrake {{{
        oceandeep  #cool turquoise
        ----
        pablo  #green+white
         solarized8_darkhigh  #dark turquoise
        molokai
        scooby
            neonwave
            gotham
        (herokudoc-gvim)
            cobalt2


        ron**, lettuce ***
          vo_dark **  #dark w. purple/white
        srcery, zenburn **(!!)   birds-of-paradise  desert

         slate  #soft gray + yellow
        navajo-night  #soft blue
        neonwave *, onedark
        herokudok
    }}}
    . cypher(* =noe4j etc):  pablo|herokudok | rockets   {{{
        rockets-away(!)  solarized**(!(!))  industry[!!] | tomorrownight-bright[!!]  lettuce(**)
          pablo[!!(!)!!]   herokudoc[!!!!]   oceandeep(='frosty mint'[**])
        evening **(*)   [monochrome !!]
          slate(=like torte for basic)
        desert(='green'(**))  onedark**
          murphy(**)
            elflord(=purple)  abbott(??)
        eva((*))
    }}}
        sparql, gremlin
    elisp:  (srcery  | onedark |lettuce) {{{
        set syntax=lisp | colors lettuce
             onedark(**)    japanesque(??)
            lettuce(!), (industry(!!!)),   monochrome,   pablo  abbott
        srcery[!!], darkblue(?), atom(?),  votl_dark
    }}}
    xml:  blue[!!]
    json: koehler
    puppet: pablo, torte[!]/koehler,  industry
    elm
    svg:  srcery | votl_dark ** | colorsbox-stblue | cobalt2 {{{
          srcery,  votl_dark ****
        abbot, atom(!), base16,  cobalt2*, colorsbox-stblue**,  vo_dark,  
        (celticsaway, 
    }}}
    ps:   {{{
                srcery(**(*))
          industry(!!(*))   elflord  turbo[!!(**)]   tomorrownight-bright(!|?)
        ron*(*)  evening**  slate[**(!)]
          bluedrake(*(?))  cobalt2(!)  birdsofparadise(*)
        (shadesofamber)  blue((*))   vo_dark[[!]]
    }}}
    osl:  tomorrownight-bright(*)
    java[!!] {{{
        birdsofparadise, molokai, holokai, torte
        ----
        industry[!!]
                onedark(**(*))
            atom[=calm pastel blue],
          zenburn**(=nice pastel semi-camostyle(!))
        bluedrake, solarized (=very nice blue|turquoise)**(!!)
                        srcery
    }}}
    kotlin  molokai/holokai  ron, votl_dark
    haskell(*)
    reason/rescript
        elda, holokai
            ron+vo_dark
      (asp.Net)
    c++: Pablo, monochrome* | neonwave   industry | srcery(**) {{{
                scooby(), 
                navajo, neonwave, oceandeep(?),  onedark, tomorrownight-bright,  (desert?)
            shadesofamber(*)
    }}}
    c#: molokai_dark
        vo_dark (****)
    F#/fsharp: industry   neonwave  oceandeep  industry/pablo, slate  shadesofamber+vo_dark  scooby  atom {{{

            murphy, desert  tomorrownight_blue
         lettuce
           onedark
         cobalt  turbo
    }}}
    c: {{{
        (ron), abbot(?),  atom, sulphur,  birdsofparadise(!!), cobalt 2(!)
        donbass(=light **)
        elda*,  herokudoc*,   monochrome **,
         tomorrownight-bright, votl_dark
        desert, evening, industry, pablo
    }}}
     golang:   {{{
        industry **(!!)  votl_dark(**!)  ||  elflord(!!*)
            holokai
            cobalt2 (=nice blue+green)
              ((evening))
          vo_dark (=minty(*(*)))
        slate(=minty blue text(!))  darkslategray   slate(!)
          [monochrome]
     }}}
    vlang
    ada
        navajo_night, holokai
      slate
      desert, koehler
    --
    perl:  lettuce

}}}
LANG.SETTINGS {{{
___iskeyword_langsettings
  Java
    set iskeyword+=@
    .
  XML
    :-
  Scheme
    -/*
  Lisp
    -*
  Clojure
    set iskeyword+=@:$-/*=?>'
}}}
more col-schemes nov. 2021 (**(!)) {{{

https://github.com/rafi/awesome-vim-colorschemes  **
https://vimcolorschemes.com/page/5

    ~/Dropbox/config/vim/colors/new2021nov (+softlink all files back up to parent-dir (**))

    https://vimcolorschemes.com/page/6
    vim-fahrenheit  #orange-black
    carbonized      #orange-grey
    vim-aldmeris    #blue-grey

    https://vimcolorschemes.com/page/8
    (vim-darkmate(??|!))
     office     #green-grey
    (twilight(!!))
    [skull-vim]     #green-grey
    dark-theme.vim  #green|purple-grey
    [superman]
    [vim-colors]

    https://vimcolorschemes.com/page/10
    vim-twilight    #yellow-brown
     vim-vwilight
     sunburst-vim
    solas.vim       #white-turquoise

    https://vimcolorschemes.com/top/page/3
    night-owl.vim   #white-darkblue
    rigel           #(solrized but brighter(##))
    'vim'       #darkturquoise-darkgrey **
    alduin      #('like twilight')

    https://vimcolorschemes.com/page/5
    vim-material-theme  #blue-darkturquoise(?*)
    ((typewriter    #white-grey(!)))
    (vimspectr      #reddish-brown)
}}}
set fonts (gvim) ** {{{
  List available fonts in Gvim ****     set guifont=*
list available fonts gvim {{{
    Agave Regular
    Agave Italic
    Agave Bold Italic
    Agave Bold
    Bitstream Vera Sans Mono Roman
    Bitstream Vera Sans Mono Bold
    Bitstream Vera Sans Mono Oblique
    Bitstream Vera Sans Mono Bold Oblique
    BPG Courier GPL&GNU Regular
    BPG Courier GPL&GNU Italic
    BPG Courier GPL&GNU Bold
    BPG Courier GPL&GNU Bold Italic
    BPG Courier S GPL&GNU Regular
    BPG Courier S GPL&GNU Italic
    BPG Courier S GPL&GNU Bold
    BPG Courier S GPL&GNU Bold Italic
    DejaVu Sans Mono Book
    DejaVu Sans Mono Bold
    DejaVu Sans Mono Oblique
    DejaVu Sans Mono Bold Oblique
    FreeMono Regular
    FreeMono Bold
    FreeMono Oblique
    FreeMono Bold Oblique
    Hack Regular
    Hack Bold
    Hack Italic
    Hack Bold Italic
    Inconsolata Medium
    Inconsolata Italic
    Inconsolata Bold
    Inconsolata Bold Italic
    Larabiefont Regular
    Larabiefont Italic
    Larabiefont Bold Italic
    Larabiefont Hold
    Liberation Mono ReguLar
    Liberation Mono Bold
    Liberation Mono Italic
    Liberation Mono Bold Italic
    Luxi Mono Regular
    Luxi Mono Bold
    Luxi Mono Oblique
    Luxi Mono Bold Oblique
    Mitra Regular
    Mitra Italic
    Mitra Bold
    Mitra Bold Italic
    Monofonto Regular
    Monofonto Italic
    Monofonto Bold
    Monofonto Bold Italic
@@  Monospace Regular
    Monospace Bold
    Monospace Italic
    Monospace Bold Italic
    Nimbus Mono PS Regular
    Nimbus Mono PS Bold
    Nimbus Mono PS Italic
    Nimbus Mono PS Bold Italic
    Noto Color Emoji Regular
    Noto Color Emoji Italic
    Noto Color Emoji Bold
    Noto Color Emoji Bold Italic
    Noto Mono Regular
    Noto Mono Italic
    Noto Mono Bold
    Noto Mono Bold Italic
    Noto Sans SignWriting Regular
    Noto Sans SignWriting Italic
    Noto Sans SignWriting Bold
    Noto Sans SignWriting Bold Italic
    OCRA Medium
    OCRA Italic
    OCRA Bold
    OCRA Bold Italic
    OCRABold Bold Italic
    OCRABold Bold
    OCRAItalic Bold Italic
    OCRAItalic Italic
    OCR B Inverted Sharp
    OCR B Regular
    OCR B Inverted
    OCR B Outline
    OCR B Sharp
    OCR B Bold
    OCR B Bold Italic
    OCR B Oblique
    Terminus Medium
    Terminus Bold
    Terminus MediumOblique
    Terminus BoldOblique
    Tlwg Mono Regular
    Tlwg Mono Bold
    Tlwg Mono Oblique
    Tlwg Mono Bold Oblique
    Tlwg Typo Regular
    Tlwg Typo Bold
    Tlwg Typo Oblique
    Tlwg Typo Bold Oblique
    Ubuntu Mono Regular
    Ubuntu Mono Bold
    Ubuntu Mono Italic
    Ubuntu Mono Bold Italic
    Unifont Regular
    Unifont Italic
    Unifont Bold
    Unifont Bold Italic
    Unifont Bold
    Unifant Bold Italic
    Unifont CSUR Regular
    Unifont CSUR Italic
    Unifont CSUR Bold
    Unifont CSUR Bold Italic
    Unifont Upper Regular
    Unifont Upper Italic
    Unifont Upper Bold
    Unifont Upper Bold Italic
    Unispace Regular
    Unispace Bold
    Unispace Italic
    Unispace Bold Italic
}}}
  Set Font Gvim **(*)                   set guifont=Monospace\ Regular\ 13
  Location of Fonts Vim/Gvim [**(!!)]

  let &guifont="DejaVu Sans Mono:h9"
  set guifont=Consolas:h10
}}}


.   #### I N D E X / O M R Å D E N ####  {{{
___VIMINDEX

    Help(s15) {{{


        tips/exempel: installera hjälpfil för plugin (matchit.vim i detta fallet)
            skapa ~/.vim/doc el andra om behövs
            :!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin       
            :!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc
            :helptags ~/.vim/doc
                =därefter funkar t.ex. :help g%
        -----------------------

        :h local-additions  =visa titlar för dessa lokala tillägg, som du sen kan hoppa med till c-] mm



        hjälpämne/länk   |manual-copyright|   = :h manual-copyright
        följ |hyper-länk|   #(kallas tag) c-]
        gå tillbaks efter 'följ hyperlänk'  ;  C-t/C-o
        :tab help gt        #'tab' funkar för alla kommandon som öppnar nytt fönster

        :h(elp)     #öppna helpfilernas stora index *******
        :h index    #=KOMPLETT LISTA ÖVER ALLA KOMMANDON O TANGENTKOMB. I ALLA LÄGEN *******
                        (=BRA ÖVERBLICK + FÖR ATT KUNNA AVGÖRA OM EN VISS TANG.KOMB. ÄR UPPTAGEN FÖR MAPPING OCH KOMMANDON MM
        :h quickref
        :h user-manual  
            :h usr_toc
            :h usr_03  
        vim-referencemanual
        :h insert-index
        :h reference_toc

         |bashsupport.txt|                Bash Support                 March 25 2014
         |templatesupport.txt|         MM Template Support                  Mar 28 2014
         |vimwiki.txt|   A Personal Wiki for Vim
         |xml-plugin.txt|  Help edit XML and SGML documents.                   v1.84


        :h x
        :h deleting
            :h index
            :h user-toc.txt
        :h CTRL-H
        :h i_CTRL-H {{{
            v_u
            i_<Esc>
            c_<Del>
                o_

          visa tabell med alla modeprefix   |help-context|
        }}}
          v_
          c_
          o_
        :h -t           #kradsflagga
        :h 'nu(mber)'
        :h :quit
        :h word +c-d  =lista alla help-entries för 'word'
        :h i_<Up>
        :h E37    E13 E21  E173   W10(warning! changing a readonly file)

        :h function()   Function "subject".
        :h -commlopt    Command-line option "-subject".
        :h +comptimefeature    Compile-time feature "+subject".
        :h AutoComm(=autocomm-EventName)   Autocommand event "EventName".
        :h digraphs.txt   The top of the helpfile "digraph.txt". Similarly for any other helpfile.
        :h patt<Tab>   Find a help tag starting with "pattern".  Repeat <Tab> for others.
        :h patt<Ctrl-D>   See all possible help tag matches "pattern" at once.



        :helpgrep word (+se mer :h :helpgrep)     *******
        :helpgrep pattern   Search the whole text of all help files for pattern "pattern". Jumps to the first match. Jump to other matches with:

            :cn   next match
            :cprev :cN   previous match
            :cfirst  :clast   first or last match
            :copen  :cclose   open/close the quickfix window; press <Enter> to jump to the item under the cursor


    }}}
    :helpgrep (++egna kommandon)
    Inställningar {{{

        https://linuxprograms.wordpress.com/2012/05/22/location-of-vim-syntax-files-for-different-programming-languages/
    Speca/Ändra var Vim lägger Swapfilerna **** {{{
        gsök: specify where vim puts swap files
        https://stackoverflow.com/questions/1636297/how-to-change-the-folder-path-for-swp-files-in-vim
            = :set directory=
    }}}


        /usr/share/vim/
        /usr/share/vim/vim74/
            syntax/tex.vim
            ftplugin/tex.vim
            indent/tex.vim
            compiler/tex.vim
        KOLLA HJÄLPFIL FÖR SPECIFIK SYNTAX, T.EX. TeX  ;  |tex.vim| ******  

            autoload =plugins för att omnicompl. ska fungera på ett pr.språk****
                autoload/phpcomplete.vim
                autoload/clojurecomplete.vim
                autoload/csscomplete.vim
                autoload/htmlcomplete.vim
                autoload/gsök: javacomplete for vim ********
                autoload/javascriptcomplete.vim
                autoload/python3complete.vim
                autoload/pythoncomplete.vim
                autoload/sqlcomplete.vim
                autoload/ccomplete.vim
                autoload/README.txt
                autoload/xmlcomplete.vim
                autoload/rubycomplete.vim
                autoload/tohtml.vim
                autoload/syntaxcomplete.vim

        omnicompletion: tex {{{
            https://github.com/Shougo/neocomplete.vim/issues/56
            https://www.reddit.com/r/vim/comments/4fm7vo/vim_not_very_well_suited_for_latex/
        }}}
        omnicompletion: java {{{
            http://blog.vinceliu.com/2007/08/vim-tips-for-java-3-use-omni-completion.html
            http://www.vim.org/scripts/script.php?script_id=1785
            https://github.com/artur-shaik/vim-javacomplete2
        }}}



        :options   =option-fönstret: visar fönster m options + korta förkl. ******
         tryck enter på option (t.ex. noic) du vill ändra till  el redigera värde *****
         +tryck enter på optionname för att gå till fullständiga beskrivningen i help ******


        några startinställningar {{{

            :set compatible?  (svaret ska vara "nocompatible")
            :scriptnames  =se vilka skript och filer som körs när vim startas
                            sätta annan vimrc-fil (=-u?)

            starta vim helt nollställd =utan vimrc (t.ex. för att testa om man misstänker att den är korrupt)
            vim -u NONE -N
            +
            set nocompatible
            filetype plugin on
            (=eftersom en del av vims inbyggda funktioner implementeras m vimskript)

            vim -u mapp/essential.vim

        }}}

        ~/.vimrc
        $HOME/_vimrc ~
        $VIM/_vimrc ~
        redigera ens vimrc-fil ; :e(dit) $MYVIMRC
        gvimrc
        :edit $MYGVIMRC
        gvim -U thisrc ...      =speca egen gvimrc
        kolla om option compatible är satt {{{

            :set compatible?    #svarar med nocompatible (med vi = rekommenderas starkt) om satt till nej

        }}}
        lista alla filer som sourcas när vim startas (inkl. vilken vimrc) {{{

            :scriptnames

        }}}
        Inställningar med if-sats {{{

            if has("vms")
                set nobackup
            else
                set backup
            endif

        }}}

        SE OCKSÅ 'VANLIGA OPTIONS' LISTADE NERE VID OPTIONS


        exempelvimrc-filen installerad på många system  ;  $VIMRUNTIME/vimrc_example.vim ~

        :syntax enable
        set nocompatible
        set history=50
        set ruler
        set showcmd
        nnoremap Q gq
        filetype plugin indent on    #slår på de tre första valen
        autocmd FileType text setlocal textwidth=78 

    }}}
    grundinställn./tips för indentering programmering (shiftwidth mm) {{{

        +SE GRUNDINSTÄLLNINGARNA I EGNA VIMRC-FILEN ***

        :set autoindent
        'smartindent'
        :set shiftwidth=4
        :set softtabstop=4
        :expandtab          #om man bara vill ha blanksteg, och inte blandningar
            tabstop=4       #????


        för att justera tilltrasslad indentering sen tidigare:
         :set tabstop=3    t.ex.
         :retab 8

    }}}
    Installera Vim (vimbsd, vimwin, Vim8, Neovim) {{{

        Kolla vilken version av vim som är installerad mm ** {{{

            small, normal, big, huge(=rekommenderad)
             :h +feature-list

            :version
                (=skriver också ut rekommenderade o installerade vimrc-filer mm *****

        }}}
        vim8/n(eo)vim {{{

            http://tipsonubuntu.com/2016/09/13/vim-8-0-released-install-ubuntu-16-04/

            https://askubuntu.com/questions/430008/how-to-install-neovim-on-ubuntu
             gsök: vim 8 vs neovim
            https://www.reddit.com/r/neovim/comments/52eu6b/how_does_vim8_compare_to_neovim/
             gsök: getting vim8

        }}}
        minpac
        https://github.com/k-takata/minpac

    }}}
    VIM SOM IDE (PYTHON, markdown/pandoc, Latex ) ***** {{{

        https://github.com/vim-pandoc/vim-pandoc/blob/master/doc/pandoc.txt
        vim plugin for editing {latex} files

        https://realpython.com/blog/python/vim-and-python-a-match-made-in-heaven/

    }}}
    syntax colorhighlighting + Colorschemes {{{


        KOLLA HJÄLPFIL FÖR SPECIFIK SYNTAX, T.EX. TeX  ;  |tex.vim| ******  


        uman s44

        set filetype    =visar vilken filtyp som är satt/används *********
        set filetype=fortran    =sätt filtyp explicit och manuellt ********

        sätt filtyp m en modeline  ;  # vim: syntax=make   ******


        You might know how to detect the file type yourself. Often the file
        name extension (after the dot) can be used.
        See |new-filetype| for how to tell Vim to detect that file type.

        - There is no highlighting for your file type.
        You could try using a similar file type by manually setting it as
        mentioned above. If that isn't good enough, you can write your own
        syntax file, see |mysyntaxfile|.


        Colorschemes {{{

            And for a light background: >
            :set background=light
            <
            Make sure you put this _before_ the ":syntax enable" command,
            otherwise the colors will already have been set. You could do
            ":syntax reset" after setting 'background' to make Vim set the default
            colors again.

        }}}
        Skapa egen colorscheme ******* {{{

            s46 uman ********

            http://bytefluent.com/vivify/
            http://www.villustrator.com/

        }}}

        kolla tips på några intressanta färgkombinationer och förslag för såna  ;  :runtime syntax/colortest.vim



        SE MER OM MANUELL STYRNING OCH PÅ/AVSLAGNING AV SYNTAX OCH COLORS MM ******  s46uman  ___SEMER


    }}}
    Rekommenderade plugins, plugin management(vundle m.fl.) {{{
        ___plugins

        ycm för vim8/neovim(??) 
            https://github.com/Shougo/deoplete.nvim

        HTML/CSS (inkl EMMET-VIM ****) {{{
            https://stackoverflow.com/questions/2154193/using-vim-as-a-html-editor      #matchit, surround, allml
            ------

    ___emmet
        EMMET-VIM ******
                    https://docs.emmet.io/cheat-sheet/ (****)
            https://github.com/mattn/emmet-vim
                https://medium.com/vim-drops/be-a-html-ninja-with-emmet-for-vim-feee15447ef1

            https://raw.githubusercontent.com/mattn/emmet-vim/master/TUTORIAL   **** {{{
            +även mer detaljerat: https://docs.emmet.io/actions/match-pair/

            https://github.com/mattn/emmet-vim  #=remap emmet leader key ('redefine trigger key') *******
                https://stackoverflow.com/questions/23033849/change-emmets-leader-key-in-vim ****


            }}}

            css-pverktl *** NY! {{{
                https://docs.emmet.io/css-abbreviations/  ********

            }}}
            html/allm.-pverktl **** {{{

                lista specialtecken: ('2. Nesting operators')
                #   id                          ___count =1
                .   class
                $   platsh/var ordningstal
                 *   flera av något
                ------
                >   child                       ___count =1
                +   sibling                     ___count =1
                ^   climb-up
                *   multiplication              ___count =1
                ()  grouping


                Mata in html-5-definition  ;  html:5 <c-y>,
                MATA IN TVÅ TAGS (EN ÖPPNANDE O EN STÄNGANDE) FÖR ORDET 'DIV'  ;  div + c-y,

                 sudda en etikett (=öppnande o stängande)  ;  c-yk / vims klassiska 'dat'       #verkar köra kommandot :call emmet#removeTag()
                 sudda innehållet i en etikett (=texten mellan etikettsblocken)  ;  dit ***
                 Dra ihop etik. till kortformen (=likn 'hr')  ;  c-yj   #split/join tag
                Expandera en förkortn (=t.ex. div p id=foo(1-3) a-href  ;  div>p#foo$*3>a c-y,
                'Wrap with an abbreviation'(test1 test2 test3 till bulleted list)  ;  V + ul>li* c-y,  V + blockquote
                Tillfoga t.ex. .class-uttryck i redan inmatad t.ex. div-tag  ;  pekare på div-blocket, c-yu(pdate), .class+Enter

                anchor (hyperlink)                  a(trigger)
                länk/fillänk (stylesheets mm)*      link(trigger)
                p, div, h1, i, script

                Gå till förra/nästa redigeringspunkt i koden (= "" el ><)******  ;  c-yN/n  ******
                balansera tag inward/outward (=välj olika delar, som en hel tag)  ;  c-yd/D (el vims klassiska it/at-block ****)
                toggle comment ***  ;  c-y/

                Make anchor av t.ex. www.drstrang.se  ;  c-ya
                make quoted text from url  ;  ?????*****  c-yA
                 code pretty (=SE MER)  ;  c-yc
                Mata in dummytext med Lorem (30 ord per def.), här i divs  ;  div>lorem + c-y,
                 mata in 3 ord dummytext  ;  div>lorem3 + c-y,
                -------
                lägg in text, t.ex m Ankare  ;  a{Click me}  will produce  <a href="">Click me</a>

                SE MER: 5. Implicit tag names
                SE MER: 7. Choose position to insert text when wrap abbreviation  ( $# )
                  emmet-alias
                  emmet-filters o http://docs.emmet.io/filters/


                uppdatera storlek för bild-fil i en img-länk ***  ;  pekare på etiketten + c-yi
                slå ihop flera rader  ;  välj m visual + c-ym
            }}}

        }}}

            https://www.reddit.com/r/vim/comments/4z7z7s/add_shebang_lines_to_your_vim_files_automatically/

            essential.vim  #standardrcfil som kommer med practvim mm =utgå ifrån, bygg och testa mm
            drew neill vimrc + dotfiles (på github + i vimcasts)

        https://github.com/mbrochh/vim-as-a-python-ide
        https://github.com/davidhalter/jedi-vim/
        https://github.com/python-mode/python-mode

        https://github.com/lfairy/lilyvim


        Plugin 'artur-shaik/vim-javacomplete2'

        VUNDLE + YCM (installera o konfigurera) {{{
            ___vundle
              https://realpython.com/blog/python/vim-and-python-a-match-made-in-heaven/
              https://github.com/Valloric/YouCompleteMe
              https://github.com/Valloric/YouCompleteMe/issues/914

            $ git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim

            set nocompatible
            filetype off
            set rtp+=~/.vim/bundle/Vundle.vim
            call vundle#begin()         
            Plugin 'gmarik/Vundle.vim'

            :PluginInstall


                ta bort/avinstallera Plugins:
                - Ta bort namnet för aktuell plugin i .vimrc
                - kör :PluginClean

            ---------

            sudo apt-get install build-essential cmake
            sudo apt-get install python-dev python3-dev
            ----
            sudo apt-get install npm    #nodejs redan installerat i ubuntu


            cd ~/.vim/bundle/YouCompleteMe
            ./install.py
                    ./install.py --js-completer
                    ./install.py --clang-completer

        }}}
        Plugin 'Valloric/YouCompleteMe' {{{
            https://github.com/Valloric/YouCompleteMe
        }}}
        https://github.com/vim-scripts/SyntaxComplete       #försöker sätta Omnicompl. för ALLA språk i Vim-installationen m Syntax installerad *******
        http://www.vim.org/scripts/script.php?script_id=3172

        obs: ev tillägg för c-langs
            https://vi.stackexchange.com/questions/7470/how-to-install-youcompleteme-with-clang-completer-offline
        ycm tillsammans m andra plugins, t.ex. emmet
            https://github.com/mattn/emmet-vim/issues/232
        enable/disable ycm
            https://github.com/Valloric/YouCompleteMe/issues/662 {{{

                autocmd FileType c++ Bundle 'Valloric/YouCompleteMe'
                autocmd FileType c Bundle 'Valloric/YouCompleteMe'
                autocmd FileType python Bundle 'Valloric/YouCompleteMe'
                autocmd FileType shell Bundle 'Valloric/YouCompleteMe'
                autocmd FileType php Bundle 'Valloric/YouCompleteMe'

            }}}
        ----
        ultisnips??

        https://github.com/terryma/vim-multiple-cursors     #liknar sublimetext multiselect/edit *******

        matchit.vim {{{

            standarplugin (=finns installerad, men inte aktiverad)
            =aktivera med 'runtimepath ??

            set nocompatible
            filetype plugin on
             #båda ovan som vanligt, +
            runtime macros/matchit.vim
             .
            se också  :h matchit-install

            =gör att man kan matcha html/xml-etiketter med % likn. (, {, [
             (+även keywords i vissa programmeringsspråk)
             (=class/end, def/end, if/end i ruby t.ex.)

            Idé/Övn.: Byta ut { mot [ i exemplet på s128|147 (practvim)
             =hoppa till första, sen sista, ändra till [, +tillbaks m ``, och ändra sen första m .

        }}}
        ----
        surround.vim {{{

            =för att kunna utföra sista exemplet fr. förra pluginen (matchit) ännu enklare (=byta ut { mot ( mm mm

            vee + S"    #omge sel. med ""
            cs}]        #ändra wraptecken fr. { till [

        }}}
        spellfile.vim

        commentary.vim {{{

                https://vimawesome.com/plugin/commentary-vim


            kommentera kod för många vanl. progr.språk

            \\(rörelse)
            \\ap
            \\G
            \\\     #bortkommentera nuvarande raden

        }}}
        textobj-entire {{{

            ie ae   #agerar på hela filen
            (t.ex. =ae      #autoindentera hela filens innehåll*)

        }}}
        unimpaired.vim  =skapar maps för bnext, qnext, tnext osv {{{

            nnoremap <silent> [b :bprevious<CR>
            nnoremap <silent> ]b :bnext<CR>
            nnoremap <silent> [B :bfirst<CR>
            nnoremap <silent> ]B :blast<CR>
            Vim already uses the [ and ] keys as prefixes for a series of related commands (see :h [ ), so these mappings have a consistent feel to them. 
            The unimpaired.vim plugin provides similar mappings for scrolling through the argument ( [a and ]a ), quickfix ( [q and ]q ), location ( [l and ]l ), and tag lists ( [t and ]t ).
            Check it out.

        }}}
        rails.vim {{{

            tips i samband m find-kommandot
            =gör många grundinställningar för rails- och ruby-projekt mm

        }}}
        bundler.vim  [snabbt kunna ställa in rätt mappar o filtyper för hela projekt (=path, find mm)**] {{{

            =plocka ut alla mappar för ett projekt (=främst ruby)
            och lägg till path så kan jobba effektivt m find, gf mm *

            tips om utvecklar mkt ruby (mm): plocka senaste versionen från github (=så får det absolut senaste)

        }}}

        textobj-laspat {{{

            i/      #opererar på senaste matchning

        }}}
        visual-star.vim
        abolish.vim {{{

            :Subvert  (='a supercharged substitute command')

            :%S/{man,dog}/{dog,man}/g  (mm mm mm) ***

        }}}
        Ack.vim **** (=ska också fungera för ag) ****
        fugitive.vim  #gitintegrering  + grep för git??

    }}}

    formatera text {{{

        :set textwidth=72

        gqap
        gggqG
        gqj  + .
        Visual select + gq

    }}}
    -------
    specialtecken  (escape m '\') {{{

        .
        *
        [
        ]
        ^
        %
        /
        \
        ?
        ~
        $


        & ???

    }}}
    Keynames / Tangentnamn i Vim** {{{
        :h key-notation


        <Left>
        <Right>
        <S-Left> or <C-Left>
        <S-Right> or <C-Right>
        <C-B> or <Home>  <End>
         <Space> (<Blank>??)
         <Tab> <S-Tab>
        <Esc>
        <Del>
        <CR>  <Enter>
        <C-R>
         <Up> <Down> <Left> <Right>
         <PgUp>
         <Home>
        <F1>  <F12>
        <C-F5>
        <A-Up> <A-Down>
        5<C-^>
        <C-S-A-Up>***
        <BS>

        :nmap <T-F5> :q<cr>     #T=winkey   https://stackoverflow.com/questions/327415/can-windows-key-be-mapped-in-vim
                                #function-key =???

        <leftmouse>
        <middlemouse>
        <rightmouse>
        <2-leftmouse>
        <s-leftmouse>



        These special keys are most useful when writing a mapping that doesn't
        leave Insert mode. The extra typing doesn't matter then.
        An overview of the keys you can use in Insert mode:
            <PageUp>        a whole screenful up
            <PageDown>      a whole screenful down
            <S-Left>, <C-Left>      one word left
            <S-Right>, <C-Right>        one word right
            <Home>          to start of line
            <End>           to end of the line
            <C-Home>        to start of the file
            <C-End>         to end of the file



    }}}
    Mapkeys mm (ev till MAPS) **** {{{
        map-which-keys

        [+Enter, Tab, Bs, Space, etc]
        m
        q
        g


        alt o acceleratorkeys för att välja menyobjekt
        'winaltkeys'  apropå att alt för maps o alt för men.accel.keys står i konfl.



        TODO: LÄGG ÖVER TILL INDEX-SKRIPT ATT KUNNA STARTA (=MANAGE AND KEEP TRACK OF SHORTCUTS IN DIFF. PROG.S)
        ~/Dropbox/keyboard_shortcuts_MALL-TEMPLATE.mm
        ~/Dropbox/keyboard_shortcuts_LIBREOFFICE.mm
        ~/Dropbox/LEDIGA_TANGENTKOBINATIONER.mm
        ~/Dropbox/tuxguitar_keyboard_shortcuts.mm


        -
        H
        L
        (M)
        <space>
        <cr>
        <bs>

        inspir: c-x ____  #=hitta ev egen variant

        c-s-a
        CTRL  SHIFT  ALT  ALT-GR
        CAPSLOCK   ESC

        PgUp/PgDn  Home/End    Insert
         Win         m.fl.
        F2-F12(?)
        \ \\
        -
        ,,
        _
        g z Q q
        Y

        H L  M    R  U

        Z

        åäöÅÄÖ


        |

    }}}
    mata in Specialtecken, visa Teckenkod + UNICODE/ASCII {{{

        g8          #visa hex-kod för tecknet under markören
        ga          #visa ascii-, hex- o oct-kod för tecknet under markören ********
        c-v u/U + nnnn/NNNNNNNN         #mata in unicodetecken med kod nnnn


        This also goes up to character 255 (CTRL-V xff). You can use "o" to type a
        character as an octal number and two more methods allow you to type up to
        a 16 bit and a 32 bit number (e.g., for a Unicode character): >
        c-v o 123
        c-v u 1234      00bf(invert. q-mark)    #el m digraph  c-k ?I
        c-v U 12345678

        c-v(el c-q) <Esc>
              <esc>
        c-v <Esc>
        c-v <Tab>   mata in tabtecken, även om expandtab är satt**
        c-v 065     #matar in ett A (vim förväntar sig tresiffrig kod)
        c-v 09      #(se förra. färre än tre siffror avslutar inmatningen)
        c-v x7f



        Copyrighttecknet m.fl.****(digraphs):
        Ctrl-k Co
        :digraphs       kolla vilka specialtecken som finns tillgängliga som digraphs
        :h dipraphs-default     samma lista, men lättare att läsa/tolka

            You can define your own digraphs.
            Example: >
        :digraph a" ä
            This defines that CTRL-K a" inserts an ä character. You can also specify the
            character with a decimal number. This defines the same digraph: >
        :digraph a" 228
            More information about digraphs here: |digraphs|
            Another way to insert special characters is with a keymap.
            More about that here: |45.5|

    }}}
    -------
    vims operatorer(operators) **** {{{

        c
        d
        y
        gu
        gU
        >
        <
        =   autoindent
        !   filtrera {rörelse} rader genom externt program

    }}}


___0000
    några grundtips/förhålln.sätt fr. pract. vim * {{{

        anv. repeats(=.) snarare än att räkna, om inte enklare i nuv. sit. + ger renare undo-history    #pr.vim s48
        föredra operatorer framför visual mode
        excommands strike far and wide (without moving the cursor)

        område där term-vim oftast är bättre in gvim  ;  !-filtrering o köra externa kommandon mm ******

    }}}
    ----------
    'finkornighet' {{{

        tips/idé:
         ist.för gå till nästa rad m Enter (i insertmode)
         = <esc> och sen 'o'    #gör nya raden undoable, ist.för båda raderna ******
             (obs: rörelse m piltangenterna i ins.mode skapar också ny undo-chunkR

        tanke: om pausat tillr.länge föratt fund. 'ska jag lämna ins.mode?', så bör/brukar jag lämna ins.mode

    }}}
    rep.punkt *** {{{

        idealet:
         en knapptryckn. föratt hoppa till rätt/nästa pos.
         en knapptryckn. föratt utföra handl.

        A;<esc>  j.
        ersätt '+' m ' + '-tricket för javascript-kod (i boken)
        gqj  +. för att repetera******

        >> på en rad + j. =fortsätta
        dra in ett gäng rader ett indrag + . för att göra ett indrag till per gång för varje rad

        ändra ordet four till five
            /four<CR>
            cvfive<Esc>
            n
            .
              osv

        <B>
        /<   df>   n   .



        fungerar för n-komm, UTOM:
            u
            c-r
            :-comm

    }}}
    ZQ-ZZ
    iao-ryp-xdcs-hjkl   ^ g^ g0   0 $ - + Ent  Bl Bs {{{

        I
        A

        X   samma som backspace

        5$  gå till slut på 4 rader ner
        s
        S
        cc  =samma som S *******


        d/get   #SUDDA FRAM TILL (MEN INTE MED) STR. 'GET' **********

        dd  5p   ***
         dG
         dgg
        y$

        dw
        db

        gp gP   =SAMMA SOM P OCH P, MEN BEHÅLL PLATS PÅ MARKÖREN ******

        klistra in text kopierad från webläsare mm, framförallt när i vim (snarare än gvim=?) (=så inte klistrar in "högerskenande trappa" ;)   ;  :set paste! (och slå av igen så snart färdig)  #######BEHÖVER FÖRMODL. INTE ANV. OM KAN MED "+ ****
        (=Lösn:  c-r c-p +


        gm      till exakt mitten av rad
        g^ g0 g$

    }}}
    mata in flera: 50a- mm** {{{

        50a-<esc>
        Vr-     #markera hel rad (t.ex. i txttab uppställn.(=tabell)

        50i*Esc
        5I-Esc  (stort i)
        25a*-Esc
        25A*-Esc

    }}}
    R gR  (+r och gr) {{{

        <BS>/c-h  ÄNDRA TILLBAKS TEXTEN TILL ORIGINAL, TECKEN FÖR TECKEN

        gR      STARTA VIRTUAL REPLACE-MODE     =HANTERAR TABS MM KORREKT ******

    }}}
    u U  c-r
    bwe c-fbdu HLM  zb zt zz  c-io   gg G   gm 5| 20% {{{

        ea   append slutet av nuv. ord
        gea  append slutet av föreg. ord


        3w
        ge   sudda till slutet av föregående ord/ORD
        gE


        33G - till rad 33
        4gg  gå till rad 4
        33gg

    }}}
    visual {{{

        o   *****
        O

    }}}

    jumps:   c-] c-io :jumps
    % {{{

        hoppa mellan matchande parenteser    ( { [    #ej <
         'matchpairs'   definiera vad som matchar

        i q/-fönstret:
          \v'([^'])+'           #m pekaren på första [
          c%(<C-r>")<Esc>       #=sätt ( runt [-erna ******


        ___SEMER EV
        :set showmatch
        :set matchtime=15   #=1.5s

    }}}
    ^ g_
    J gJ {{{
        gJ  slå ihop rader utan att ändra blanksteg och annat
         'joinspaces'
        3J  slå ihop markörraden + 2 efterföljande
    }}}
    v V c-v {{{

        välj/markera förra vis.området igen  ;  gv

    }}}
    c-g   g c-g {{{

        markör, rader och position i filen (+antal filer?)

    }}}
    char.Case * {{{

        För 'Matcha Xml och Xhtml = /\vX(ht)?ml\C '-uppgiften: Ändra all bokstäver i matchningarna till Versaler (=oavsett matchningens längd)  ;  gU//e<cr> ********
        (för ideal dotsolution =slippa hoppa till nästa matchning m //<cr>, se plugin textobj-lastpat)


        ~
        U
        u

        g~~ (g~g~)
        guu
        gUU


        guaW
        gUas  ******
        gUiB
        gUat

    }}}
    te: ranges, radnummer, adresser (=för sökning, exkommandon mm) **** {{{

        ranges:
            radnr               :4
            radrange            :3,56
            sökmönster
            spec.tecken(0.$)
            ; 
            -4                  .-4 t.ex.
            't `x

            1:  5:              #SKICKA NUV. +N-1 RADER FRAMÅT TILL : SOM RANGE****
            `[ `< `. `"

        visa vilka rader som kommer inkluderas i en range  ;  :[range]p(rint) {flags=?}
            :1 :p
            :$ :p
            :3p
            :2,5p

            :'<,'>p  +  @: och @@

    }}}
    sök:  /?n //e+2,b-1   * #  g* g#   \c \C {{{

        tips: jobba ofta med stegvis förfining för sökmönster =testa först att matcha lite/grovkornigt, utöka sen, osv
        +anv. med fördel sökhist.fönstret ****

        Kopiera ordet i filen under markören o sätt in på krad/i '/'-sökn  ;  c-r c-w ****************
        Kopiera ORDET i filen under markören o sätt in på krad/i '/'-sökn  ;  c-r c-a ****************

        Om använder incsearch: slutför ord för sökslash, som matchas delvis just för tillfället (men inte skrivits ut hela än) ((obs: textsök o inte \v))  ;  c-r c-w

        Omdefiniera så * i vis. matchar current selection ***:
        [packetering: sätt raderna i vimrc, lägg i egen fil som sourcas till vimrc (el lägg som egen plugin (pathogen el vundle?)), el installera visual-star.vim 
        koden: {{{

            xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>    #x=visualmode men inte selectmode
            xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

            function! s:VSetSearch()
              let temp = @s
              norm! gv"sy
              let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
              let @s = temp
            endfunction

        }}}


        Räkna förekomst av senaste /-sökordet i filen  ;  :%s///gn  #ev map för


        För 'Matcha Xml och Xhtml = /\vX(ht)?ml\C '-uppgiften: Ändra all bokstäver i matchningarna till Versaler (=oavsett matchningens längd)  ;  gU//e<cr> ********
        (för ideal dotsolution =slippa hoppa till nästa matchning m //<cr>, se plugin textobj-lastpat)


        sök samma igen  ;  n
        Sök igen m samma mönster o offset, men byt riktn (förra = /sökn)  ;  ?<cr>   ****

        dn ; sudda fram till nästa matchning för senaste långsök
        dgn ; sudda EXAKT nästa matchning för senaste långsök**

        \c  ignore case     #=någonstans i sökmönstret
        \C  Match case
        /Sökning\C /Sök\Cning olikn
         =sätter till ic el noic för just den sökningen oavsett(!) vad ignorecase mm är satta till 

        *  matcha helt ord framåt
        g*  matcha ordet som ord/del av ord framåt
        3*  hitta ord 3 framåt ***


        //e-1   #kör senaste sökn igen, men med end -1--offset
        ??b+4
        //-3    #tre rader upp


        sök fram till OBJS, gå ner 1, ange range fram till (men inte med) blank rad
        /^OBJS
        j
        :.,/^$/-1!sort


        :set hlsearch       ********
        :nohlsearch
        :set incsearch
        :set nowrapscan     (wrapscan är defaultinställningen)
        :set ignorecase smartcase       ********
            smartcase =om inkluderar nån versal, så blir sökningen skifteslägeskänslig(case sensitive)


        avbryt sökning som hängt sig mm  ;  c-c


    }}}
    ftFT ;, {{{

        Grundidé för anv. av fF o tT:
            fF för c-sök på nuvarande rad,
            och tT för c(change)- och d(delete)-motions *** 
                #fF=n-mode  och  tT=o-mode

        Bra trick är ofta att (på alfapet-vis) söka ovanliga bokstäver som tar en nära den man vill åt (om den inte själv är en ovanlig) *  (=även UPPER o ./%& m.fl.

        2fx

    }}}
    Red. bö/slut flera rader **** {{{

        VISUAL BLOCK MODE
            mata in samma text i början av flera rader
            markera raderna med ctrl+v
        tryck I (stort i)
            mata in text
            tryck Esc

            mata in samma text i slutet av flera rader :D
            markera raderna med ctrl+v
            förläng alla rader till slut med $  ***
        tryck A
            mata in text
            tryck Esc

            The Visual block "c" command deletes the block and then throws you into Insert mode to enable you to type in a string. The string will be inserted in each line in the block. :) ***
        The "C" command deletes text from the left edge of the block to the end of line. It then puts you in Insert mode so that you can type in a string, which is added to the end of each line.
            Other commands that change the characters in the block: :D

    }}}
    tab/indent  = c-dt c-i > < >> << {{{

        =       #autoindent  t.ex. om B-text i fold hamnat längst ut till v i marginalen istället för med rätt indra (=två indrag t.ex.) *****
        ==      #autoindentera nuvarande raden
        =iB     #autoindentera nuvarande stycket(inre)
        gg=G    #autoindentera hela filens innehåll

        >iB     #allt inne i fold/{-block mm **********
        >ip
        >G

        Sätt in tab i text  ;  Tab / C-i

        Indentera rad när i insertläge (pekaren var som helst)  ;  C-t / C-d

            |i_0_CTRL-D|    0 CTRL-D    delete all indent in the current line
            |i_^_CTRL-D|    ^ CTRL-D    delete all indent in the current line, restore

    }}}
    Redigera ord i insertläge {{{

        obs! fungerar också på vims kommandorad ***


        c-h c-d     #backspace/delete
        c-w         #sudda ord
        c-u         #sudda hel rad
        c-m         #enter

        <C-Home>
            to start of the file
        <PageUp>
            a whole screenful up
        <Home>
            to start of line
        <S-Left>
            one word left
        <C-Left>
            one word left
        <S-Right>
            one word right
        <C-Right>
            one word right
        <End>
            to end of the line
        <PageDown>
            a whole screenful down
        <C-End>
            to end of the file
        There are a few more, see |ins-special-special|.


        Ctrl-o      Pausa insertmode för att kunna köra ett kommando

    }}}
    (i_c-o) {{{

        i_c-o D
        i_c-o "g3dw

    }}}
    COMPLETION + CTRL-X MODE {{{


        Ställ in så vim förstår include även för andra filer o filtyper (än c mm)  ;  'include' (:h 'include') )

                Om hur man inkluderar fler filers innehåll i aucompl-listan  ;  280/291
                 (#include, import, require
                +CUSTOMIZING THE GENERIC AUTOCOMPLETION ** 281/292  (:set complete-=i t.ex. för att inte ta med 'included files')

        vilka filer som letas igenom (=buffers mm*): 
            Current file
            Files in other windows
            Other loaded files (hidden buffers)
            Files which are not loaded (inactive buffers)
            Tag files
            All files #included by the current file

        tips: om ignorecase är satt så påverkar det förstås completion. Detta går delvis att fixa med 'infercase'




        c-n / c-p
                            c-x c-n
                    c-y / c-e
        c-x c-l c-n/p
        c-x c-o
                    c-x c-v     #ino  =inoremap t.ex. (=för skriva vimscr/.vimrc ***)

        c-x c-f ...

        thesaurus  c-x c-t
        dictionary              #:h dictionary      =custom ordlistor, t.ex. egna rhyming-dict ****
          spelling  c-x c-s

        makro-def
        keyword (in current and incl. files)
          tags








        c-N  /  c-P    (+fler tryckningar för att bläddra i listan som visas) {{{
                             (därefter: bara fortsätt att skriva*****)
        (:h popupmenu-completion)
        c-e     #exit
        c-y     #yes
        c-h     #sudda ett tecken fr. nuvarande match
        c-l     #lägg till ett tecken till nuvarande match
        SPECIALTIPS: C-N + C-P (EL TVÄRTOM) STARTAR SÖKNING, MEN MED REALTIDSFILTRERING AKTIVERAD = NÄR VI FORTSÄTTER SKRIVA SÅ FÖRSVINNER INTE MATCHLISTAN, UTAN FILTRERAS OCH UPPDATERAS *******
        ******* FUNGERAR ÄVEN MED OMNICOMPLETION O ALLA DE ÖVRIGA: T.EX.  C-X C-O C-P *******
            'complete'  'completeopt'
            'ignorecase'
            'infercase'
}}}
        i_c-A
        i_c-@  
        c-x c-n         #ord BARA från nuvarande/aktiva buffern ****
        c-x c-u         ___SEMER    "Guess what kind of item is in front of the cursor and find the first match for it."
        c-y     tecknet från raden rakt ovanför
        c-e     tecknet från raden rakt under

        vim command line word (=när skriver vimskript mm ****)
            c-x c-v   c-p
        =vim commandline: gissa vad det innan markören (som ska slutföras) är, och mata in träffar.

        file names
                i wd, och slutför ~/Dr till ~/Dropbox/ mm ********
            c-x c-f   c-p
             s119-120
            filenames (of files that resides anywhere on the linuxsystem)
             =när du ger sökväg refererad till inne i dokument.
        OBS!: OM SÖKVÄG INTE ANGES, SÅ ANVÄNDS VIMS WD = om programmeringsprojekt t.ex., kan först vara lämpligt att cd:a till rätt mapp  (=path används inte än i vim, men kanske i någon framtida version/uppgradering)

        whole line completion
            c-x c-l   c-p

        macro definitions (also in included files)
            c-x c-d   c-p
        keyword in current and included files (??)
            c-x c-i   c-p       #:h compl-keyword)

        words from a word dictionary
            c-x c-k   c-p {{{


                :h dictionary



            }}}

        c-x c-s   c-p  = Spelling  {{{


            exempel:
            :set spellfile=~/.vim/spell/techspeak.utf-8.add

            drs nedladdade spellfiles sv:
            .vim/spell/
                sv.utf-8.add  sv.utf-8.add.spl          



            c-x c-s   = LETAR BAKÅT TILL FÖRSTA FELSTAVADE + VISAR POPUPMENY  NÄSTA KNAPPTRYCKNING GÅR TILL NÄSTA *********
            s192/303 **********************

https://www.linux.com/learn/using-spell-checking-vim
https://ubuntuforums.org/showthread.php?t=2177596


                ladda ner rätt spellfiler (el ev som anges nedan: =om saknas o försöker köra, kommer erbjuda ladda ner
                och installera åt dig **** )
                    ftp://ftp.vim.org/pub/vim/runtime/spell/

                ladda ner till downloads + sudo-mv till /usr/share/vim/vim74/spell/


                :set spell?
                :set spell!
                 :set spell! spelllang=sv,en_us
                eller ange filer du vill använda; lägg i 'dictionary'

                z=          ge stavn.förslag för ord under markören
                1z=         sätt in ord 1 direkt, utan att visa listan 
                ]s          gå till nästa felstavning
                zg/zw       lägg till/ta bort nuvarande ord från stavningsfilen
                 1zg 2zg     lägg till ord i sourcad spellfil 1 el 2 osv (=specialfilen m specialistjargong mm)
                    #lär vim att känna igen vissa ord
                zug         undo zg/zw för nuvarande ord

                stäng av = :set spell! / nospell

                'spelllang'     =inte global option, utan alltid lokal till buffern
                 t.ex. :set spelllang=en_us

                :set spell
                :set spellang=fr
                  =om inte installerad så erbjuder vim sig att installera den åt oss ******
                Sourcing spellfiles for specialist jargon etc  291/302


            svensk stavning <http://ubuntu-se.org/phpBB3/viewtopic.php?f=67&t=32844>
            getting dictionaries :) <http://vim.runpaint.org/typing/auto-completing-text/#getting-dictionaries>
            språkkod för svenska i vim :D <http://ubuntu-se.org/phpBB3/viewtopic.php?f=67&t=32844>
            dictionaries för andra språk i vim :) <ftp://ftp.vim.org/pub/vim/runtime/spell/>
            human-language-codes vim <https://www.google.com/search?client=ubuntu&channel=fs&q=language+codes+vim&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=zou&tbo=d&channel=fs&sclient=psy-ab&q=human+language+codes+vim&oq=human+language+codes+vim&gs_l=serp.3...35825.36815.0.37089.6.6.0.0.0.1.130.570.4j2.6.0.les%3B..0.0...1c.1.8Gwbg5LXOQE&pbx=1&fp=1&bpcl=39468505&biw=1366&bih=634&bav=on.2,or.r_gc.r_pw.r_cp.r_qf.&cad=b&sei=5_3EUKWeBKTl4QSg0IGYAg>

        }}}

        words from a thesaurus
        ord från synonymordbok {{{

            thesaurus i vim <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+thesaurus+file&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=fHa&tbo=d&channel=fs&sclient=psy-ab&q=vim+thesaurus&oq=vim+thesaurus&gs_l=serp.3..0l3j0i8i30.18174.18742.0.19024.5.5.0.0.0.0.119.461.4j1.5.0.les%3B..0.0...1c.1.h2VTMF7o51U&pbx=1&fp=1&bpcl=39468505&biw=1366&bih=634&bav=on.2,or.r_gc.r_pw.r_cp.r_qf.&cad=b&sei=L_7EUPCrGcKC4ATYk4GoDg>
            set up a lightweight vim thesaurus < http://www.nickcoleman.org/blog/index.cgi?post=vim-thesaurus!201202170802!general%2Cblogging%2Cinternet%2Cprogramming%2Csoftware%2Cunix >
            synonymer.se :) <http://www.synonymer.se/>
            thesaurus i vim mm {{{

                https://www.google.com/search?client=ubuntu&channel=fs&q=vim+thesaurus+file&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=fHa&tbo=d&channel=fs&sclient=psy-ab&q=vim+thesaurus&oq=vim+thesaurus&gs_l=serp.3..0l3j0i8i30.18174.18742.0.19024.5.5.0.0.0.0.119.461.4j1.5.0.les%3B..0.0...1c.1.h2VTMF7o51U&pbx=1&fp=1&bpcl=39468505&biw=1366&bih=634&bav=on.2,or.r_gc.r_pw.r_cp.r_qf.&cad=b&sei=L_7EUPCrGcKC4ATYk4GoDg
              set up a lightweight vim thesaurus
                http://www.nickcoleman.org/blog/index.cgi?post=vim-thesaurus!201202170802!general%2Cblogging%2Cinternet%2Cprogramming%2Csoftware%2Cunix
              synonymer.se
                http://www.synonymer.se/

            }}}

        }}}
            c-x c-t   c-p

        tags file keywords      **********
            c-x c-]   c-p

        c-x c-o  (s120 pcpdf vim-uman)
        OMNICOMPLETION {{{

            =samma som c-x c-v nedan, men mer specifikt för programmeringsspråk.
            för att kunna köra omnicompletion: 
                filetypeplugin (indent) på, och kör 
                ctags
            For Omni completion to work you may need to do some setup. At least make sure
            filetype plugins are enabled. Your vimrc file should contain a line like this:
                filetype plugin on
            Or:
                filetype plugin indent on

            For C code you need to create a tags file and set the 'tags' option. That is
            explained |ft-c-omni|.
            For other filetypes you may need to do something
            similar, look below |compl-omni-filetypes|. It only works for specific
            filetypes. Check the value of the 'omnifunc' option to find out if it would work.


            För inställningar mm:  h compl-omni-filetypes
                filer finns i $VIMRUNTIME/autoload/{lang}compl.vim  #python, xml, javascript, css, html mm mm ********
                  :h complete-functions  (=hur man skriver egna complete-plugins mm)

        }}}



    }}}


    @:  ****** 
        TIPS: När repeterat ex-komm. m @: =fortsätt repetera m @@  ********
        + även för "= gissningsvis *****??
    Redigera Kommandoraden {{{

        Kopiera ordet i filen under markören o sätt in på krad/i '/'-sökn  ;  c-r c-w ****************
        Kopiera ORDET i filen under markören o sätt in på krad/i '/'-sökn  ;  c-r c-a ****************

        tecken för k-radsredigering {{{

            <S-Left> or <C-Left>    ord till vä/hö
            <S-Right> or <C-Right>

            CTRL-B or <Home>    bö/sl av kommandoraden
            CTRL-E or <End>

            CTRL-W      SUDDA ETT ORD
             CTRL-U     Sudda till början på kommandoraden
             <Insert>   skifta mellan skrivläge och overstrike-läge
            <Esc>, C-c      Avbryt påbörjat kommando (C-c = även för gamla Vi)




            CTRL-V      Insert next non-digit literally.  Up to three digits form the
                    decimal value of a single byte.  The non-digit and the three
                    digits are not considered for mapping.  This works the same
                    way as in Insert mode (see above, |i_CTRL-V|).
                    Note: Under Windows CTRL-V is often mapped to paste text.
                    Use CTRL-Q instead then.
                                        *c_CTRL-Q*
            CTRL-Q      Same as CTRL-V.  But with some terminals it is used for
                    control flow, it doesn't work then.

                                        *c_<Left>* *c_Left*
            <Left>      cursor left
                                        *c_<Right>* *c_Right*
            <Right>     cursor right
                                        *c_<S-Left>*
            <S-Left> or <C-Left>                    *c_<C-Left>*
                    cursor one WORD left
                                        *c_<S-Right>*
            <S-Right> or <C-Right>                  *c_<C-Right>*
                    cursor one WORD right
            CTRL-B or <Home>                *c_CTRL-B* *c_<Home>* *c_Home*
                    cursor to beginning of command-line
            CTRL-E or <End>                 *c_CTRL-E* *c_<End>* *c_End*
                    cursor to end of command-line

                                        *c_<LeftMouse>*
            <LeftMouse> Move the cursor to the position of the mouse click.

                                        *c_<MiddleMouse>*
            <MiddleMouse>   Paste the contents of the clipboard (for X11 the primary
                    selection).  This is similar to using CTRL-R *, but no CR
                    characters are inserted between lines.

            CTRL-H                      *c_<BS>* *c_CTRL-H* *c_BS*
            <BS>        Delete the character in front of the cursor (see |:fixdel| if
                    your <BS> key does not do what you want).
                                        *c_<Del>* *c_Del*
            <Del>       Delete the character under the cursor (at end of line:
                    character before the cursor) (see |:fixdel| if your <Del>
                    key does not do what you want).
                                        *c_CTRL-W*
            CTRL-W      Delete the |word| before the cursor.  This depends on the
                    'iskeyword' option.
                                        *c_CTRL-U*
            CTRL-U      Remove all characters between the cursor position and
                    the beginning of the line.  Previous versions of vim
                    deleted all characters on the line.  If that is the
                    preferred behavior, add the following to your .vimrc: >
                        :cnoremap <C-U> <C-E><C-U>
            <
                                    *c_<Insert>* *c_Insert*
            <Insert>    Toggle between insert and overstrike.  {not in Vi}

            {char1} <BS> {char2}    or              *c_digraph*
            CTRL-K {char1} {char2}                  *c_CTRL-K*
                    enter digraph (see |digraphs|).  When {char1} is a special
                    key, the code for that key is inserted in <> form.  {not in Vi}

            CTRL-R {0-9a-z"%#:-=.}                  *c_CTRL-R* *c_<C-R>*
                    Insert the contents of a numbered or named register.  Between
                    typing CTRL-R and the second character '"' will be displayed
                    to indicate that you are expected to enter the name of a
                    register.
                    The text is inserted as if you typed it, but mappings and
                    abbreviations are not used.  Command-line completion through
                    'wildchar' is not triggered though.  And characters that end
                    the command line are inserted literally (<Esc>, <CR>, <NL>,
                    <C-C>).  A <BS> or CTRL-W could still end the command line
                    though, and remaining characters will then be interpreted in
                    another mode, which might not be what you intended.
                    Special registers:
                        '"' the unnamed register, containing the text of
                            the last delete or yank
                        '%' the current file name
                        '#' the alternate file name
                        '*' the clipboard contents (X11: primary selection)
                        '+' the clipboard contents
                        '/' the last search pattern
                        ':' the last command-line
                        '-' the last small (less than a line) delete
                        '.' the last inserted text
                                        *c_CTRL-R_=*
                        '=' the expression register: you are prompted to
                            enter an expression (see |expression|)
                            (doesn't work at the expression prompt; some
                            things such as changing the buffer or current
                            window are not allowed to avoid side effects)
                            When the result is a |List| the items are used
                            as lines.  They can have line breaks inside
                            too.
                            When the result is a Float it's automatically
                            converted to a String.
                    See |registers| about registers.  {not in Vi}
                    Implementation detail: When using the |expression| register
                    and invoking setcmdpos(), this sets the position before
                    inserting the resulting string.  Use CTRL-R CTRL-R to set the
                    position afterwards.

            CTRL-R CTRL-F               *c_CTRL-R_CTRL-F* *c_<C-R>_<C-F>*
            CTRL-R CTRL-P               *c_CTRL-R_CTRL-P* *c_<C-R>_<C-P>*
            CTRL-R CTRL-W               *c_CTRL-R_CTRL-W* *c_<C-R>_<C-W>*
            CTRL-R CTRL-A               *c_CTRL-R_CTRL-A* *c_<C-R>_<C-A>*
                    Insert the object under the cursor:
                        CTRL-F  the Filename under the cursor
                        CTRL-P  the Filename under the cursor, expanded with
                            'path' as in |gf|
                        CTRL-W  the Word under the cursor
                        CTRL-A  the WORD under the cursor; see |WORD|

                    When 'incsearch' is set the cursor position at the end of the
                    currently displayed match is used.  With CTRL-W the part of
                    the word that was already typed is not inserted again.

                    {not in Vi}
                    CTRL-F and CTRL-P: {only when |+file_in_path| feature is
                    included}

                                *c_CTRL-R_CTRL-R* *c_<C-R>_<C-R>*
                                *c_CTRL-R_CTRL-O* *c_<C-R>_<C-O>*
            CTRL-R CTRL-R {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
            CTRL-R CTRL-O {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
                    Insert register or object under the cursor.  Works like
                    |c_CTRL-R| but inserts the text literally.  For example, if
                    register a contains "xy^Hz" (where ^H is a backspace),
                    "CTRL-R a" will insert "xz" while "CTRL-R CTRL-R a" will
                    insert "xy^Hz".

            CTRL-\ e {expr}                     *c_CTRL-\_e*
                    Evaluate {expr} and replace the whole command line with the
                    result.  You will be prompted for the expression, type <Enter>
                    to finish it.  It's most useful in mappings though.  See
                    |expression|.
                    See |c_CTRL-R_=| for inserting the result of an expression.
                    Useful functions are |getcmdtype()|, |getcmdline()| and
                    |getcmdpos()|.
                    The cursor position is unchanged, except when the cursor was
                    at the end of the line, then it stays at the end.
                    |setcmdpos()| can be used to set the cursor position.
                    The |sandbox| is used for evaluating the expression to avoid
                    nasty side effects.
                    Example: >
                        :cmap <F7> <C-\>eAppendSome()<CR>
                        :func AppendSome()
                           :let cmd = getcmdline() . " Some()"
                           :" place the cursor on the )
                           :call setcmdpos(strlen(cmd))
                           :return cmd
                        :endfunc
            <       This doesn't work recursively, thus not when already editing
                    an expression.  But it is possible to use in a mapping.

                                        *c_CTRL-Y*
            CTRL-Y      When there is a modeless selection, copy the selection into
                    the clipboard. |modeless-selection|
                    If there is no selection CTRL-Y is inserted as a character.

            CTRL-J                  *c_CTRL-J* *c_<NL>* *c_<CR>* *c_CR*
            <CR> or <NL>    start entered command
                                        *c_<Esc>* *c_Esc*
            <Esc>       When typed and 'x' not present in 'cpoptions', quit
                    Command-line mode without executing.  In macros or when 'x'
                    present in 'cpoptions', start entered command.
                    Note: If your <Esc> key is hard to hit on your keyboard, train
                    yourself to use CTRL-[.
                                        *c_CTRL-C*
            CTRL-C      quit command-line without executing

                                        *c_<Up>* *c_Up*
            <Up>        recall older command-line from history, whose beginning
                    matches the current command-line (see below).
                    {not available when compiled without the |+cmdline_hist|
                    feature}
                                        *c_<Down>* *c_Down*
            <Down>      recall more recent command-line from history, whose beginning
                    matches the current command-line (see below).
                    {not available when compiled without the |+cmdline_hist|
                    feature}

                                        *c_<S-Up>* *c_<PageUp>*
            <S-Up> or <PageUp>
                    recall older command-line from history
                    {not available when compiled without the |+cmdline_hist|
                    feature}
                                    *c_<S-Down>* *c_<PageDown>*
            <S-Down> or <PageDown>
                    recall more recent command-line from history
                    {not available when compiled without the |+cmdline_hist|
                    feature}

            CTRL-D      command-line completion (see |cmdline-completion|)
            'wildchar' option
                    command-line completion (see |cmdline-completion|)
            CTRL-N      command-line completion (see |cmdline-completion|)
            CTRL-P      command-line completion (see |cmdline-completion|)
            CTRL-A      command-line completion (see |cmdline-completion|)
            CTRL-L      command-line completion (see |cmdline-completion|)

                                        *c_CTRL-_*
            CTRL-_      a - switch between Hebrew and English keyboard mode, which is
                    private to the command-line and not related to hkmap.
                    This is useful when Hebrew text entry is required in the
                    command-line, searches, abbreviations, etc.  Applies only if
                    Vim is compiled with the |+rightleft| feature and the
                    'allowrevins' option is set.
                    See |rileft.txt|.

                    b - switch between Farsi and English keyboard mode, which is
                    private to the command-line and not related to fkmap.  In
                    Farsi keyboard mode the characters are inserted in reverse
                    insert manner.  This is useful when Farsi text entry is
                    required in the command-line, searches, abbreviations, etc.
                    Applies only if Vim is compiled with the |+farsi| feature.
                    See |farsi.txt|.

                                        *c_CTRL-^*
            CTRL-^      Toggle the use of language |:lmap| mappings and/or Input
                    Method.
                    When typing a pattern for a search command and 'imsearch' is
                    not -1, VAL is the value of 'imsearch', otherwise VAL is the
                    value of 'iminsert'.
                    When language mappings are defined:
                    - If VAL is 1 (langmap mappings used) it becomes 0 (no langmap
                      mappings used).
                    - If VAL was not 1 it becomes 1, thus langmap mappings are
                      enabled.
                    When no language mappings are defined:
                    - If VAL is 2 (Input Method is used) it becomes 0 (no input
                      method used)
                    - If VAL has another value it becomes 2, thus the Input Method
                      is enabled.
                    These language mappings are normally used to type characters
                    that are different from what the keyboard produces.  The
                    'keymap' option can be used to install a whole number of them.
                    When entering a command line, langmap mappings are switched
                    off, since you are expected to type a command.  After
                    switching it on with CTRL-^, the new state is not used again
                    for the next command or Search pattern.
                    {not in Vi}

                                    *c_CTRL-]*
            CTRL-]      Trigger abbreviation, without inserting a character.  {not in Vi}

        }}}

        Commandline Completion****** {{{

             Tab    complete/rulla igenom matches
             Ctrl+p/S-Tab   gå baklänges genom completion-lista
                :set iskeyword=+Tab     visa/lista nuvarande satta värden i t.ex. option iskeyword

             Ctrl-d     LISTA MATCHES
             Ctrl-l     SLUTFÖR COMPLETION SÅ LÅNGT MÖJLIGT (=SOM TAB I BASH)


            Sätta beteende för tab-completion på kommandoraden  ;  :h 'wildmode'
            t.ex.
            set wildmode=longest,list       #liknar bash
            ------
            set wildmenu
            set wildmode=full
            .
            wildmenu visar lista som för c-n-completion *******
            (=navigerbar med tab/c-n/hö och s-tab/c-p/vä) *****

            grundinställning i vim är _  ;  wildmode=full


            definiera tabcompletion-beteende för Egna ex-kommandon  ;  :h :command-complete

        }}}

        The 'wildmode' option can be used to change the way completion works.
        The 'wildmenu' option can be used to get a menu-like list of matches.
        Use the 'suffixes' option to specify files that are less important and appear
        at the end of the list of files.
        The 'wildignore' option specifies files that are not listed at all.

    }}}
    EXKOMMANDON FÖR YANK, PUT, JOIN, MOVE MM (kop. klipp o klistra från kraden)** {{{

        :%ya+   *******

        :%ya a
        :3,54d
        :/beg/,$m74

        :0,$co x  /  :0,$t x



        BRA ATT ANVÄNDA M ANDRA EXKOMMANDON O I VIMSKRIPT + MED GLOBAL :DDD
        (=FÖR FILTRERING MM)***  (:d c | pu c )

        :[range]d(elete)    #range=  radnr, radrange, sökmönster, spec.tecken(0.$), ; , -4
        :%d(elete)
        :%d+                #sudda text till clipboard
        :%d a               #sudda text till reg. a
        :%d A               #lägg till text till sist i reg. a

        :[range]ya [a]

        :[line]put [a]      #sätt in text fr. reg. a under rad 'line'

        :[range]co {address}
        :[range]t {address} #kop. specade rader till under raden specad m 'adress'
        :6t.                #kop. rad 6 till under nuv. rad
        :t6         #kop. nuv. rad till under rad 6
        :t.         #samma som yyp
        :t$         #kop. nuv. rad till sist i filen****
        :'<,'>t0    #kop. vis.valda rader till först i filen*****

        ********NOT: ANVÄNDER INTE REGISTER, VILKA DÄRFÖR ÄR INTAKTA EFTER OPERATIONEN ***


        :[range]move {address}  #flytta specade rader till under raden specad m 'adress'


        Idé:
         (vis.)rader
         :'<,'>m$       #flytta valda rader till sist i filen   el t.ex. efter 'm
         @: @@          #gå till + välj andra rader  +repetera***



        för fler exkommandon o hela listan
        =se :h ex-cmd-index  +EGNA LISTAN LÄNGST NER HÄR =SKUMMA O SORTERA

    }}}
    flera kommandon på samma rad  (=komm | komm) {{{

        :1,3d | s/deres/deras/

        :argdo %s/\<x_cnt\>/x_counter/ge | update

        :write
        :!ruby %
        tips = om använt kombinationen ovan flera gånger 
        =vill dra ihop/slå ihop två redan (för sig) använda kommandorader:  
        q:(=kommandohist-fönstret) + redigare o dra ihop två (el fler)
        redan existerande raderna  + Enter = kör **************

    }}}
    Commandhistory window {{{

        vilka är de fyra k-radshistorylistorna?  ;  : /? \= input()
            EXHISTORIKEN            q:
            SÖKHISTORIKEN           q/
            EXPRESSIONHISTORIKEN    q=  ??
            INPUT()HISTORIKEN   
        :se<Up>   *******

        Skifta till kradshist-fönstret från kraden (=medan skriver kommando i ex-läge)  ;  c-f **********

        :write
        :!ruby %
        tips = om använt kombinationen ovan flera gånger 
        =vill dra ihop/slå ihop två redan (för sig) använda kommandorader:  
        q:(=kommandohist-fönstret) + redigare o dra ihop två (el fler)
        redan existerande raderna  + Enter = kör **************

        kommandoradshistoriken / sökhistoriken 
        :history        #:-historiken
        :history /      #sökhistoriken =/?
         CTRL-N/P  <Down>/<Up>

        q:    **** Ändra som vanl. + tryck Enter ****

    }}}
    pausa vim (+skalkommandon mm) {{{

        Ctrl-z
        (blandade skalkommandon)
        fg

        :shell  :!xterm&

    }}}
    encryption (=kolla nere under 'editing other filetypes') {{{

        special =recover för krypterade filer
            :recover-crypt

    }}}

    -------
    gfgF cw-f cw-gf  c-io ******* {{{

         =öppna fil under markören *****
        (se också 'path'-option *****)

        Ange filsuffix vim ska lägga till på filer utan .ext, för att kunna utföra fil/länk-hoppen m gf m.fl. *****  ;  :set suffixesadd+=.rb  #går att speca flera suffix


        gf  ;i samma fönster
        60gF  ;+till rad nr 60 

        c-w f  ;i split
         c-w F  ;i slit + till radnummer N

        c-w gf  :i ny flik
         c-w gF  :i ny flik (+till radnummer? 8)

    }}}
    path, current directory; find {{{

        OBS! BÅDE PATH O SUFFIXESADD KAN SÄTTAS BUFLOCAL  = VARJE FILTYP KAN HA MAPPAR SOM STÄLLS IN SOM " DEFAULTPATHS *******

        Bra grundtips för find  ;  anv. när jobbar på ett projekt = filer kan ligga både en o flera mappar ner i projektets mappträd
        =föratt hitta filer i både app/controllers- och app/views-mapparna i exempelprojektet, lägg till m  :set path+=app/**       ****** (:h file-searching)
        -------------
        därefter funkar t.ex.  :find Navigation.js  #tab funkar också för completion

        Tips/Idé: för att Öppna många filer i samma mapp (utan att öppna/speca alla direkt i skalet)  ;  gå till rätt mapp + vim index.html  (skifta till filens mapp/lägg till mappen i path   o öppna resten m :e el :find ????)

        Öppna fil utifrån aktiva filens mapp  ;  :e %:h<Tab>  **********


        :find :sfind :tabfind

        :cd
        :cd -
        :pwd
        :lcd ******* /etc


        :set path?
        path=.,/usr/include,,   #.=dir of curr file ''(,,)=cwd

        tips: att alla mappar som ingår i ett visst projekt finns med i path
        anv. t.ex. bundler.vim
        ang. bundler mm:  många filtyps-plugins ingår redan i vim, så ofta behöver man inte göra allt detta arbetet själv


        :set path+=c:/prog/include
            This directory is an absolute path. No matter where you are, it will be the
            same place. What if you have located files in a subdirectory, below where the
            file is? Then you can specify a relative path name. This starts with a dot:
        :set path+=./proto
            This tells Vim to look in the directory "proto", below the directory where the
            file in which you use "gf" is. Thus using "gf" on "inits.h" will make Vim
            look for "proto/inits.h", starting in the directory of the file.
            Without the "./", thus "proto", Vim would look in the "proto" directory
            below the current directory. And the current directory might not be where the
            file that you are editing is located.


            When you know the file name, but it's not to be found in the file, you can
            type it: >
        :find inits.h
            Vim will then use the 'path' option to try and locate the file.
            This is the same as the ":edit" command, except for the use of 'path'.
        :sfind      #splitfind


            A nice way to directly start Vim to edit a file somewhere in the 'path': >
        vim "+find stdio.h"
        vim -c "find stdio.h"
            This finds the file "stdio.h" in your value of 'path'.

    }}}
    backupfil ORIGINALFIL(PATCHMODE) ******* {{{

        sätt så backupfiler skapas  ;  :set backup
        ändra ändelse för backupfiler (def. = ~)  ;  :set backupext=.bak
        slå på 'patchmode'  ;  :set patchmode=.orig    #"om du t.ex. redigerar källkod(+vampires mm) o vill behålla originalfilen: .bak(!) skrivs ju över varje gång orig.filen sparas

        'backupdir' (default =samma mapp som/tillsammans med originalfilen)

    }}}
    oldfiles***** 'edithistory' {{{

        :oldfiles

        redigera 2 från :oldfiles-listan
        :e #<2

        dela fönster med fil 2 från oldfileslistan
        :split #<2

        #<2 olikn kan användas med alla kommandon som tar ett filnamn som argument :D
        t ex :split #<2

        :browse oldfiles


        More info at |:oldfiles|, |v:oldfiles| and |c_#<|

    }}}
    ((gui filebrowser)) {{{

        :browse split
        :browse split /etc
            'browsedir'     #last(def.), buffer, el current
        :browse edit

    }}}
        vim-buffer till gvim ****** {{{

            :gui
            el :gui -f

        }}}
    redigera fil: öppna spara byt_fil/namn (edit, save, saveas, ändra filnamn mm) {{{

        öppna vim m markör på rad 9
            vim goldrush.txt +9
        öppna vim m markör på ordet 'ord'
            vim goldrush.txt +/ord

        Öppna vim i aktiv mapp (=från skalet), snarare än med en fil  ;  vim .  (el annan mapp)  #startar vim m Netrw

        :hid(e) e(dit) file.txt   #red. annan fil + lägg nuvarande som hidden buffer i bufferlistan ****

        :pwd
        :cd -
        :lcd        #local cd  =byt till annan mapp, utan att byta mapp för andra fönster ******

        vim `grep -l frame_counter *.c`




        :e fil.txt
        :e(dit)! fil.txt
        :e!

        :w(rite) fil.txt
        :.w otherfile.txt

        ----
        (vis.):w >> collectlines.txt/logfile
        :write >> logfile
        :.write >>collection
        :5,$w >> /tmp/nyfil.txt      spara ut rad 5 till sista raden och lägg till i filen nyfil
        :.,$write tempo
        :.,$write! tempo

        :sav(eas) movefile.txt
        :sav! fil.txt


        :file nyttfilnamn.txt   #ändra namn på fil utan att spara än   ***+SE EV MER OM KOMMONDAT FILE   ___SEMER
        :file move.c


        vim *.txt





        ge dialogruta för bekr. om försöker avsluta med ändringar
            :confirm edit x.txt

        Just like ":browse", the ":confirm" command can be prepended to most commands
        that edit another file.  They can also be combined: >
            :confirm browse edit


    }}}
    undoträdet **** {{{

        undo till senaste filewrite(=rak linje utan grenar**) {{{

            :earlier 1f     #undo tillbaks till efter senaste sparning
            :later 1f

        }}}
            undo-persistence    #om att skriva undo-info till fil  **?

        numrera ändringar (grenar och undoträdet) ******* {{{

            :undo 2     #hoppa rakt(??) i undo-trädet
                =är framförallt användbar när du vet precis vilken ändr. du vill gå till

            g- g+       #gå bakåt/framåt i tid OAVSETT var i trädet
                        #+ändringen ligger ********
                    #=bästa kommandot, om du inte vet exakt vilken ändr. du ska till (=var i trädet den ligger)

            2g-  osv

        }}}

        tidshopp ** {{{
            :undolist       #visa ändr./trädet i lista

            :earlier 10s
            :earlier 100d   #100 dagar
            :later 1m
                s m h d


            :echo undotree()
        }}}

    }}}
    Spara fil som kräver rootpriv. (t.ex. /etc/hosts ) {{{

        :w !sudo tee % >/dev/null

        ( :w !sudo tee /etc/hosts >/dev/null )

    }}}
    View file / Readonly {{{

        vim -R fil.txt / view fil.txt       öppna fil.txt readonly-light
         :w!                                 spara ändringar till readonly-fil

        vim -M fil.txt                      öppna filen readonly-hard
         :se modifiable write                sätt så kan göra ändringar även i -M-fil

    }}}
    Recover from crash* {{{

        If you know which swap file needs to be used, you can recover by giving the swap file name. Vim will then finds out the name of the original file from the swap file.
            vim -r .help.txt.swo

        mönster bash känner igen som swapfilnamn
            *.s[uvw][a-z]

        +SE EV MER OM VAR VIM KAN HA LAGT EN VISS SW-FIL, =om inte hittar den på första försöken
        mm =s82-84

        :recover

        öppna fil x.txt som kraschade
            vim -r help.txt
        tips för att vara säker: =när öppnat filen, skriv först till annat filnamn
            :w x.txt.recov
        jämför sen med grundfilen i dfsplit, o se så allt stämmer
            :w x.txt.recov
            :e(dit) #
            :diffsp(lit) x.txt
             sudda därefter .swp-filen om allt stämmer

        'updatetime'
        'updatecount'

        redigerade fil utan namn
            vim -r ""

        lista alla swapfiler i en viss mapp
            cd till rätt + vim -r

        +FLER OPTIONS  =SIST s85

    }}}
    filnamn sökväg:   %:h #:t :r :e  :p {{{

        annat sätt att skriva :w {aktivafilen}.kopia
        :w %.kopia ***

        %:p %:h  :t :e :r


        /sök/väg/filnamn.txt   /sök/väg/filnamn.txt
            :p  ????

        /sök/väg/filnamn.txt   /sök/väg/  *******
            :h
        /sök/väg/filnamn.txt   filnamn.txt
            :t
        /sök/väg/filnamn.txt   .txt
            :e
        /sök/väg/filnamn.txt   filnamn
            :r



        :nnoremap <A-p> :!evince %:r:r:r.pdf &<CR><CR>


    }}}
    BUFFERS OCH ARGSLIST {{{

        Obs! Skillnad mellan buf-list och args-list  ;  Först!: Dessa är inte samma  ("the arg-list is a great complement to the buffer list")
        Idéer/Uppgifter(fr.practvim)*: gruppera filer från bufferlistan 'into a collection' ????**  (=föratt kunna köra argdo mm) *?

        bufferlistan  ;  =lista över alla filer som är öppnade (=deras innehåll inlästa i buffrar av vim)
        anl. till att practvim rekommenderar att anv. arglistan mer än buflistan  ;  "the bufferlist numbers etc are assigned by vim and cant be reassigned by us/the user = lacks some flexibility"  (=förutom att organisera fönster m.hj.av splitwindows, tabs mm så är det förmodl. bra trick att anv. arglistan (=HUR???) *

        kör kommando/kommandosekvens på args/buflistan  ;  argdo / bufdo

        hur man kan speca namn till args-kommandot(föratt öppna fler filer mm)  ;  filnamn, globs, `  `  (mm?)


        arg:a alla filer i nuv. mapp  ;  :args *.*
        ARG:A ALLA .JS-FILER I NUV. MAPP + ALLA UNDERMAPPAR ******  ;   :args **/*.js
        ARG:A ALLA .JS-FILER OCH .CSS-FILER I NUV. MAPP + ALLA UNDERMAPPAR ******  ;   :args **/*.js **/*.css
        ARG:A ALLA FILER I NUV. MAPP + ALLA UNDERMAPPAR ******  ;   :args **/*.*
        kör args på alla filer i filen .chapters  ;  :args `cat .chapters`      #:h backtick-expansion
        kör args på alla filer i ` `-expand, OCH utvärdera vim-expression(funktioner mm) i `  `  ;  :args `= vimfunktnamn() .  x  `    #mm


        Se snabbt hur många filer som redigeras i nuv. bufferlist *****  ;  (1 of 2)  t.ex.  *******
        :ls :args    #csa-l

        c-^  byt mellan % och #         #csa-c


        :args(!) *.c   #öppna ny uppsättning filer som arglista
            :args *.txt
        :args one.c two.c three.c next.h

        :2n(ext)  :n!  :wn(ext)  :4pre(vious)  :wpre(vious)  :last  :first  
            (det finns inga :wlast och :wfirst)

        :argdo
        TIPS/SE UPP MED FÖR ATT KUNNA KÖRA :ARGDO OCH :BUFDO  ;  KOLLA SÅ 'HIDDEN' ÄR SATT; ANNARS KAN INTE VIM GÅ VIDARE TILL FIL 2 EFTER FIL 1
        kolla sen ändr. med ':first o :wn  el :argdo write (or :wall) 


     :h argument-list
      :h buffers
            |:buffers|  :buffers  or  :files    list all known buffer and file names

            |:ball|     :ball     or  :sball    edit all args/buffers
            |:unhide|   :unhide   or  :sunhide  edit all loaded buffers

            |:badd|     :badd {fname}       add file name {fname} to the list
            |:bunload|  :bunload[!] [N]     unload buffer [N] from memory
            |:bdelete|  :bdelete[!] [N]     unload buffer [N] and delete it from
     :h windows.txt
        :ls, :files, :buffers  Modtecken --> (= +-= u%# ahx) ****** {{{
         om filer/buffers är modifierade mm****
            +   modified buf
            =   readonly buf
            =+  readonly buf, men innehåller ändringar
            -   buf with 'modifiable' off
            ----------
            u   unlisted buf (displ when [!])
            %   curr win buf
            #   alt buf 
            a   active buf =loaded and visible
            h   hidden buf =loaded, but curr not displayed in a window
            x   buf with readerrors
        }}}
        :argadd filename
        :aredit filename

        ---
        :hid(e) e(dit) nyfil.txt   #stoppa in fil i arglistan, utan att byta till den direkt*


        :ls       :ls!  #lista unlisted buffers
           :bunload
        :bd :bd!  #:bdelete
           :2,5bd  #ta bort buf 2-5
        visa fil som tagits bort med :bd (=unlisted)  ;  :ls! :buffers! *********
        ta bort bufs 1-2 o 4-8
           :bd 1 2 4 5 6 7 8

           :bwipe  :bwipeout

            'buflisted'


        :b :bu :buf :buffer 
        :b nam      #öppnar namn.txt, om 'nam' är tillr. föratt matcha namnet unikt
         :b3  :b 3  #byt till buf 3

         3<c-^>  #byt till buf 3
         :e #5
         :b OMR  #buf som bö m el inneh OMR
         :b MRÅ<TAB>  ***#compl bufnamn (el C-d ****)
        :new :vnew  #ny tom buffer
        :bn(ext) :bp(rev)
         :bfirst :brewind :blast  :sbfirst :sbrewind :sbnext  :bprevious :bNext

        ev tips på maps till bnext osv  ;  se uppe i plugin-tips

        :ball :wall 
         :unhide :sunhide  :bmodified :sbmodified
        C-w_hjkl C-w_HJKL 
         :badd f1.txt :badd f2.txt
        -------
        blandade exempel:
        :vertical sb 3 
        :vertical rightbelow sfind file.txt 
        :rightbelow sfind file.txt

        :argdo :windo :bufdo :tabdo
        -------
        :setlocal textwidth=70
        :map <buffer> ,w /[.,;]<CR>

        byt till filerna 1 2 3 när redan redigerar  ;  :args 1 2 3
        byt buf.lista till alla txt-filer, när redan redigerar  ;  :args *.txt

        'buflisted'

    }}}
    Vimdiff, Diffsplit, 3]c {{{

        öppna två filer i vimdiff     vimdiff main.c~ main.c
        snabbsyntax bash:     vimdiff main.c{~,}

        the foldcolumn


            notering:
                ändrad text
                highlighting
                text som saknas i ena filen

        öppna vimdiff från INNE I vim :)
            A. :) (=grund)
                Another way to start in diff mode can be done from inside Vim. Edit the "main.c" file, then make a split and show the differences: >

                :edit main.c
                :vertical diffsplit main.c~

            B. (? :] )
                If you have a patch or diff file, you can use the third way to start diff mode. First edit the file to which the patch applies. Then tell Vim the name of the patch file: >

                :edit main.c
                :vert(ical) diffpatch main.c.diff

                WARNING: The patch file must contain only one patch, for the file you are editing. Otherwise you will get a lot of error messages, and some files might be patched unexpectedly.
                The patching will only be done to the copy of the file in Vim. The file on your harddisk will remain unmodified (until you decide to write the file).

            slå av/på scrollbind:
                :se scrollbind!


        uppdatera highlighting mm när i diffläge (om gjort ändr. mm)  ;  :diffupdate
        gå till nästa/förra ändr. i vimdiff  ;  zj/zk m folds, alt. ]c / [c
        gå till tredje ändring framåt  ;  3]c


         :e main.c    :vert diffpatch main.c.diff
            :vert diffsplit main.c~

        :diffthis

        lägg till vertical i diffopt (=??)

        markör på rad som inte finns i andra filen (=skicka aktiv rad till andra filen)  ;  dp
        markör på saknad rad (=hämta rad till den här filen där raden saknas)  ;  do


    }}}
    'editing other filetypes' (win/mac,web/ftp,encryption,binary,zip/compressed) {{{

        lin/win/mac {{{

            unix: <lf>
            win: <cr><lf>
            mac: <cr>

            :set fileformats=unix,dos
            :set fileformat?
            :set fileformats+=mac

            :edit ++ff=unix file.txt
            The "++" string is an item that tells Vim that an option name follows, which
            overrules the default for this single command. "++ff" is used for
            'fileformat'. You could also use "++ff=mac" or "++ff=dos".
            This doesn't work for any option, only "++ff" and "++enc" are currently
            implemented. The full names "++fileformat" and "++encoding" also work.


            s112(PC-pdf) Vim U.M.


            Vim will recognize this as a dos format file.
            Now change the file format to UNIX: >
                :set fileformat=unix
                :write


        }}}
        filer på nätet (+se också netrw) {{{

            du har fått en länk av någon till en fil
                ftp://ftp.vim.org/pub/vim/README

            prova nu: gf el c-w_f

            Accessing files over the internet works with the netrw plugin.
            these formats are recognized:
            ftp://
            rcp://
            scp://
            http://  uses wget (reading only)

        }}}
        encryption {{{

            vim -x exam.txt

            enter encryption key: _

            slå av kryptering för en fil
                :set key=

            :X  (+skriv in din nyckel)

            redigera fil utan swapfil (=kan inte läsas av andra medan öppen av dig)
                vim -x -n file.txt
            eller om filen redan öppen
                :setlocal noswapfile

        }}}
        binary/binära filer {{{

            vim -b datafil

            Many characters in the file will be unprintable.
            To see them in Hex format: >
            :set display=uhex

            Otherwise, the "ga" command can be used to see the value of the character
            under the cursor. The output, when the cursor is on an <Esc>,

            tips kan vara att sätta nowrap (s115)

            g c-g  =se byteposition

            gå till byte 2345
                2345go

            konvertera binärkoden så den går se både som den är, och i hexformat
                Now convert the file to a hex dump with xxd: >
                :%!xxd

            när klar kollat och pysslat i hex, konvertera tillbaks med:
                :%!xxd -r

        }}}
        packade/komprimerade filer {{{

            redigera som vanl. (gzip används)

            format som stöds (för tillfället):
                .Z  .gz  .bz2

        }}}

    }}}
    stäng fönster/fil {{{

        stäng ett splitfönster  ;  ZZ, :close, :quit
        stänga alla splitfönster UTOM nuvarande  ;  :only :D
        stäng alla tabfönster utom nuvarande  ;  :tabonly

    }}}
    skriv ut fil/skriv ut del av fil** {{{

        markera och skriv ut 100 rader ; V100j:ha(rdcopy)  ******

        s47uman  = Mer om färger etc i utskrift     ___SEMER

    }}}
    NETRW* {{{
        ___netrw

        obs: Grundinställningar i vimrc för att Netrw ska funka {{{
         set nocompatible
         filetype plugin on
        }}}
        mapp            
        sorteringsmetod: namn, tid redigerad, storlek
        fil/namnsortering: mappar först, sen *.h-filer, *.c-filer mm mm

       Om börjar redigera fil/mapp som inte finns  ;  kan vara bra att skapa den sen med touch/mkdir -p  så att de finns när ska spara ***  [ :!mkdir -p %:h ]
       (tips för att undersöka filer o deras status:  c-g)


         (lista = s107uman, netrw-maps)
        hjälp netrw {{{

                :h netrw-help

        }}}
        (inställningar) {{{

            :NetrwSettings

        }}}
        navigera netrw {{{

                netrw-browse

        Öppna netrw i cwd  ;  :e.
        ÖPPNA NETRW I AKTIV BUFFERS MAPP  ;  :Ex            #samma som :e %:h
          EX, SEX, VEX M.FL. {{{

            öppna filbläddraren i mappen för senaste öppnade fil
            :Ex.
            dela fönster och öppna explorer i splitfönstret, med WD för filen du just redigerar
            :Sex
            samma med vertical split, med WD för filen du just redigarer
            :Vex
            samma med tab
            :Tex
            . {{{
                 :[N]Explore[!]  [dir]... Explore directory of current file      *:Explore*
                 :[N]Hexplore[!] [dir]... Horizontal Split & Explore             *:Hexplore*
                 :[N]Lexplore[!] [dir]... Left Explorer Toggle                   *:Lexplore*
                 :[N]Sexplore[!] [dir]... Split&Explore current file's directory *:Sexplore*
                 :[N]Vexplore[!] [dir]... Vertical   Split & Explore             *:Vexplore*
                 :Texplore       [dir]... Tab & Explore                          *:Texplore*
                 :Rexplore            ... Return to/from Explorer                *:Rexplore*

                 Used with :Explore **/pattern : (also see |netrw-starstar|)
                 :Nexplore............. go to next matching file                *:Nexplore*
                 :Pexplore............. go to previous matching file            *:Pexplore*

                                    *netrw-:Explore*
            :Explore  will open the local-directory browser on the current file's
                      directory (or on directory [dir] if specified).  The window will be
                  split only if the file has been modified and |'hidden'| is not set,
                  otherwise the browsing window will take over that window.  Normally
                  the splitting is taken horizontally.
                  Also see: |netrw-:Rexplore|
            :Explore! is like :Explore, but will use vertical splitting.

                                    *netrw-:Hexplore*
            :Hexplore  [dir] does an :Explore with |:belowright| horizontal splitting.
            :Hexplore! [dir] does an :Explore with |:aboveleft|  horizontal splitting.
            }}}

          }}}

        Gå tillbaks till filen man redigerade, efter att använt :Ex  ;  c-o/c-i (=funkar flera gånger om******) el c-^      #csa-c


            vanliga kommandon =flytta runt (c-f, HLM, mm mm)

            öppna mapp, öppna fil
                <cr>
            gå uppåt(bakåt) i fil/mappträdet
                -

            change to recently visited directory (back)
            u
            change to subsequently visited directory (forw)
            U

            sätt mapp som topp av filträdet
                gn

        }}}
        öppna mapp/fil {{{

            sätt mappen bläddrar i till cur.dir i vim
                c

            öppna fil med vim
                $vim .
                $vim /NÅNMAPP/
                :e.
                öppna filbläddraren (i nuvarande mappen)
                :e.  #+gå tillbaks till mappen igen, efter att ha öppnat fil   äv. Ctrl-o
                :sp.
                :vs(plit).

                <cr>, v-mus
                  +även över nätverk o.likn.

                :Explore ftp://somehost/path/to/dir/
                :e scp://somehost/path/to/dir/   #scp o sftp =säkrare vers. av ftp
                    +även rsync, http (via wget, fetch, curl etc), m.fl.    netrw-externapp
                     ssh
                    . {{{
                        :Nwrite
                        :Nsource
                    }}}
                lösenord mm {{{
                    :call NetUserPass()



                    The typical syntax for lines in a <.netrc> file is given as shown below.
                    Ftp under Unix usually supports <.netrc>; ftp under Windows usually doesn't.
                    >
                        machine {full machine name} login {user-id} password "{password}"
                        default login {user-id} password "{password}"

                    Your ftp client must handle the use of <.netrc> on its own, but if the
                    <.netrc> file exists, an ftp transfer will not ask for the user-id or
                    password.

                        Note:
                        Since this file contains passwords, make very sure nobody else can
                        read this file!  Most programs will refuse to use a .netrc that is
                        readable for others.  Don't forget that the system administrator can
                        still read the file!  Ie. for Linux/Unix: chmod 600 .netrc


                    The script attempts to get passwords for ftp invisibly using |inputsecret()|,
                    a built-in Vim function.  See |netrw-userpass| for how to change the password
                    after one has set it.

                    Unfortunately there doesn't appear to be a way for netrw to feed a password to
                    scp.  Thus every transfer via scp will require re-entry of the password.
                    However, |netrw-ssh-hack| can help with this problem.

                }}}

            starta ny fil i nuvarande mappen
                %

            öppna m split
                o
            öppna m v-split
                v
            öppna filen i ny flik ***
                t

            använd preview-fönstret     netrw-p
                p
            öppna i föregående(?) fönster       netrw-P
                P, mhj-klick

        }}}
        redigera fil över nätverk (scp, ssh mm mm ***) {{{
            scp, ftp, curl, wget   :h netrw-ref


            hämta kopia(?) på fil till lokala datorn  utan att öppna
                O       #mnem. =obtain
        }}}
    Skapa filer/mappar, Döpa om filer/mappar, Sudda filer/mappar = Se ep. 15 av Vimcasts **
        döp om mapp/fil ******
            R   #om ej mark. filer: fil under markören döps om
                #om mark. filer (mf, mr mm): s/sök/subst/ körs på filnamnen ******
            (+se också c-x  o  c-x,c-x) **
        sudda/skapa fil/mapp {{{

            skapa ny mapp
                d
            skapa ny fil (i nuv. mapp)
                %
            sudda fil/mapp
                D, <del>, h-mus

        }}}
        (läs/spara fil) {{{

            :Nw
            :Nr
            :Ns(source)

        }}}
        bokmärken {{{

            markera/avmarkera fil
                mf, s-vmus
            sätt dir (t.ex. current browsing-dir) as markfile target
                mt  :)
                :MT _____    #=tillåter blanksteg
            sätt märke på flera filer
                :MF *.c
            markera filer som matchar glob
                mr

            flytta filer: från märkta filer-listan, till arglistan
                ma
            flytta filer: från arglistan, till märkta filer-listan
                mA

            avmarkera alla filer (i nuvarande buffer)
                mF
            avmarkera alla(!) markerade filer

            placera marked files i arglistan och redigera ***
                me

            använd vimgrep(??) på markerade filer(s namn??)
                mg

            nuvarande öppna mappen blir/sätts som markfile target
                t
            sätt bokmärke i nuvarande/aktiv mapp
                mb
            gå till föregående(?) bokmärkt mapp
                gb
            ta bort märken (??*)
                mB

            avmarkera alla markerade filer
                mu

            lista bokmärken och history
                qb
                          lista mappar m bokmärken
            sätt fil i qb-listan som märkt fil
                Tb
            sätt fil i qb-listans history som märkt fil
                Th


            'Copy marked files to marked-file target directory'
                mc
            'Move marked files to marked-file target directory'
                mm


        }}}
        behandla/processa fil med progr. x *** {{{

            tillämpa diff på marked files (upp till 3st)
                md

            Kör ctags på märkta filer
                mT

            kör vimkommando på märkta filer
                mv

            sourcea fil **
                ms

                gx ??

            kör för-angivet(associated) program på märkt fil
                x
            kör (skal)kommando (som anges) på märkt fil
                mx
            kör skalkommando på märkta filer som en enhet
                mX
                    =t.ex.:  tar cf mynewtarball.tar

                X   #=som x, men använder system()  =output dyker upp i meddelanden (:messages)

            skriv ut marked files
                mp

            packa/packa upp filer (m zip o/el likn)
                mz

        }}}
        convert |quickfix-error-lists| into a marked file list
        You may then proceed with commands such as 'me' (|netrw-me|) to edit them.
        Quickfix error lists are generated, for example, by calls to |:vimgrep|.
            qF
        One may convert |location-list|s into a marked file list
        You may then proceed with commands such as me (|netrw-me|) to edit them.
            qL

        fil/mapplista  visa/dölj {{{

            visa/göm gömda filer (.fil)   ?????
                gh

            reverse sortorder
                r
            ändra sorteringsmetod
                s       namn, mod.time, storlek

            ange sorterings/visningsordning, special (=se sträng)
                S

            ändra liststil (??)     netrw-i
                i
            . {{{
                thin
                long    =inkl. storlek, datum
                wide
                tree
            }}}

            'toggle marked file suffices presence on hidinglist'
                mh      #extraherar märkta filers suffix o slår av el på att filer m samma suffix syns i listan


            (SE UPP!!!!) visa/gömma filer/mappar [norm. hiding o show]      netrw-a
                a       hidelist
        }}}
        fil/mappinfo {{{

            visa info om fil
                qf

        }}}
        behandla/ange _ som x {{{

            force treatment as file
                gf
            force treatment as directory
                gd

        }}}

        .lista på maps som använder märkta filer =lägg över markering till listorna ovan### {{{
            |netrw-a|   Hide marked files/directories
            |netrw-D|   Delete marked files/directories
            |netrw-ma|  Move marked files' names to |arglist|
            |netrw-mA|  Move |arglist| filenames to marked file list
            |netrw-mb|  Append marked files to bookmarks
            |netrw-mB|  Delete marked files from bookmarks
            |netrw-mc|  Copy marked files to target
            |netrw-md|  Apply vimdiff to marked files
            |netrw-me|  Edit marked files
            |netrw-mF|  Unmark marked files
            |netrw-mg|  Apply vimgrep to marked files
            |netrw-mm|  Move marked files to target
            |netrw-mp|  Print marked files
            |netrw-mt|  Set target for |netrw-mm| and |netrw-mc|
            |netrw-mT|  Generate tags using marked files
            |netrw-mv|  Apply vim command to marked files
            |netrw-mx|  Apply shell command to marked files
            |netrw-mX|  Apply shell command to marked files, en bloc
            |netrw-mz|  Compress/Decompress marked files
            |netrw-O|   Obtain marked files
            |netrw-R|   Rename marked files
        }}}



        setting the editing-window
            C
        speca hide-lista :)
            C-h

        kör ctags på markerade filer  :) <http://www.google.com/search?client=ubuntu&channel=fs&q=ctags&ie=utf-8&oe=utf-8>
            mT

        c-r     browse using a gvim server


    }}}
    Öppna nytt fönster {{{

        öppna 'fil2' i splitfönster ovanför nuvarande;:split fil2
        öppna ny tom fil som splitfönster :D

        :new
        öppna 3 rader högt splitfönster

        :tabedit

    }}}
     FÖNSTER, TABS, SPLIT WINDOWS {{{

        Sätt wd för nuvarande fönster ******  ;  :lcd
        Sätt wd för alla fönster i nuvarande tab  ;  :windo lcd
        Flytta fönster/split m pekaren i till ny Egen Tab  ;  c-w T  ******
        Öppna ytterligare ett fönster/viewport på t.ex. en av flera splits (=ett litet fönster där svårt att få överblick  ;  :tabe(dit) %
        'splitbelow'
        'splitright'   ******
        Öppna split på ny vertikal fil(höger)*****  ;  :vertical botright new
        :wall


        s57uman
        'winheight' 
        'winminheight'
        'winwidth' 
        'winminwidth' 
        'equalalways' 


        Tips och idéer för splits:
            Redigera programmeringskod:     var.defs i övre split, huvudkoden i nedre (mm)
            Text/Bokdokument:               topp o hoppmärken, oöppnade rubrikerna, öppnad del el rubr
        Tips o idéer för splits + tabedit:
            =Nytt! KOMBINERA M OVAN FÖR BÄSTA 'MIKROSKOP'- O ÖVERBLICKS-VYER--KOMBO****** (=senaste Alltodoist/Plandok/Mothership


        SCRATCH MM:
         Öppna split på ny fil  ;  :new  :vnew
         Öppna split på ny vertikal fil(höger)*****  ;  :vertical botright new


        2 splitvarianterna för komm. som redigerar en fil
        ""Many commands that edit another file have a variant that splits the window. ""
        1. Ex-mode: s (t ex :tag hoppar till tag och :stag delar och hoppar till)
        2. Normal mode: Ctrl-w (t ex Ctrl+w Ctrl-(tak)
        :3sb(uf(fer))
            sal(l)      öppna alla buffers i varsin split ****
            3sunhide        öppna alla filer i buf.lista i splits; om siffra (här 3) =anger maximalt antal att öppna (även om finns fler i listan)
             vertical sall
            stag
            stjump

            4sbmodified     dela fönster o gå till 4:e modifierade filen

            sball
            sbfirst sbrewind
            sblast
            sbnext
            sbprevious

            4sbNext     dela(split) + gå till buf. nr 4 ******
            snext
            sNext sprevious
            sfirst srewind
            slast
                sargument

            sview       samma som split, men filen öppnas som readonly

            sfind




        stäng splitfönster
            :close ZZ :q
        dela fönster (split)
            :split fil2.txt     :vsplit  :vertical split
             :3sp(lit) file.c

          :vertical :leftabove :rightbelow  =combos
        dela fönster vertikalt
        :vsp(lit)
        dela fönster vertikalt med 'fil2'
        :vsplit fil2.txt
        o
        :new   #öppna ny tom fils fönster i split
        öppna ny tom fil i vertikal split
        :vnew
        :vertical new   #"vertical som för-led funkar för alla kommandon som delar fönster" (mm)
      :h buffers
      :h tabpage
     :only   #stäng alla fönster utom det aktiva

        3C-w + -   3C-w _
        3C-w > <   3C-w |


         :h window-move-cursor


    :3split alpha.c
    öka storlek på splitfönstret
    dra med musen
    ctrl+w + // ctrl+w -
    öka storlek på fönster till 4 rader
    4 Ctrl-w +
    Both of these commands take a count and increase or decrease the window size by that many lines. Thus "4 CTRL-W +" make the window four lines higher.
    CTRL-W h j k l
    FLYTTA SPLITFÖNSTER :)))
    CTRL--W K J H L
    move window to the top








    fler kommandon att kolla i nästa stycke: p n c q o ^ ] r R

    RESTEN FÖNSTERKOMMANDONA (CTRL-W X)
        Gå till fönster x (förra/(n)nästa) ******* {{{

            gå till (n) nästa fönster (wraps around)  CTRL-W w
            gå till n föregående fönster (wraps around)  CTRL-W W
            gå till föregående använt fönster ***  CTRL-W p
            gå till föregående fönster  CTRL-W P

            move to the TOP/BOTTOM window  CTRL-W t / b

            Gå till n fönster/split hö/vä/upp/ner  ;  3 c-w l/h/k/j

        }}}
        byt pos./flytta/rotera fönster(arrangering) {{{

            rotera fönster uppåt n gånger  CTRL-W R
            rotera fönster neråt n gånger  CTRL-W r
            byt fönstret mot fönster n (def. = nästa :)  CTRL-W x
            FLYTTA VERT.FÖNSTER TILL HORIS.FÖNSTER HÖGST UPP ********  ;  c-w K *******

            When splitting a window you can prepend a modifier command to tell where the window is to appear:  
            left or above the current window  :aboveleft {cmd} / :leftabove {cmd}
            right or below the current window  :rightbelow {cmd} / :belowright {cmd}
            at the top or left of the Vim window  :topleft {cmd}
            at the bottom or right of the Vim window  :botright {cmd}

            Flytta fönster/split till Ytterst hö/vä/upp/ner  ;  c-w L/H/K/J

        }}}
        Öppna(split)/stäng fönster + Ange pos./arr. {{{

            öppna nytt fönster n rader högt  CTRL-W n

            split  7 rader högt  7 CTRL-W s(plit)
            vsplit  5 bred  5 CTRL-W v
            stäng nuvarande fönster  CTRL-W q, CTRL-W c / :close :quit ZZ

             stäng alla fönster  ;  :qall  :qall!  :wqall
            stäng alla fönster utom nuvarande  CTRL-W o / :only


            stäng preview-fönstret  ;  c-w z

        }}}
        Sätt storlek fönster {{{

            fönsterhöjd till 3(rader)  3 CTRL-W _
                CTRL-W +       öka fönsterstorleken 1
                CTRL-W -       minska fönsterstorleken 1
                |CTRL-W_+|  N CTRL-W +     increase current window height N lines
                |CTRL-W_-|  N CTRL-W -     decrease current window height N lines
            maximera fönsterhöjd  CTRL-W _

            fönsterbredd till 3  3 CTRL-W |
                CTRL-W >       öka fönsterbredden 1
                CTRL-W <       minska fönsterbredden 1
                |CTRL-W_>|  N CTRL-W >     increase current window width N columns
                |CTRL-W_<|  N CTRL-W <     decrease current window width N columns
            maximera fönsterbredd  CTRL-W |

            |CTRL-W_=|  CTRL-W =       make all windows the same height & width

        }}}
            DELA + HOPPA TILL FIL/SÖKVÄG UNDER MARKÖREN  =se specialrubrik längre upp (=gf mm) ***********

        spara ändringar i alla splits/filer  ;  :wall

            Öppna nytt fönster som vertikal splitruta  ;  :vertical new

|CTRL-W_P|  CTRL-W P       go to preview window
|CTRL-W_R|  CTRL-W R       rotate windows upwards N times

            flytta nuvarande fönster till ny tab  ****CTRL-W T


        |CTRL-W_}|  CTRL-W }       show tag under cursor in preview window
            split window and jump to definition under cursor  CTRL-W d
            split window and jump to declaration of identifier under cursor  CTRL-W i
            |CTRL-W_]|  CTRL-W ]       split window and jump to tag under cursor
            |CTRL-W_g_CTRL-]| CTRL-W g CTRL-]  split window and do |:tjump| to tag under cursor
            |CTRL-W_g]| CTRL-W g ]     split window and do |:tselect| for tag under cursor
            |CTRL-W_g}| CTRL-W g }     do a |:ptjump| to the tag under the cursor
            |CTRL-W_]|  CTRL-W ]       split window and jump to tag under cursor


|CTRL-W_^|  CTRL-W ^       split current window and edit alternate file


            stänga alla splitfönster och vim
            :qall :)
            :qa
            stäng alla fönster även om ändringar gjorts
            :qa!
            öppna splitfönster för alla öppna filer när inne i vim  :all
                $vim -o fil1 fil2 fil3 osv
            öppna vsplits för alla öppna buf.filer  ;  :vertical all
                $vim -O fil1 fil2 fil3 osv  #vsplits
            öppna splitfönster för öppna filer, men max 3st  :3al
            öppna vertikala splitfönster för alla öppna filer när inne i vim  :vertical all
            spara alla ____  :wall
            spara och stäng alla ___  :wqall / :xall
            o
            :qall!
            t ex :)
            TABS/TABSPLIT :)

    }}}
    Tabs/=redigera filer i Flikar (=inte splits)* {{{

                    $vim -p fil1 fil2 fil3 osv  #tabs

        Snabbt öppna scratchpad i split  ;  :tabe   #öppnar ny tom, snarare än split mm, som öppnar på nuvarande buffer ***

        Flytta aktiv tab till först av tabs  ;  :tabmove 0
        Flytta aktiv tab till pos N av tabs  ;  :tabmove N
        Flytta aktiv tab till sist av tabs  ;  :tabmove
        EL DRAG AND DROP I GVIM  #OBS: INTE STÖD I ALLA INSTALLATIONER


        :tab help gt (=??) [kommentar: "tab funkar för alla kommandon som öppnar nytt fönster)
        visa lista på alla öppna tabs
        :tabs
        öppna fil2 i tab :DD
        :tabsplit fil2
        gå till nästa flik (tab)
        gt :)
        skapa flik (tab) på SAMMA fil som kommandot körs ifrån :DDD
        :tab split
        :tabedit alt-fil.txt
        double click with the mouse in the top line
        A new tab page will be created.
        stäng alla flikar utom nuvarande
            tabonly :DDD
        öppna fil1, fil2 och fil3 i varsin flik (från kommandoraden) :)
            vim -p fil{,2,3}
        stäng nuvarande tab (oavsett hur många fönster/splits öppna i) ****
            :tabclose
        gå till tab 5
        5gt ; :tabnext 5

        :tabn(ext / :tabp(revious


        tabsplit och tabedit  
        :tabedit % / :tab split

        :tabnext     gt
            gå till nästa tab
        :tabprevious    gT
            gå till förra tab
        :tabdo cmd
            utför kommando cmd i alla öppna flikar

        :tabonly  ;  stäng alla tabs utom nuvarande

            tab-page


    }}}
    ----
    KÖR KOMMANDO PÅ FÖNSTER/BUFFERS/TABS {{{

        kör kommando på flera öppna tabs i ett fönster (t ex ersätt x med y)
        :windo w(rite) :DDD
        :windo s/x/y/g

        :bufdo

        :tabdo

        :argdo %s/\<x_cnt\>/x_counter/ge | update

    }}}
    --------
    ((gui blandat)) {{{

        fönsterpos {{{

            :winpos

            You can use this command in your startup script to position the window at a
            specific position.

            The size of the Vim window is computed in characters.  Thus this depends on
            the size of the font being used.  You can see the current size with this
            command: >

                :set lines columns

            To change the size set the 'lines' and/or 'columns' options to a new value: >

                :set lines=50
                :set columns=80

            You can start the X-Windows version of gvim with an argument to specify the
            size and position of the window: >

                gvim -geometry {width}x{height}+{x_offset}+{y_offset}

            {width} and {height} are in characters, {x_offset} and {y_offset} are in
            pixels.  Example: >

                gvim -geometry 80x25+100+300

        }}}
        gvim som editor för annat epost-program {{{

            gvim -f fil.txt

        }}}
        visa/dölj delar av gui {{{

            Remove T-option from guioptions;:set guioptions-=T
            This removes the 'T' flag (Toolbar) from the 'guioptions' option. Other parts of the GUI can also be enabled or disabled with this option. See the help for it.
            :set guioptions+=l
            scrollbars

        }}}

    }}}


    BLOCK/TEXTOBJEKT {{{

        skillnaden mellan rörelser(motions) och objects  ;  objects =spelar ingen roll om pekaren stod mitt i objektet, medan rörelse processar text mellan objekts start- och slut-pos.

        c vs d  ;  c(change) funkar oftast bäst med iw m.fl. ,  och d(delete) bäst med aw, as, ap (o likn)

        tagblock: <html>hi</html>
         gUit       <html>HI</html>
         gUat       <HTML>HI</HTML>
            +j. (vis.). :g/mönster/normal .     för att köra på fler rader *****
        Fler exempel: practvim s142/(123 i datorversionen)

        as
        is

        (cib,diB,sat ,  aw,as,ap,   (,{,[,",',<,` )

        daw caw yaw  vaw*** ViB********

        aw iw
        ap ip

    }}}

    MARKS {{{

        vad är ett hopp(a jump)?  ;  ett hopp längre än inom nuvarande raden        #dock ej j/k, och w/e

        Tabs, splits mm o jumplists  ;  Varje fönster(window) har sin egen separata jumplist ******
        +changelists: hålls för varje BUFFER i vimsessionen

        (ma,mF,`a, '', ``,  `[`] [`]`, `", '0-9 `^ `.   `{ `(

        M-marks ska tydligen finnas kvar mellan sessioner = (så länge som de inte klubbats av nån viminfoläsning) så ska man kunna använda 'V för att hoppa till sin vimrc, om man en gång har satt märket där.

        mK
        :marks M     :marks acM

        jumplist (=hopplistan)
        :jumps

        Tips på anv.område för G-marks: Sätt i grundfilen innan hoppar iväg m vimgrep mm *  t.ex. mM `M   (=innan hoppar iväg nånstans, t.ex. med  :grep/vimgrep/make el :args {argslista} o :argdo


        hoppa tillbaks till förra hopp-positionen  ;  c-o / c-i/Tab   //  ``(fyra tryck)
        hoppa tillbaks till förra hoppraden  ;  ''(2 enkelcitat)
        senast redigerade fil/buffer ****  ;  '0  (+bakåt ytterligare m '1, '2 osv)


        fö(rra)/nä märket****  ;  [`
        gå till märke a(exakt pos.)***** ; `a
         gå till rad för märke a  ;  'a

        gå till märke a, utan ändra jumplist  ;   g'a  g`a





        senaste ändr.  ;  `. / u c-r         #kompletterar 'the change-list'
        BAK/FRAM I CHANGELIST  ;  g; / g,
        markörpos. där ins.mode stoppades  ;  gi / `^

        bö. senaste ändr./kop. text****  ;  `[

        bö. senaste v-mark. text ; `<
        mark.pos. senast red. filen  ;  `"
        bö. av mening  ;  `(
        bö. av stycke  ;  `{

        bö/slut av vikning ******  ;  [z , ]z


        mark.pos. senast gjorde ett hopp**** ; '

        lite mer grund + blandat övrigt {{{

            globalt märke (t ex 'f') = mF
            sudda märken  ;  :delm
            sudda märke a  ;  :delm a
            ta bort alla mark. i texten  ;  :delm!
            visa var flera märken finns  ;  :marks McP

            Utför 'kommando' utan att det mesta av märken och jumplists mm ändras ; :lockmarks kommando

             :keepmarks
             :keepjumps

        }}}

    }}}
    FOLDS + foldmethod folddo****** {{{

        :set foldcolumn=4
         :set foldopen=all  ??___SEMER EV  usr28 .3bot
         :set foldopen&

        :set foldclose=all      =gör så att vikningar stängs automatiskt när flyttar ut markören ur dem


        usr_28  28.7
        In the syntax files it is possible to add syntax items that have the "fold"
        argument.  These define a fold region.  This requires writing a syntax file
        and adding these items in it.  That's not so easy to do.  But once it's done,
        all folding happens automatically.


        foldm.
            marker
            indent
            syntax      #definieras av syntax highl.
            ----
            manual
            expr usr_28.8       #speca expression för att defin. vikningar  =T.EX. >-RADER I E-POSTMEDDEL. ***
            diff usr_28.9 (=folding unchanged lines  ___SEMER EV)

        Autocommand setlocal foldmethod=marker ****
        " Vimscript file settings ---------------------- {{{
            augroup filetype_vim
            autocmd!
            autocmd FileType vim setlocal foldmethod=marker
            augroup END
        " }}}


        EXERCISE: Find out how to make Vim fold everything automatically the first time you open the file. Look at
        :help foldlevelstart for a good place to start.     = :set foldlevelstart=0  el =1


   za{{{
            za      When on a closed fold: open it.  When folds are nested, you
                    may have to use "za" several times.  When a count is given,
                    that many closed folds are opened.
                    When on an open fold: close it and set 'foldenable'.  This
                    will only close one level, since using "za" again will open
                    the fold.  When a count is given that many folds will be
                    closed (that's not the same as repeating "za" that many
                    times).

            }}}
   zA{{{
            zA      When on a closed fold: open it recursively.
                    When on an open fold: close it recursively and set
                    'foldenable'.

            }}}
      . {{{
          skapa folds {{{
   zF{{{
            zF      Create a fold for [count] lines.  Works like "zf".


            :{range}fo[ld]                      
                    Create a fold for the lines in {range}.  Works like "zf".

            }}}
   zf{{{
            zf{motion}  or
            {Visual}zf  Operator to create a fold.
                    This only works when 'foldmethod' is "manual" or "marker".
                    The new fold will be closed for the "manual" method.
                    'foldenable' will be set.
                    Also see |fold-create-marker|.

            }}}
          }}}
      }}}
        gå till bö/slut/nä fold**** {{{
   [z{{{
            [z      Move to the start of the current open fold.  If already at the
                    start, move to the start of the fold that contains it.  If
                    there is no containing fold, the command fails.
                    When a count is used, repeats the command [count] times.

            }}}
   ]z{{{
            ]z      Move to the end of the current open fold.  If already at the
                    end, move to the end of the fold that contains it.  If there
                    is no containing fold, the command fails.
                    When a count is used, repeats the command [count] times.

            }}}
   zj{{{
            zj      Move downwards to the start of the next fold.  A closed fold
                    is counted as one fold.
                    When a count is used, repeats the command [count] times.
                    This command can be used after an |operator|.

            }}}
   zk{{{
            zk      Move upwards to the end of the previous fold.  A closed fold
                    is counted as one fold.
                    When a count is used, repeats the command [count] times.
                    This command can be used after an |operator|.
            }}}
        }}}
        öka/minska foldlev {{{
   zm {{{
            zm      Fold more: Subtract one from 'foldlevel'.  If 'foldlevel' was
                    already zero nothing happens.
                    'foldenable' will be set.

    }}}
   zM{{{
            zM      Close all folds: set 'foldlevel' to 0.
                    'foldenable' will be set.

            }}}
   zr{{{ 
            zr      Reduce folding: Add one to 'foldlevel'.

            }}}
   zR{{{
            zR      Open all folds.  This sets 'foldlevel' to highest fold level.

            }}}
        }}}
       Öppna/Stäng hel hier. under Markör**** {{{
   zO{{{
            zO      Open all folds under the cursor recursively.  Folds that don't
                    contain the cursor line are unchanged.
                    In Visual mode it opens all folds that are in the selected
                    area, also those that are only partly selected.

            }}}
   zC{{{
            zC      Close all folds under the cursor recursively.  Folds that
                    don't contain the cursor line are unchanged.
                    In Visual mode it closes all folds that are in the selected
                    area, also those that are only partly selected.
                    'foldenable' will be set.

            }}}
       }}}
        .(Öpp/stä/toggle) {{{
   zi (zn zN) {{{
            zi      Invert 'foldenable'.

   zn{{{
            zn      Fold none: reset 'foldenable'.  All folds will be open.

            }}}
   zN{{{
            zN      Fold normal: set 'foldenable'.  All folds will be as they
                    were before.

            }}}

            MOVING OVER FOLDS 
            }}}
   3zo{{{
            zo      Open one fold under the cursor.  When a count is given, that
                    many folds deep will be opened.  In Visual mode one level of
                    folds is opened for all lines in the selected area.

            }}}
   3zc{{{
            zc      Close one fold under the cursor.  When a count is given, that
                    many folds deep are closed.  In Visual mode one level of folds
                    is closed for all lines in the selected area.
                    'foldenable' will be set.

            }}}
            ÖPP FR KOMM.RADEN**** {{{
   :foldo{{{
            :{range}foldo[pen][!]
                    Open folds in {range}.  When [!] is added all folds are
                    opened.  Useful to see all the text in {range}.  Without [!]
                    one level of folds is opened.

            }}}
   :foldc{{{
            :{range}foldc[lose][!]
                    Close folds in {range}.  When [!] is added all folds are
                    closed.  Useful to hide all the text in {range}.  Without [!]
                    one level of folds is closed.

            }}}
            }}}
        }}}
         EXECUTING COMMANDS ON FOLDS {{{
   :[range]foldd[oopen] {cmd}           {{{
                    Execute {cmd} on all lines that are not in a closed fold.
                    When [range] is given, only these lines are used.
                    Each time {cmd} is executed the cursor is positioned on the
                    line it is executed for.
                    This works like the ":global" command: First all lines that
                    are not in a closed fold are marked.  Then the {cmd} is
                    executed for all marked lines.  Thus when {cmd} changes the
                    folds, this has no influence on where it is executed (except
                    when lines are deleted, of course).
                    Example:
                        :folddoopen s/end/loop_end/ge
                    Note the use of the "e" flag to avoid getting an error message
                    where "end" doesn't match.

            }}}
   :[range]folddoc[losed]{cmd}          {{{
                    Execute {cmd} on all lines that are in a closed fold.
                    Otherwise like ":folddoopen".
            }}}
         }}}


   zd *** {{{
            zd      Delete one fold at the cursor.  When the cursor is on a folded
                    line, that fold is deleted.  Nested folds are moved one level
                    up.  In Visual mode all folds (partially) in the selected area
                    are deleted.  Careful: This easily deletes more folds than you
                    expect and there is no undo.
                    This only works when 'foldmethod' is "manual" or "marker".
                    Also see |fold-delete-marker|.

            }}}
   zD *** {{{
            zD      Delete folds recursively at the cursor.  In Visual mode all
                    folds (partially) in the selected area and all nested folds in
                    them are deleted.
                    This only works when 'foldmethod' is "manual" or "marker".
                    Also see |fold-delete-marker|.

            }}}

   zE{{{
            zE      Eliminate all folds in the window.
                    This only works when 'foldmethod' is "manual" or "marker".
                    Also see |fold-delete-marker|.


            OPENING AND CLOSING FOLDS 

            A fold smaller than 'foldminlines' will always be displayed like it was open.
            Therefore the commands below may work differently on small folds.

            }}}

???
   zv{{{
            zv      View cursor line: Open just enough folds to make the line in
                    which the cursor is located not folded.

            }}}


   zx{{{
            zx      Update folds: Undo manually opened and closed folds: re-apply
                    'foldlevel', then do "zv": View cursor line.
                    Also forces recomputing folds.  This is useful when using
                    'foldexpr' and the buffer is changed in a way that results in
                    folds not to be updated properly.

            }}}
   zX{{{
            zX      Undo manually opened and closed folds: re-apply 'foldlevel'.
                    Also forces recomputing folds, like |zx|.

            }}}

   }}}
    zj/zk
    REGISTERS******** {{{

        :reg(isters)


        ___SEMER
        "=   {{{

            c-r=2+2 +Ent
            c-r=system('ls') +Ent
            "=2+2 +Ent p        #4 will be placed after the cursor

            If you don’t find this syntax as impossibly awkward as I do, then this may well suit you for quick inline calculations … personally, I’d drop to a shell and bust out bc for this.


        }}}

        Kopiera, sudda något(=unnamed register) + "0p
         (el kop., (vis.)markera + p)**
        OBS! Texten i yank-reg byts ut i lösning två
        ='Swap words'-tricket
         .
        Byta x o y mot y o x: 'de' på första + 'mm', till sista + p:a, +tillbaks till första märket o p:a där också
        ****** (kanske ännu bättre)
        Kop. första ordet, sudda nästa ord(ciw) + c-r 0

        :reg
        kolla vad som finns i register 0  ;  :reg 0
        kolla vad som finns i unnamed register och register 0  ;  :reg "0

    ang. om ens installerade version av vim är kompilerad m stöd för xterm_clipboard  ;  se s149/166 practvim

        "a-z
            :let @W='i;'  =Lägg till ett semikolon sist i "w

            :let @w='<Ctrl-r w>   ???????    (http://www.brianstorti.com/vim-registers/   under rubriken 'Macros'
        ------
            "x yas  #as(entence)
            "l3yy
            (vis.)"by
            "w daw

        "Ay     1.Samla på sig mat./rader i reg.  2.Lägga till tecken sist i @x (="kommando-reg.")

        ctrl-r w
        ctrl-r ctrl-r w

        "0      senaste yanked text    "0p
        "1-9    senaste deleted text
        "_      t.ex. "_daw(???)

        "-      ='lilla deleteregister (=saker suddade som var mindre än en rad i längd, t.ex. med '3x')

        ".      *****Last inserted text
        ""      senaste text ("the unnamed register")


        @: (+@@*****)
            (@@ = också förstås med . och andra reg., om de innehåller körbara teckenkombinationer***)

        "% "#
        @+ @*

        "/      =för /,?,*,#-sökningars historik
            :%s/<Ctrl-r />/mustache/g  *******


        CTRL-R {0-9a-z"%#:-=.}                  *c_CTRL-R* *c_<C-R>*
                Insert the contents of a numbered or named register.  Between
                typing CTRL-R and the second character '"' will be displayed
                to indicate that you are expected to enter the name of a
                register.
                The text is inserted as if you typed it, but mappings and
                abbreviations are not used.  Command-line completion through
                'wildchar' is not triggered though.  And characters that end
                the command line are inserted literally (<Esc>, <CR>, <NL>,
                <C-C>).  A <BS> or CTRL-W could still end the command line
                though, and remaining characters will then be interpreted in
                another mode, which might not be what you intended.
                Special registers:
                    '"' the unnamed register, containing the text of
                        the last delete or yank
                    '%' the current file name
                    '#' the alternate file name
                    '*' the clipboard contents (X11: primary selection)
                    '+' the clipboard contents
                    '/' the last search pattern
                    ':' the last command-line
                    '-' the last small (less than a line) delete
                    '.' the last inserted text
                                    *c_CTRL-R_=*
                    '=' the expression register: you are prompted to
                        enter an expression (see |expression|)
                        (doesn't work at the expression prompt; some
                        things such as changing the buffer or current
                        window are not allowed to avoid side effects)
                        When the result is a |List| the items are used
                        as lines.  They can have line breaks inside
                        too.
                        When the result is a Float it's automatically
                        converted to a String.
                See |registers| about registers.  {not in Vi}
                Implementation detail: When using the |expression| register
                and invoking setcmdpos(), this sets the position before
                inserting the resulting string.  Use CTRL-R CTRL-R to set the
                position afterwards.


    }}}
    i_c-r c-r x  c-r c-p + {{{

        mata in reg. x bokstavligt *****    c-r c-r     #om innehåller spec.tecken mm

        c-r c-p     mata in reg. x +fixera indentering (??)*    #om klistrar in från internet mm
         (tips: el skifta till n-mode o anv. put-kommandona)

    }}}
    Scriptregisters
    automatic marks (??)
    senaste inmatning/ändring
    c-a c-x {{{

        addera / subtrahera
        5c-a  ;  addera 5 till nästa tal        
        -180c-x
        inställning för att hantera tal som 007 som decimaltal ****  ;  
         :set nrformats-=octal

        tips: c-a / c-x behöver inte pekaren på talet, utan går autom. till nästa tal på samma rad o kör +/-

        tips: Använd . för att upprepa operationer ****

    }}}
    RECORD MACRO *** (q mm) {{{

        Redigera i flera filer {{{
            ändra ett namn i alla filer i en argslista :D ******

            .förklaring {{{
                Let's assume you have a directory with C++ files, all ending in ".cpp".
                There is a function called "GetResp" that you want to rename to "GetAnswer".
                vim *.cpp
                Start Vim, defining the argument list to contain all the C++ files. You are now in the first file.
                qq
                Start recording into the q register
                :%s/\<GetResp\>/GetAnswer/g
                Do the replacements in the first file.
                :wnext
                Write this file and move to the next one.
                q
                Stop recording.
                @q
                Execute the q register. This will replay the substitution and ":wnext". You can verify that this doesn't produce an error message.
                999@q
                Execute the q register on the remaining files.
                Obs! :)
            }}}
                vim *.cpp
                qq
                    :%s/\<getResp\>/getAnswer/ge        *********
                    :wnext
                q
                @q
                999@q

            There is one catch: If one of the .cpp files does not contain the word "GetResp", you will get an error and replacing will stop. To avoid this, add the "e" flag to the substitute command: >
                :%s/\<GetResp\>/GetAnswer/ge
            The "e" flag tells ":substitute" that not finding a match is not an error.
        }}}
        Record Macro** {{{
            Lägg till inneh. i register x **
            lägg till i inspelat kommando
            redigera (klipp/klistra mm) i inspelat kommando
            redigera felinspelat kommando i register x
            klistra in raden från register
            redigera

            Suppose you have recorded a command to change a word to register c. It works properly, but you would like to add a search for the next word to change. This can be done with: >
            qC/word<Enter>q
            You start with "qC", which records to the c register and appends. Thus writing to an uppercase register name means to append to the register with the same letter, but lowercase.
            This works both with recording and with yank and delete commands. For example, you want to collect a sequence of lines into the a register. Yank the first line with: >
            "aY
            Now move to the second line, and type: >
            "AY
        RECORD/SPELA IN KOMMANDOSEKVENS
        qa
            spela in kommandosekvens i register a
            gör kommandosekvensen
            avsluta med q
        kör kommandosekvens i register a
        @a
        kör senaste körda kommandosekvens
        @@
        kör kommandosekvens i register a 3 gånger
        3@a
        }}}
        qC/word<Enter>q

        This works both with recording and with yank and delete commands. For
        example, you want to collect a sequence of lines into the a register. Yank
        the first line with: >
        "aY
        Now move to the second line, and type: >
        "AY

        Öppna alla filer som ska redigeras
        :%s/\<GetResp\>/GetAnswer/g
        Do the replacements in the first file.
        :wnext
        999@q
        :%s/\<GetResp\>/GetAnswer/ge  ********


        MATA IN STIGANDE RÄKNARE I BÖRJAN AV VARJE RAD ******* {{{

            :let i=1
            qa
            I<c-r>=i<cr>
            <esc>
            :let i += 1
            q

            kör m  :normal @a el  :'<,'>normal @a

        }}}


        Kör ett makro på alla rader i filen  ;  1000@a el likn

    Två sätten: Köra i sekvens el Köra parallellt (=på de rader som matchar):
        A. 999@a  ,  :%normal @a (??)  ,  :'<,'>normal @a   #nackdel breaks om stoppar på något  fördel detta gör att man direkt ser o kan undersöka filen
        B. :argdo normal @a     #kör snabbare och enklare  gör att man får gå tillbaks o undersöka uttryckligen om något gått fel

        Undersök makro(teckensekvens) i register a  ;  :reg a

        Att tänka på när spelar in ändringar att göra på flera filer  ;  Ev återställ första filen m :e! om den ingår i listan m filer som ska argdoas senare (annars kommer den förstås redigeras två gånger)
        :argdo normal @a    #kör inspelade makrot a på alla filerna i argslist

    }}}
    formatera text:  gq  =((equalprog)  ,,  rader förbi kanten,  TABELLER(TABLES/COLUMNS) {{{

        :set textwidth=72

        omformatera redigerade rader (=uppdaterar inte autom. för textwidth mm  när gjort manuella ändr.)  ;  gq
            gqap
            gggqG
            (vis.)gq
            gqj

        v4jgq       #omformatera 4 rader som blivit felformaterade när tog bort annat

        +se också auto-format  #=automatisk formatering för vissa filformat
        'joinspaces'  =hur många blanksteg som anv. efter en punkt
        ******** 'formatprg' =ange externt program att anv. för formatering av text ******

        Filtrera progr.kod (t.ex. xml, html mm) med externt program/utility
            =gsök: vim equalprg
        https://coderwall.com/p/ov0l3w/set-vim-s-equalprg-for-better-formatting
        http://vim.wikia.com/wiki/Cleanup_your_HTML



        tabeller (=med kolumner)  s132
            set virtualedit=all

            =t.ex. sök till sista kolumnen (=bara tom rubrik) + tryck j
            Bj

            tips/uppgift: kopiera o klistra in kolumn m c-v

            återställ till normallägesredigering
             set virtualedit=

            gör en/flera ersättningar i dessa tabeller, utan att uppställning förskjuts/blir skev
                =virtual replace-mode     grx  gR(tecken)

    }}}
    justera/ställ upp(align+justify) text {{{

        NY! :{range}center [width]
        :1,5center 40
        :1,5right 37

        (def. för textwidth i textdokument är oftast ca 80)

        :1left 5
        :2,5left
        This results in the following:
            I taught for a while. One ~
        time, I was stopped by the ~
        Fort Worth police, because my ~
        homework was too hard. True ~
        story. ~


        Vim has no built-in way of justifying text. However, there is a neat macro
        package that does the job. To use this package, execute the following command:
        :runtime macros/justify.vim
        _j      #justify textblock (vis. t.ex) med justify.vim i vim el genom program:
        :%!fmt    *****


        skillnad mellan 'wrap' och 'linebreak'
        :set linebreak      #bryter inte ord på mitten =*********
        :breakat   #speca tecken där brytningar är tillåtna
        undvika att stycken bryts  ;  :set textwidth=0


        gj gk   ********

         (:set guioptions+=b   visa rullningslist längst ner, om rader längre än fönstret = nowrap)

        zh
        4zh
        zH
        ze
        zl
        4zl
        zL
        zs

        g0
        g^
        gm
        g$


    }}}
 / / / / / / / / / / / / / / / / /      as =(autoindent/adjust indent)
    write(toprocess) Read******  FILTRERA MED UNIXKOMMANDON ******** {{{
        Några externa skalkommandon har wrappers som gör det enklare att köra dem i vim + fånga resultatet  ;  make och grep t.ex.

        http://www.softpanorama.org/Editors/Vimorama/vim_piping.shtml



        område där term-vim oftast är bättre in gvim  ;  !-filtrering o köra externa kommandon mm ******


        Ersätt m resultatet <==> Sätt in resultatet
            = !!date    vs    :read !date     ********


            When you have problems with filtering, check the values of these options:

            'shell' specifies the program that Vim uses to execute external programs.
            'shellcmdflag' argument to pass a command to the shell
            'shellquote' quote to be used around the command
            'shellxquote' quote to be used around the command and redirection
            'shelltype' kind of shell (only for the Amiga)
            'shellslash' use forward slashes in the command (only for MS-Windows and alikes)
            'shellredir' string used to write the command output into a file



    =
        Filtrera progr.kod (t.ex. xml, html mm) med externt program/utility
            =gsök: vim equalprg
        https://coderwall.com/p/ov0l3w/set-vim-s-equalprg-for-better-formatting
        http://vim.wikia.com/wiki/Cleanup_your_HTML



    FILTER

        (:h :range!)

        sortera fil m rader av typen
        john,smith,john@example.com; sortera efter ,-fält 2; inte rubriken
         :2,$!sort -t',' -k2
          .
        tips: gå till rad 2, !G  =sätter upp :.,$!
        (tänk: Kör externkommando (!) på RÖRELSE_X)

        filtrera/sortera till blank rad** {{{
            sortera en lista (som slutar vid en blank rad :DDD (s88)
            To sort this list, filter the text through the external sort command: >
            /^OBJS
            j
            :.,/^$/-1!sort
            This goes to the first line, where "OBJS" is the first thing in the line.
            Then it goes one line down and filters the lines until the next empty line.
        }}}

            http://vim.wikia.com/wiki/Use_filter_commands_to_process_text
            gsök: vim unix command filtering ******* (=se mer exempel och plocka)

        :!{program}     execute {program}
         !{motion}{program}
                !5jsort     
                :.,.+5!sort   #även 5:!sort

        !!      processa nuvarande rad m kommando (och ersätt raden med resultatet)
        5!!     processa nuv. rad +4 m komm. (o ersätt raderna m resultatet

                !5Gsort         =sortera från nuvarande raden, till rad 5

        :w !{program}    execute {program} and send text to its input
        :w(rite) !wc        =räkna rader, ord och tecken i öppna filen      #se upp med  :write! wc

        IDÉ FÖR :w !sh  =DÖP OM FILER I EN MAPP (fr. *.x till *.c) ***** {{{
            $ vim
            :r !ls *.c
            :%s/\(.*\).c/mv & \1.bla
            :w !sh
            :q!
        }}}


        Filtrera text [range] genom externt kommando {filter}
        :[range]!{program}     filter text through {program}
            A. :.,/^$/-1!sort
            B. Visualvälj lista + :sort     Filtrera en lista******

            Now convert the file to a hex dump with xxd: >
        :%!xxd
        :%!xxd -r

        :!ruby %

        :!!     kör senast körda unixkommando på kommandoraden, igen
        !
            !!date<Enter>   =ersätter nuvarande raden med resultatet/outputen för kommandot date

        STARTA SKAL (???) {{{
            ls, pwd mm/m.fl. skalkommandon efter varandra
            även jobs, kill mm mm (jobcontrol mm)
            ----------------------------------
            el om kör terminalvim: c-z kommandon(jobs mm) fg

            Executing a whole row of programs this way is possible.  But a shell is much
            better at it. You can start a new shell this way: >
                :shell
            This is similar to using CTRL-Z to suspend Vim.
            The difference is that a new shell is started.

            When using the GUI the shell will be using the Vim window for its input and
            output.(=??????) Since Vim is not a terminal emulator, this will not work perfectly.
            If you have trouble, try toggling the 'guipty' option. If this still doesn't
            work well enough, start a new terminal to run the shell in. For example with:
                :!xterm&

        http://vim.wikia.com/wiki/Display_output_of_shell_commands_in_new_window

        }}}


    READ
        :r !{program}    execute {program} and read its output
        :r(ead) !ls
        :read patch(.pa)
        :$r patch
        :0read patch    sätt in filen patch längst upp i filen (=innan rad 1)
        :0read !date -u




    }}}
    Processa/Konvertera (txt2html,pdf mm)**** {{{
        KONVERTERA NUVARANDE FILEN TILL HTML ; :so $VIMRUNTIME/syntax/2html.vim :w main.c.html  skriv ut filen från webläsare   :TOhtml
        :write main.c.html

        Open this file in your favorite browser and print it from there. If all goes
        well, the output should look exactly as it does in Vim. See |2html.vim| for
        details. Don't forget to delete the HTML file when you are done with it.
        Instead of printing, you could also put the HTML file on a web server, and let
        others look at the colored text.
    }}}
    MAPS {{{
        Grundtips för maps: Tänk efter testa och planera ; Använd alla vims rörelser mm som behövs för att göra makrona så repeterbara och generaliserbara som möjl. (så de inte kraschar på små detaljer)


        http://vim.wikia.com/wiki/Preview_current_HTML_file

        !!! Se upp med att göra map på tab  (=kommer att skugga c-i, eftersom den sätter in tab i insertläge)
        Obs! _noremap gör så det inte spelar roll om man satt ingående tang. till ngt annat


        Lista nuvarande mappings ; :map  (m.fl.)

        http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29

        :nnoremap <leader>ev :split/vsplit $MYVIMRC<cr>
        vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>
        :nnoremap Q gq  ,,  vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>
        :map <F5> i{<Esc>ea}<Esc>
        :map \p i(<Esc>ea)<Esc>
        :map \c i{<Esc>ea}<Esc>

        For example, to change the date mark in a file: >
        :map <F2> msHmtgg/Last [cC]hange:\s*/e+1<CR>"_D"=strftime("%Y %b %d")<CR>p'tzt`s
        :map <F2> a<C-R>=strftime("%c")<CR><Esc>

        map <F4> :execute " grep -srnw --binary-files=without-match --exclude-dir=.git --exclude-from=exclude.list . -e " . expand("<cword>") . " " <bar> cwindow<CR>


        :nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel     #sätt "-tecken runt ord
        övning: gör ytterligare en map för ' ist.för "
        +om vill göra en m vnoremap: anv. `< och `>

        0 till H
        $ till L
        nya mappings för topp skärm o bott. skärm
        q till Q
         :inoremap qj <esc>
        capslock till leader  el Esc


        Speciella escapesekvenserna (<args> för alla arguments t.ex. *** ) {{{
___pickout
            Replacement text

            The replacement text for a user defined command is scanned for special escape
            sequences, using <...> notation.  Escape sequences are replaced with values
            from the entered command line, and all other text is copied unchanged.  The
            resulting string is executed as an Ex command.  To avoid the replacement use
            <lt> in place of the initial <.  Thus to include "<bang>" literally use
            "<lt>bang>".

            The valid escape sequences are

                                    *<line1>*
                <line1> The starting line of the command range.
                                    *<line2>*
                <line2> The final line of the command range.
                                    *<count>*
                <count> Any count supplied (as described for the '-range'
                    and '-count' attributes).
                                    *<bang>*
                <bang>  (See the '-bang' attribute) Expands to a ! if the
                    command was executed with a ! modifier, otherwise
                    expands to nothing.
                                    *<reg>* *<register>*
                <reg>   (See the '-register' attribute) The optional register,
                    if specified.  Otherwise, expands to nothing.  <register>
                    is a synonym for this.
                                    *<args>*
                <args>  The command arguments, exactly as supplied (but as
                    noted above, any count or register can consume some
                    of the arguments, which are then not part of <args>).
                <lt>    A single '<' (Less-Than) character.  This is needed if you
                    want to get a literal copy of one of these escape sequences
                    into the expansion - for example, to get <bang>, use
                    <lt>bang>.

                                        *<q-args>*
            If the first two characters of an escape sequence are "q-" (for example,
            <q-args>) then the value is quoted in such a way as to make it a valid value
            for use in an expression.  This uses the argument as one single value.
            When there is no argument <q-args> is an empty string.
                                        *<f-args>*
            To allow commands to pass their arguments on to a user-defined function, there
            is a special form <f-args> ("function args").  This splits the command
            arguments at spaces and tabs, quotes each argument individually, and the
            <f-args> sequence is replaced by the comma-separated list of quoted arguments.
            See the Mycmd example below.  If no arguments are given <f-args> is removed.
               To embed whitespace into an argument of <f-args>, prepend a backslash.
            <f-args> replaces every pair of backslashes (\\) with one backslash.  A
            backslash followed by a character other than white space or a backslash
            remains unmodified.  Overview:

                command        <f-args> ~
                XX ab          'ab'
                XX a\b         'a\b'
                XX a\ b        'a b'
                XX a\  b       'a ', 'b'
                XX a\\b        'a\b'
                XX a\\ b       'a\', 'b'
                XX a\\\b       'a\\b'
                XX a\\\ b      'a\ b'
                XX a\\\\b      'a\\b'
                XX a\\\\ b     'a\\', 'b'

            Examples >

               " Delete everything after here to the end
               :com Ddel +,$d

               " Rename the current buffer
               :com -nargs=1 -bang -complete=file Ren f <args>|w<bang>

               " Replace a range with the contents of a file
               " (Enter this all as one line)
               :com -range -nargs=1 -complete=file
                 Replace <line1>-pu_|<line1>,<line2>d|r <args>|<line1>d

               " Count the number of lines in the range
               :com! -range -nargs=0 Lines  echo <line2> - <line1> + 1 "lines"

               " Call a user function (example of <f-args>)
               :com -nargs=* Mycmd call Myfunc(<f-args>)

            When executed as: >
                :Mycmd arg1 arg2
            This will invoke: >
                :call Myfunc("arg1","arg2")

               :" A more substantial example
               :function Allargs(command)
               :   let i = 0
               :   while i < argc()
               :      if filereadable(argv(i))
               :         execute "e " . argv(i)
               :         execute a:command
               :      endif
               :      let i = i + 1
               :   endwhile
               :endfunction
               :command -nargs=+ -complete=command Allargs call Allargs(<q-args>)

            The command Allargs takes any Vim command(s) as argument and executes it on all
            files in the argument list.  Usage example (note use of the "e" flag to ignore
            errors and the "update" command to write modified buffers): >
                :Allargs %s/foo/bar/ge|update
            This will invoke: >
                :call Allargs("%s/foo/bar/ge|update")
            <
            When defining a user command in a script, it will be able to call functions
            local to the script and use mappings local to the script.  When the user
            invokes the user command, it will run in the context of the script it was
            defined in.  This matters if |<SID>| is used in a command.
        }}}


    }}}
    Operatorpending Maps **     #o-pending ='operator waiting for object/motion'*** {{{

        :h map-operator

        te-tips: special/komm.-prefix som c-w, g och z är inte op.pending mode
         =namnavgränsare(namespaces) som utökar mängden möjliga maps *

    }}}
    Custom motions (som G, ae(?) mm) {{{

        läs först mer i :h omap-info

    }}}
    modelines {{{

        modeline sist i usermanindexet

        var lägga modelines?  ;  första eller sista fem raderna (=för vissa filer passar det bra högst upp, men för textfiler och andra typer där de ligger ivägen överst, lägg längst ner)
        :set modelines=10       anger hur många rader i bö. och slutet av filer som kollas för model.s
        slå av model.s = t.ex. när arbetar som root/admin  ;  :set nomodeline


            Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:

             vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:

        any-text vim:set {option}={value} ... : any-text ~
         you need to insert a backslash before a colon (otherwise it would be seen as the end of the modeline).

            behöver vara blanksteg innan 'vim:', eller att 'vim:' kommer först på raden


        Modeline  ;  # vim: syntax=make
        /* vim:set shiftwidth=4: */ ~

        // vim:set textwidth=72 dir=c\:\tmp:   use c:\tmp here ~

        |modeline|

        sätt filtyp m en modeline  ;  # vim: syntax=make   ******


    }}}
    Abbreviations**** {{{
        :abb <buffer> FF for (i = 0; i < ; ++i) 
        :iabbrev 

        :iabbrev adn and

        :iabbrev ad advertisement   #=triggas när man kör främst blanksteget(!) efter ordet
        :iabbrev JB Jack Benny
        :iabbrev #b /****************************************
        :iab(brev) #e <Space>****************************************/
        :abbreviate @f fresh

        :abbreviate teh the

        :abbreviate      #lista alla definierade förkortningar          
        :unabbreviate @f
        :abclear        rensa alla förkortningar

        :noreabbrev @a adder    =för att undvika att oavsiktliga rekursiva förkortningsmappningar

        :iabbrev @@ steve@stevelosh.com
        :iabbrev ccopy Copyright 2013 Steve Losh, all rights reserved.


            :abbreviate
            i #e            ****************************************/
            i #b            /****************************************
            i JB            Jack Benny
            i ad            advertisement
            ! teh           the
            The "i" in the first column indicates Insert mode. These abbreviations are
            only active in Insert mode. Other possible characters are:
            c           Command-line mode
            !           both Insert and Command-line mode
            :cabbrev
            :abbreviate


        *****?????
        :iunmap ssig
        :iabbrev ssig -- <cr>Steve Losh<cr>steve@stevelosh.com
        Now try out the abbreviation again.
        This time Vim will pay attention to the characters before and after ssig and only expand it when
        we want.

        epostadress
        hemsida
        fb o andra kontaktdata
        namn o signatur
         text och textdelar du skriver o infogar ofta


        There is one thing to watch out for when defining an abbreviation: The
        resulting string should not be mapped. For example: >
        :abbreviate @a adder
        :imap dd disk-door
        When you now type @a, you will get "adisk-doorer". That's not what you want.
        To avoid this, use the ":noreabbrev" command. It does the same as
        ":abbreviate", but avoids that the resulting string is used for mappings: >
        :noreabbrev @a adder
        Fortunately, it's unlikely that the result of an abbreviation is mapped.
    }}}

     Substitute  {{{

         KÖR ETT SUBST.KOMMANDO PÅ ALLA FILER I NUV. (PROGR./BOK(=filer i mappar o undermappar))PROJEKT *****
            /Pragmatic\ze Vim   #testa först sök- o ersättningshandl.
            :%s//Practical/g
            ------
            :args **/*.txt      #öppna alla filer i mapp o undermappar som ingår i projektet ****
            :set hidden
            :argdo %s//Practical/g(e)
        STEG 2 (=KÖR ERS. PÅ DE FILER DÄR MÖNSTRET MATCHAR =BEHÖVER INTE KÖRAS I ONÖDAN)
            /Pragmatic\ze Vim
            :vimgrep /<C-r>// **/*.txt      #sök rätt på filer m match + kör vimgrep (=skickar alla filer som matchar till quickfixlistan ****
                ist.föratt köra copen (=gå igenom res. manuellt):
                Skapa liknande (om funnits) :quickfixdo
                qargs.vim (substitution/qargs.vim): {{{

                    command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
                    function! QuickfixFilenames()
                      let buffer_numbers = {}
                      for quickfix_item in getqflist()
                        let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
                      endfor
                      return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
                    endfunction


                    (lägg till i vimrc el installera som plugin)

                }}}
            :Qargs
            :argdo %s//Practical/g(e)
            :argdo update
            (el  :Qargs | :argdo %s//Practical/g(e) | :argdo update )



        Subst.idiom*****  ^([^,]*)      #matcha fr.bö rad till , för att kunna återkalla med \1 (osv)

        ist. för '* * *' osv för att hoppa till nästa *-match, osv  ;  gör * en gång + sen n n n n  =sökmönstret sparas i "/  ******  o kan därför användas m :s//repl/gc osv ******

        Om används tillsammans m visual-star-skriptet =(vis.)+* sen s//+ersättn. **

        Tips för att enkelt fylla ut hela sökmönstret, även om tidigare gjort sökn. separat m * el / (=om vill kunna återkalla kommandot senare i sin helhet t.ex. för att kunna redigera och köra igen något annorlunda)**** ; c-r /  när i sökfältet



        öka på numrering för html-headings 
            (=matcha <h1, </h1 osv med \v-sök)  #tänk på att < är \< i \v-sök (=annars start av ord)
            :%s//\=submatch(0)-1/g

        Byta ut två ord mot varandra (typ 'man and dog' mot 'dog and man') i ett Subst.svep ******
            /\v(<man>|<dog>)
            :%s//\={"dog":"man","man":"dog"}[submatch(1)]/g
        *********
          Detta går förstås att återanv. om man lägger som funktioner mm i ett skript
          (+se också abolish.vim för ett färdigt exempel (som rekommenderas))



        *  cwcopy<esc>  n  .



        :%s/four/4/g
        :%s/\<four/4/g

        :%s/\s\+$//


        byt ut ord med :s och visa bytena som gjorts
        /p :)
        ----

        hela matchade mönstret (\1 är ju matchade parenteser nr 1) ???
        \0


        ändra 'That or this' till 'This or that'
        :s/\(That\) or \(this\)/\u\2 or \l\1/ [näst sista= litet L!]




        :h sub-replace-special

        hela det matchade
            &
            :%s/Kalle/& Stropp/
        senaste ersättningen
            ~
            :s/honoms/hans/ :s/hanses/~/

        \=      utvärdera/köra kod/vimscriptexpr. o sätt in resultatet som repl.string

        Anv. \= för att i ersättn.fältet komma åt innehållet i reg. 0  ;  :%s//\=@0/g

        Tips för när det kan vara bra att expl. sätta "/ med let @/=  ;  Om ska köra substitution med sökmönster som plockas/hanteras av skriptet  ****  (++skapar inte en post i /-historiken) (practv223/237)

        Ev spara o anv.  ' :%s//\=@0/g ' som ett verktyg  (=ersätter senaste sökmönstret m mönstret i reg a  ****


        Gör om exakt senaste s-substitueringen (men förra flaggorna anv. inte)
            :s(ubstitute)  (el  & ***)

        Gör om exakt senaste s-substitueringen (OCH förra flaggorna anv.)
            :&&         =PÅ NUVARANDE RADEN  (=som & med &(=alla flaggor) på slutet)

        Gör om exakt senaste s-substitueringen (OCH förra flaggorna anv.) MEN inte bara på markörraden, utan på VISUAL SELECTION
            :'<,'>&&            

        g&          Synonym for `:%s//~/&` el :%&& (repeat last substitute with
                    last search pattern on all lines with the same flags).
                    For example, when you first do a substitution with
                    `:s/pattern/repl/flags` and then `/search` for
                    something else, `g&` will do `:%s/search/repl/flags`.
                    Mnemonic: global substitute. {not in Vi}
        (=om du går in för att redigera i kradshistoriken för att lägga till % du missade första gången)



        :s gc 3  //  :&[&][flags] N     :&
            gör om samma subst. som sist, men med gc, och bara på de tre sista raderna i range
          =kör samma s igen, m samma sök o ersättn.  MEN inte samma flaggor

        You have a list of names in this form:
            Doe, John ~
            Smith, Peter ~
        You want to change that to:
            John Doe ~
            Peter Smith ~
        This can be done with just one command: >
            :%s/\([^,]*\), \(.*\)/\2 \1/


        :~  :s//red/  :&r
            kör samma substitute som förra, men med senaste genomförda/sparade /-sökningsmönstret


        ------

        ändra alla tecken fram till \e / \E till versal
        \U
        ändra alla tecken fram till \e / \E till gemen
        \L
        repetera substitution global ???
        G  ???


        :?^Chapter?,/^Chapter/s=grey=gray=g  ******
        :1,5s/this/that/g       #g=ändra ALLA förekomster på varje matchad rad
        :54s/President/Fool/
        :.,$s/yes/no/


        Redigera i flera filer (e =undvik att fel stoppar kommandot****) {{{
            ändra ett namn i alla filer i en argslista :D ******

            .förklaring {{{
                Let's assume you have a directory with C++ files, all ending in ".cpp".
                There is a function called "GetResp" that you want to rename to "GetAnswer".
                vim *.cpp
                Start Vim, defining the argument list to contain all the C++ files. You are now in the first file.
                qq
                Start recording into the q register
                :%s/\<GetResp\>/GetAnswer/g
                Do the replacements in the first file.
                :wnext
                Write this file and move to the next one.
                q
                Stop recording.
                @q
                Execute the q register. This will replay the substitution and ":wnext". You can verify that this doesn't produce an error message.
                999@q
                Execute the q register on the remaining files.
                Obs! :)
            }}}
                vim *.cpp
                qq
                    :%s/\<getResp\>/getAnswer/ge        *********
                    :wnext
                q
                @q
                999@q

            There is one catch: If one of the .cpp files does not contain the word "GetResp", you will get an error and replacing will stop. To avoid this, add the "e" flag to the substitute command: >
                :%s/\<GetResp\>/GetAnswer/ge
            The "e" flag tells ":substitute" that not finding a match is not an error.
        }}}

        Val att göra vid c-flaggan (s///gc t.ex.):
        y
            Yes; make this change.
        n
            No; skip this match.
        a
            All; make this change and all remaining ones without further confirmation.
        q
            Quit; don't make any more changes.
        l
            Last; make this change and then quit.
        CTRL-E
            Scroll the text one line up.
        CTRL-Y
            Scroll the text one line down.

        fler flaggor (= s/ / /x)
        &
            behåll flaggorna från sist körning av subst.
        e
            (se ovanovan)
        i
            ignore case
        I
            MATCH CASE
        [n] Report the number of matches, do not actually substitute.  The [c]
            flag is ignored.  The matches are reported as if 'report' is zero.
            Useful to |count-items|.
            If \= |sub-replace-expression| is used, the expression will be
            evaluated in the |sandbox| at every match.

        [p] Print the line containing the last substitute.

        [#] Like [p] and prepend the line number.

        [l] Like [p] but print the text like |:list|.


    Exempel {{{

        :?^Chapter?,/^Chapter/s=grey=gray=g

      :1,$s/a\|b/xxx\0xxx/g      modifies "a b"      to "xxxaxxx xxxbxxx"
      :s/\([abc]\)\([efg]\)/\2\1/g   modifies "af fa bg" to "fa fa gb"
      :s/abcde/abc^Mde/      modifies "abcde"    to "abc", "de" (two lines)
      :s/$/\^M/          modifies "abcde"    to "abcde^M"
      :s/\w\+/\u\0/g         modifies "bla bla"  to "Bla Bla"
      :s/\w\+/\L\u/g         modifies "BLA bla"  to "Bla Bla"

    }}}



     }}}
    (RADADRESSER)****  :r1,r2 {{{
        :?^Chapter?,/^Chapter/s=grey=gray=g  ******
        /Chapter/-1
        /Chapter/+2
        :.+3,$-5
        :'t,'b
         :`t,`b  ????????
        :'<,'>
        :'>,$
        :.;+4

        från nuv. fram till (men inte med) blank rad
        :.,/^$/-1!sort

        5:      ger  :.,.+4     *********

    }}}
    räkna ord, räkna tecken mm**** {{{

                /n sist
        Räkna ord i hela filen;Kör substitute med /n sist
         :%s/ord//gn 

         :w !wc
         gg !Gwc     (obs! räknar men ersätter hela filen med resultatet.
         :r(ead)((osv))  räkna + skriv resultatet i filen


         For other ways to count words, lines and other items, see |count-items|.  ___SEMER

        g c-g
        (vis.)g c-g

        :%s/./&/gn      characters
        :%s/\i\+/&/gn       words
        :%s/^//n        lines
        :%s/the/&/gn        "the" anywhere
        :%s/\<the\>/&/gn    "the" as a word
          (+e som flagga, om inte nomatch ska ge felmeddelande)



        If you want to find matches in multiple files use |:vimgrep|.

                                    *count-bytes*
        If you want to count bytes, you can use this:

            Visually select the characters (block is also possible)
            Use "y" to yank the characters
            Use the strlen() function: >
                :echo strlen(@")
        A line break is counted for one byte.


    }}}
    VISA(print) RADER M MÖNSTER {{{

        hitta och visa alla rader mellan 60 och 124 som innehåller 'mönster'
        :60,124g/mönster/p

    }}}
     :normal {{{

        :[range]normal {kommandon}

        3,/endpos1/ normal .        #kör normallägeskomm . på varje specad rad

        jVG
        :'<,'>normal.       #utför ett n-lägeskommando/ins.chunk + uppr. på alla valda rader

        :%normal A;         #samma som förra i ett svep

        :%normal i//        #kommentera bort alla rader i en hel javascript-fil *****************

        :normal @q      #kör makro q på specade rader

     }}}
     GLOBAL {{{

        Anv. sökhistoriken (=från / och ?) =kan utelämnas om redan sökt något. ****
        /\v\<\/?\w+>
        :g//d

        sudda allt utom länkrader(='href')  ;  :v/href/d

        PLOCKA ALLA RADER MÄRKTA TODO TILL REGISTER ******
            1.Visa lista m alla rader som matchar TODO
              :g/TODO
            2a.Spara TODO-rader i reg. a
              (qaq =rensa registret)
              :g/TODO/yank A        *********
              :reg a
            2b.Klistra kopior på TODO-raderna sist i filen
              :g/TODO/t$
        UPPG:SAMLA ALLA TODO-RADER M :BUFDO/:ARGDO ('tips96 på s233 för tips om upplägg')

        SORTERA ALLA RADER INNE I ETT BLOCK ******* (t.ex. egenskaper inne i css-block)
            :g/{/ .+1,/}/-1 sort        #****** range nr 2 är för ex-kommandot sort **
                ( :g/{start}/ .,{finish} [cmd] )

        fler exempel för handl.
            :g/{/ .+1,/}/-1 >
            :g/{/sil .+1,/}/-1 >    #=gör att inte varje handling skrivs ut i loggen*


        omvandla ett vimstycke till stycke lämpl. att importera till t.ex. word som stycke  ;  :g/./,/^$/join
          :g/\S/,/^\s*$/join


        GLOBAL (= :g)
         :range vglobal /patt/ cmd
         :range global! /patt/ cmd
        :[range]global/{pattern}/{command}      =kör på alla rader i range där mönstret matchar
            cmd =  :-kommandon el 'normal dd'
        funkar för alla regexmönster :)

        Suppose you want to change "foobar" to "barfoo", but only in C++ style comments. These comments start with "//". Use this command: >
        :g+//+s/foobar/barfoo/g         ändra foobar till barfoo, men bara i c/java/javascript-kommentarer

        :g/re/d     #sudda alla rader där mönstret re matchas

        :g
        kör på alla rader där mönster förekommer

        :g!
        kör på alla rader där mönster INTE förekommer
        :v
        kör på alla rader där mönster INTE förekommer

        hitta och visa alla rader i fil som innehåller mönster
        :g/mönster/p
        hitta och visa alla rader i fil som inte innehåller mönster + visa radnummer för dessa rader
        :g!/mönster/nu  :v/mönster/nu

        Vänd upp och ner på rader i en fil (hela)*
            :global/^/m 0    :g/^/m 0
        Vänd upp och ner på rader i en fil (del)***
            markera första raden med 'mt'     gå till sista aktuella +  :'t+1,.g/^/m 't

     }}}
    g/PATT/CMD  ******* {{{
        g/-\( .\)\?$/join
        g/x/normal @: 
    }}}
    REGEX {{{
      :h pattern

        #######magic(?)     vanlig textsök
        \v(ery magic    mönster/regex-sök
        \V(ery nomagic  söka vanliga strängar, o även m många specialtecken (a.k.a. osv)  #bara \ har speciell mening i dessa sökningar

        [0-9a-zA-Z] el \x       #de längre (till vä.) tar längre tid i sökningar om inte minns fel ******


        regular expressions

        ändra Svensson, Lars  till Lars Svensson
        :%s/\([^,]*\), \(.*\)/\2 \1/

        ändra Första andra  till Andra första
         (=kolla extraväxlarna \u \l \U \L \e \E   till Substitute)

        Matcha ordmönster av typen 'the the' (även om över två rader)  ;  /\v<(\w+)\_s+\1>
        Ytterligare exempel på där det är användbart m \N-referenser i sökmönstret  ;  matcha öppnande och stängande xml/html-etiketter **

        \0   återger hela matchade mönstret, även om inte använde ( ) runt något

        Sök text (minst ett tecken) inom "-tecken  ;  "[^"]+"    (+tillfoga \zs o \ze efter första och innan sista ", om de inte ska inkluderas

        Kör sökning på url i "u, och anv. funktion för att 'escape' specialtecken (=behövs Även om kör med \V)  ;  /\V + c-r= escape(@u, getcmdtype().'\')  #getcmdtype-delen = ger / om framåtsökn. och ? om bakåtsökn. + slår ihop m \ som de två tecken som ska escapeas

        Regex vim mm {{{

        ___regexpatt
            .
            *
            +
            = ?
            ^ $
            \< \>
            (  )
            \{3,5}
             \{4}
             \{3,}
            \{-1,3}     #så få som möjligt ******
            a.\{-}b
            |
            (  |  |  )


            ___SEMER
            ????????????
            A related item is "\&".  This requires that both alternatives match in the
            same place.  The resulting match uses the last alternative.  Example: >

                /forever\&...

            This matches "for" in "forever".  It will not match "fortuin", for example.
            ????????????



            [a-z]
             [1234abcde]
             [0-9a-f]
             [\e]   <Esc>
             [\t]   <Tab>
             [\r]   <CR>
             [\b]   <BS>
                            +SE /[] I HELP FÖR MER  
            "[^"]*"

            \a
                char.ranges =innehåller en fast uppsättning tecken
            \d      #alla(?) kan anv. med/som \_d  =siffra el linebreak
            \D
            \x
            \X
            \s
            \S
            \l
            \L
            \u
            \U
                            +SE /\s I HELP FÖR HELA LISTAN
            \h  [A-Za-z]
            \w  [0-9A-Za-z]
                char.classes =går att omformulera för att inkludera fler tecken *****
            \i      ident.chars     'isident'
            \I      som \i, utom siffror
            \k      keyw.chars      'iskeyword'
            \K
            \p      printable chars 'isprint'
            \P
            \f      filename chars  'isfname'
            \F

            /the\nword
            /the\_sword     #blank el nl
            /the\_s\+word   #blanka(!) el nl
            \_.     \_.* #SEUPP
            \_[a-z]     a-z el nl
            /"\_[^"]*"      #hittar text inom cit.tecken som kan vara brutet över rader ********


            3 EXEMPLEN för amer. bilreg.skyltar
             \d\u\u osv
             \d\u\{3} osv
             [0-9][A-Z] osv
                =om kan komma ihåg alla, undvik den nedersta =perform.issues        


        }}}
        matcha Xml och Xhtml  ;  /\vX(ht)?ml\C

        Sök rader som inte(!) innehåller 'sträng'  ;  @!    \ om magic

        huvudsakliga anv.omr. för negative lookarounds  ;  syntax highlighting-regelfiler

    }}}


    pausa vim + köra Bash-kommandon mm {{{

    evince -p 98 ~/Dropbox/vim_user_manual.pdf &

    }}}
    VIEWS/SESSIONS/VIMINFO {{{
        :mksession! ~/.vim/secret.vim
        :source ~/.vim/boring.vim   vim -S session.vim
        ---
        :mkview 3
        :loadview 2
        ---
        :rviminfo
        :wviminfo
        }}}
    Viminfo {{{

        The ! character is used by ":wviminfo" to forcefully overwrite an existing
        file. When it is omitted, and the file exists, the information is merged into the file.
        The ! character used for ":rviminfo" means that all the information is
        used, this may overwrite existing information. Without the ! only information that wasn't set is used.

        tre saker som inte sparas med sessions (=wviminfo istället) ; marks, registers och kommandorads-historik
        saker som sparas i viminfo
            k.rad- + sök-historik
            registers
            märken(x o X)
            bufferlistan
            globala variabler

        the Viminfo-string ** {{{
            Take a look at how you can build up your own viminfo string. First, the '
            option is used to specify how many files for which you save marks (a-z). Pick
            a nice even number for this option (1000, for instance). Your command now
            looks like this:
                :set viminfo='1000
            The f option controls whether global marks (A-Z and 0-9) are stored. If this
            option is 0, none are stored. If it is 1 or you do not specify an f option,
            the marks are stored. You want this feature, so now you have this:
                :set viminfo='1000,f1
            The < option controls how many lines are saved for each of the registers. By
            default, all the lines are saved. If 0, nothing is saved. To avoid adding
            thousands of lines to your viminfo file (which might never get used and makes
            starting Vim slower) you use a maximum of 500 lines:
                :set viminfo='1000,f1,<500

            <           Other options you might want to use:
            :           number of lines to save from the command line history
            @           number of lines to save from the input line history
            /           number of lines to save from the search history
            r           removable media, for which no marks will be stored (can be used several times)
            !           global variables that start with an uppercase letter and don't contain lowercase letters
            h           disable 'hlsearch' highlighting when starting
            %           the buffer list (only restored when starting Vim without file arguments)
            c           convert the text using 'encoding'
            n           name used for the viminfo file (must be the last option)

            See the 'viminfo' option and |viminfo-file| for more information.
        }}}
        ----
        utbyta register-innehåll mm mellan två instanser av vim :DDDD !!
        You can use the ":wviminfo" and ":rviminfo" commands to save and restore the information while still running Vim. This is useful for exchanging register contents between two instances of Vim, for example. In the first Vim do: >
        :wviminfo! ~/tmp/viminfo
        And in the second Vim do: >
        :rviminfo! ~/tmp/viminfo
        SE MER EV  s99+  s101 :)
    }}}
    Sessions {{{
        https://bocoup.com/blog/sessions-the-vim-feature-you-probably-arent-using
        http://stackoverflow.com/questions/1642611/how-to-save-and-restore-multiple-different-sessions-in-vim
        http://www.atrixnet.com/save-a-vim-session-and-then-resume-it/
        https://vi.stackexchange.com/questions/5624/how-do-i-restore-a-group-of-tabs
        http://vim.wikia.com/wiki/Go_away_and_come_back


        Vad som sparas med en session:
            file list
            window layout, sizes mm
            global variables
            options 
             mm
        Exactly what is remembered is controlled by the 'sessionoptions' option, described below.
        The default value is "blank,buffers,curdir,folds,help,options,winsize"
            blank       keep empty windows
            buffers     all buffers, not only the ones in a window
            curdir      the current directory
            folds       folds, also manually created ones
            help        the help window
            options     all options and mappings
            winsize     window sizes

        Change this to your liking. To also restore the size of the Vim window, for example, use:
        :set sessionoptions+=resize

        Some people have to do work on MS-Windows systems one day and on Unix another
        day. If you are one of them, consider adding "slash" and "unix" to
        'sessionoptions'. The session files will then be written in a format that can
        be used on both systems. This is the command to put in your vimrc file:
            :set sessionoptions+=unix,slash



        :mksession session.vim
        skapa en session

        öppna en sparad session
        :so(urce) session.vim
        vim -S session.vim
        (S funkar för att sourcea alla vimskript) :]


        :wall
        :mksession! ~/.vim/secret.vim
        :source ~/.vim/boring.vim

        :mksession! ~/.vim/secret.vim
        :wviminfo! ~/.vim/secret.viminfo
            And to restore this again: >
        :source ~/.vim/secret.vim
        :rviminfo! ~/.vim/secret.viminfo


        Anv.områden:
            Projekt
            Skapa fönsterkomposition du gillar (t.ex. hjälpfil i topp el tab + fileexplorer till vä.)



        SESSIONS AND VIMINFO
        Sessions store many things, but not the position of marks, contents of
        registers and the command line history. You need to use the viminfo feature
        for these things.
        In most situations you will want to use sessions separately from viminfo.
        This can be used to switch to another session, but keep the command line
        history. And yank text into registers in one session, and paste it back in
        another session.
        You might prefer to keep the info with the session. You will have to do
        this yourself then. Example:
            :mksession! ~/.vim/secret.vim
            :wviminfo! ~/.vim/secret.viminfo
        And to restore this again:
            :source ~/.vim/secret.vim
            :rviminfo! ~/.vim/secret.viminfo



    }}}
    View {{{
        man kan låta vim själv spara en fil =bestämma var ska sparas mm
        när redigerar den igen =ladda view
            :mkview
            :loadview

        You can store up to ten views on one file. For example, to save the current setup as the third view and load the second view:
            :mkview 3
            :loadview 2

        10 st: unnumbered + 1-9


        :mkview ~/.vim/main.vim
            You can restore it with:
        :source ~/.vim/main.vim
    }}}

    pipe input to vim / läs från stdin {{{
        ls | vim -
        ls | gvim -
    }}}
    SOURCE/RECORD SCRIPT (-S, -w ) {{{
        -S 
            anropa extern vimfil/externt vimskript från komm.raden** ; -S = source
            vim -S ~/mysession.vim
            gvim -S ~/Dropbox/planeringsdok_session.vim
            vim -S sessionfilnamn och :so(urce) sessionfilnamn

            gvim -S ~/Dropbox/planeringsdok.vimsession -c 'rviminfo ~/Dropbox/planeringsdok.viminfo'

            Processa/Kör vim m skript(=source) på text som läses från stdin  ;  ls | vim -S ~/scripts/change.vim

        -s 
            kör angiven fil som ett skript (som om skrivet i normal-läge) ; -s
            vim -s ~/scripts/nlskript.vim fil.txt
                (=körs precis som skrivna, inkl. radbrytn. tolkas som Enter(!))
        -s -e 
            här betyder s 'silent mode' + e =kör vim i Ex-läge
            vim -e -s svenskasynonymer.temp.txt < ~/scripts/vim/clean_svenskasynonymer.vimscript {{{
                " sudda tomma rader
                g/^$/d

                " radbrytning efter varje kolon/semikolon
                %s/[:;]\zs /\r/g

                " dra ihop ord som lagts över två rader med bindestreck
                g/-\( .\)\?$/join
                %s/- \(. \)\?//

                " gör 1 tabs indrag på alla rader som slutar med/utan semikolon (men inte de med kolon=uppslagsorden)
                %s/^\ze.*[^:]$/\t/

                " ta bort semikolon
                %s/'//
                %s/\\//

                "DET FUNKAR!!
                write
                quit
            }}}
            vim -e -s danskordlista.temp.txt < ~/scripts/vim/clean_danskordlista.vimscript {{{
                "" sudda tomma rader
                "g/^$/d
                "
                " radbrytning efter varje kolon/semikolon
                %s/[:;]\zs /\r/g

                " dra ihop ord som lagts över två rader med bindestreck
                g/-\( .\)\?$/join
                %s/- \(. \)\?//

                " gör 1 tabs indrag på alla rader som slutar med/utan semikolon (men inte de med kolon=uppslagsorden)
                %s/^\ze.*[^:]$/\t/

                " DRA IHOP ORD SOM LAGTS ÖVER TVÅ RADER MED BINDESTRECK (=FÖR ATT KUNNA SÖKA ÄVEN PÅ DE DANSKA ORDEN)
                """""""""""%s/-$\n//g


                """  lägg till write och quit
            }}}
        -w 
            record (normalmode-commands) script (append)
            =kan köras flera gånger om på samma fil
             för att bygga upp skriptet bit för bit
        -W 
            record (normalmode-commands) script (Overwrite)


        %s/-person-/Jones/g
        write tempfile
        quit

        for file in *.txt; do
         vim -e -s $file < change.vim
         lpr -r tempfile
        done


    }}}
    Autocommands **** {{{

        |:autocmd|  :au           list all autocommands
        |:autocmd|  :au {event}       list all autocommands for {event}
        |:autocmd|  :au {event} {pat}     list all autocommands for {event}
                              with {pat}
        |:autocmd|  :au {event} {pat} {cmd}   enter new autocommands for {event}
                              with {pat}
        |:autocmd|  :au!              remove all autocommands
        |:autocmd|  :au! {event}          remove all autocommands for {event}
        |:autocmd|  :au! * {pat}          remove all autocommands for {pat}
        |:autocmd|  :au! {event} {pat}    remove all autocommands for {event}
                              with {pat}
        |:autocmd|  :au! {event} {pat} {cmd}  remove all autocommands for {event}
                              with {pat} and enter new one



        autocmd FileType text setlocal textwidth=78

        i vimrc t.ex.:
        if has("autocmd")
            autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
        endif

        autocmd BufReadPost *
            \ if line("'\"") > 1 && line("'\"") <= line("$") |
            \ exe "normal! g`\"" |
            \ endif


    }}}
    Funktioner/Egna Kommandon
    VIMSCRIPT **** {{{

        I Vimscript, använd ALLTID :normal!
        =normal-varianten av :_noremap ********

        |write-plugin|


        if has("vms")
            set nobackup
        else
            set backup
        endif


        if &t_Co > 2 || has("gui_running")
            syntax on
            set hlsearch
        endif

        if &t_Co > 1
            syntax enable
        endif


VIMSCRIPT**********{{{
    genomläsning/genomgång 'Vimscript the hard way'

    :echo "Hello, world!"
    :echom "Hello again, world"
    :messages
    :set number!
    :set numberwidth=10  :set numberwidth=4  :set numberwidth?
    :set numberwidth=2  :set nonumber
    :set number numberwidth=6
    :map <c-d> dd
    :nmap \ dd
    :imap <c-d> dd
    Set up mapping so you can press <c-u> to convert the current...
    So far we've used map, nmap, vmap, and imap to create key mappings that...
    :nunmap -   :nunmap \
    :nnoremap -d dd  :nnoremap -c ddO
    6.2 Leader
    6.3 Local Leader
    :let maplocalleader = "\\"
    Now you can use <localleader> in mappings and it will work just like...
    Read :help mapleader
    Read :help maplocalleader.
    :nnoremap <leader>ev :vsplit $MYVIMRC<cr>
    Read :help myvimrc.
    Vim has a feature called "abbreviations" that feel similar to ...
    Last search start
    :iabbrev ccopy Copyright 2013 Steve Losh, all rights reserved
    :nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
    :inoremap jk <esc>
    ·<c-c> ·<c-[>
    :inoremap <esc> <nop>
    The convention of using <localleader> for local mapping.....
    When you press Q, Vim wil run the first mapping, not the second, b...
    Now we're going to look at a topic almost as important as mappings: ...
    :autocmd BufNewFile * :write
    This is pretty self-explanatory, except for one catch: you can't use special...
    :autocmd BufWritePre *.html :normal gg=G
    This lets us target our autocommands at specific files, wh...
    12.3 Multiple Events
    :autocmd BufWritePre,BufRead *.html :normal gg=G
    A common idiom in Vim scripting is to pair BufRead and BufNewFile...
    One of the most useful events is the FileType event.
    :autocmd FileType javascript nnoremap <buffer> <localleader>....
    Skim :help autocmd-events to see a list of all the events you can bind... *******
    13 Buffer-Local Abbreviatons
    :iabbrev <buffer> &mdash;(=???)
    Let's pair up these buffer-local abbreviations with autocommands ...
    :autocmd FileType python :iabbrev <buffer> iff if:&....
    Some good candidates are return for most languages, function for jav....
    :autocmd BufWrite * :echom "Writing buffer!"
    14.1 The Problem
    The first step is to group related autocommands into named groups.
    :augroup testgroup
    :autocmd BufWrite * :echom
    "Foo" : autocmd BufWrite * :echom " ....
    If you want to clear a group you can use autocmd!
    Now that we know how to group autocommands and clear those gro....
    augroup filetype_html autocmd!
    autocmd FileType html nnoremap <buffer> <localleader>f Va....
    Go through your ~/.vimrc file and wrap every autocommand you have....
    You can put multiple autocommands in the same group if it makes sense ....
    15 Operator-Pending Mappings
    An operator is a command that waits for you to enter a movement ...
    :onoremap p i(
    :onoremap b /return<cr>
    When you're trying to think about how to define a new operator-pending....
    :onoremap in( :<c-u>normal!
    :onoremap ih :<c-u>execute "normal
    Vim will write your file, just as if you had typed :write<cr>
    The problem is that normal!
    doesn't recognize "special characters" like <cr>
    17 Status Lines
    :set statusline=%f " Path to the file :set statusline+=\-\ " Separ...
    Skim the list of available codes in :help statusline.
    Be sure to use the +=-form of set to split the definition across multiple li....
    Make sure to wrap the autocommands in groups to preven....
    18 Responsible Coding
    Some places to start might be: "Basic Settings", "FileType-specific ....
    Using ==# and ==?   *******
}}}


        |:<abuf>|   <abuf>  buffer number, for use in an autocommand (only where a
                       file name is expected)
        |:<afile>|  <afile> file name, for use in an autocommand (only where a
                       file name is expected)
        |:<amatch>| <amatch>    what matched with the pattern, for use in an
                       autocommand (only where a file name is expected)
        |:<cword>|  <cword> word under the cursor (only where a file name is
                       expected)
        |:<cWORD>|  <cWORD> WORD under the cursor (only where a file name is
                       expected) (see |WORD|)
        |:<cfile>|  <cfile> file name under the cursor (only where a file name is
                       expected)
        |:<sfile>|  <sfile> file name of a ":source"d file, within that file (only
                       where a file name is expected)


    }}}
    Egna menyer


    -----
    VUNDLE / INSTALLERA PLUGINS {{{

            *******  https://lepture.com/en/2012/vundle-vs-pathogen #vundle vs pathogen==VUNDLE ***
            gsök: how to install plugins in pathogen and vundle
                (pathogen: https://gist.github.com/romainl/9970697 #how to use mm av tim pope på github)
              gsök: vundle vs pathogen



            Vad är en plugin? ; En vimscriptfil som laddas automatiskt när vim startar
            Installera en plugin ; lägg plugin-filen.vim i rätt mapp  =((från??)) $VIMRUNTIME(/usr/share/vim/vim74)/macros och /ftplugin [vim.org m.fl. ställen**]   #=från de som distribueras med programmet (t.ex. justify.vim)
            Två typerna ; global plugins(=för alla filtyper) och ftplugin(=för vissa specifika filtyper) |add-filetype-plugin|
            Varför man anv. plugins (=vimscript som laddar automatiskt)  ;  för att kunna lägg till funktionalitet som de flesta vill ha, men läggs som skript istället för att kompileras direkt in i vim
            Installera global/ftplugin*** ; lägg i ~/.vim/plugin/ // ~/.vim/ftplugin  (mkdir -p ~/.vim/plugin)  ,,  cp $VRT/macros/justify.vim ~/.vim/plugin   add-global-plugin    
            Skapa vim(global)plugin-mappen + lägg till skriptet "justify"  ;  mkdir -p ~/.vim/plugin/    cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin

            Var hittar man plugins?  ;  vissa följer med vim ($VIMRUNTIME/macros och undermappar),, ladda ner från nätet (många finns på www.vim.org),, vim maillist (|maillist|),, Skriva en själv |write-plugin|

             visst sätt att distribuera en plugin ; |vimball|-arkiv
            Sätt så vissa installerade plugins installeras automatiskt** ; |getscript|
            Gruppera plugins 't.ex. i kategorin perl' ; ~/.vim/plugin/perl/*.vim    (+se till att :filetype plugin on )

The generic names for the filetype plugins are: >
ftplugin/<filetype>.vim
ftplugin/<filetype>_<name>.vim

            Namngivning av ftplugin 'justify' för filtyp 'scm' ; scm_justify.vim
            Mer om namngivning för ftplugins ; ~/.vim/ftplugin/stuff.vim   ~/.vim/ftplugin/stuff_def.vim   ~/.vim/ftplugin/stuff/header.vim



        DECAGON VUNDLE TUTORIALS (3st): {{{
            v1 (installera vundle) {{{

                https://www.youtube.com/watch?v=tbWOlzj0tvY&list=PLACaMjX8w4lns7P5MthaYM0RHcawTp3ei  

                git clone https:/github.com/gmarik/vundle.vim.git ~/vimfiles/bundle/vundle.vim  #bundlemappen heter förmodl. annat i unix (=.vim/????) =se nedan i dokumentationen ***********

                redigera .vimrc-filen {{{

                    set nocompatible
                    filetype off


                    " set Runtime path to inc Vundle and initialize
                    set rtp+=~/vimfiles/bundle/Vundle.vim

                    "this is the call to begin the Vundle Plugin Opperation


                    call vundle#begin()

                    Plugin 'gmarik/Vundle.vim'

                    " TODO: tpope vim-fugitive plugin
                    Plugin 'tpope/vim-fugitive'

                    " this plugin is from vim.org : L9

                    call vundle#end()
                    filetype plugin indent on

                }}}

                Link to the Vundle.vim repo and Documentation:  *********
                https://github.com/VundleVim/Vundle.vim

                Here are some commands that are usefull in Vundle.vim 
                " Brief help
                " :PluginList - list configured plugins 
                " :PluginInstall(!) - install (update) plugins 
                " :PluginSearch(!) foo - search (or refresh cache first) for foo 
                " :PluginClean(!) - confirm (or auto-approve) removal of unused plugins


                i vundle#begin i rc:n
                    Plugin 'gmarik/Vundle.vim'  #installerar sig själv rekursivt ***


                kör vim (= $vim)

                :PluginInstall

            }}}
            v2 (lägga till plugins med vundle) {{{

                Installera en plugin från github av timpope
                som heter vim-fugitive (puller/merger mm för Github ****** )

                $vim
                :PluginList

                $vim .vimrc
                Plugin 'tpope/vim-fugitive'
                source:a vimrcfilen (så ändringen uppfattas av vim)

                $vim
                :PluginList

                :PluginInstall  #installerar icke installerade, och uppdaterar installerade  #+se helpmm på pluginens hemsida *****

            }}}
            v3 (installera fler plugins; ta bort plugins) {{{

                Installera fler plugins
                Installera från andra ställen (=utöver github)
                Ta bort plugins


                $vim .vimrc 
                "this plugin is from vim.org : L9
                Plugin 'L9'

                $vim
                :PluginList
                :PluginInstall


                ta bort plugin
                $vim .vimrc 
                "this plugin is from vim.org : L9
                "Plugin 'L9'
                ------
                $vim
                :PluginList
                :PluginClean


            }}}
        }}}
        youtsök: install vundle ******
        youtsök: how to use vundle ******
        https://www.youtube.com/watch?v=tbWOlzj0tvY  #Vim Plugin Tutorials - Episode 1 (Installing Vundle.vim)



        Further reading:
        |filetype-plugins|  Documentation for the filetype plugins and information about how to avoid that mappings cause problems.
        |load-plugins|      When the global plugins are loaded during startup.
        |ftplugin-overrule| Overruling the settings from a global plugin.
        |write-plugin|      How to write a plugin script.
        |plugin-details|    For more information about using plugins or when your plugin doesn't work.
        |new-filetype|      How to detect a new file type.


    }}}
        vimplugin management ***** {{{

            https://github.com/rust-lang/rust.vim/issues/137

            https://vi.stackexchange.com/questions/9522/what-is-the-vim8-package-feature-and-how-should-i-use-it  ******
            gsök: installing plugins in vim 8

            4vimplugin-hanterarna(https://www.youtube.com/watch?v=vMAeYp8mX_M&t=2300s 18:10-30ca): pathogen,vundle,neobundle,vim-plug)
            +gsök: {FÖRRA}  +  pathogen vs vundle vs neobundle vs vim-plug

        }}}
    PLUGINS / POPULAR BEST VIM PLUGINS {{{
        gsök: popular vim plugins
        https://github.com/akrawchyk/awesome-vim
        https://github.com/akrawchyk/awesome-vim#learning-vim
        https://github.com/python-mode/python-mode
        youcompleteme/Vimcompleteme ******** {{{
            https://www.reddit.com/r/vim/comments/4ufblz/alternatives_to_youcompleteme/
        }}}
    }}}
    REDIGERA KOD/PROGRAM**** {{{
        bash *** {{{
            ~/Dropbox/vim-bash_hotkeys.pdf
            ~/Dropbox/vim_bashsupport.pdf
        }}}
        python **** {{{
        }}}
        c/cpp {{{
            'Edit C in Vim'
                make och compile
                ctags
                 ((highlight och indent))
                (omnicompletion för c och java??) [youcompleteme]
            http://www.alexeyshmalko.com/2014/using-vim-as-c-cpp-ide/
            http://www.thegeekstuff.com/2009/01/tutorial-make-vim-as-your-cc-ide-using-cvim-plugin
        }}}
        java {{{
        }}}
        Move through Programs  k29-s154
        Redigera/Kompilera programmeringskod  k30-s163
        xml ** {{{
            http://www.pinkjuice.com/howto/vimxml/setup.xml
            http://oss.sgi.com/LDP/HOWTO/Vim-HOWTO/xml_editor.html
            gsök: xml edit tools for vim
            xml.vim: http://www.vim.org/scripts/script.php?script_id=1397
        }}}
        htmlcss {{{
        }}}
        javascript {{{
        }}}
        docbook {{{
            http://supportweb.cs.bham.ac.uk/documentation/tutorials/docsystem/build/tutorials/gvim/gvim.html#gVim-DocBook
        }}}
        lua {{{
        }}}
    }}}
    tags, tagslist, Ctags {{{
        komplement till ctags, för javascript:
            Doctor JS (vilket inkluderar 'jsctags')
        Indexera en kodbas med ctags/Generera tags-filer för kodfiler m ctags {{{

            generera tags för alla .rb-filer i nuv mapp ($ls => code/ctags)  ;  $ ctags *.rb
            = skapar en enkel textfil som heter 'tags' (som innehåller ett index över keywords från de tre källkodsfilerna som ctags kördes på)


            :!ctags -R      #kör ctags från inne i vim, för filer i alla undermappar***  tagsfilen sparas i wd


            ev options
                --exclude=.git
                --languages=-sql   mm



            :nnoremap <f5> :!ctags -R<CR>
            ELLER
            :autocmd BufWritePost * call system("ctags -R")
            ++
            Automatically Execute ctags with Version Control Hooks
            Most source control systems provide hooks that allow us to execute a script
            in response to events on the repository. We can use these to instruct our
            source control to re-index the repository every time we commit our code.
            In “Effortless Ctags with Git,” Tim Pope demonstrates how to set up hooks
            for the post-commit , post-merge , and post-checkout events. 2 The beauty of this solution
                is that it uses global hooks, so configuring each individual repository on your
                system is unnecessary.

            not:
            Discussion (ang. vilken lösning som är bäst)  (practv253/265)



        }}}

        var letar vim efter tags-filer?  ;  'tags'-options värde
            :set tags?
            tags=./tags,tags
        VAR LETAR VIM EFTER TAGS-FILER I EXEMPLET HÄR?  ;  CURR.FILE-WD OCH WD

        rekommendationer för var lägga sina tags-filer?  ;  (om inställningarna som ovan/standard = i varje undermapp för projektet (=ev fiddly), EL SKAPA EN GLOBAL TAGS-FIL I ROTMAPPEN FÖR PROJEKTET *?
        Tips: för att inte alla tags-filer ska sacka ner när kör commits mm (till git o likn?)  ;  instruera source-control att ignorera tags-filer

        HOPPA TILL DEFINITION AV KEYWORDS MM **** (=klass/funktionsnamn o annat)
            c-]         (:h tag-stack,  :h tag-priority)
            g c-]       #om flera matchningar, visar lista, likn c-n ****  (N +<cr>)
            c-t (el :pop)   likn c-o, för tags-lista

            :tselect
            :tnext
            :tprev
            :tfirst
            :tlast

        tips: Exkommandon för g c-] mm ****
            :tag Fran<Tab>      #=för klassen/nyckelordet Francophone t.ex. *****
            :tag /Pattern       #Pattern =regex *****
            :tjump /phone$      #lista (för att kunna hoppa till) tags som slutar med 'phone'



    }}}
    MAKE, COMPILER MM** {{{
                compiler(i vimterminologi): 'ett externt program som gör något m vår källfil och producerar en lista m felmeddelanden el varningar'

        =t.ex. köra latex-fil så processas till pdf


        (se också vissa anteckningar i 'qf-list')

        Sätta makeprg (t.ex. för nodelint för js mm)  ;  practv266/277
        + kolla ev senare hur man konf.ar errorformat (nästa sida)

        Snabbväg för att slippa komma ihåg en massa krånglig kod  ;  spara relevant makeprg- o errorformat-kod i fil (practv267/278) +kör m compiler
        :compiler nodelint


        öppna o kika på olika compiler-filer som följer m vim/är installerade:
            :args $VIMRUNTIME/compiler/*.vim

        två sätt att använda nodelint för kompilering/koll av javascriptkod i vim:  först installera, sen aktivera m autocommand el file-type plugin  (practv A1.3)

    }}}
    Man {{{
        K

        :runtime! ftplugin/man.vim

        :Man csh
        :Man 3 echo
         \K
    }}}
    :grep(ag)/vimgrep** + quickfix(copen) {{{
    The ":grep" command uses the external commands grep (on Unix) or findstr (on Windows). You can change this by setting the option 'grepprg'.
    +'grepformat' (271/282)

        :grep error_string *.c
        :cnext
        :cprev
        :clist
          'grepprg'   (t.ex. ag)
          (def. =       set gp=grep\ -n\ $*\ /dev/null)

        gsök: setting up vim to use ag*
        Ack.vim: https://github.com/mileszs/ack.vim#can-i-use-ag-the-silver-searcher-with-this

        ack (o även ag)  272/283
        (+trixa sen med %x-flaggorna i grepformat o grepprg  för att få resultatet att likna standardoutputen m :grep som möjl., eller nåt format du gillar bättre)

        Idé: skapa ett :Ack-kommando, kanske också ett :ag-kommando  för att kunna använda flera verktyg parallellt (+ack anv. perl-style regexes mm)

        Ack rapportera rad OCH kolumn(!) vilket kan användas  ****

        vimgrep /mönster/ fil/omfånginneifil
        vimgrep! /mönster/gj fil/omfånginneifil ...

            g       om flera matches på samma rad =en matchpost för varje skapas*
            j       (likn make!) =hoppar inte till första matchningen som standard

        vimgrep /mo/ % | copen | resize

        vimgrep /fooBar/ **         #samma som *(=alla filer), men äv. i alla subdirs
        vimgrep /fooBar/ ##         #alla filer i argslistan
        vimgrep /fooBar/ `=    `

        Bra tips: Testa ut mönster först m /-sökn (bygg ett bra regex, ev steg för steg)  + sen :vimg /c-r// **    *******    #OBS: om vi vill anv. :grep(alltså stdgrep) måste vi först översätta regexet till posix)

        :grep -i Waldo *
        :grep error_string *.c
        :grep pattern *.c
        This causes Vim to search for the string "error_string" in all the specified files (*.c). The editor will now open the first file where a match is found and position the cursor on the first matching line.
        :cnext
        To go to the next matching line (no matter in what file it is), use the ":cnext" command.
        :cprev
        To go to the previous match, use the ":cprev" command.
        :clist
        Use ":clist" to see all the matches and where they are.
        o
        Vim has a built-in command that you can use to search a set of files for a
        given string. If you want to find all occurrences of "error_string" in all C
        program files, for example, enter the following command: >
        o
        :vimgrep /vindruvor/ inköpslista
        :vimgrep /vindruvor/ *.txt
            sök i flera filer (eller mappar).

        :cn  /  :cN
        :cl
        :cc 5
        gy till post nr 5 i lista över responses från senaste vimgrepsökning

        :grep vs :vimgrep       =om inte behöver snabbhet, vims regexes, el vims förmåga att uppt. file-encodings


        map <F4> :execute " grep -srnw --binary-files=without-match --exclude-dir=.git --exclude-from=exclude.list . -e " . expand("<cword>") . " " <bar> cwindow<CR>
    }}}
    Quickfix list/Location list {{{
        :h quickfix  ger full kommandolista  (+qf =+make: 'it allows us to speed up the edit-compile-edit-cycle')

        keeps list of annotated addresses, w
            filename
            line-no
            col-no(opt.)
            message

        T.ex.:
            felmeddelanden från en kompilator
            varningar från en syntaxchecker, linter o.likn

        Kompilera kod o kolla igenom felmeddelanden (bash vs make+qflist) (practv260/271) {{{

            i bash:
            $ make      #måste sen navigera till varje fil fr. felmedd.ena manuellt


            i vim:
            :make
                (=om felmedd., så hoppar vim till felställe 1 i första filen)
            :cnext


            :make!      #om man vill att pekaren ska stå kvar =inte hoppa till första felstället i första filen
            ( :make c-o  funkar också(*) )



        }}}

        :cnext  :5cnext 
        :cfirst
        :clast
        :cprev

        :copen
        :cclose     #stänger qf-fönstret, även om markören i annat fönster/split
        :cnfile
        :cpfile
        :cwin
        :cN  :ccN

        Öppna en fil som listas i qf-fönstret + placera pekaren på det listade felet  ;  <cr>  ***

        Hur många tidigare qf-listor ligger sparade i vim?  ;  10st
        Plocka fram en tidigare qf-lista  ;  :colder / :cnewer   :3colder


        Hur kör man grep mm interna wrapperkommandon m locationlist ist.för qf?  ;  :lmake, :lgrep, :lvimgrep  (practv263/274)

        locationlist-kommandona har samma namn, men börjar m 'l'
        :lopen
        :lwin
        :lclose
        :lnext
        :lN  :llN
        :lprev


         KÖR ETT SUBST.KOMMANDO PÅ ALLA FILER I NUV. (PROGR./BOK(=filer i mappar o undermappar))PROJEKT *****
            /Pragmatic\ze Vim   #testa först sök- o ersättningshandl.
            :%s//Practical/g
            ------
            :args **/*.txt      #öppna alla filer i mapp o undermappar som ingår i projektet ****
            :set hidden
            :argdo %s//Practical/g(e)
        STEG 2 (=KÖR ERS. PÅ DE FILER DÄR MÖNSTRET MATCHAR =BEHÖVER INTE KÖRAS I ONÖDAN)
            /Pragmatic\ze Vim
            :vimgrep /<C-r>// **/*.txt      #sök rätt på filer m match + kör vimgrep (=skickar alla filer som matchar till quickfixlistan ****
                ist.föratt köra copen (=gå igenom res. manuellt):
                Skapa liknande (om funnits) :quickfixdo
                qargs.vim (substitution/qargs.vim): {{{

                    command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
                    function! QuickfixFilenames()
                      let buffer_numbers = {}
                      for quickfix_item in getqflist()
                        let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
                      endfor
                      return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
                    endfunction


                    (lägg till i vimrc el installera som plugin)

                }}}
            :Qargs
            :argdo %s//Practical/g(e)
            :argdo update
            (el  :Qargs | :argdo %s//Practical/g(e) | :argdo update )



    }}}
    -----


   }}}

Mappable Characters + "follow my leader" {{{
    c:
        cd cs cq c. c<tab>
        c<Space>
    d:
        d Ent, c Ent
        d up, c up (??)

        q Ent (etc)  q[

        q1, etc(??)

        @0 etc (*)

    g

    z
}}}

___ptools
Ptools 2022+ {{{
___ptools

clip/copy/export/redirect vim output to clipboard/file {{{

Ah, a practical need! You can definitely do that directly within Vim. Here are a couple of simple ways to get that list into your other text file:

Method 1: Using the Clipboard

This is probably the quickest for pasting into another open file.

    Run the :ls command in Vim.
    Select the output of :ls with your mouse.
    Copy the selected text to your clipboard (usually Ctrl+C on Windows/Linux, Cmd+C on macOS).
    Switch to your other text file in Vim and paste (usually Ctrl+V on Windows/Linux, Cmd+V on macOS)


Method 2: Redirecting the Output to a Temporary File

This is useful if you want to save the list for later or if the clipboard method isn't working as expected.

    Run the following command in Vim:
    Vim Script

    :redir! > /tmp/open_files.txt | silent ls | redir END

        :redir! > /tmp/open_files.txt: This redirects all subsequent command output to a new file named open_files.txt in the /tmp directory. The ! overwrites the file if it already exists. Feel free to change the path and filename if you prefer.
        silent ls: This executes the :ls command, and silent prevents the :ls output from also appearing in your Vim command line.
        redir END: This stops the redirection of command output.
    Open the /tmp/open_files.txt file (or your chosen path) in Vim using :edit /tmp/open_files.txt.
    You can then copy the contents of this file and paste them into your other text file.

Either of these methods should get that list of open files into your other text file for logging! Let me know if you have any other Vim wrangling you need assistance with.

}}}
GVim Windows (Fonts, Actions) {{{

  if has("gui_running")
    if has("gui_gtk2")
      set guifont=Inconsolata\ 12
    elseif has("gui_macvim")
      set guifont=Menlo\ Regular:h14
    elseif has("gui_win32")
      set guifont=Consolas:h11:cANSI
    endif
  endif

  nnoremap <C-MouseUp> :silent! let &guifont = substitute(&guifont, ':h\zs\d\+', '\=eval(submatch(0)-1)', '')<CR>
  nnoremap <C-MouseDown> :silent! let &guifont = substitute(&guifont,':h\zs\d\+','\=eval(submatch(0)+1)', '')<CR>

}}}

gn (=act on search-matches ****)

:args `ls *.c`
:e `=tempname()`
:argdo (**)

, even if mapped as leader  c-,  #both for char-searching and i-input
's/^- '  = shortcut syntax for 's/^- //'  __ __

:h
  index
  index.txt  @@@@
  toc
  help-summary

g@  (=apply '@' globally)

    ## noremap <leader>gv <Esc>yiw:vimgrep /<C-R>"/ % <bar> copen <bar> resize<CR>
vimgrep /@/ % | copen | resize

snabbant./summering (=personl. verkt.lista) practvim (juli 2018) {{{
___practmodhardw_etc2023_summer

~/Empire/Doks/Comp/editor/vim/PRACTICAL_VIM.pdf
    ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/practvim.txt

    virtual replace-mode  gR gr                 35
    tabs and spaces (=progr.inställningar)      42
    gå till rad 1 ; :1
    :/sök1/,/sök2/p
___practmodhardw_etc2023_summer
        evince -p 59 ~/Empire/Doks/Comp/editor/vim/PRACTICAL_VIM.pdf &
    :co / :t            #range  copy adress     60 ***
        :6co .
@@  :[range]m adress

    :normal @q                                  63
        :normal @:  ***
    'wildmode'
    * + n + %s//(c-r c-w) ++ **
      cnoremap <C-p> <Up>
      cnoremap <C-n> <Down>
    write | !ruby %
    c/s-history **      (q: q/)
    c-f ******                              byt från c-mode till c-history ****
                                                    :shell
        :w !sh                                  74 ***
    %!sort -n  ****
    !G
    unimpaired.vim                              (79)
        5,10bd
    args + argdo **                             80

    :args *.* index.html
    :args **/*.js app.js  ******   :args **/*.js **/*.css
     :next / :prev  first / last                #=n/p för argslistan (hm (****))
    c-w T
    :lcd        =cd för nuv. fönster/tab (el split???)***
    :tabmove ****                               91
    :edit %:h <Tab>                 path(head) för nuv. filen ***
     %% + edit command-vimcast                  (95**)
    find (****)                                 96, 136(path**)
        netrw (vimcast 15)                      98

    :w !sudo tee % > /dev/null
     `` g; 
    gi *****                    (samma som `^ + i)
    % + matchit.vim  #=+html/xml-tags mm****    127-128

    Öppna filer/nästa fil (i mappsystemet) som har ord ***** ; :vimgrep /fooBar/ **
     +finns sen i qf-listan *****

    tips: sätt mM innan vimgrep, make mm (=snabbt hoppa tillb./mellan)
                                        registers       s149
    swapping mm                                 151
    gp gP   Klistra in rader, men låt pekaren stå kvar ****

    Makro i serie/parall****:  6@a / '<,'>norm @a  *****    165
      :reg a
    ----
    :argdo normal @a                #+i serie kan vara mer anv.bart här

    Mata in ökande siffra m makro (+normal @a på rader)     175 ***
    Redigera innehåll i reg. a med kod
        :let @a=substitute(@a, '\~', 'vU', 'g')     ****  :h function-list

    \v - regexes, \V - a.k.a.(=verbatim text, t.ex. http:// mm *****)
    %( ) - non-capt.paren
    \\\\ + Escape Characters Programmatically   196     =escape(@u, .....

    ( c-r c-w efter sök 1 ????                  204)
    Räkna antal X  *****        :%///gn
     gU //e <CR>
    Stegvis förfina Sökning 1                   210++
        /-history, 
    -----
    Search for curr. v-selection *** / visual star plugin *     212

Subst *****
    :s återanvänd flaggor från senaste sök ; &-flaggan ****
    ~   samma söksträng som förra /
    &   det som matchats (=kan anv. i ersättningen)
    \0  allt matchade
    \=script    =anv. res. i ersättningen ****
     \=@0 *****
     :%s//\=@0/g
        klistra in (=let) i sökregistret
    Stegvis förfina Sökning 1
        Sök först, Ersätt sen m %s//"\1"/g t.ex. ****
    g&  :%s//~/&  :%&&      =gör om senaste, men på hela filen
    :'<,'>&&                =gör om senaste, men på selection
    ------
    nnoremap & :&&<CR>
    xnoremap & :&&<CR>
    ------
    Swap several w e-register o vimscr dict.    230     #+abolish.vim
    Sök/Ersätt i flera filer (incl. :set hidden)
    ------
    +BYGG UPP LISTA PÅ FILER M MATCHES I QF-LISTAN
        +QUICKFIX-DO                            235

Global
    #Sök först m / el g/ ****
    g/re/d / v/re/d     ta bort/behålla matchande ****
    Samla Todo-rader i Register ****            240     #global + yank
        :g/TODO/yank A      :g/TODO/t$
    ALPHABETIZE THE PROPERTIES OF EACH RULE IN A CSS FILE *****     242
        =sortera properties alfabetiskt ****
        :g/{/ .+1,/}/-1 sort
         :g/{/sil .+1,/}/-1 >

(adv.) Tools
    Ctags (+Cscope)                             250
      configuring                                 252 ****
    jstags                                      250 
    Navigera i källkod (efter kört ct) m c-]/g_c-] + c-t    254
                    :tselect :tag :tjump +tabell 257 *****

Kompilera Kod + Fel med QuickFix-listan ****    260
    :make   :make!(markör flyttar inte)
        :cnext  (prev,last,first,, :5cnext, :cnfile/cpfile, :cc N, copen/cclose)
        :colder/cnewer
    LOCATION-LIST  (lmake, lgrep, lvimgrep,, lfirst, lnfile mm)
    -----
    Sätta så make kör nodelint(js)
        :setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %
    'errorformat'
    :compiler filnamnminställn(??)      både makeprg o errfm
    -----
    hitta ord i filer (+qf-list **) m Grep ***      :grep Waldo *   271
    -----
    Vimgrep                                     274

X-mode/Completion                               277
    'infercase'
    c-n_c-p
     c-y c-e c-l
    ----
    l
    f
    o
        You can find the full list by looking up :h compl-omni-filetypes
     c-x c-i                                    280
     :set include?
     c-x c-]                #anv. tags-fil om genererad
    c-x c-k  (dict.completion)

    Spellchecker Vim                            287
        ]s, [s, z=          +tabell s288
        alternate dictionaries                  289
        c-x c-s

    AUTOCOMMAND CUSTOMIZATIONS TO CERTAIN FILE-TYPES        298 ******



    'hidden' innan :argdo/:bufdo        #så kan hoppa ur filen utan att beh. spara först *
    lista alla filer i argslist ; :args ***

    negative lookahead/behind   @= / @<=

    With the judicious use of Vim script, we can add this functionality to Vim. My favorite
    solution is the textobj-lastpat plugin, by Kana Natsuno, a which adds an i/ text object
    for operating on search matches. Using this, we can make the same change as before
    just by running gUi/ . Instead of needing three keystrokes ( // <CR> ) to jump to the next
    match, we can get there in just one: n . In other words, we can achieve an ideal Dot
    Formula.        209 *

    :changes                    #visa changelist som textlista
        surround.vim
    'pastetoggle' ??                            156
    :set suffixesadd+=.rb



}}}
  :set ff=unix
  :set(local) ff=dos | write

best of best + quicklists restart (**(!)) {{{

list lines in this(!) file matching pattern ***(!)
    vimgrep /^tabedit/ % | clist

change next block/Block, ', ", <   cib  #=behöver bara vara på samma rad ****[!!]
change inner Tag  ****

set so long lines in paras get wrapped, but not(!) breaking words(**!!)
    set wrap linebreak  ******

turn 'all caps-header' to titlecase (**(!!))
    @c: :s/\v<(.)(\w*)/\u\1\L\2/g
    @c: :s/\v<(.)([A-ZÅÄÖ]*)/\u\1\L\2/g  #swe

--

flip betw. left to right|right to left text-mode (**)
    set rl!   # set rl  ||  set norl

find + pull in file names
    r !find -L path/1 path/2 -iname '*guitarix*.txt' 2>/dev/null

input cwd-string in file
    =getcwd()

echo current file name (in ex)
    :echo expand("%")

}}}
SUBST: UPCASE/LCASE-FLAGS           :s/\v<(.)(\w*)/\u\1\L\2/g       ___SEMER2019

BEST OF THE BEST:
    c-x c-n *****************       #drs: c-n  ,xn     +ev. ny   ,a = c-x c-n (=easily add new words after first **)
    :set textwidth=55  :set tw=55   #bryt rader  =t.ex. GimpProj (=GIBI mm) ****  #+gq
     :set wrap!                      #visa(!) rader brutna  #+gq
    go to funct. def. ******        gd, gD, 1gd mm (**)
    !ip                             #t.ex. !ipsort -R (=skicka 'rörelse'/block/text-objekt till filtrering*)

COOKBOOK / ÖNSKELISTA VANLIGA UPPGIFTER (=VIM.LEGACY) {{{

___cookbook     
    blandade småtips
        trappstegsindenteringen i prvim ; >G + repetera med .
        söka efter ordet/del-ordet under markören (=obs! inte bara ___tags***) ; * # g* g#

    DOS-TXT TILL UNIX-TXT
        :set ff=unix

    HELP: VISA H-INDEX FÖR MODE (T.EX. I_) ,, VISA H-INDEX FÖR REF-MAN ***** {{{

        insert-index, visual-index mm       #+ /\d\. / för nästa kap. o ?? för ändra riktn.
        reference_toc

    }}}
    specialnotering för sökbart ord=nyckelord i helpfil {{{

        *ord*

    }}}

    kolla vilka script/filer/plugins som laddas av vim när startas {{{

        :scriptnames

    }}}
    starta vim m minimal vimrc {{{

        vim -u ~/essential.vim
            set nocompatible
            filetype plugin on

    }}}
    använd annan vimrc än standard (=~/.vimrc) {{{

        vim -u ~/alternativ-fil.vim

    }}}
    starta vim helt rent, utan rc {{{
        vim -u NONE -U      #=utan vimrc, o med nocompatible
    }}}
    kompileringsflaggor för vim (som tiny, huge mm) {{{
        practvim25
    }}}
    kolla vilka features som är tillgängliga/inkompilerade i vim du har {{{
        vim --version
    }}}

    sätt så c-a 007 ger 008 **** {{{
        set nrformats=
    }}}
    Skapa Egna/Custom Operators {{{
        läs och kolla info i  :h map-operator
    }}}
    Skapa egna Motions ** {{{

        se :h omap-info

    }}}

    kör senaste :subst på nuvarande raden * {{{
        &
    }}}

    Ersätt flera tecken utan att ändra radlängd = för Tab-tabeller mm ***** | ersätt ett tecken = för Tab-tabeller mm **** {{{

        R/i_insert      gr

    }}}
    'insertmode-triad' =sudda tecken, sudda ord, sudda till bö raden {{{

        c-h, c-w, c-u

    }}}

    EKA FILNAMNET MED HJÄLP AV VIMS 'ECHO' OCH '%' {{{

        =
        :echo %
          och
        :echo "%"
          funkar som bekant inte ***

        :echo expand("%")   --> filename
        This calls the expand() function to expand the '%'

    }}}
    TA REDA PÅ ETT TECKENS TECKENKOD (ASCII, UNIC. MM ****) {{{

        ga  *******
          :ascii
        g8
        8g8      hitta 'illegal' utf8/encoding

    }}}
    MATA IN FILNAMNET PÅ NUV. FIL ***** (i_) {{{

        c-r=expand("%")

    }}}
    MATA IN SPECIALTECKEN (UNICODE, TAB/CR-TECKEN MM) ****** {{{

        c-v 118
        c-v u 0b19      c-v U 0123abdc
        c-v Tab                 #tab, även om expandtab satt-tricket
        c-k co                  #:h digraph-table  :digraphs    ****** {{{
                                        +se ev också :h digraphs-defaults   (=multibyte support för o med makron mm**)

            CR      ^M
            TAB
            co??
            <<      «
            12 13 34        ½ ¼ ¾

        }}}

    }}}
    radnummer för nuvarande rad
    räkna tecken
     räkna ord {{{

        g ctrl-g
        Visualmarkera aktuell text + g ctrl-g

     }}}
    Sätt så radnummer visas för raderna 30-100 {{{
        :30,100nu(mber)
        :30,100#
    }}}

    Ändra filformat från/till win/lin/mac-txt ***** (se nedan i indexlistan)

}}}
. 'TIPS OCH BÄSTA'.LEGACY {{{

    KOMMANDE/SE MER/NÄSTA:
     SUBSTITUTE
     GLOBAL
      FUNCTIONS



    Räkna saker (tecken, ord mm) i filen/filer  ;  se 'räkna ord, räkna tecken mm' nedan i Vim-indexet   #///n för ord, tecken mm, o vimgrep för flera filer (el likn/mm)

    5c-a  ;  addera 5 till nästa tal        
    -180c-x
    inställning för att hantera tal som 007 som decimaltal ****  ;  
     :set nrformats-=octal

    c-r=2+2 +Ent
    c-r=system('ls') +Ent

    zO          öppna alla folds hierarkiskt neråt under pekaren
    zm Space    stäng tillbaks
    ---------
    :set foldclose=all      =gör så att vikningar stängs automatiskt när flyttar ut markören ur dem
    Autocommand setlocal foldmethod=marker ****
    " Vimscript filetype setting ---------------------- {{{
        augroup filetype_vim
          autocmd!
          autocmd FileType vim setlocal foldmethod=marker
        augroup END
    " }}}
    EXERCISE: Find out how to make Vim fold everything automatically the first time you open the file. Look at
    :help foldlevelstart for a good place to start.     = :set foldlevelstart=0  el =1

     (vis.)rader
     :'<,'>m$       #flytta valda rader till sist i filen   el t.ex. efter 'm
     @: @@          #gå till + välj andra rader  +repetera***

    tips: jobba ofta med stegvis förfining för sökmönster =testa först att matcha lite/grovkornigt, utöka sen, osv
    +anv. med fördel sökhist.fönstret ****

    Kopiera ordet i filen under markören o sätt in på krad/i '/'-sökn  ;  c-r c-w ****************
    Kopiera ORDET i filen under markören o sätt in på krad/i '/'-sökn  ;  c-r c-a ****************

    :edit ++ff=unix file.txt
    The "++" string is an item that tells Vim that an option name follows, which
    overrules the default for this single command. "++ff" is used for
    'fileformat'. You could also use "++ff=mac" or "++ff=dos".
    This doesn't work for any option, only "++ff" and "++enc" are currently
    implemented. The full names "++fileformat" and "++encoding" also work.

    undoträdet:
    :earlier/later 1f   #tillbaks till efter senaste sparning
    undo-persistence    #om att skriva undo-info till fil  **?
    g+ g-   #gå framåt bakåt i undos, oavsett var/vilka grenar i undoträdet

    Sätt wd för nuvarande fönster ******  ;  :lcd
    Sätt wd för alla fönster i nuvarande tab  ;  :windo lcd
    Flytta fönster/split m pekaren i till ny Egen Tab  ;  c-w T  ******
    Öppna ytterligare ett fönster/viewport på t.ex. en av flera splits (=ett litet fönster där svårt att få överblick  ;  :tabe(dit) %
    'splitbelow'
    'splitright'   ******
    Öppna split på ny vertikal fil(höger)*****  ;  :vertical botright new
    :wall
    ----
    :tab help gt (=??) [kommentar: "tab funkar för alla kommandon som öppnar nytt fönster)
    ------
    Flytta aktiv tab till först av tabs  ;  :tabmove 0
    Flytta aktiv tab till pos N av tabs  ;  :tabmove N
    Flytta aktiv tab till sist av tabs  ;  :tabmove

    ARGLIST:
    3<c-^>  #byt till buf 3
    ARG:A ALLA .JS-FILER I NUV. MAPP + ALLA UNDERMAPPAR ******  ;   :args **/*.js
    ARG:A ALLA .JS-FILER OCH .CSS-FILER I NUV. MAPP + ALLA UNDERMAPPAR ******  ;   :args **/*.js **/*.css
    ARG:A ALLA FILER I NUV. MAPP + ALLA UNDERMAPPAR ******  ;   :args **/*.*
    kör args på alla filer i filen .chapters  ;  :args `cat .chapters`      #:h backtick-expansion
    kör args på alla filer i ` `-expand, OCH utvärdera vim-expression(funktioner mm) i `  `  ;  :args `= vimfunktnamn() .  x  `    #mm
        :argadd  :argedit??
    :hid(e) e(dit) nyfil.txt   #stoppa in fil i arglistan, utan att byta till den direkt*

    öppna två filer i vimdiff     vimdiff main.c~ main.c
    snabbsyntax bash:     vimdiff main.c{~,}


    :argdo %s/\<x_cnt\>/x_counter/ge | update

    :write
    :!ruby %
    tips = om använt kombinationen ovan flera gånger 
    =vill dra ihop/slå ihop två redan (för sig) använda kommandorader:  
    q:(=kommandohist-fönstret) + redigare o dra ihop två (el fler)
    redan existerande raderna  + Enter = kör **************

    Skifta till kradshist-fönstret från kraden (=medan skriver kommando i ex-läge)  ;  c-f **********


    path o find: OBS! BÅDE PATH O SUFFIXESADD KAN SÄTTAS BUFLOCAL  = VARJE FILTYP KAN HA MAPPAR SOM STÄLLS IN SOM " DEFAULTPATHS *******

    Öppna fil utifrån aktiva filens mapp  ;  :e %:h<Tab>  **********


     =iB        autoindentera nuv. block ****
     as (a sentence)


    MARKS:  '  `  `[ `]  [` ]`  "  0-9  ^  .   { (

        g; / g,   [z , ]z

        g'a  g`a

    BLOCK:  ib iB at ,  aw as ap,   ( { [ " ' < `
    tagblock: <html>hi</html>
     gUit       <html>HI</html>
     gUat       <HTML>HI</HTML>
    -----
    vim `grep -l frame_counter *.c`     redigera alla filer som inneh. str.mönster ****

    vim "+find stdio.h"
    vim -c "find stdio.h"

    %       curr. filename
    #/#0    alt. filename
    #n      buf. n:s filnamn
    ##      alla filnamn i arg.listan , blanksteg mellan        #blankst. i filnamn m '\' framför
    #<n     oldfile nr n        #:oldfiles o v:oldfiles ger numret

    . {{{
        *:_%* *c_%*
        *:_#* *c_#*
        *:_#0* *:_#n*
        *c_#n*
        *:_##* *c_##*
        *:_#<* *c_#<*
    }}}



    Sätt in tab i text  ;  Tab / C-i

    Indentera rad när i insertläge (pekaren var som helst)  ;  C-t / C-d
        |i_0_CTRL-D|    0 CTRL-D    delete all indent in the current line
        |i_^_CTRL-D|    ^ CTRL-D    delete all indent in the current line, restore

    >   gör ett indrag
    <
    >>
    <<


}}}

zzzz  dubletter att plocka in vimindex {{{
    g/-\( .\)\?$/join

    Öppna alla filer som ska redigeras
    :%s/\<GetResp\>/GetAnswer/g
    Do the replacements in the first file.
    :wnext
    999@q
    :%s/\<GetResp\>/GetAnswer/ge  ********

    gvim -S ~/Dropbox/planeringsdok.vimsession -c 'rviminfo ~/Dropbox/planeringsdok.viminfo'

    Redigera i flera filer {{{
        ändra ett namn i alla filer i en argslista :D ******

        .förklaring {{{
            Let's assume you have a directory with C++ files, all ending in ".cpp".
            There is a function called "GetResp" that you want to rename to "GetAnswer".
            vim *.cpp
            Start Vim, defining the argument list to contain all the C++ files. You are now in the first file.
            qq
            Start recording into the q register
            :%s/\<GetResp\>/GetAnswer/g
            Do the replacements in the first file.
            :wnext
            Write this file and move to the next one.
            q
            Stop recording.
            @q
            Execute the q register. This will replay the substitution and ":wnext". You can verify that this doesn't produce an error message.
            999@q
            Execute the q register on the remaining files.
            Obs! :)
        }}}
            vim *.cpp
            qq
                :%s/\<getResp\>/getAnswer/ge        *********
                :wnext
            q
            @q
            999@q

        There is one catch: If one of the .cpp files does not contain the word "GetResp", you will get an error and replacing will stop. To avoid this, add the "e" flag to the substitute command: >
            :%s/\<GetResp\>/GetAnswer/ge
        The "e" flag tells ":substitute" that not finding a match is not an error.
    }}}

}}}

checklistan vrefman-genomg.2019-1(=fr. vscrhard+usr41***) {{{

    :vsplit
    $MYVIMRC
    :source script.vim
    :iabbrev waht what
     :nunmap
        :set iskeyword?     #=ändra så .- m.fl. räknas in i ord (=c-n-complet.)**
            (förmodl. enklast m :se iskeyw+=- el likn. (***))
        :help isfname
    :nnoremap <buffer> <localleader>x dd
    :setlocal number
                                (ev. lista m. de teoretiska termerna (=shadowing mm))
    au {{{
            :h autocmd-events
        FileType
        BufNewFile
            :autocmd BufNewFile *.txt :write
        BufWritePre
        BufRead
            :autocmd BufWritePre,BufRead *.html :normal gg=G
            :autocmd BufNewFile,BufRead *.html setlocal nowrap

        :autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
        :autocmd FileType python nnoremap <buffer> <localleader>c I#<esc>
        (wrap, list, spell, number)


        autocmd FileType html nnoremap <buffer> <localleader>f Vatzf

    }}}

    :autocmd FileType python     :iabbrev <buffer> iff if:<left>
    :autocmd FileType javascript :iabbrev <buffer> iff if ()<left>

    (returns, functions, iffs mm**, &ldquo; + &rdquo  mm)


    :inoremap <esc> <nop>

      :augroup testgroup
      : autocmd!
      : autocmd BufWrite * :echom "Cats"
      :augroup END




    CUSTOM MOTIONS (=t.ex. 'next header', 'inside header', 'inside notes', 'next notes', 'inside chords' mm
    ****** (namn mm: 'ah'=a heading, 'in@'=inside next email-address

    :onoremap p i(          #=överför idiomet ovan fr. 'filetype_html' till omaps här ****####
                            # =Markdown-exemplet mm (**)
    omap def.area 'tips/algor.'
        1. Start at the cursor position.
        2. Enter visual mode (charwise).
        3. ... mapping keys go here ...
        4. All the text you want to include in the movement should now be selected.
        ----
                * If your operator-pending mapping ends with some text visually selected, Vim will operate on
                that text.
                * Otherwise, Vim will operate on the text between the original cursor position and the new
                position.

    :onoremap in( :<c-u>normal! f(vi(<cr>

    :onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>        #normal förstår inte spec.-
                                                                                # tecken, som <CR>
    :h expr-quote  #=escape-sekvenser i strängar (\t, \xfa mm ***)


        Statuslines  (pdf-vimscrhard_42)    BUILDING UP STATUSLINES INCREM. ****

        :set statusline=%f      " Path to the file
        :set statusline+=%=     " Switch to the right side
        :set statusline+=%l     " Current line
        :set statusline+=/      " Separator
        :set statusline+=%L     " Total lines

        Try using autocommands and setlocal to define different status lines for different filetypes.

    folding syntax (pdfs_46)




    :echo &textwidth
    :echo @a
     :let &textwidth = &textwidth + 10
    :let &g:number = 1
    :let &l:number = 1
    :let b:hello = "world"
     :echom "foo" | echom "bar"
    " string coersion to integers
    te:case insens. (string) comparisons (##)
    :function Meow()  :call Meow()  :echom GetMeow()
      return 1
    a:name      #function argument-variable
    ----
    function Varg(...)
    : echom a:0
    : echom a:1
    : echo a:000
    " obs: can't(!) reassign funct-vars(!!)     #use tempvars etc

    :echom "Hello, " . "world"
        strlen(  len(  split(  join(  tolower(  toupper(


                :execute "rightbelow vsplit " . bufname("#")
      :execute "normal! gg/foo\<cr>dd"
    :execute "normal! mqA;\<esc>`q"         ;-terminator *****      #=till prlangsedit

      :execute "normal! gg" . '/\vfor .+ in .+:' . "\<cr>"





___last  =sista små bitarna från skriptet nedan (=intress. delarna/operat. borttagna när utv.proc. klar(***))


    <cword>
    <cWORD>
    :h copen  :cnext :cprevious
    :grep!





    grep-operator.vim
    ------------------------------      kolla ev SID ihop m <SNR>
    nnoremap <leader>g :set operatorfunc=<SID>GrepOperator<cr>g@
    vnoremap <leader>g :<c-u>call <SID>GrepOperator(visualmode())<cr>

    function! s:GrepOperator(type)
        let saved_unnamed_register = @@

        if a:type ==# 'v'
            normal! `<v`>y
        elseif a:type ==# 'char'
            normal! `[v`]y
        else
            return
        endif

        silent execute "grep! -R " . shellescape(@@) . " ."
        copen

        let @@ = saved_unnamed_register
    endfunction








    synt:lists + indexing
        add(  len(  get(  index(  join(  reverse(   deepcopy(  append(  assoc(  pop(  sort(  map(
    synt:dicts + indexing
        let+remove (/unlet)     get(  has_key(  items(  keys(  values(  map(



    " toggle-function 1 - för funct som tar värde  **
    ----
    nnoremap <leader>f :call FoldColumnToggle()<cr>

    function! FoldColumnToggle()
        if &foldcolumn
            setlocal foldcolumn=0
        else
            setlocal foldcolumn=4
        endif

    endfunction


    " toggle-function/idiom 2  **   #idiom: spara state i var

    nnoremap <leader>q :call QuickfixToggle()<cr>

    let g:quickfix_is_open = 0

    function! QuickfixToggle()
        if g:quickfix_is_open
            cclose
            let g:quickfix_is_open = 0
            execute g:quickfix_return_to_window . "wincmd w"
        else
            let g:quickfix_return_to_window = winnr()
            copen
            let g:quickfix_is_open = 1
        endif
    endfunction


    Functional Programming

    function!
                                                         deepcopy(
                                                         sort(
     function(  ****
    :let Myfunc = function("Append")        #[[:upper:]]arname  =spara funct i var varname

    call filter(new_list, '!' . string(a:fn) . '(v:val)')





    :echom expand('%')
    :echom expand('%:p')
    :echom fnamemodify('foo.txt', ':p')
        simplify(  resolve( 

    :echo split(globpath('.', '*'), '\n')
     ----
    :echo split(globpath('.', '**'), '\n')        globpath =*****



    FULL PLUGIN ****** (potion, lilypond mm)

    :set runtimepath=/Users/sjl/Desktop

    PATHOGEN/VUNDLE/VIM8/NEOVIM PLUGINPATH/DIR.ORGANIZATION ****    vscrhard-pdf_123
            (~/.vim/bundle/{pluginname}/doc, ftdetect, ftplugin, syntax
              syntax/potion.vim


    au BufNewFile,BufRead *.pn set filetype=potion


    Advanced Folding - s135++ ***
        * Each line of code in a file has a "foldlevel". This is always either zero or a positive integer.
        * Lines with a foldlevel of zero are never included in any fold.
        * Adjacent lines with the same foldlevel are folded together.
        * If a fold of level X is closed, any subsequent lines with a foldlevel greater than or equal to X
          are folded along with it until you reach a line with a level less than X.
        (+testexemplet)**


    PROGR.CODE MOVEMENT:  [[, [], etc  ( :h sections )      #=SKA FUNKA DIREKT M. BRACES I LILYPOND ****
     (+'defining custom 'section' movements')

        noremap <script> <buffer> <silent> [[ <nop>


    function! s:NextSection(type, backwards)
        if a:type == 1
            let pattern = '\v(\n\n^\S|%^)'
            let flags = 'e'
        elseif a:type == 2
            let pattern = 'two'
            let flags = ''
        endif


        if a:backwards
            let dir = '?'
        else
            let dir = '/'
        endif

        execute 'silent normal! ' . dir . pattern . dir . flags . "\r"
    endfunction



    vnoremap <script> <buffer> <silent> ]]
        \ :<c-u>call <SID>NextSection(1, 0, 1)<cr>

    vnoremap <script> <buffer> <silent> [[
        \ :<c-u>call <SID>NextSection(1, 1, 1)<cr>

    vnoremap <script> <buffer> <silent> ][
        \ :<c-u>call <SID>NextSection(2, 0, 1)<cr>

    vnoremap <script> <buffer> <silent> []
        \ :<c-u>call <SID>NextSection(2, 1, 1)<cr



    if !exists("g:potion_command")
        let g:potion_command = "potion"
    endif

    function! PotionCompileAndRunFile()
        silent !clear
        execute "!" . g:potion_command . " " . bufname("%")
    endfunction

    nnoremap <buffer> <localleader>r :call PotionCompileAndRunFile()<cr>


    :echom system("ls")
    :echom system("wc -c", "abcdefg")



    function! PotionShowBytecode()
        " Get the bytecode.
        let bytecode = system(g:potion_command . " -c -V " . bufname("%") . " 2\
    >&1")

        " Open a new split and set it up.
        vsplit __Potion_Bytecode__
        normal! ggdG
        setlocal filetype=potionbytecode
        setlocal buftype=nofile

        " Insert the bytecode.
        call append(0, split(bytecode, '\v\n'))
    endfunction


    :call somefile#Hello()
    When you run this command, Vim will behave a bit differently than a normal function call.
    If this function has already been loaded, Vim will simply call it normally.
    Otherwise Vim will look for a file called autoload/somefile.vim in your ∼ /.vim directory (and
    any Pathogen bundles).
    If this file exists, Vim will load/source the file. It will then try to call the function normally.
    Inside this file, the function should be defined like this:
    function somefile#Hello()
    " ...
    endfunction
    You can use multiple # characters in the function name to represent subdirectories. For example:
    :call myplugin#somefile#Hello()

    'ADDING AUTOLOADING TO THE POTION PLUGIN' - s176 ****


    if !exists("g:potion_command")
        let g:potion_command = "/Users/sjl/src/potion/potion"
    endif

    function! PotionCompileAndRunFile()
        silent !clear
        execute "!" . g:potion_command . " " . bufname("%")
    endfunction

    function! PotionShowBytecode()
        " Get the bytecode.
        let bytecode = system(g:potion_command . " -c -V " . bufname("%"))

        " Open a new split and set it up.
        vsplit __Potion_Bytecode__
        normal! ggdG
        setlocal filetype=potionbytecode
        setlocal buftype=nofile

        " Insert the bytecode.
        call append(0, split(bytecode, '\v\n'))
    endfunction

    nnoremap <buffer> <localleader>r :call PotionCompileAndRunFile()<cr>
    nnoremap <buffer> <localleader>b :call PotionShowBytecode()<cr>



    echom "Autoloading..."

    function! potion#running#PotionCompileAndRunFile()
        silent !clear
        execute "!" . g:potion_command . " " . bufname("%")
    endfunction

    function! potion#running#PotionShowBytecode()
        " Get the bytecode.
        let bytecode = system(g:potion_command . " -c -V " . bufname("%"))

        " Open a new split and set it up.
        vsplit __Potion_Bytecode__
        normal! ggdG
        setlocal filetype=potionbytecode
        setlocal buftype=nofile

        " Insert the bytecode.
        call append(0, split(bytecode, '\v\n'))
    endfunction



    if !exists("g:potion_command")
        let g:potion_command = "/Users/sjl/src/potion/potion"
    endif

    nnoremap <buffer> <localleader>r
            \ :call potion#running#PotionCompileAndRunFile()<cr>
    nnoremap <buffer> <localleader>b
            \ :call potion#running#PotionShowBytecode()<cr>



    DOCUMENTATION - s179



    55.4 Exercises
    Create an account on Vim.org if you don't already have one.
    Look at the README files for some of your favorite plugins to see how they're structured and what
    kind of information they include.


                                                            '#' ___last



}}}
samma(usr41) {{{

fr. egna rc(practvim): cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'


    source other.vim
    :unlet s:count
    :unlet! s:count
    :if !exists("s:call_count")

    (=m.fl. i doublequotestrings **)
    \b      <BS>, backspace
    \"      "
    \\      \, backslash
    \<Esc>      <Esc>
    \<C-W>      CTRL-W

    :echo i > 5 ? "i is big" : "i is small"

    comparison: For strings there are two more items:
    a =~ b      matches with
    a !~ b      does not match with

    :  sleep 50m

    :tag get_cmd

    :let optname = "path"
    :let optval = eval('&' . optname)

    :call search("Date: ", "W")
    ----
    :let line = getline(".")
    :let repl = substitute(line, '\a', "*", "g")
    :call setline(".", repl)

    FUNCTIONS-LIST (string manipul, list manipul, dictionary, floating point, 
     variables, cursor + mark pos, text in curr. buffer, sysfunct + manip. files
     datetime, bufwinarglist, commandline, qfloclist, i-completion, folding
     syntax + highl, spelling, history, interactive, gui, vimserver, winsize + pos
     BLANDAT(mode, checkexistence, eventhandler, libcall, Registers, TAGS**)

    function: range

     line(

    :    echo "  Arg " . index . " is " . a:{index}

    :echohl

    :function               #list u-defined functions ***

    :delfunction Show


    range()


    50%++
    DICTIONARY FUNCTIONS
    OBJECT ORIENTED PROGRAMMING (WITH VIMSCRIPT DICTIONARIES)***

    41.9 - EXCEPTIONS **


        ???????????


    line-continuation ***************
    'cpoptions'


    if !hasmapto('<Plug>TypecorrAdd')

    map ,c  <Plug>TypecorrAdd


    24  noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
    ..
    28  noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>


    noremenu <script> Plugin.Add\ Correction      <SID>Add


    (mer om SID och Plug)  sök *using-<Plug>*



    39    command -nargs=1  Correct  :call s:Add(<q-args>, 0)



    THE RESULT

    Here is the resulting complete example:

    SEMER ********



    DOKUMENTATION **

    local-additions


    exists(":Cmd")





    if !hasmapto('<Plug>JavaImport')
    map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
  endif
  noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>



    " Add mappings, unless the user didn't want this.
    if !exists("no_plugin_maps") && !exists("no_mail_maps")
      " Quote text by inserting "> "
      if !hasmapto('<Plug>MailQuote')
        vmap <buffer> <LocalLeader>q <Plug>MailQuote
        nmap <buffer> <LocalLeader>q <Plug>MailQuote
      endif
      vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
      nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
    endif


    :command -buffer  Make  make %:r.s      ****


    Writing a Compiler Plugin


    Writing Library Scripts ****    = autoload +  call mylib#myfunction(arg)


    automatic updating with 'glvs-plugins' (??)

}}}

        TODO:
         - language input  :set langmap

    cmdline.txt  /filename-modifiers
:h filename-modifiers
  :echo @%  def/my.txt  directory/name of file (relative to the current working directory of /abc)
  :echo expand('%:p:h')     /abc/def    directory containing file ('head')
:help expand  {{{
  :echo expand('%:t')   my.txt  name of file ('tail')
  :echo expand('%:p')   /abc/def/my.txt     full path
  :echo expand('%:p:h:t')   def     First get the full path with :p (/abc/def/my.txt), then get the head of that with :h (/abc/def), then get the tail of that with :t (def)
  :echo expand('%:r')   def/my  name of file less one extension ('root')
  :echo expand('%:e')   txt     name of file's extension ('extension')
}}}

    rds:
        alias vimrds =  vim -c 'nnoremap å :!scrot<CR><CR>'
        nnoremap å :!scrot

    reverse order for selected lines
        :'<,'>!tac  #select lines + '!'

    - #stub: cut only between pattern-lines#
        g/^[^ {].*@/sil .,/}}/ yank A
          '<,'>g/^[^ {].*@/sil .,/}}/ yank A


    spelllangs ( ftp://ftp.vim.org/pub/vim/runtime/spell/ ) *********  (+spelllang svenska =sv(!!!!!!!))
        @n: ]s
        +FLER RÄTTSTAVNINGS-MAKRON      (++s288 Pract. Vim)
            zg      lägg till ord till stavn.filen
            zw      ta bort ord från stavn.filen

        <t_%9>      Spec.tecken =Print Screen (**(*))


    tpope personal config (!!(**))
        sensible
        unimpaired
         fugitive
        scriptease
        --
        51:57 **(!)
        52:47
             53:08

Vim Scripts **** (=pull sourcecode + include as rsc in samples/code (!!!!(****)) {{{
    https://vimawesome.com/
     https://www.dunebook.com/best-vim-plugins/
            https://www.ubuntupit.com/100-useful-vim-commands-that-youll-need-every-day/
https://github.com/rafi/awesome-vim-colorschemes
}}}


VimRc update Empire  (+BETTER ORGANIZED MAPPINGS//HOTKEYS(!!)) {{{
     - Japanese hiragana|katakana (+kanji??) input mode *****
        - cs-pgup/pgdn  =TabMove to Left/Right [!!!!! ********]
        - a-Home  =  :cd  (??)   a-End = cd %:h  [****]
            - Extension to 'v-line ruler-read' ****: cs-right|left =Next/Prev. Sentence ************
        - qq =Format (eg. 'gq')  #Or only for visual-marked area
  ???????????????????????????????????
     --
  - modularize .vimrc // init.el
    = using :source / :runtime!   #runtimepath / packpath
      **** - Prwords-File for Vim (="-c 'tabdo set foldmethod=marker' \" etc(=common lines drs at-files)) ****
    - RESTRUCTURE AND REBIND DRS PLUGINS 1 (!!)
  -----------------------------------------
       - Directory-walk: back / forward(=if only one path), bookmark, back to bookmark N, back / forw. betw. bookmarked(**)
            a-home, a-end, a-pgup/pgdn
        - colors favorite-list for progr-langs(!!)
       - Start new Skeletons etc (eg New at-Script with Indexfile ...)
       - insert progr.lang-specific fragments (!!!)
      -- O-map objects ** {{{
        - Lilypond
        - Markdown
        - html css (??(?))
        - Python (!!)
         - drs vim calender-format 2022+[!!]
        ----
        - RUN '[g/^/]norm .' WITH EG. }-MOVEMENT // V-MARKED BLOCK !!!!!! ******* __
      }}}
  - Flip common settings: wrap (etc etc etc) **   #wrap, scrollbind,  rightleft|rl!
  --
  - ack.vim: ag(!)/rg  +agrep
  --
  - Vim 'va-Utils' (=open files w. android-path on black-tower (etc))
  - Unix-Wrappers: ****
      touch
      find(+pull in found path)*, open file (=even if moved it**)
          @f: $T/yE:cd:r !find -L -iname '*"*' 2>/dev/null:cd -:!ding
      mv rm
    - a b c ... to 0 1 2  (=in insertmode)  #using hex-like syntax(??)
- Find + Open file (=based on 'dprograli'-style dokids, __tags  etc) ****
  --
  - Easier Indenting (!!)
  - VimCompletions (=better shortcuts):  line, file**, c-x c-n **(!)
  proj: SmartCompleting common words/sever. words with Space + c-Space + s-Space (=from autopopup with common words) ****(*) {{{
      +idea: activate with c-Space (**!)
  }}}
  - Add/Remove common c-n_chars to 'iskeyword' (. , -  etc (=some common, +specify char(!)))
  -- --
  - next / previous mark (=exact position)
  - substitution: whole file, between marks, v-marked, to the end (!!*)
  - global: --- " ---
  - commandline|/-searchline: '.*' \zs \ze \v {n}  ^[^  forwards/backwards  'cd ../'
   - refactor: quickly start commandline  [,ii]
   - Pull in file names (etc:  :let @"=@% )
        - read in macros  #or, export to 'rviminfo'-files
    - common search patt.s: .*@.*  ___tag  ***  #highlight: whole line, to end, adjacent word (!!)
    - Report sorted by number of '@'s / stars ***(!!)
  -------
    - flip case of char.
    - Flip Common Settings: wrap, ......
    insmode: - 'a b c ...' to '1 2 3 ...'  #+maybe hexmode [!!!!]
  - Find + Open file  based on ___tags etc (+'dprograli' etc codes)
  - Easier back / forward in changes-history  (=create submode? (instead of drs:'gg'))
   - 'dualsearch': =reverse started search (=highlighting indicates wrong direction **)
  -----
  - Common text/post rds-cleans
   - clean 'pure wsp'-lines
   - clean accidental comments on fold-markers
  - Formatting pdf2txt conversions (=text + code to fmt35 (etc))
  -----------------------------------------
  [ - DFT LYRICSPLAYLIST.VIM (eg. goto next post, open first filelink (etc)) ]
  ------
  [ - 'VimPlane ++' ]
  Folding ----
  - increase / decrease
  - set default level  |  reload default level
  - set exact foldlevel
  - QuickMark (=with 'visual') innerBlock  !!
        + Next 'vis' (+position cursor at start of 'vis') @@!!
  -----------------------------------------
     - Loading scrot with 'å' for Ocr *(!)
     [[ - Ocr: report remaining files [!!!] ]]
  ----

}}}

New Ptools-lists 2021++ (=based on vanki-workthrough of vuman, practvim, lvimscrhardw, usr_41, drs-vimnotes1 + Refman, ibm-tuts, modvim)
TODO: Collate + Survey All Tagged Entries (=in the 'first rounds(!)')  **(!!)
    --
    [vuman 1/2]  ~/Dropbox/rsc/data/lists/learnqna/vanki/vim2021.twothirds.tagged/DECK.MASTER.sec20211116-1700.txt {{{

88 posts|questions

Find a help-tag starting w. "pattern" **** !! @@(@)
{{{
    :h pattern<Tab>  #+cont. for cycling through alt.s
    :h pattern<C-D>  #(=list all matches)  **
    --
    vuman-p16
    }}}
Search Regex-patt. in all(!!) Help-files (*****)!! @@(@)
{{{
    :helpg(rep) /pattern/
    --
     :cn  |  :cN
     :cfirst  |  :clast
       --
     :copen  |  :cclose  (??)
        (+:clist ??)  p90
    --
    vuman-p16
    }}}
Open Quickfix-win w. hgrep-matches (**)*  #+jump to match (in help) w. Enter (*) @@
{{{
    :copen  |  :cclose
    --
    vuman-p16
    }}}
Change wh. vim considers to be word-char.s (=affects movement|completion)  (eg. add '-') ****(!!!!) @@(@@)
{{{
    :set iskeyword+=-
        (eg. adding/removing spec.chars like '~', '_' etc)
    --
    vuman-p17,p43(*)
      # 'all alphas, 0-9, _, printable latin char.s'  (etc)
    }}}
Set to include [, {, (etc??) in 'moving betw. brackets' **(**) @
{{{
    inspect + set 'matchpairs' **(!*)
      (eg. include <-pairs (??))
    --
    vuman-p19
    }}}
move to line N in file  (eg. 33) @
{{{
    33G  //  :33
    --
    vuman-p19
    }}}
Show file info (specif. which line you're on) @
{{{
    c-g
        .
    :set nu
        .
    :set ruler
    --
    vuman-p20
    }}}
Star|Hash-search(=search word under cursor)  (incl: 'search no 3 next cursor-word' (***(*)) @
{{{
    *  #   3*
    \v<word>
    --
    vuman-p22
    }}}
c-g: 'Column + Screen column' @T
{{{
    eg. "col 2-9" as output fr. c-g
     --
    col. (eg. 2)            char.num. for cursor-pos.
    screen-col. (eg. 9)     'absol. char.num.'(=including leading spaces) for cursor-pos.
    --
    vuman-p20
    }}}
mark-list auto-marks: cursor pos. bef. last jump || cursor pas. wh. last editing the file (**!) @
{{{
    `
    "
    --
    vuman-p26
    }}}
jump-list notation: mark in list for last used place/entry (**) @T
{{{
    '>'
    --
    vuman-p25
    }}}
gp vs gP (????) @@ @@
{{{
    (=appears to be contextual in some way(??))
      (=cursor sometimes lands on paste-line, sometimes after (!!))
    }}}
Example of Modeline Syntax (***!!) @@
{{{
    vim:tw=78:ts=8:ft=help:norl:
      # =can put text bef. and after
        +all options are set betw. ':'
            --
    # vim: syntax=make
    --
    vuman-p34,p45
    }}}
Activate v-mode + Increm. include more T-Objects (=sentences / paragraphs etc) ****(**!!) @@(@)
{{{
    v + as, as ....
    v + ap, ap ....
     ****
    --
    vuman-p33
    }}}
List of Operators (d, c, > etc) ***(*) @(@)
{{{
    :h operator
    --
    vuman-p33
    }}}
[Names of the Helpfiles:  Chapter 5 (='settings')  ||  Table of Contents]  ****(!) @@(@)
{{{
    usr_05.txt
    usr_toc.txt
    --
    vuman-p35
    }}}
___vimscript  'if has vms'... @@@(!!)
{{{
    if has("vms")
      set nobackup
    else
      set backup
    endif
    --
    vuman-p36
    }}}
___vimscript  mapping = search v-text (=like visualstar) in c-files (*!)  #includes :exe, functions (etc) ** @@
{{{
    vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>
    --
    vuman-p37
    }}}
'minimal vimrc-file' @
{{{
    set nocompatible
      .
    filetype plugin indent on
      ='switches on three clever mechanisms'
        - filetype detection
        - using filetype plugin files
        - using indent files
           (+see 'indentexpr')
    --
    syntax enable   p44
    --
    vuman-p37,p39
    }}}
Sort line 1 through 5 (=cursor on line 1) ****(**)  #+relative version ='fr. cursor line +4 lines'  (******)  @@!!
{{{
    !5Gsort<Enter>
    5!!
    --
    vuman-p79
    }}}
Replacing a Word in several Files ****(*) @@(!)
{{{
    - start file-list
    - record the wanted substitution (= w. eg. g-flag at end)
    - :wnext
    - stop macro + play back w. @q  (=to test and verify that doesn't produce err.mess.s etc)
    - run w. 99@q  (or the like)
    --
    vuman-p86,p87
    }}}
Reverse lines in a Block (***(*)) @@(@!)
{{{
    mark above first line w. mt
     + move to last line and type:
            :'t+1,.g/^/m 't
    --
    vuman-p88
    }}}
Search set of files for Cert. String  (=fr. within vim) **(**) @@(!)
{{{
    :grep error_string *.c
        #+ set the program (=grep, ag etc)
          by setting 'grepprg'
       ..
    +uses the qf-win
        =can use
    :cn / :cN
    --
    see all matches and where they are
        :clist
    --
    +fr. the hgrep examples at top:
     :cfirst  |  :clast
     :copen  |  :cclose  (??)
    --
    vuman-p90
    }}}
Edit / Inspect val. for an Option (eg. iskeyword) (****) @
{{{
    =complete w. Tab after '='
    :set iskeyword?
    :set iskeyword
    --
    vuman-p95
    }}}
Change Which Completion (=list, longest, cycle (etc)) ***(*!) @(@) @@
{{{
    'wildmode'  (+'wildmenu')
    --
    vuman-p95
    }}}
completion =specify less important files (=will appear at end of completion-lists) || files not to list at all (!!) @@
{{{
    'suffixes'
     'wildignore'
    +read more  |cmdline-completion|
    --
    vuman-p95
    }}}
(recap: filter text through ext. progr.) @(@)
{{{
    :[range]!{progr.}
    (=SUMMARIZE/COLLECT ALL WAYS TO SPECIFY THE RANGE(****))
    --
    vuman-p98
    }}}
+(!) (diff. betw. executing ext. progr. // filtering text w. ext. progr.) @@(@)
{{{
    :!progr
        vs
    :[range]!progr
    --
    vuman-p98
    }}}
save + restore  =eg. for exchanging register contents betw. two instances of vim @
{{{
    :wviminfo! ~/tmp/viminfo
    + use  :rviminfo! ~/tmp/viminfo  to restore
    --
    vuman-p101
    }}}
what is restored for sessions [**(*)]   # +add to restore size of the vim-win (**(!)) @
{{{
    - the win.s (+positions and sizes)
    - mappings
    - option values
        +what is set in 'sessionoptions'
    --
    def. is  "blank,buffers,curdir,folds,help,options,winsize"
        blank       keep empty wins
        buffers     all buf.s (=not just ones in win)
        curdir      the curr. dir
        folds       folds (=also manually created ones)
        help        the h-window
        options     all options and mappings
        winsize     =win-sizes
    --
      :set sessionoptions+=resize
    --
    vuman-p101
    }}}
Tut: Save a session as Secret + Reopen the Boring-session  (****) (@@)
{{{
    :wall
    :mksession! ~/.vim/secret.vim    #=overwrites prev. session
    :source ~/.vim/boring.vim
    --
    vuman-p102
    }}}
sessions +(!(!)) viminfo () @@
{{{
    keeping separ.
    =switch sessions  but keep cmdline-history, text in registers (etc)
    --
        +if(!!) want to keep together(**)  =store together
    :mksession! ~/.vim/secret.vim
    :wviminfo! ~/.vim/secret.viminfo
        ..
    :source ~/.vim/secret.vim
    :rviminfo! ~/.vim/secret.viminfo
    --
    vuman-p103
    }}}
Views (=unnamed  +advantage with) ** @
{{{
    =store :number set, some defined folds, etc  (for a certain win/buf)
    --
    :mkview   (=the unnamed one)
    :loadview
       .
    :mkview 1   (=1-9)
    :loadview 1
    --
     advant:  is stored with its file (=dont have to keep separ. file  **)
    --
    vuman-p103
    }}}
Keeping specific options (eg. shiftwidth etc) w. the file **(**) @@(!) @
{{{
    =Modeline (****) [=often commented]
    /* vim:set shiftwidth=4: */  (':' betw. posts)
       [first/last five] (+tip (=header or bot. for txt-files) ]
    --
      format:  any-text vim:set {option}={value} ... : any-text
    --
        |modeline|
    --
    vuman-p104
    }}}
string|part that makes modeline recognizable to vim (**(*)) @@
{{{
    'vim:'
    '^vim'    =at beg. of line
    --
    vuman-p104
    }}}
specif. num. of modelines (=in how many lines at top/bot to look for m.lines) @
{{{
    :se modelines=10
    --
    vuman-p104
    }}}
Open files (from netrw) **(**) @
{{{
    Ent     open file in curr. win
    o       hsplit win + open file
    v       vsplit --"--
    p       use the |preview-win|
    P       edit in the -"-
    t       open file in new tab
    --
    vuman-p107
    }}}
controlling netrw browsing display (=way of showing the file names)  ** @@
{{{
    i (listing style (ie, thin, long, wide, tree****)
    s (Sorting**)
    r(everse sorting)
    --
    vuman-p107
    }}}
more commands: change curr.dir to browsing-dir, rename file*, del. file|dir *, make/goto bookmark * @@(@) @
{{{
    c(urr dir =browse dir)    +see g:netrw_keepdir  (!!)
    R(ename)
    D(el)
    mb gb **
    --
    vuman-p107
    }}}
Change dir. for only one win|buf. (**(*)) @
{{{
    :lcd dir  (**)
    --
    vuman-p108
    }}}
using normal :cd for a win using a diff. (=winlocal) dir @
{{{
    = goes back to shared dir (?))
    --
    vuman-p108
    }}}
The 'path' Option **(!): Absolute, relative (@) @@(@) @
{{{
    :se path+=c:/prog/include
        # searches in spec.d dir
         fr. any locat.
        .
    :se path+=./proto   (=subdir to file's dir(!!))
        # search in dir 'proto'
         below curr. file's dir (****)
        .
    :se path+=proto   (=subdir to file's dir(!!))
        # =dir 'proto' below curr.dir
         (=not(!) below curr. file's dir (*))
    --
    vuman-p109
    }}}
more info|help on what can be done w. path (='allows specifying the dir.s where to search for files in many more ways') @(@) @
{{{
    :h 'path'
    --
    vuman-p109
    }}}
Open file (like w. :e), if know f-name but name not in the dok (=can't use gf etc) ****(**) @@
{{{
    :find inits.h
      (=uses 'path')
    --
    vuman-p109
    }}}
Using easy 'Fuzzy-Find' w. :find in vim ****(**!!) @@(@) @@(@) @@(@)
{{{
    set path+=**
     (+can use '*', eg. *.txt)
        .
    +(!) set wildmenu
          (=display + cycle all matches when tab|s-tab-completing(!))
    --
      '90%wjustvim': 00:09:00-00:10:00
    }}}
start vim w. a file in the path **(*)  #=w.out having to specif. whole filename @@
{{{
    vim -c 'find stdio.h'
      vim '+find stdio.h'
    --
    vuman-p109
    }}}
open file in (normal) split (*) @(@)
{{{
    c-w f
    --
    vuman-p109
    }}}
Open file w. :find in split / vsplit (**!!) @@
{{{
    :sfind file
    :vert sfind file
    --
    vuman-p109
    }}}
edit file 'two.txt', if has changes in curr. file  (+don't want to save yet(!!))  (**) @
{{{
    :hide edit two.txt
        #+'careful!' (=don't exit vim w.out having inspected your buf.list, if y. have any hidden buffers (in y. b.list))
    --
    vuman-p110
    }}}
'active/hidden/inactive' buffers' @
{{{
    active      normal (=appears in win, text loaded)
    hidden      (not in win + text loaded)
    inactive    (neither in win, nor text loaded)
    --
    vuman-p110
    }}}
buflist--marks//flags: a, h, u  (+previous list above (+, -, =))  **(*) @
{{{
    %   current
    #   alt (*)
     --
    a       active
    h       hidden
    u       unlisted   |unilsted-buffer|
    --
    vuman-p110
    }}}
Edit buffer X in buf.list (****(!!)):  buffer nr 2  ||  buf. w. string 'help' in name  **** @
{{{
    :b2   :b help
      # +completion w. tab and :set wildmenu(*)****
      #  (=see '90 % w.out plugins')
    --
    vuman-p110,p111
    }}}
Listing all =Including unlisted buffers **(**!!) @@
{{{
    :buffers!  (***)
    :b!
    --
    vuman-p111
    }}}
fileformats (=unix, win, mac):  (tell vim to) try unix, then win (**)  #=wh. opening a file @@
{{{
    :set fileformats=unix,dos
    --
    vuman-p112
    }}}
see|echo fileformat (=unix, win or mac)  for a textfile (**!) @@
{{{
    :set fileformats?
    --
    vuman-p112
    }}}
explicitly set fformat for a textfile (=the 'vi trick' etc)  ** @@(@) @
{{{
    :edit ++ff=dos file.txt    (++enc)
    --
    vuman-p113
    }}}
Convert (**) txt-file's fileformat ****(**) @@(@)
{{{
    :se fileformat=unix | write
    :se fileformat=dos | write
        ..
      (=set fileformat + write the file)
        eg. content hasn't changed, just the fileformat
    --
    vuman-p113
    }}}
'Files on the internet' (=open file someone refers|links to, à la ftp://ftp.vim.org/pub/vim/README)  (**) @
{{{
    place cursor on link-address (=inside vim) + gf  (****)
    --
    vuman-p113
    }}}
(editing binary files **) @
{{{
    vim -b datafile
    --
    +tip: usage
        change a message in a program
    see unprintable char.s in file (=see in hex format)
        :set display=uhex
    see val. of char. under cursor
        ga
    get better overview (=if not many linebreaks in the file **)
        :set nowrap
    see which byte you're on
        g c-g
    Move to specific byte in the file (**)
        2345go
    --
    edit converted w. xxd **
        :%!xxd
        (=can now be edited like ordinary text)  (+convert back w:)
        :%!xxd -r       (man xxd)
       [=only changes in the hex part is used, =not changes in the printable part at right side)
    --
    vuman-p115,p116
    }}}
[Def.places where Vim looks for matches for Completion (**(*))] (@)
{{{
    - curr. file
    - o. wins
    - other loaded (=hid)
    - inact
        --
    - tag-files
    - #includes etc
    --
    vuman-p119
    }}}
CUSTOMIZE COMPLETION SEARCH-ORDER (**!!) (=see more) @@ @ @@ @
{{{
    = use the 'complete' option (!!)
    --
    vuman-p119
    }}}
Ignoring + Matching case for completion (****) @@
{{{
    =uses ic if set (=not by def.(??))
        .
    'infercase' (=if ic is set)
        =matches 'For' in 'Fortunately' if searching w. "For"
    --
    vuman-p119
    }}}
Omni Completion **(!) @@
{{{
    =for source code        c-x c-o
    --
        example (=for c code):  |ft-c-omni|
            |compl-omni-filetypes|
    - vimrc std (=minimal modern, w. filetype and plugins switched on)
    - create tags-file
    - set the 'tags'-option
    --
            (+see more: compl-omni-filetypes  etc)    +check 'omnifunc'
     seeing if it would work (=for curr. filetype)
        check value of 'omnifunc' option
    --
    vuman-p120
    }}}
Avail. ins-completion modes (***) @@(@)
{{{
    - file
    - line
    - Incremental(**)
     - MacroDef         xd
    - curr. + included files
                        xi
     - Dict(K)          xk  **
     - Thes(T)          xt
     - Tags(])***       x]
     - V.CmdLine(V)     xv
    --
     |ins-completion|
    --
    vuman-p119
    }}}
set (=ins)abbrev 'ad' =expands to 'advertisement'  (****) @@(@)
{{{
    :iabbrev ad advertisement
        # = +put some in your vimrc (**)
    --
    vuman-p122
    }}}
make abbrev.s that includes spaces (***(**))  #=normally gets stripped @
{{{
    :iabbrev #b /****************************************
    :iabbrev #e <Space>****************************************/
    --
    vuman-p122
    }}}
List Abbrev.s (***), Del. an / all(!) abbrev.s (*(*)) @
{{{
    List abbrevs
        :abbrev
    remove abbreviation
        :unabbrev @f
    remove all(!) abbrev.s
        :abclear  :iabclear  :cabclear  :!abclear
    --
    vuman-p123
    }}}
NON RE-REMAPPING ABBREV.S (***************) @@
{{{
    :inoreabbrev @d trulystrange@gmail.com
     :cnoreabbrev
     :!noreabbrev
    --
    vuman-p123
    }}}
Modes/Variants for Abbreviations (**(**)) @
{{{
    =insmode (of course)
    :cabbrev  (=for commandline mode)
    :!abbrev  (=for both(!) ins- and cline mode) *****(???)
    --
    vuman-p123
    }}}

    }}}
    [vuman 2/2]  ~/Dropbox/rsc/data/lists/learnqna/vanki/vim2021.twothirds.tagged/DECK.vimuman2of2.patch.txt {{{


(ins. a del-char(!!)  =via its key-code (127)) @
{{{
    c-v 127
    --
    vuman73-p124
    }}}
ins. spec.char w. hexcode 7f | octcode 123 (**) @@(@)
{{{
    c-v x7f
        c-v o123
    --
    vuman73-p124
    }}}
ins. 16 | 32 bit unicode char.s ****(!) @
{{{
    c-v u1324
    c-v U13245678
    --
    vuman73-p124
    }}}
digraphs: copywrite-sym | c/o **(**!) @@ @
{{{
    c-k Co
      c-k co
    --
    vuman73-p124
    }}}
avail. digraphs | info ab. digraphs (***(!)) @@
{{{
    :digraphs
      = digraph  char. it gives  char.num(*)
      .
    (spec, nordic, greek, hebr, arabic, Logic(*), kana (etc))
    --
    :h digraphs
    --
    vuman73-p124
    }}}
define own digraphs (**!)  a" = ä @@ @ @@ @
{{{
    :digraph a" ä
    :digraph a" 228
    --
    vuman73-p125
    }}}
insert spec. char.s directly (=w. normal keys) ***(*) @@ @@ @@
{{{
    keymaps (**)
    :h mbyte-keymap
     --
    +see|list avail. keymaps (**)
    :echo globpath(&rtp, "keymap/*.vim")
    --
    vuman73-p125
    }}}
make Vim display lines w. line breaks (but do not insert line breaks in the file) (**(!)) @
{{{
    :set wrap   **
    --
    vuman73-p126
    }}}
some ex. text-formatting commands (!) @
{{{
    =use v-mode
    v4jgq
    or: movement, text object (= gqap)
     --
    gqj
    gq}
     gggqG
    --
    + both v-mode, movem, textobj. + gq works because
        = gq is an operator (!!(**))
    --
    vuman73-p126,p127
    }}}
specifying rules for text-formatting (**(!)) @@
{{{
    'formatoptions'  'fo'
    + :h fo-table
    --
    vuman73-p127
    }}}
Specify num of spaces when joining sentences (****(!!)) @(@)
{{{
    :set joinspaces=1
    --
    vuman73-p127
    }}}
use external progr. for formatting (**)  (????) @@ @
{{{
    :se formatprg=
    --
    vuman73-p127
    }}}
[format 5-line paragr. w. 5 chars indent for first line] @@
{{{
    :1left 5
    :2,5left
    --
    vuman73-p128
    }}}
set so you never(!!) get tabs for indents in files (#### (!!!!*****)) @
{{{
    :set shiftwidth=4
    :set softtabstop=4
    :set expandtab
    --
    vuman73-p129
    }}}
([changing tabs  (=editing file w. tabstops originally set to 3 etc(!!))]) @
{{{
    :set tabstop=3
    :retab 8
      .
    = 'The ":retab" command will change 'tabstop' to 8, while changing the text such that it looks the same.
    ((+ 'It changes spans of white space into tabs and spaces for this. You can now write the file. Next time you edit it the indents will be right without setting an option.
    Warning: When using ":retab" on a program, it may change white space inside a string constant. Therefore it's a good habit to use "\t" instead of a real tab.  (?????)
    --
    vuman73-p129
    }}}
DISPLAYING LINES WIDER THAN WIN. AS WRAPPED +(!!) DISPLAY WHOLE WORDS ****(**)  [=display like if formatted w. gq] ******(!!) @@ @ @@ @
{{{
    :set linebreak
    --
    vuman73-p131
    }}}
specify char.s where a line break can be inserted | specify string to show at start of broken line @@
{{{
    :set breakat=____
    :set showbreak=**
    --
    vuman73-p131
    }}}
Tip: Convert all paragr.s to one line each (*!!) @@ @@ @@ @
{{{
    :g/./,/^$/join
      .
    = for each line of at least one char
    until blank line   + join
      .
    (+Note: =leaves no blank lines (=since are included in the match(!!)))
    --
    vuman73-p131,p132
    }}}
convert all paragr.s to one line each (=if some sep-lines empty(!!), but not blank)  (***) @@ @@
{{{
    :g/\S/,/^\s*$/join
    --
    vuman73-p132
    }}}
set so can input text in empty columns (=as if contained default spaces) (!!(*)) @
{{{
    :set virtualedit=all
      +eg. /-search col.header-name, then j + a
    --
    vuman73-p132
    }}}
copying a whole column (*) @
{{{
    c-v for blockwise v-mode
    include until last char.s (+amount of space wanted after)
    cursor on first char of column to paste before + P
    --
    vuman73-p132,p133
    }}}
make :s-changes in only certain(=contigous) lines (!!(*)) @@ @@
{{{
    v-mark lines | specify range for :s
    + :s/.......(=changes)/g
    --
    vuman73-p135
    }}}
Change x_cnt to x_counter in sever. Files ****(!!)  [=in all c-files in dir] ** TT @@ @@
{{{
    :args *.c
    :argdo %s/\<x_cnt\>/x_counter/ge | update
       (+search-item can be obtained w. '*' and incl. w. %s// or %s/ + c-r /
       # +'e'-flag included not to abort on 'not found in this file'(!!(****))
    --
    vuman73-p136
    }}}
Change '-person-' to 'Jones' in many files (=not open) in a Dir ****(!!) @@
{{{
    %s/-person-/Jones/g
    write tempfile
    quit
            =put in a file, like 'change.vim'
      .
      .
            +in a shell|terminal, run:
    for file in *.txt; do
      vim -e -s $file < change.vim
          "run vim in ex-mode + in sil.mode
      lpr -r tempfile
          "??(=print file + then delete it)
    done
    --
    vuman73-p137
    }}}
run vim-file as a script: =contains n-mode commands (!!!!(**)) @
{{{
    vim -s script file.txt ...
      .
      (+note diff. fr. the 'vim -e -s change.vim'-ex:
        ='run as ex-cmds + silently'
      .
    Note: File should be edited exactly(!)
    as keys one wants pressed (=Enter is set by a normal newline(!!))
    --
    vuman73-p137
    }}}
edit|record script that should be run as n-mode commands **(!) @
{{{
    vim -w script file.txt ...  (=??)
      =all keypresses will be saved to file 'script'
    --
    vim -w script file.txt ...  (=when run second time)
      =appends more cmds to the file 'script'
    --
    vim -W script file.txt ...
      ='this rec.session (for keystrokes) overwrites curr. contents in file 'script' '
    --
    vuman73-p137,p138
    }}}
turn off ic(=if set) + using smartcase (****) @@
{{{
    :set noic smartcase
    If you have a pattern with at least one uppercase character, the search becomes case sensitive. (**!!)
    --
    vuman73-p139
    }}}
search for 'patt' + move 1 | 2 lines down **(!!**)  || 2 lines above patt. **** @
{{{
    /patt/1
    /patt/2
    /patt/-2
      .
      ?patt?-2
    --
    vuman73-p141
    }}}
search 'ababab.....' etc @@
{{{
    /\(ab\)*
    --
    vuman73-p142
    }}}
match ab, abb, or abbb (+but as few b:s as possib.) **** @@ @
{{{
    /ab\{-1,3}
    --
    vuman73-p143
    }}}
match "foo", "foobar", "foofoo", "barfoobar", etc. (****** (#####)) ******* @@ @@
{{{
    /\(foo\|bar\)\+
    --
    vuman73-p143
    }}}
match "endif", "endwhile" and "endfor"  (**********) !! ????? @@
{{{
    matches "endif", "endwhile" and "endfor"
    --
    vuman73-p143
    }}}
match "for" in "forever" (=but not(!!!!) "fortuin")  (??????????????????  (#### !!!! ********************) @@ @
{{{
    /forever\&...
       = '\& requires that both alternatives match in the same place (??????? (!!!!!!!))
    --
    vuman73-p143
    }}}
match nums + a-f and(!!) '-' @
{{{
    /[0-9a-f-]
    /[-0-9a-f]
    --
    vuman73-p144
    }}}
Search esc, tab, cr, or bs ***** @@
{{{
    /[\e\t\r\b]
    --
    vuman73-p144
    }}}
(more help on [a-z]-ranges) @
{{{
    :h /[]
    --
    vuman73-p144
    }}}
find char.s, nondigits, hex, Wh.Spaces, lcase, uppercase letters (etc) ********* (SSSSSS)  #='predefined ranges' @
{{{
    \d digit [0−9]
    \D non-digit [^0−9]
    \x hex digit [0−9a−fA−F]
    \X non-hex digit [^0−9a−fA−F]
    \s white space [  ]  (=<Tab> | <Space>)
    \S non-white characters [^  ]
    \l lowercase alpha [a−z]
    \L non-lowercase alpha [^a−z]
    \u uppercase alpha [A−Z]
    \U non-uppercase alpha [^A−Z]
         (++ are much faster(!!) than their range equiv.s (**))
      .
    (+ :h /\s for whole list
    --
    vuman73-p144
    }}}
[\d\l]  (****) @@ @ @@
{{{
    =\d-style _ does not work in ranges
    Use "\v(\d|\l)" instead.
    --
    vuman73-p144
    }}}
\i, \I etc are called ___ (!!!!!) @@
{{{
    'char. classes'
      (=contrary to char. ranges (eg. \d) they can be redefined by setting eg. 'iskeyword' (*****))
    --
    vuman73-p145
    }}}
char.classes: identifier char.s @@
{{{
    \i      option 'isident'
    \I  =like \i, but excl. digits
    --
    vuman73-p145
    }}}
char.classes: printable char.s @
{{{
    \p      option 'isprint'
    \P  =like \p, but excl. digits
    --
    vuman73-p145
    }}}
char.classes: filename char.s @
{{{
    \f      option 'isfname'
    \F  =like \f, but excl. digits
    --
    vuman73-p145
    }}}
MATCH 'THE WORD', EVEN IF SPLIT ON TWO LINES **** @@
{{{
    /the\_sword
      .
      .
    (or if 'the     ' + '     word' =on two lines:
    /the\_s\+word
    --
    vuman73-p145
    }}}
Explain the patt.s \_a, \_s, \_.,  /"\_[^"]*"  (### (*******************(!!!)))  (SSS(S)) @@ @ @@ @
{{{
    a-z or a line break
    space  or a line break
    a char  or a line break
     --
    A string | Quoted text, that may be split over two lines ******
    --
    vuman73-p145,p146
    }}}
Find license plate num. à la 1MGU103  (**!) @
{{{
    /\d\u\u\u\d\d\d
    /\v\d\u{3}\d{3}
     --
    /[0−9][A−Z]\{3}[0−9]\{3}  #avoid (=long to type and slow to run)
    --
    vuman73-p146
    }}}
FIND AN IDENTIFIER (IN C ETC. ******) (=letter and uscore + letter, digit or uscore) ******* @@
{{{
    /\v<\h\w*>
      .
    \h = "[A-Za-z_]"
    \t = "[0-9A-Za-z_]"
    --
    vuman73-p146
    }}}
the 'ident-' and  /\w\@<!\h\w*\w\@! --example  (?????????) @
{{{
     (=maybe sssss)
    --
    vuman73-p146
    }}}
MAKE '*'-SEARCH FIND WORD LIKE 'ident-id' (=Uses 'iskeyword') ********(********(!!!!)) SSSS @@ @ @@ @
{{{
    :set iskeyword+=-
    --
    vuman73-p146(!)
    }}}
"zf can be used with ___" (*) @@
{{{
    is an operator, =can be used with v-marking,
      movements, text objects (=like 'ap')
    --
    vuman73-p147
    }}}
open|close all folds at top level // down all levels *(*) @@
{{{
    zr | zm
      zR | zM
    --
    vuman73-p148
    }}}
deactivate | activate all folds **(*) @
{{{
    zn | zN  //
    zi | zi
    --
    vuman73-p148
    }}}
showing control column w. plus/minus-controls @
{{{
    :set foldcolumn=2 
    :set foldcolumn=0
      open =click '+'
      close =click '-' or '|'
    --
    vuman73-p148,p149
    }}}
open|close all folds at cursor line **(**) @@(@)
{{{
    zO | zC
    --
    vuman73-p149
    }}}
del. a fold at cursor line **(*) @
{{{
    zd
      .
    for closed fold (=w. closed subfold)
     = remove foldmarks for toplevel fold
     (= the closed fold the marker is on)  (**)
    --
    vuman73-p149
    }}}
Del. all folds at the cursor line ((**(*))) @@
{{{
    zD   =removes foldmarks for folds all levels down (=at cursor line)
    --
    vuman73-p149
    }}}
set so folds always open when cursor on top + reset  (SSSs) @@ @@
{{{
    :set foldopen=all
    :set foldopen&
      +see more ='The 'foldopen' option can be changed to open folds for specific commands.'
    --
    vuman73-p149
    }}}
set so folds close autom. wh. moving out of it @
{{{
    :set foldclose
    --
    vuman73-p149
    }}}
tip: "different views" on a dok. w. folds (**) @
{{{
    'The folding is local to the window.'
       =can have two win.s|views open on the same buf. (=one w. folds open, +one w. them closed (etc))
    --
    vuman73-p149
    }}}
[[tip: saving and restoring manually created folds]] @
{{{
    (w. the dok. open:
      :mkview  +
      :loadview
    + storing diff. views:
      :mkview 3
      :loadview 2  (=can store 10 views on same file)
        .
        ((+note: views can become invalid, if deletes lines et))
    --
    vuman73-p149
    }}}
((managing views + where views are stored)) @
{{{
    'viewdir'  (=where the views are stored)
    +tip: "might want to del. old views now and then"
    --
    vuman73-p149
    }}}
[what does ':set foldlevel=3' actually mean?[**]] @@
{{{
    = all folds w. three times a 'shiftwidth' indent (or more) will be closed
    aoeu {{{
    }}}
    --
    vuman73-p150
    }}}
[what actually happens when using zm | zr (*) @
{{{
    increases | decreases foldlevel
    --
    vuman73-p150
    }}}
[[Summarize foldlevels + zM and zR [****]]] @@(@)
{{{
    foldlevel=0     =All folds are closed **(!)
    foldlevel=1     =all folds at topmost level are open (**)
    zM              =sets foldlevel to 0
    zR              =sets foldlevel to curr. file's max.level
    --
    vuman73-p150
    }}}
(marker-folds displays ___ for folded|closed lines)  @
{{{
    =the text before the opening marker
    --
    vuman73-p151
    }}}
(Using numbered(!) fold-markers) @
{{{
    = putting the foldlevel-num behind the marker
        [[[1
          ]]]1   (etc)
    --
    vuman73-p151
    }}}
(['At every numbered marker a fold at the specified level begins. This will make any fold at a higher level stop here.' (?????)  (+Tip: @
{{{
    ='You can just use numbered start markers to define all folds.
    += 'Only when you want to explicitly stop a fold before another starts you need to add an end marker.  (***(!!))
    --
    vuman73-p151
    }}}
'folding by syntax' (*(*)) @
{{{
    'In the syntax files it is possible to add syntax items that have the "fold" argument.' (= 'These define a fold region.'
            (= syntax file must be written + not easy, but folding is automatic
    --
    vuman73-p151
    }}}
folding by expression (!)  [SSSSS(SSs)] @@ @@
{{{
    = calling a user function to compute the fold level of a line
    You can use this for text where something in the text indicates which lines belong together.
    An example is an e−mail message where the quoted text is indicated by a ">" before the line.
    :set foldmethod=expr
    :set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))
        gets curr line
        remove wh.space fr. line
        remove all after leading '>'
        strlen =num. of '>'s found
      .
    +try w. this text:
    > quoted text he wrote
    > quoted text he wrote
    > > double quoted text I wrote
    > > double quoted text I wrote
      .
    --
    vuman73-p151,p152
    }}}
(+tip: testing and checking a|your folding-expression (=because '\' must be insert bef. space, ", and \ for the set-command etc @@(@)
{{{
    inspect the current|active folding-expression
        :set foldexpr
    tinker w.|correct an actual expression
        :set foldexpr= (+Tab)
    --
    vuman73-p152
    }}}
Tip: Managing very complicated folding expressions (**!!**) @@(@)
{{{
    put it in a function + set 'foldexpr' to call that function
        (+see |fold-expr| in the ref.man)
    --
    vuman73-p152
    }}}
([[manually setting options and folding for diff]]) @
{{{
    :setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1
    --
    vuman73-p152
    }}}
(Tips/Rules ab. which fold-method to use) (!) @@
{{{
    If there is a syntax file w. folding for the lang. you are editing
        = use that
    if, want to write your own
        = requires good knowl. of search-patterns
    --
    +'Folding w. expr.s can make folds in almost any structured text.
    (+quite simple to specif, espec. if start and end of a fold can easily be recogn.
        +if using expr-method, and folds are not exactly right
        =one can switch to manual for deleting|adding folds manually (="embellishing")
    --
    vuman73-p152
    }}}
generate tags (for jumping to name definitions in program files) **(!!) @@(@)
{{{
    ctags *.c       #generate tags for all c-files in dir
    (cscope
      (ctags -R *.c ??)
    --
    vuman73-p154
    }}}
jump to def of name(eg. function) 'startlist'  =fr. a code file   [[=CHECKING WHAT A FUNCTION ACTUALLY DOES (!! =lifting the cover and inspecting its machinery|working parts) ***** @@
{{{
    :tag startlist      (=function)
      //
    cursor on word 'startlist'      +c-]  (cgs-ö)
    --
    vuman73-p154
    }}}
show list of files+lines one has traveled through (=w. :tag | c-] )  (**)  [='find out where you are'] @@(@)
{{{
    :tags
    --
    vuman73-p155
    }}}
go back to prev. tag (=go back in ':tags'-list) @
{{{
    c-t
    3 c-t     =go back 3 steps (*)
    --
    vuman73-p155
    }}}
go all way forward in tags-list (=to top entry (="to deepest visited file")) || "go 3 steps in" @ @
{{{
    :tag  (=like many c-])
    :3tag
    --
    vuman73-p155
    }}}
visit tag 'tagname' in a split **(****) @@
{{{
    :stag tagname
    c-w ]
    5 c-w ]         =splitwin will be 5 lines high
    --
    vuman73-p155
    }}}
=if have progr.files in many (sub)dir.s (=creating tags-files + setting options to find|search them) ((??(/****))) ([SSSs]) @@
{{{
    ='creating tags-files in all of them' (??)
        +
    :set tags=./tags,./../tags,./*/tags
      .
      same dir
      parent dir
      all subdirs
      .
    ++ 'when editing a file in "~/proj/src", you will not find the tags file "~/proj/sub/tags".  =
    :set tags=~/proj/**/tags
        = search a whole directory tree for tags files.  (*******)
    --
    vuman73-p155
    }}}
BETTER SOLUTION GENERATING TAGS FOR WHOLE PROJ. (=SUBDIR OF PROGR. FILES) ****(**)**  (+=ctags|cscope can be used for c, python etc etc + vimscript files (**)) @@ @@
{{{
    cd ~/proj
    ctags -R .
    :set tags=~/proj/tags
    --
    vuman73-p156
    }}}
inspecting tags w. :tag (=wh. defined in sever. places (**)) @@(@)
{{{
    :tag jumps to first def.
      .
    - jump to next w. :tnext
          :tfirst
          :[count]tprev
          :[count]tnext
          :tlast
    - show list of all matching tags
        = :tselect tagname  (+sel. match w. number)
    --
    vuman73-p156
    }}}
TIP: SEARCH|USE PATT. FOR :TAG, :TSEL (eg. tag-commands) ****(***!!) @@(@)
{{{
    :tag /block     =the tag contains patt. 'block'
    :tselect /^write_       =tag starts w. 'write_'
        /_bfg$  (etc)
    --
    vuman73-p156,p157
    }}}
[(tip: using a tag-file as a tags browser (=eg. for browsing function-names in a progr.) (*(****)))] @@ @@ @
{{{
    ctags --c-types=f -f functions *.c
    gvim
    :vsplit functions
    :setlocal ts=99
    :nnoremap <buffer> <CR> 0ye<C-W>w:tag <C-R>"<CR>
      .
    (+can then browse functions in f-list by just pressing Enter on the names(**(!)))
    --
    vuman73-p157
    }}}
option 'tagbsearch' ((**)) @
{{{
    = tells if the tags file is sorted or not
      .
    default is to assume it is (which makes searching a lot faster)
    (but: that will not work if the tags file isn't sorted)
    --
    vuman73-p157
    }}}
opt. 'taglength' (!) @
{{{
    can be used to tell vim num. of signif. char.s in a tag
    --
    vuman73-p157
    }}}
Cscope (****) @
{{{
    free program
     - find where identifiers are declared
     - find where identifiers are used (!!)**
    --
    vuman73-p157
    }}}
inspecting how to call a function (=looking in its def. for what arg.s to use when calling it):  =opening :tag w. the preview win.  (**) @@ @
{{{
    :ptag write_char
        (='vim will open a win + jump to the tag + takes y. back to the orig. pos.
        ( = can cont. typing w.out having to use c-w--commands ((?|!))
    --
    vuman73-p157,p158
    }}}
cursor on identifier in progr. text: show def. in preview win (**)  (=like jumping w. c-] )  (**) @@
{{{
    c-w }
    --
    vuman73-p158
    }}}
[script that autom. displays the text where word under cursor (=in progr. text) was defined (**!!)]  (SSSSs) @@ @@ @@ @@
{{{
    |CursorHold-example|
    --
    vuman73-p158
    }}}
(close the preview-win)(*) @
{{{
    :pclose
    --
    vuman73-p158
    }}}
tip: editing specif. file in the preview-win (eg. useful for header files) * @
{{{
    :pedit defs.h
    --
    vuman73-p158
    }}}
find word in curr. + included files  + display the match in the preview win.  [+tip: useful when ___] @@ @@ @
{{{
    :psearch popen
        eg. useful when using library functions, for which y. do not have a tags file
    + 'This(=example) will show the "stdio.h" file in the preview window, with the function prototype for popen():
    --
    vuman73-p158
    }}}
((specif. height of preview win. when opened)) (@)
{{{
    'previewheight'
    --
    vuman73-p158
    }}}
jump (=forw.) betw. items in a C(==only??) #ifdef|#else|#endif  (**(!)) @
{{{
    cursor on one of lines  +  %
      .
    [#  ]#   =  jump back | forw. to #line **
      (+skips "#if" − "#endif" blocks encountered (??  (sss))
    --
    vuman73-p158
    }}}
to end of prev.|start of next function (**)  [+(!!) FIND GOOD SCHEME|MNEMONICS-TABLE FOR THE DIFF. ]-movem.commands(!!)] @
{{{
    []
     ]]
    --
    vuman73-p159
    }}}
spec. case using [{ and ]} for C++ and Java (*(!!))  (=functions, blocks, classes and methods)(!!) @@
{{{
    = outer {}-blocks are for classes
    + next {}-level are for methods
     .
    =  use [m and ]m  to find prev.|next start of methods (**)
    --
    vuman73-p159
    }}}
move to start|end of /* */-style comments (**) @
{{{
    [/
     ]/
    --
    vuman73-p160
    }}}
editing C progr. + wonder if a var is declared as "int" or "unsigned" (**)  (=finding global identifiers)  [+advant. over using tags|the preview window **] @@ @@(@)
{{{
    [I
      (+vim lists matching lines
       = in curr. + all included (=including recurs.) files
      .
      .
    - included files are searched (=unlike w. tags and preview-win)
    - works w.out tags-file|if tags-file is out of date (**)
    --
    Tip/note: 'include'-opt. must specif. how files are included
                =works well for C/C++
    +Will have to tune this setting for other langs (!!)
    --
    vuman73-p160
    }}}
locating|listing included files (+= broken include-links) ****(**(!)) @@ @@ @
{{{
    :checkpath
      .
    (= gives:
      .
    --- Included files not found in path ---
    <io.h> ~                    NOT FOUND
    vim.h −−> ~                 =successful search down
      <functions.h> ~           NOT FOUND
      <clib/exec_protos.h> ~    NOT FOUND
    --
    vuman73-p160
    }}}
fix broken includes found w. checkpath (!) @ @
{{{
    find dir. w. missing dep.s + add to 'path' (!!(*))
      .
    check makefile for -I--items like "-I/usr/local/X11"
    :set path+=/usr/local/X11
    --
    vuman73-p160,p161
    }}}
setting path for whole nested tree of "include"-dirs  = like /projects/invent/include, /projects/invent/main/include, /projects/invent/main/os/include  (etc)  (**  [++NOTE: CONTRAST DIFF. "STAR-PATH"-EXAMPLES(=TO UNDERSTAND BETTER)(****) @@ @@ @(@)
{{{
    :set path+=/projects/invent/**/include
    --
    vuman73-p161
    }}}
(( show full include-list (=see which included files are actually(!!) found) )) @@
{{{
    :checkpath!
    --
    vuman73-p161
    }}}
find global id.fiers: =jump to match for [I || jump to 3rd match  (**(!)) @
{{{
    [ + Tab|c-i
     3[ + tab|c-i
      .
    [[++jump back w. c-o]]
    --
    vuman73-p161
    }}}
[I (=find glob. identif.):  only list first match,  only list items on lines below cursor,  only list first item below cursor  [=="higher line nr than cursor line nr"] (**(*)) @
{{{
    [i      only list first match
    ]I      only items w. higher line nr
    ]i      only first item w. higher line nr
    --
    vuman73-p161
    }}}
find id.fs for macros (=set w. #define)  (*) @
{{{
    [D
        =searches included files
      .
    (+ [d ]D ]d )
        =only first match, only lower, only first lower(=next)
    --
    vuman73-p161
    }}}
Change|Set so [D works for other langs than C|C++ (****) @@ @@ @
{{{
    :set define=
      (eg. tips for setting for JS etc (**(!)) )
    --
    vuman73-p161
    }}}
Find local identifiers (**)  (eg. variables in bash scripts || only in curr. function) ** @@
{{{
    gD
        (= finding var.s defined locally (eg. 'static' in C terms))
    gd
    --
    vuman73-p162
    }}}
    ----

editing|compiling programs

    ----
example|typical make session @@
{{{
    :make (arguments)
      :!make | &tee /tmp/vim134545.err
    Enter   #vim goes to first error
    :cnext
    :cc     #display full of shortened error message
    :clist  #get an overview of all e.messages
    display all messages    :clist! (=not just w. linenr and filename)
    :cprev
      :cfirst
      :clast
      :cc 3     go to error nr 3
    --
    vuman73-p163,p164
    }}}
program to use for make ((+make to set for visual c++))  incl. setting options to the progr. (*) @
{{{
    :set makeprg=nmake
      :set makeprg=nmake\ −f\ project.mak
    --
    vuman73-p164
    }}}
set makeprogr. +use 'curr file' (=as main.o instead of main.c) ****(**!!) @@
{{{
    :set makeprg=make\ %:r.o
      (+see more |filename-modifiers|)
    --
    vuman73-p164
    }}}
prev.|next error lists  (eg. file 1 = warning, file 2 = error, +fixing error, go back to warning, + forw. to latest list) @(@)
{{{
    :colder
      (+ :clist  :cc (nr)
    :cnewer
    --
    vuman73-p165
    }}}
'switching compilers' @(@)
{{{
    telling vim what format your compiler produces
        = opt. 'errorformat'
    +tip:
    :compiler msvc  (as an example)
        (=will find the vim script for the "msvc" compiler and set the appropriate options
    --
    vuman73-p165
    }}}
info ab. writing y. own compiler files (=vim script(*!)) @
{{{
    |write-compiler-plugin|
    --
    vuman73-p165
    }}}
[make-cmd error-file output redirection]  (="manually") @(@)
{{{
    'shell'
    'makeef'
    'shellpipe'
     'shellquote'
     'shellxquote'
    --
    +"if you can't get ':make' to redirect the file for you:
        compile progr. in another win
        + redirect the output into a file
        + let vim read this file  :cfile efilename  (**)
    --
    vuman73-p165
    }}}
    ----

    ----
'indenting cstyle text' (****)  (=c, cpp, java, d)   [+how indenting can help you to find errors early] @@(@) @
{{{
    :set cindent shiftwidth=4
      .
    + if vim indents a block weirdly  =good indication some braces are missing (**!)
        (+use % to find which start-brace is matched)
    --
    vuman73-p165,p166
    }}}
RE-INDENT CODE *******(***) @@
{{{
    the '=' operator ****
      .
    ==      reindent line
    =a{     reindent cstyle code block
    gg=G
    --
    vuman73-p166
    }}}
customize indentation-style @(@)
{{{
    'cinoptions'
    eg.
    :set cinoptions+={2
        |cinoptions-values|
    ((+ is switched on automatically with:
            :filetype indent on
        (=searches for an indentfile for the detected filetype
      .
            :filetype indent off   (=switch off autom. indenting)
    --
    vuman73-p166
    }}}
[show filetype detected for a certain file(**!)]  (+check dir. to put filetype-files (ie. vims fileinstall-directories(!)) @
{{{
    :set filetype
      (ex.  filetype=help)
    :set runtimepath
      (eg. first dir is ~/.vim/
            = ~/.vim/indent/help.vim
    --
    vuman73-p167
    }}}
info on writing own indent-files ((**(!))) @
{{{
    |indent-expression|
    --
    vuman73-p167
    }}}
diff. betw. >i{ and >a{  (*****(!!)) @@
{{{
    >i{     indents contents of {-block
    >a{     indents contents + the '{'s
     ***
    --
    vuman73-p168
    }}}
    ----

(tabs and spaces)

    ----
'tabstop' is set to ___ by def. @
{{{
    8
      universal value =used by many other programs, and printers
      = prob. leave this value alone
    --
    vuman73-p168
    }}}
'If y. want absolutely no tabs in your file,'  ****(!!) @(@)
{{{
    :set expandtab
      =pressing tab inserts a series of spaces
      .
    + tip: use tab|c-t for indent || c-d for deindent (=or lots of bs-presses)
    --
    vuman73-p169
    }}}
[recalculate existing tabs in a file to spaces (**)] @@ @@ @
{{{
    :set expandtab
    :%retab
      .
      .
    but(!) tabs after first non-blank char. will be kept
    to convert all(!!) tabs to spaces:
      .
    :%retab!
    ((+note: will also change tabs inside strings(!)
      /"[^"\t]*\t[^"]*"  #=check if there are tabs inside strings
      (+if exists, replace w. "\t" 'to avoid trouble')
    --
    vuman73-p169,p170
    }}}
[[recalculate all spaces (that can be converted) to tabs]] @@
{{{
    :set noexpandtab
    :%retab!
    --
    vuman73-p170
    }}}
format a c-style comment /* multi * line  s */  (*****)!! (@)
{{{
    - cursor at start of comment + gq]/
    - v-sel. comment + gq
        (+vim will autom. handle inserting new stars + checking line lengths wh. editing | inserting lines w. 'o' (etc))
      .
      .
    flags in 'formatoptions' for this to work:
     r  insert star when pressing enter in ins-mode
     o  insert star when pressing o in normal-mode
     c  break comment text acc. to 'textwidth'
    --
    vuman73-p170
    }}}
defining what a comment looks like @@
{{{
    :set comments=://  (=cpp-comments)
      .
    =  {flags}:{text}
    --
    vuman73-p171
    }}}
the 'mail-comments' ex.  =two-part comments @
{{{
    :set comments=n:>,n:!
      (n-flag=nesting comments)
    --
    vuman73-p171
    }}}
    ----


ch. 31 - (exploiting the gui  [=extra features as compared to terminal vim])

    ----
tip: sel. menu-item w. keys (**(!))  (@)
{{{
    a-key  (!!)
    --
    vuman73-p175
    }}}
[Report curr. pixel.pos of vim-win on screen **]  +Move to another pos. ** @(@)
{{{
    :winpos
    :winpos 172 103  #note: can be small diff. because of the border added around the win by the winmanager
    --
    vuman73-p175
    }}}
get|set size of vim-win (*(****)) @@(@)
{{{
    calculated in char.s (=depends on the fontsize)
      .
    report curr. win-size:
        :set lines columns
    change win-size:
        set one|both values to diff. values
            :set lines=50
            :set columns=80
    --
    set win-size for gvim
        gvim -geometry {width}x{height}+{x_offset}+{y_offset}
    eg.  gvim -geometry 80x25+100+300
    --
    vuman73-p175
    }}}
using gvim for editing an e-mail message(*) @@
{{{
    gvim disconnects fr. the shell it was started fr.
    (= program trying to use gvim will think it has exited)
    gvim -f file.txt  #f = foreground
    --
    vuman73-p175,p176
    }}}
gvimrc (!) @
{{{
    = settings only to apply to gvim
    eg.  :set lines=55  (=other size specifically for gvim)
    --
    vuman73-p176
    }}}
Location of gvimrc (+setting specific gvimrc | no gvimrc (!!)) @
{{{
    ~/.gvimrc" for Unix and "$VIM/_gvimrc" for MS-Win
    :edit $MYGVIMRC
      .
      .
    gvim -U specifrc ...
    gvim -U NONE ...
    --
    vuman73-p176
    }}}
    ----


Ch. 32 - The Undo Tree **(!!)

    ----
go back|forward to save-state of file ****  (=eg. want to discard changes made to file since last save) @
{{{
    :earlier 1f     #f = file
      ( :e! )
    :later 1f
        #+"note! these commands work in time sequence(!!)"
    --
    vuman73-p177
    }}}
go back|forw. in undo-time  (=last|prev. change, no matter on which undo-tree branch) [***********] ** @@ @@ @
{{{
    g- || g+
    (="more useful than ':undo' if don't know exact nr of change want to jump to (***))
    --
    vuman73-p178
    }}}
inspect all branches in undo-tree (=show as list) ***(*) @@ @
{{{
    :undolist
    --
    vuman73-p179
    }}}
(ex  = two changes in list  (=16 secs, 5 secs ago):  go back to last change)  go forward in change-list @
{{{
    :earlier 10s
    :later 1m
    --
    vuman73-p179
    }}}
going back far in undo-history (**(!)) @(@)
{{{
    :earlier 10m
    :earlier 10h
    :earlier 3d
    :earlier 100d  #go back to beg. = give really big number
    --
    vuman73-p179
    }}}
([showing more detail fr. undo-hist || set info in undo-hist]) @(@) @
{{{
    undotree()
    :echo undotree()  =see what info is returned by ___
    --
    vuman73-p179
    }}}
    ----


ch. 40 - make new commands (*!)


mappings (**)

    ----
te: the '<>'-style special notation for spec.keys  (+tip: why use (**)) @@(@)
{{{
    angle bracket notation
      (makes mapping better readable + text can be copied easier)
    --
    vuman73-p180
    }}}
[tips on good keys for mappings (*(*))] @@(@)
{{{
    |map-which-keys|
    --
    vuman73-p180
    }}}
:map-- and :noremap--mappings work in ___-modes [(***)] @@(@) @
{{{
    = normal, visual, op-pending
    (= n- v- o- modes)
        =  nmap  vmap  omap
    --
    vuman73-p180
    }}}
make mapping for insert- and cline-modes ***(!!*) @@(@)
{{{
    :map!  ||  :noremap!
      |
    + imap  cmap  (=for just one of them)
    --
    vuman73-p181
    }}}
Explain o-maps (****)!! @@ @
{{{
    'custom movements|text-objects' (=to be used w. operators pending a motion(!!) (****)
      .
    substitutes a key (eg. <F7>)
    for a movem.(??) or text-block(=obj.)
    --
    vuman73-p181
    }}}
O-map Ex: =so d+f7 deletes a brace-block (eg. for a function) ****(!!) @(@) @
{{{
    :omap <F7> a{
      .
        (=tip: espec. useful if '{' is diff. writing|reaching on the keyboard(!))
    --
    vuman73-p181
    }}}
    ----

    ----
List all curr. defined mappings (**(**!)!) @@ @
{{{
    :map
      .
      .
    :vmap
    :imap
      (etc)
      .
      .
    [+mappings listed w.out 'n', 'v' etc mode-specifiers:
        =defined w. ':map'/':noremap' (=effective in n-, v- and o-modes) ***(*)
    --
    vuman73-p181
    }}}
[tip =extra usage for listing mappings w. ':map'] (*) @
{{{
    = checking if <>-style keys have been properly recognized (=colored correctly)
    --
    vuman73-p181
    }}}
remapping (=the 'chaining "input date"'- and 'can still start Q-mode'-examples)(!) @@
{{{
    --
    vuman73-p181...
    }}}
[Tip|Idea: =RECURSIVE MAPPINGS] (**(!)) (SSSS!) @
{{{
    :map ,, :s/5.1/5.2/<CR>:wnext<CR>,,
      # interrupts on error (or interrupt)
    --
    vuman73-p182
    }}}
    ----

    ----
define a map that writes + runs cmd 2 (**(!)) @
{{{
    :map <F8> :write <Bar> !checkin %<CR>
       (cannot use '|' inside the mapping, since used to separate two commands (=effectively ending the map-command))
    --
    vuman73-p182
    }}}
Making mappings local to a script (?????? (*******) SSSS) @@
{{{
    the <script> keyword
      |:map-<script>|
    --
    vuman73-p183
    }}}
Making mappings local to a specific Buffer (?? (!!*******) SSSS) @(@)
{{{
    the <buffer> keyword
      |:map-<buffer>|
    --
    vuman73-p183
    }}}
making new mapping fail wh. it alr. exists ((!**) SS) @
{{{
    the <unique>-keyword
      |:map-<unique>|
    --
    vuman73-p183
    }}}
[make the f7-key do nothing(!)] (@)
{{{
    :map <F7> <Nop>| map! <F7> <Nop>
    --
    vuman73-p183
    }}}
    ----


evince -p 183 ~/Empire/Doks/Comp/editor/vim/vim_user_manual.pdf &


180 - Make New Commands  maps, cline commands, aucommands
  p184 --
    defining new cline-commands
        :command   (+=shortening, completion, 
        (must start w. Cap.letter(!)
        (list u-defined cmds)
    ex:  :command -nargs=0 DeleteFirst 1delete  (=effectively runs  :1d )
    the <args>-keyword,  <q-args>,  <f-args>
        :command -nargs=* DoIt :call AFunction(<f-args>)
        :DoIt a b c
         (=executes :call AFunction("a", "b", "c") )
    Line Ranges (*)
    -count, -bang, -register, -complete(+type, -bar, -buffer,  <lt>
        |user-commands|
  p186 --
    AutoCommands
        eg. own function DateInsert(),  + :autocmd FileWritePre * call DateInsert()
        :autocmd [group] {events} {file_pattern} [nested] {command}
    Events (=like BufReadPost)
        TODO: CHECK AND SORT REFLIST FOR AUCMD-EVENTS (****!!!!!!)
            (= |autocmd-events| )
    Ex.
        :autocmd BufReadPost *.gsm set filetype=asm
        :autocmd Filetype text source ~/.vim/abbrevs.vim
        :autocmd BufNewFile *.[ch] 0read ~/skeletons/skel.c
    file wildcards
        *  ?  [abc]  a{b,c} (=matches ab and ac)
        (+absol.|relative paths)
    managing aucmds **
        deleting, listing(**), Grouping
        nested  (=triggering nested) *
    trigger aucmds w. other au.cmds
        expand()  +  <afile>
    :autocmd BufReadPost *.chg execute "normal ONew entry:\<Esc>" |
            \ 1read !date   [SSSS(!)]
    When you want the autocommand do something complicated, which involves jumping around in the file and then returning to the original position,
        |restore-position|
    ('eventignore')
190 - VimScripts (*!)
        218 - filetype plugin
        221 - compiler plugins
          quickload plugins
          +writing library scripts (*)
225 - new menus  (=incl. popup menu)
231 - using filetypes
234 - make syntax highlighting
245 - Select y. Language
        249 - enter langtext + keymaps **
 251 - installing vim



    }}}
    [practvim (+hardway??)]  ~/Dropbox/rsc/data/lists/learnqna/vanki/vim2021.twothirds.tagged/vim-practhardw.20211118-1115_practdone.txt {{{


Vim Pract (**)  Vankilist 1 **(*)  TODO: TRANSLATE TO ENG. (!!!!)
___vimpract1

    ----
Two recommended Vim-plugins (**) (+ev. 1) @
{{{
    visualstar.vim
    Qargs.vim
    (+ev. Kana Natsuno =textobj-entire) (ie, ae)
    }}}
Vim-Golf Tie breaker: Which command wins?
{{{
    'Which is most repeatable (=eg. 'daw') **(*!)
    }}}
    ----

    ----
mer info om omaps @
{{{
    :h map-operator
    }}}
mer info om att skapa egna motions @@
{{{
    :h omap-info
    }}}
    ----

    ----
små hakcitat-tecken / 1/2 m. c-k () @
{{{
    c-k >> / 12
    }}}
(drews tips för py-redigering  (=tabstops and indenting @@
{{{
    :set softtabstop=4 shiftwidth=4 expandtab (+se vimcasts: tabs and spaces))
    }}}
    ----

    ----
Select html-tags/it's content (**!) @@(@)
{{{
    vat / vit
    }}}
Shouty Case för innehåll i html-tag **(*) @
{{{
    gUit (***!)
    }}}
lägg till buffer utan att gå till @@(@)
{{{
    :badd fil (+:bd =ta bort)
    }}}
    ----

    ----
Exempel: Operera på inre del av <html>-block ***** @@ @@ @
{{{
    /<html>/+1 osv *****
    }}}
kopiera nuv. rad till slutet av filen (m. ex) **(**) @@ @@ @
{{{
    :t$
    }}}
kopiera v-sel. till start filen (m. ex) **(*) @@ @@
{{{
    :'<,'>t0
    }}}
Fördel m. copy mm. fr. Ex (***) @@ @
{{{
    Använder ej reg. (=skriver ej över) **
    }}}
Gör om senaste (=.) på hel range (!!)******** @@ @@ @@ @
{{{
    Range/Adress(t.ex. med v-select) + :'<,'>normal .  *********
    }}}
Kör makro q på nuv. rad **(*) @
{{{
    :norm @q
    }}}
    ----

    ----
Kör makro på rader (ev. mellan radnummer) som matchar sökkriterium ********** @@ @@
{{{
    :1,30g/sök/normal @q  (+move/copy $ mm/o.likn) *********
    }}}
define tab completion behav. for custom ex-commands (*) (@)
{{{
    :h command complete
    }}}
Styra tab-completion_behav. i vim **(*) @
{{{
    :set wildmode  (89t/67d)  (=longest, list, full mm)
    }}}
Subst.exemplet m. stjärna, förra sökmönstret + c-r c-w (***(*)) @@ @@ @@
{{{
    (90t/68d): asterisk + ändra ord, Subst (m. 'samma mönster som förra), +c-r c-w =hämta ändrade ordet till subst-kommandot (****)
    }}}
sök c-mode c-r c-w i help (*) (@)
{{{
    :h c_CTRL-R_CTRL-W
    }}}
    ----

    ----
Sätt så kan anv. c-n/c-p med filtrering i commandline history * @@ @
{{{
    cnoremap <C-p> <Up>
    cnoremap <C-n> <Down>
    (92t/70d) (**)
    }}}
help-post för the commandline window (*) @
{{{
    :h cmdwin
    }}}
Öppna commandline win fr. commandline (****) @@
{{{
    c-f
    }}}
provfiltrera text vs filtrera text (=som sed vs sed -i) **(*) @(@)
{{{
    :r !cmd och movem!cmd **(*)  vs :w !cmd
 =  :w !cmd  :r !cmd  :range!cmd
    }}}
    ----

    ----
kör alla rader i filen med bash (=från/med vim) ****! @@
{{{
    :w !sh  ****
    }}}
Exempel: Sortera kontaktinfo-lista (=på andra fältet) **(**) @
{{{
    :2.$!sort -t',' -k2
    (96t/74d)
    }}}
styra var :read matar in inläst text (**) @(@)
{{{
    below cursor line
    or use eg :0read (??)
    (97t/75d) (++se mer)
    }}}
    ----


    ----
Hur spe=car man filer för args-listan (=format)? @
{{{
    :args filnamn / wildcards / output fr. skalkommandon (mm) (s103 tel-pdf / s81 data-pdf)
    }}}
Hitta ALLA txt-filer i ALLA undermappar (=till args-listan) ***********!!!  @@
{{{
    **/*.txt
    doc**/*.gz
           (el. ??) *****(!)
           (t.ex. :args **/*.txt )
    }}}
(mer info om **-wildcard (@)
{{{
    starstar-wildcard
    }}}
tips/fördelar m. args-list @
{{{
    går att speca ordning (**)
    }}}
args-list: all js|css-files ** @@ @@
{{{
    :args **/*.js **/*.css 
    }}}
Exemplet: Öppna Boks kapitelfiler i ordning med args(***) @@ @@
{{{
    :args `cat bchapts.txt`
    s 104 tel-pdf / s 82 data-pdf (**)   + (248t/234d)
    }}}
populate argslist w. all js and css files recursively below in dir. ***** @@(@@)@@
{{{
    :args **/*.js **/*.css
    }}}
    ----

    ----
Split-kommando: Stäng alla fönster utom nuvarande (**) @
{{{
    c-w o (**)
    }}}
    ----

    ----
Gå till annan mapp för ALLA fönster/splits i viss Tab (**(*)) @
{{{
    :windo lcd dir  (**(*))
    }}}
flytta fönster/split till egen Tab (**) (@)
{{{
    c-w T  (=stort t??)
    }}}
Stäng alla tabs utom nuvarande (**(*)) (@)
{{{
    :tabonly
    }}}
siffror för :tabmove (*) @@(@)
{{{
    start=0 nr2=1  bara :tabmove =till slutet (**)
    }}}
på kommandoraden: Expandera dir-namn från aktiva filens path (=*******!!!!) @(@)
{{{
    :e %:h<Tab>
    }}}
Map-förslaget för %:h (*) (@)
{{{
    cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
      .
    s117 tel-pdf / s 95 data-pdf (**)
    }}}
    ----

    ----
Plocka/Ge värde för variabel, t.ex. %:h =på komm.raden/m. vimscript (***(*)) @@
{{{
    expand('%:h')   (=t.ex.  :echo expand(testvar)
    }}}
Lägg till sökväg (=för mapp app/ (+undermappar)), så kan använda :find (****!) @ @
{{{
    :set path+=app/**  (+90% with vim, tips 1)
    }}}
helppost för :find, paths mm (**) (@)
{{{
    file-searching
    }}}
    ----

    ----
Öppna aktiv fils mapp (=m. netrw) ****(**!) (@)
{{{
    :e %:h  :Exp (**)    :Sex :Vex :Tex  **(*)  =s 120 tel-pdf / s 99 data-pdf
    }}}
ny fil, ny dir, sudda obj. (=i netrw) (**) (@)
{{{
    %, d, del
    }}}
(Skapa mapp för ny startad fil (=m. icke-exist. dir) ** (@)
{{{
    :!mkdir -p %:h
    }}}
skriv till rotägd fil m. sudo (**) @
{{{
    :w !sudo tee % > /dev/null
    s 124 tel-pdf / s103 data-pdf
    }}}
    ----

    ----
"missade" textobjekten 8) (@)
{{{
    i`  is (***!)
    }}}
marks/jumps: tillbaks till Pos. för senaste ändring (**!) (@)
{{{
    ˋ.
    }}}
marks/jumps: tillbaks till Pos. för senaste Insertionmode-stopp (**!) (@)
{{{
    ˋˆ
    }}}
    ----

    ----
Hoppa mellan matchande parenteser o klamrar, XML-tags och äv. nyckelord i vissa progr.språk (******!!!) (@)
{{{
    %  +matchit.vim (146t/124d)
    }}}
Exempelanv. matchit.vim. i Html-fil (**) (@)
{{{
    hoppa mellan start/slut-tags (**!)
    }}}
omge markering m. t.ex. " @
{{{
    surround.vim (148t/126d)
    }}}
    ----

    ----
visa changelist (@)
{{{
    :changes
    }}}
punkt o tom sträng i path står för dirs _ (@)
{{{
    active file's dir, wdir
    }}}
visa värde för path-variabeln (=för find mm) (**(*)) (@)
{{{
    :set path?
    }}}
    ----


    ----
Fördelen m. Global marks framför c-o, c-o osv (****!) @(@)
{{{
    =t.ex. sätt innan dyker ner i projekts underfiler + hoppa tillbaks med ETT(!) steg/kommando (= t.ex. `M) (156t/138d)
    }}}
Hitta/Visa alla filer matchande 'fooBar' =neråt i trädet ****! @@ @@
{{{
    :vimgrep /fooBar/ ** (156t/138d)
    }}}
Tips på kommandon där bra att först sätta Global mark innan kör (**(*)) @
{{{
    :grep, :vimgrep, :make + buf/args-kommandon (=args, argdo mm/o.likn.) (156t/138d)
    }}}
sudda nuv. rad till register c (=fr. kommandoraden) (**(*!)) @
{{{
    :delete c
    }}}
    ----

    ----
namn på beräknings-register + helppost (@)
{{{
    the expression register + :h quote=
    }}}
Vad kan beräknas i vims "=-register? (******!!!) @@
{{{
    Vimscript Expressions (=!!!!*****)
    }}}
    ----

    ----
Kör makro på (sammanh.) rader 'an parallel'(***) (=äv. om innehåller felande rad (=kan inte bara köra 999@a) (***) @
{{{
    t.ex.(!)  :'<,'>normal @a  (=gärna m. t.ex. !ip (för att skapa val))  (184t/167d)
    }}}
Automatiskt sätta options för progr.språk =t.ex. Ruby (@)
{{{
    (187t/170d)  (setlocal ts=2 sts=2 sw=2 expandtab)  (=tabstop, softtabstop, shiftwidth)
    }}}
Kör ändring (=med makro, t.ex. s/replace) på flera filer i en lista (****!) @@(@)
{{{
    =starta i vim m. :args *.rb (el. likn.), kolla att 'hidden' (o annat relevant) är satt, +kör inspelad ändr. med :argdo normal @a  (el. 99@a om tatt med :next på slut av makrot)  (187-188t/170-171d)
    }}}
fördel m. :argdo normal @a  vs  99@a (=för ändring i hel lista m. filer) (*) (@)
{{{
    :argdo (='run in parallel' stoppar inte i en fil om fel påträffas där (!/*)  =kör snabbare, men(!!) svårare att se fel (=99@a stoppar i filen med felet (**))
    }}}
    ----

    ----
(spara ändringar till flera filer i args-list mm (*) (@)
{{{
    :wnext (inspektera individuellt) ,  :wall (=skriv alla(!) filer i bufferlist) )
    }}}
Kolla värdet på variabel 'Var' **(*) @@
{{{
    i-mode: c-r= Var<CR>  (**)
    }}}
(exempel: lista m. stigande nummer (=med "=-register o mini-vimscript) ** @(@)
{{{
    "=-register + Vars (i) +  :let i += 1  (+ev. kör m.  :'<,'>normal @q  (??))  (192t/175d)
    }}}
(te: vad betyder/ger c-[ ? (@)
{{{
    =ger ^[-tecknet (=escape(**)) )
    }}}
(skillnad/fördel :put a jmf. med "ap @@(@)
{{{
    :put a klistrar in "a nedanför nuvarande raden, även om innehåller kortare sträng) *
    }}}
REDIGERA INNEHÅLL I REG. 'a' FR. EX/MED VIMSCRIPT (*****!!) @
{{{
    :let @a=substitute(@a, '\~', 'g')  (=i reg. a, sök '~', ersätt med, global) *****!
    }}}
Lista/Förteckning tillgängliga ex-funktioner (=som substitute() ) i Vim (****!) @
{{{
    :h function-list
    }}}
    ----

    ----
Annat sätt att söka 'case sensitive' för enstaka sökningar (***(*!)) (@)
{{{
    :set smartcase (** =ta med Versal, så tolkas strängen 'ci') **  (=anv. ev./gärna(?) tills. med ignorecase (**)) (++ se också infercase(!!) (287/276))
    }}}
Regex: Sök Hexsträng (=csscolor) m. antingen 6 el. 3 siffror efter # (**) @@(@)
{{{
    /\v#(\x{6}|\x{3})  (**) (el. 0-9a-fA-F)
    }}}
namn på regexläget för \V (??) (@)
{{{
    very nomagic  (??)
    }}}
    ----

    ----
regex: söka även specialtecken som bokstavl. sträng (t.ex. 'a.k.a') (=liknar raw-strings i python (****)) @(@)
{{{
    \V (=very nomagic-läget) (**)
    }}}
Sök dubblerat ord (+ev. över två rader**) **** @@(@)
{{{
    /\v<(\w+)\_s+\1  #=inkluderar 'blank or newline' **!
    }}}
Tips användning dubblering av sökmönster ( (orig) .... \1  o.likn.) (**) (@)
{{{
    Matcha par av XML/HTML-tags (**)
    }}}
regex: Icke-fångande parenteser =om t.ex. har många + anv. nån för gruppering: (And|D)rew @@
{{{
    %(And|D)rew
    }}}
    ----

    ----
Icke-fångande parenteser-exemplet =byt plats på Förnamn / Efternamn för både(!) Drew och Andrew Neill (***!) @@(@@)
{{{
    /\v(%(And|D)rew) (Neil)
    :%s//\2, \1/g
    (206t/191d)
    }}}
lilla \zs- // \ze-exemplet: matcha "-sträng + INOM(!) "-sträng (**!) @@(@)
{{{
    /\v"\zs[^"]+\ze"
    /\v"@<=[^"]+"@=
    (208t/193d)  (+ "[^"]+" -idiomet (**)
    }}}
Söka efter url mm/o.likn (**) @
{{{
    /\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\
    (210t/194d)  (+strängen avslutas m. två backslashes =sökningen måste sluta '\\\\'(!))
    }}}
Utför \escapes (t.ex. i "u) med Vimscript-funktion (**!) @@@ @@@
{{{
    =escape(@u, getcmdtype().'\')
    escape(@u, 'tecken att \-a')  (211t/196d)  (+kör med "= när ska matas in i sökfältet (!!!!))
    }}}
 map för 'bygg in nohlsearch i c-l_clearing' (**) @@
{{{
    nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>
    (216t/202d)  (=inkluderar <silent> och :<C-u> ) (=semer)
    }}}
AUTOCOMPL: Vid sökpreview (=med incsearch på) =Slutför ord i sökrutan enligt aktiv preview (****!!) @@ @@ @(@)
{{{
    /sökn<C-r><C-w>  (=slutför till 'sökning' i sökrutan, om det ordet är aktivt som preview) ****!  (+OBS: bäst för ordsök (=om \v är inkluderat kan ord ev. dubbleras (!/?)))
    }}}
    ----

    ----
Tips: Snabbersätt alla (eller vissa) 'lang' i ett dok m. 'language' (**) @(@)
{{{
    Sökn. + offset ( /lang/e ) + a uage<Esc>  (**)
    }}}
UTFÖR HANDL. (=gemener till versaler) PÅ SÖK-MATCH (=t.ex. Xml och Xhtml) (****!) ??????? (@)
{{{
    Sökn (med ()? )  +  gU//e<CR>  +  .  (****!)  #obs: måste repeteras med  //<CR>  (=måste köras från match-start (**/!))
    }}}
litet snabbtips: ersätt [^']-konstruktion m. '( )' runt (***!) @(@)
{{{
    markör på första [ + c% ( c-r " ) Esc  (***)
    }}}
    ----

    ----
Funktion/Vimscript: Sätt så * söker v-selected text (***!) (@)
{{{
    (329t/213d)  = +/el. installera visual-star.vim (**!)
    }}}
tips: något som går att använda i ersättningsfältet för :s (****!) @
{{{
    =köra/utvärdera vimscript expressions i ersättningsfältet (*****!!!)
    }}}
:s  &-flaggan (***!) @
{{{
    =använd samma flaggor (t.ex. gc) som för förra/senast körda :s-kommandot
    }}}
Utvärdera vimscript expression i ersättnings-strängen (**) @@ @@ @
{{{
    \={vimscript expr} i ers.strängen (**!)
    }}}
    ----

    ----
Vimscr. i :s ersättn.fält: Ersätt senaste sökn. med text (=multiline) i yank-register (*****!!) @@ @@ @@ @
{{{
    :%s//\=@0/g  (****!!)
    }}}
sätt /-reg till strängen Pragmatic Vim (*) (@)
{{{
    :let @/='Pragmatic Vim'
    }}}
 ev: Sök/ersättn.tricket (=med 'förra sök' + 'utvärdera innehåll i reg. a') + 'Återanvänd' @@
{{{
    :%s//\=@a/g
    (238t/224d)
    }}}
Kör senaste :s (=körd på enbart en rad) på hela filen (**!) @@(@) @@
{{{
    g&  //  :%s//~/&
    }}}
Kör senaste :s  m. samma sök/ersätt + flaggor MEN(!!) på annan range (****!!) @@(@) @@
{{{
    :&&  (=t.ex. :'<,'>&&   :%&&  (=samma som  g& ) ****!
    }}}
vad gör kommandot :&&  ? @(@)
{{{
    kör förra sök/ersätt + med samma flaggor  enbart(!!) på nuv. raden (**!)
    }}}
    ----

    ----
Tips: Skapa map som sätter & (=:s utan(!!) förra flaggorna) till :&&  =som förra med samma flaggor (+visual-variant) (****!!) @(@)
{{{
    nnoremap & :&&<CR>   xnoremap & :&&<CR>
    }}}
:s + Vimscript i ersättn-sträng: Förskjut alla rubrik-tags i html upp en (2-1 osv) ****!! @@ @@ @@ @
{{{
    /\v\<\/?h\zs\d
    :%s//\=submatch(0)-1/g
    (=sökmönster "siffra efter h") + utvärdera submatch() med \=  (****)  (243-244t/229d)
    }}}
Use vimscript dictionary to swap places of two words (**) (=dog / man  etc) @@ @@ @@ @
{{{
    :let swapper={"dog":"man","man":"dog"}
    :echo swapper["dog"]
    man
    :echo swapper["man"]
    dog
      .
    /\v(<man>|<dog>)
    :%s//\={"dog":"man","man":"dog"}[submatch(1)]/g
    (245t/231d)
    }}}
vimscript dictionaries: referera post (t.ex. man, ger dog) (@)
{{{
    dictnamn["man"]  #dictnamn = variabelnamn
    }}}
Använd Vimgrep =bygga (qf)-lista, bara för filer som matchar sök-sträng (=slippa köra ersätt för alla filer i proj.dir som inte innehåller söksträng(!/**) @@(@)
{{{
    vimgrep /mönstret/ **/*.txt  (249t/235d)
    }}}
öppna senaste quickfix-fönstret (=t.ex. efter att ha kört vimgrep (**)) (@)
{{{
    :copen
    }}}
Vimscript: Skapa kommando(=Qargs) ist. för saknade 'quickfixdo' (****) (@@)
{{{
    /Pragmatic\ze Vim
    :vimgrep /<C-r>// **/*.txt
      .
    (249t/235d)  (=kopierar alla b-nummer(??) för alla matchande filer i vimgrep-sök (t.ex.) till :args-lista (**) (=kan sen köra :argdo  + därefter :update)
      .
    substitution/qargs.vim
      .
    command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
    function! QuickfixFilenames()
      let buffer_numbers = {}
      for quickfix_item in getqflist()
        let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
      endfor
      return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
    endfunction
    }}}
    ----


    ----
:g! (**) (@)
{{{
    eller :vglobal / :v  =kör kommando på alla rader som inte(!!) matchar mönster(!)
    }}}
Kopiera alla rader m. texten 'TODO' till reg a (****!) @@(@) @@
{{{
    :g/TODO/yank A  ***
    }}}
kopiera TODO-rader fr. flera filer till reg x (****) @
{{{
    :g + :bufdo/:argdo  (255t/243d)  +'se tips 96 på s233'  (**)
    }}}
(om en fil:) kopiera TODO-rader till slutet av filen (*) @
{{{
    :g/TODO/t$
    }}}
SORTERA(=ALFABETISKT) CSS =SEPARAT INNE I VARJE {-BLOCK (*******!!!!!!!) @@ @@ @@ @@
{{{
    :g/{/ .+1,/}/-1 sort  (257-259t/243-245d)
    }}}
Indentera alla rader inne i CSS-blocken (='local' offsets, m. global) (******!!) @@ @@ @@ @@(@)
{{{
g/^[^ {].*@/sil .,/}}/ yank A
    :g/{/sil .+1,/}/-1 >   #OBS! =Behöver använda sil(ent)  eftersom > annars ekar varje action (**)  (259t/245d)
    }}}
    ----

    ----
tips: javascript-variant för ctags (*) @
{{{
    jsctags (=doctor js)
    }}}
kolla option tags i vim (=var vim letar efter ctags-filer) * (@)
{{{
    :set tags?
    }}}
några tips ctags/cscope (**) (@)
{{{
    kör återkommande för att hålla kodbasen uppdaterad,
     (=ev.) ha global fil för ett projekt i dess rotmapp
     (+behöver man lägga till något i option 'tags' då??)
   lägg till tagsfiler i (git)ignore(!)
    }}}
Generera tagsfil i Projektmapp (***) @@(@)
{{{
    (=från inne i vim) 
    :!ctags -R  (265t/253d)
      +tips: skapa ev. mapping 
      =nästa sida (**!)
    }}}
Sätt så ctags -R körs automatiskt, varje gång sparar fil (**(**)) @@(@@)
{{{
    :autocmd BufWritePost * call system("ctags -R")  (265t/253d)
    }}}
    ----

    ----
Sätt så ctags-filer för projekten uppdateras automatiskt, när projektet uppdateras i git (=post-commit mm mm) (**(*)) (@)
{{{
    semer "Effortless Ctags with Git"  (265t/253d)  (verkar vara det föredragna tipset
    }}}
Hoppa tillbaks efter c-]_hopp (*****!!) @
{{{
    c-t  #'acts as our back button for our tag history'  (=:h tag-stack)
    }}}
Hoppa till def.ställe för Funktion =om flera(!!) matchande tags (****!) @@(@)
{{{
    g c-] / g csg-ö (**)  (=visar lista +kan välja med nummer till vilken tag-def man vill hoppa)
    }}}
visa matchlista för tagshopp =om körde c-], men flera matchande @@
{{{
    :tselect
    }}}
hoppa till nästa matchande för c-] =om flera matchande @
{{{
    :tnext  (+:tprev  mm mm  + unimpaired (**))
    }}}
exkommando-var för c-] (**) @(@)
{{{
    :tag {keyword}
    }}}
exkommando-var för g c-] (**) @
{{{
    :tjump {keyword}
    }}}
 KOMPLETT TABELL/LISTA TAGHOPPS-KOMMANDON (****) (=se mer + plocka ev. in fler) (**) (@@)
{{{
    (269t/257d)
    }}}
    ----

    ----
Kompilera c-program i Vim (**!) @(@)
{{{
    make (=i skal)  el.  :make  (+vim öppnar qf-listan)
    }}}
kör make utan att hoppa till första felmedd. @
{{{
    make!
    }}}
hoppa tillbaks (=om kört :make =hoppat till första felmedd.) (@)
{{{
    c-o
    }}}
Program som genererar output till qf/loc-lists (**) (@@)
{{{
    :grep, :vimgrep, :make (**)
    }}}
lista kommandon för att navigera qf-listan (@)
{{{
    :h quickfix
    }}}
Loc-list vars av qf-list_kommandon @
{{{
    :lnext, :lnfile, :ll N,  :lopen, :lclose
    }}}
    ----

    ----
Kör :grep, :vimgrep el. :make med Loclist (=ist.för qf-list) (***(*)) (@)
{{{
    :lmake, :lgrep, :lvimgrep
    }}}
Skillnad mellan qf- och loc-lists (=i omfång) @@(@)
{{{
    loc är bunden till ett indiv. fönster (=kan ha många öppna samtidigt) ,  qf är global för vim (**)
    }}}
5 punkter/poster framåt i qf-listan @
{{{
    :5cnext
    }}}
stäng qf-listan (=om fokus i annat fönster) (@)
{{{
    :cclose
    }}}
hoppa tillbaks/fram mellan gamla qf-listor (**) @
{{{
    :colder  /  :cnewer
    }}}
tips :colder mm @
{{{
    'instead of repeating a :make/:grep command,
    we could pull up the results from the last time it was executed'
        (=bra om tar lång tid att köra mm) (**)  (276t/265d)
    }}}
Customize the compiler (t.ex./= Kör js-fil genom JSLint) @(@)
{{{
    först npm + nodelint (*)
      (=makeprg  (277t/266d)
    }}}
    ----

    ----
visa/lista compiler-plugins installerade för vim @(@)
{{{
    :args $VIMRUNTIME/compiler/*.vim
    }}}
Vims defin. av 'compiler' (*) (@)
{{{
    =externt program som gör något med dok + genererar listor m. fel o varningar  (=se t.ex. latex o lilypond (**))  (279t/268d)
    }}}
Customize the grep wrapper progr. (*) (@)
{{{
    grepprg  +  grepformat  (282t/271d)
    }}}
kör ack, ag mm med vim-regex(/flera progr. samexisterar(??)) @@(@)
{{{
    Ack.vim (+fugitive.vim)  (284t/273d)  (=We can have several greps installed, and use the best suited for a certain task)
    }}}
    ----


    ----
Grundsyntax vimgrep (*(*)) @(@)
{{{
    :vimgrep /pattern/ FILER(**)
    }}}
vimgrep: hoppa ej till första match(**) @@(@)
{{{
    :vimgrep /patt/j
    }}}
vimgrep: matcha patt. i fil i specad mapp (eller undermappar) (***) @
{{{
    :vimg /patt/ **
    }}}
vimgrep: Matcha patt. i filerna i Argslistan (******!!!!) @@ @@ @@ @
{{{
    ##
    }}}
Tips för vimgrep (**) @@
{{{
    Sök först m. '/' för att sätta mönster,, klistra sen in i vimgrep-sök ( :vim / c-r/ / **
    }}}
aucompl: tips för aucompl. när har 'ignorecase' satt (*) @@ @@ @(@)
{{{
    :set infercase  (=gör att man kan undvika 'stampa m. fel skiftesläge' för ett ord)  (287/276)
    }}}
    ----

    ----
helppost om vims alla/olika aucompl:s (**) (@)
{{{
    :h ins-completion
    }}}
aucompl, grund(*): keywords enbart från nuv. fil (*) (@)
{{{
    c-x c-n
    }}}
aucompl, grund(*): slutför tags (=tags file keywords(**)) @
{{{
    c-x c-]  (c-x csg-ö)
    }}}
aucompl, grund(*): ord från dictionaries/spelling files(? =custom/special-filer ??)(*) (@@)
{{{
    c-x c-k
    }}}
info/helppost om completion-menyn i vim (*) (@)
{{{
    :h popupmenu-completion
    }}}
aucompl, grund(*****!): Gå ur popupmenyn m. förslag (=tillbaks/fortsätt skriv**) ((@)
{{{
    c-e // skriv in fler tecken efter startordet (**)
    }}}
    ----

    ----
aucompl, grund(*): mata in ordet kommit fram till m. c-n/c-p (el. upp/ner) (@)
{{{
    <CR> // c-y
    }}}
(aucompl: skillnad mellan anv. c-n/p och upp/ner för navigering förslagslistan (!) @(@)
{{{
    c-n/p uppdaterar dokumentet direkt (=avsluta menyn genom att bara börja skriva igen), medan upp/ner bara navigerar listan + <CR> / c-y för att mata in valda ordet (!)
    }}}
aucompl(*****): UPPDATERA/MINSKA NER LISTAN MEDAN SKRIVER IN MER AV ORDET (!!*****) @@ @@ @@ @
{{{
    =Skriv startord + 'Gå tillbaks till startordet' (=c-n c-p  /  c-p c-n)  +fortsätt skriv =minskar ner listan i realtid efter vidare infon ****
    }}}
aucompl: UPPDATERA SPECIALLISTA (T.EX. OMNICOMPLETION(, THESAURUS??), FILENAMECOMPL, LINEW-COMPL. MM) I VIM (********!!!!!) @@ @@ @(@)
{{{
    exempel för omni: c-x c-o c-p  =starta omni, tillbaks till startordet, +fortsätt skriv kokar ner listan  i realtid (**)
    }}}
aucompl: uppdatera/kolla så vim förstår fler typer av includes än C @(@)
{{{
    :h 'include'  (=option)  (obs! funkar redan för python o många andra välkända program)
    }}}
    ----

    ----
aucompl: Ställ in var c-n / c-p letar efter ord (=buffers, included mm) =ta bort "included" @@ @@ @@(@)
{{{
    :set complete-=i  (default är .,w,b,u,t,i)
    }}}
aucompl: Lägg till spelling/dictionary-completion i c-n (=standard)completion (*) @@
{{{
    :set complete+=k
    }}}
aucompl: kolla help =vad olika flaggor i 'complete'-option gör (w t.ex.) (@)
{{{
    :h complete
    }}}
aucompl: Grund/Förklaring av vad dictionary (=c-x c-k) aucompl gör (**!) (@)
{{{
    =När ordet man vill infoga inte(!!) finns i någon av ens öppnade eller kopplade filer (=buffers, included mm)
    }}}
aucompl: helppost för vims dictionary completion (@)
{{{
    :h compl-dictionary
    }}}
aucompl: Slutför ord med dictionary =i vims spell-läge (***!) @@ @@(@) @
{{{
    :set spell  +  c-x c-k (**)
    }}}
    ----

    ----
aucompl: tips/not för whole line completion (@)
{{{
    =w.l.au. bortser från indentering i början på rad
    }}}
(aucompl: =viktig första grundinställning för att vims omnicompl. ska fungera (@)
{{{
    filetype plugin on  #=o.c. är implementerad som file-type plugin
    }}}
aucompl: Full lista språk som stöds för omnicompl. i vim ((*)) @(@)
{{{
    :h compl-omni-filetypes  (+se egna tidigare sammanställd lista i vim.orig.txt(?))
    }}}
aucompl: tillägg för att förbättra visst språks omnicompl. i vim (*) @
{{{
    hämta bättre plugin / skriv egen (= :h complete-functions)
    }}}
    ----

    ----
(spellch: vad kallas flaggningen för ett felstavat ord? (=vims funktion/terminologi) (@)
{{{
    SpellBad)
    }}}
spellch: Hoppa till nästa/förra Felstavade ord (*****!!) @@ @@
{{{
    ]s  [s
    }}}
spellch: Visa lista m. förslag för Felstavat ord (**!) @@ @@
{{{
    z=  (+t.ex. 3 Enter)
    }}}
spellch: (Lägg till felstavat ord som korrekt i stavningsordlistan) @@(@)
{{{
    zg
    }}}
spellch: Ta bort ord under markören från stavningsordlistan @@(@)
{{{
    zw
    }}}
    ----

    ----
spellch: Undo för ta bort/lägg till felstavat ord (=som korrekt) fr. stavningsordlistan (**!) @
{{{
    zug
    }}}
spellch: Sätt/Tillåt enbart amer. eng. spellings (*(*)) (@)
{{{
    :set spell spelllang=en_us  (+can, au mm)  (300/289)
    }}}
spellch Drew-tip: En/Flera special-filer m. t.ex. vimkommandon + ange som extra spellfiles (=special-ord/terminologi dyker inte hela tiden upp som felstavningar) *****/!!! @@ @@(@)
{{{
    setlocal + spellfile+=~/books/.......  (302/291) *****
    (=filen kan ligga där man vill
       (=egna home, drop, annan hårddisk mm)**
    }}}
spellch: Lägga till ord som felstavat i standard-spelldict / egna custom indragen (=två att välja mellan) (**) @@ @@(@)
{{{
    1zg  eller  2zg (**(*))
    }}}
spellch: Fixa stavfel(/=få stavningsförslag för ord) direkt i/från insert-mode(**) (***!!) @@
{{{
    c-x s  /  c-x c-s
    }}}
    ----

    ----
spellch: FIXA 2 STAVFEL PÅ RAD PÅ EN GÅNG (=FRÅN INSERTMODE) @@(@)
{{{
    Pekaren på slutet(!) av raden + c-x s två(!) gånger (???)  =testa/semer  (**)  (303/292)
    }}}
inställn: helppost/lista över vims options (@)
{{{
    :h option-list
    }}}
inställn: Återställ option till sitt grund/utgångsvärde (**!) @@(@)
{{{
    :set option&
    }}}
inställn: Referera till option som variabel (=värde) (**/?) @@ @@ @
{{{
    :echo expand(&option) ???
    }}}
    ----

    ----
inställn: TIPS OPTIONS (**) (@)
{{{
    Sätt flera options på samma rad  (=
    :set spell spelllang=en
    :set s(t)s=2 sw=2 ts=2 et
    }}}
inställn: tips Drew N mm options (**) (@)
{{{
    kortnamn för snabba direkta inställn. när redigerar
    + långoptions i vimrc, skript mm (**!)
    }}}
inställn: Sätt lokala inställn. (=för flera buffers/fönster) **** ((@)
{{{
    :bufdo setlocal tabstop=4
    :windo setlocal number
    }}}
inställn: kör ladda vimrc, om är aktiva filen (*!) (@)
{{{
    :so %
    }}}
inställn: Inställningar per filtyp (=ol. inställn. för JS, Python, Ruby, Java mm) (*****) @@(@)
{{{
    autocmd +
    FileType +
    setlocal  (+buffer)
      + värden mm  (=se mer (309/298)) **
    }}}
inställn: +Tips Inställningar per filtyp (=JS, Python, Ruby, Java mm) (***) @@
{{{
    Går att sätta flera rader/aucmd:s per språk/filtyp (=kan tillfoga t.ex.
      autocmd FileType javascript compiler nodelint
    enkelt som extra rad för tidigare grundexempel m. ts=4 mm) ****(***)
    }}}
inställn: Alternativt sätt att sätta inställn. för speciell filtyp (=blir för rörigt m. mängd extra autocmd-rader i vimrc) (##/!!**) @@
{{{
    lägg t.ex. javascript.vim som ~/.vim/after/ftplugin/javascript.vim  (=??/**)  (=semer  (309/298) *****)   + :h ftplugin-name    (+kräver förstås  filetype plugin on )
    }}}
    ----


    }}}
    [excmds-vimfuncts]  ~/Dropbox/rsc/data/lists/learnqna/vanki/vim2021.twothirds.tagged/vim-practhardw.ExFuncts20211120-1500.txt {{{



___vimexfunc_excmds  (:h index)

    ----
:# (@)
{{{
    same as ":number"
    }}}
:= (@)
{{{
    print the cursor line number
    }}}
:@
{{{
    execute contents of a register
    }}}
:@@
{{{
    repeat the previous ":@"
    }}}
:append @(@)
{{{
    append text
    }}}
:all (@)
{{{
    open a window for each file in the argument list
    }}}
:argadd (@)
{{{
    add items to the argument list
    }}}
:argument (ssS @)
{{{
    go to specific file in the argument list
    }}}
:ascii ((@)
{{{
    print ascii value of character under the cursor
    }}}
    ----

    ----
:ball (@)
{{{
    open a window for each buffer in the buffer list
    }}}
:badd @
{{{
    add buffer to the buffer list
    }}}
:behave @@(@@))
{{{
    set mouse and selection behavior
    }}}
:bmodified @@
{{{
    go to next buffer in the buffer list that has been modified
    }}}
:break (@)
{{{
    break out of while loop
    }}}
:breakadd @(@)
{{{
    add a debugger breakpoint
    }}}
:breakdel (@)
{{{
    delete a debugger breakpoint
    }}}
:breaklist @
{{{
    list debugger breakpoints
    }}}
:buffers (@)
{{{
    list all files in the buffer list
    }}}
    ----

    ----
:change (@)
{{{
    replace a line or series of lines
    }}}
:cNext @
{{{
    go to previous error
    }}}
:cNfile @
{{{
    go to last error in previous file
    }}}
:cabove (@)
{{{
    go to error above current line
    }}}
:caddbuffer (@)
{{{
    add errors from buffer
    }}}
:caddexpr @
{{{
    add errors from expr
    }}}
    ----

    ----
:call @(@)
{{{
    call a function
    }}}
:cbottom (@)
{{{
    scroll to the bottom of the quickfix window
    }}}
:cbuffer (@)
{{{
    parse error messages and jump to first error
    }}}
:cc @
{{{
    go to specific error
    }}}
:cdo (@)
{{{
    execute command in each valid error list entry
    }}}
:cfdo (@)
{{{
    execute command in each file in error list
    }}}
:cexpr (@)
{{{
    read errors from expr and jump to first
    }}}
:cfile (@)
{{{
    read file with error messages and jump to first
    }}}
    ----

    ----
:changes (@)
{{{
    print the change list
    }}}
:checkpath (@)
{{{
    list included files
    }}}
:chistory @
{{{
    list the error lists
    }}}
:clist @
{{{
    list all errors
    }}}
{{{
    go to next error
    }}}
:cnewer @(@)
{{{
    go to newer error list
    }}}
:cnfile (@)
{{{
    go to first error in next file
    }}}
:copy (!@)
{{{
    copy lines
    }}}
    ----

    ----
:command @
{{{
    create user-defined command
    }}}
:confirm (@)
{{{
    prompt user when confirmation required
    }}}
:const @
{{{
    create a variable as a constant
    }}}
:cquit (@)
{{{
    quit Vim with an error code
    }}}
:cscope (@)
{{{
    execute cscope command
    }}}
:cstag (@)
{{{
    use cscope to jump to a tag
    }}}
    ----

    ----
:delmarks (@)
{{{
    delete marks
    }}}
:debug @
{{{
    run a command in debugging mode
    }}}
:delfunction (@)
{{{
    delete a user function
    }}}
:diffget @
{{{
    remove differences in current buffer
    }}}
:diffpatch @
{{{
    apply a patch and show differences
    }}}
:diffthis (@)
{{{
    make current window a diff window
    }}}
:digraphs @(@)
{{{
    show or enter digraphs
    }}}
    ----

    ----
:djump (@)
{{{
    jump to #define
    }}}
:doautocmd @
{{{
    apply autocommands to current buffer
    }}}
:doautoall @(@)
{{{
    apply autocommands for all loaded buffers
    }}}
:dsplit (@)
{{{
    split window and jump to #define
    }}}
:echo (@)
{{{
    echoes the result of expressions
    }}}
:echoerr @
{{{
    like :echo, show like an error and use history
    }}}
:echohl (@)
{{{
    set highlighting for echo commands
    }}}
    ----

    ----
:echon (@)
{{{
    same as :echo, but without <EOL>
    }}}
:emenu (@)
{{{
    execute a menu by name
    }}}
:endtry (@)
{{{
    end previous :try
    }}}
:execute @@(@)
{{{
    execute result of expressions
    }}}
:exusage (@)
{{{
    overview of Ex commands
    }}}
:file (@@)
{{{
    show or set the current file name
    }}}
:filetype (@)
{{{
    switch file type detection on/off
    }}}
:filter @
{{{
    filter output of following command
    }}}
:finish (@)
{{{
    quit sourcing a Vim script
    }}}
    ----

    ----
:fold (@)
{{{
    create a fold
    }}}
:foldclose (@)
{{{
    close folds
    }}}
:folddoopen @(@)
{{{
    execute command on lines not in a closed fold
    }}}
:function @
{{{
    define a user function
    }}}
    ----

    ----
:goto ((@)
{{{
    go to byte in the buffer
    }}}
:grepadd (@)
{{{
    like :grep, but append to current list
    }}}
:helpfind (@@)
{{{
    dialog to open a help window
    }}}
:helptags ((@)
{{{
    generate help tags for a directory
    }}}
:ijump (@)
{{{
    jump to definition of identifier
    }}}
:k ((@)
{{{
    set a mark
    }}}
:keepmarks (@)
{{{
    following command keeps marks where they are
    }}}
:keepjumps @(@)
{{{
    following command keeps jumplist and marks
    }}}
:keeppatterns (@)
{{{
    following command keeps search pattern history
    }}}
    ----

    ----
:laddexpr (!@)
{{{
    add locations from expr
    }}}
:lbottom (@)
{{{
    scroll to the bottom of the location window
    }}}
:lbuffer (@)
{{{
    parse locations and jump to first location
    }}}
:lclose ((@)
{{{
    close location window
    }}}
:lcscope @(@)
{{{
    like ":cscope" but uses location list
    }}}
:ldo @
{{{
    execute command in valid location list entries
    }}}
:lfdo @(@)
{{{
    execute command in each file in location list
    }}}
:let (@)
{{{
    assign a value to a variable or option
    }}}
:lexpr @(@)
{{{
    read locations from expr and jump to first
    }}}
:lfile (@)
{{{
    read file with locations and jump to first
    }}}
:lgrep @@(@)
{{{
    run 'grepprg' and jump to first match
    }}}
:lgrepadd @(@)
{{{
    like :grep, but append to current list
    }}}
:lhelpgrep @@(@)
{{{
    like ":helpgrep" but uses location list
    }}}
    ----

    ----
:lhistory @@
{{{
    list the location lists
    }}}
:ll @@(@)
{{{
    go to specific location
    }}}
:llist @
{{{
    list all locations
    }}}
:lmake @@
{{{
    execute external command 'makeprg' and parse error messages
    }}}
:lnewer (@)
{{{
    go to newer location list
    }}}
:lnoremap @(@)
{{{
    like ":noremap!" but includes Lang-Arg mode
    }}}
:lockmarks (@)
{{{
    following command keeps marks where they are
    }}}
:lockvar @(@)
{{{
    lock variables
    }}}
:lopen @
{{{
    open location window
    }}}
:ltag (!@@)
{{{
    jump to tag and add matching tags to the location list
    }}}
:lunmap (@)
{{{
    like ":unmap!" but includes Lang-Arg mode
    }}}
    ----

    ----
:luado @(@)
{{{
    execute Lua command for each line
    }}}
:luafile @@(@)
{{{
    execute |Lua| script file
    }}}
:lvimgrep @(@)
{{{
    search for pattern in files
    }}}
:lvimgrepadd @@(@)
{{{
    like :vimgrep, but append to current list
    }}}
:lwindow (@)
{{{
    open or close location window
    }}}
:match (@)
{{{
    define a match to highlight
    }}}
:mkexrc @@ @@(@)
{{{
    write current mappings and settings to a file
    }}}
:mkspell @ @(@)
{{{
    produce .spl spell file
    }}}
:mkvimrc @@ @@
{{{
    write current mappings and settings to a file
    }}}
:mzscheme (@)
{{{
    execute MzScheme command
    }}}
:mzfile (@)
{{{
    execute MzScheme script file
    }}}
:nbclose (@@)
{{{
    close the current Netbeans session
    }}}
    ----

    ----
:noautocmd (@)
{{{
    following commands don't trigger autocommands
    }}}
:number (@)
{{{
    print lines with line number
    }}}
:oldfiles (T@)
{{{
    list files that have marks in the viminfo file
    }}}
:omenu (@)
{{{
    add menu for Operator-pending mode
    }}}
:ownsyntax @
{{{
    set new local syntax highlight for this window
    }}}
:packadd @@(@)
{{{
    add a plugin from 'packpath'
    }}}
:packloadall (@)
{{{
    load all packages under 'packpath'
    }}}
:profdel (@)
{{{
    stop profiling a function or script
    }}}
:profile @
{{{
    profiling functions and scripts
    }}}
:pop @
{{{
    jump to older entry in tag stack
    }}}
:popup (@)
{{{
    popup a menu by name
    }}}
:ppop (@)
{{{
    ":pop" in preview window
    }}}
:psearch (??@)
{{{
    like ":ijump" but shows match in preview window
    }}}
    ----

    ----
:ptag (@)
{{{
    show tag in preview window
    }}}
:put @
{{{
    insert contents of register in the text
    }}}
:py3 @
{{{
    execute Python 3 command
    }}}
:py3do @(@)
{{{
    execute Python 3 command for each line
    }}}
:py3file @
{{{
    execute Python 3 script file
    }}}
:pydo @
{{{
    execute Python command for each line
    }}}
:pyfile (@)
{{{
    execute Python script file
    }}}
:redir @(@)
{{{
    redirect messages to a file or register
    }}}
:redraw (@)
{{{
      force a redraw of the display
    }}}
:redrawtabline|  :redrawt[abline] (@)
{{{
    force a redraw of the tabline
    }}}
:return @
{{{
    return from a user function
    }}}
    ----

    ----
:rundo @(@)
{{{
    read undo information from a file
    }}}
:runtime @
{{{
    source vim scripts in 'runtimepath'
    }}}
:sNext (@)
{{{
    split window and go to previous file in argument list
    }}}
:sandbox (@)
{{{
    execute a command in the sandbox
    }}}
:sall (@)
{{{
    open a window for each file in argument list
    }}}
:sball (@)
{{{
    open a window for each file in the buffer list
    }}}
:sbfirst (@)
{{{
    split window and go to first file in the buffer list
    }}}
:sbmodified @
{{{
    split window and go to modified file in the buffer list
    }}}
:scscope @
{{{
    split window and execute cscope command
    }}}
:setlocal (@)
{{{
    show or set options locally
    }}}
:silent @
{{{
    run a command silently
    }}}
    ----

    ----
:smagic @(@)
{{{
    :substitute with 'magic'
    }}}
:smap ((@)
{{{
    like ":map" but for Select mode
    }}}
:spelldump ((@)
{{{
    split window and fill with all correct words
    }}}
:spellgood (@)
{{{
    add good word for spelling
    }}}
:spellrepall @
{{{
    replace all bad words like last |z=|
    }}}
:spellundo ((@)
{{{
    remove good or bad word
    }}}
:startinsert (@)
{{{
    start Insert mode
    }}}
:stopinsert (@)
{{{
    stop Insert mode
    }}}
:sview ((@)
{{{
    split window and edit file read-only
    }}}
:swapname @
{{{
    show the name of the current swap file
    }}}
:syncbind @(@)
{{{
    sync scroll binding
    }}}
    ----

    ----
:tabdo (@)
{{{
    execute command in each tab page
    }}}
:tablast @(@)
{{{
    go to last tab page
    }}}
:tabmove (@)
{{{
    move tab page to other position
    }}}
:tabonly @
{{{
    close all tab pages except the current one
    }}}
:tabs (@)
{{{
    list the tab pages and what they contain
    }}}
:tag @
{{{
    jump to tag
    }}}
:tags @(@)
{{{
    show the contents of the tag stack
    }}}
:tcd @@
{{{
    change directory for tab page
    }}}
:terminal @@
{{{
    open a terminal window
    }}}
:tfirst (@)
{{{
    jump to first matching tag
    }}}
    ----

    ----
:tjump (@@)
{{{
    like ":tselect", but jump directly when there is only one match
    }}}
:tlnoremenu (@(@)
{{{
    like ":noremenu" but for Terminal-Job mode
    }}}
:tmap @@
{{{
    like ":map" but for Terminal-Job mode
    }}}
:tnoremap @@
{{{
    like ":noremap" but for Terminal-Job mode
    }}}
:undojoin (????) (@@(@@)
{{{
    join next change with previous undo block
    }}}
:undolist (@@)
{{{
    list leafs of the undo tree
    }}}
:unhide (@)
{{{
    open a window for each loaded file in the buffer list
    }}}
:unlet @(@)
{{{
    delete variable
    }}}
:unsilent (@)
{{{
    run a command not silently
    }}}
:verbose @(@)
{{{
    execute command with 'verbose' set
    }}}
:vimgrepadd @(@)
{{{
    like :vimgrep, but append to current list
    }}}
:viusage (@(@)
{{{
    overview of Normal mode commands
    }}}
    ----

    ----
:wincmd @(@)
{{{
    execute a Window (CTRL-W) command
    }}}
:winpos (@)
{{{
    get or set window position
    }}}
:wundo @@(@) @
{{{
    write undo information to a file
    }}}
:xall @@
{{{
    same as ":wqall"
    }}}
:xmap (@)
{{{
    like ":map" but for Visual mode
    }}}
:xmenu ((@)
{{{
    add menu for Visual mode
    }}}
:~ (@@)
{{{
    repeat last ":substitute"
    }}}
    ----



___vimexfunc_functs

Vim cmdlineFunctions (:h eval) **!  OBS! FUNC-LIST  +HELA FÖRKLARINGARNA(!!)

    ----
appendbufline({expr}, {lnum}, {text}) @
{{{
    Number  append {text} below line {lnum} in buffer {expr}
    }}}
argc([{winid}]) (@)
{{{
    Number  number of files in the argument list
    }}}
argidx() (@)
{{{
    Number  current index in the argument list
    }}}
argv({nr} [, {winid}]) ((@)
{{{
    String  {nr} entry of the argument list
    }}}
argv([-1, {winid}]) @
{{{
    List    the argument list
    }}}
assert_exception({error} [, {msg}]) (@)
{{{
    Number  assert {error} is in v:exception
    }}}
assert_inrange({lower}, {upper}, {actual} [, {msg}]) @
{{{
    Number  assert {actual} is inside the range
    }}}
assert_match({pat}, {text} [, {msg}]) (@)
{{{
    Number  assert {pat} matches {text}
    }}}
balloon_gettext() (@)
{{{
    String  current text in the balloon
    }}}
balloon_show({expr}) @
{{{
    none    show {expr} inside the balloon
    }}}
browsedir({title}, {initdir}) (@)
{{{
    String  put up a directory requester
    }}}
bufadd({name}) @
{{{
    Number  add a buffer to the buffer list
    }}}
    ----

    ----
bufexists({expr}) (@)
{{{
    Number  |TRUE| if buffer {expr} exists
    }}}
byte2line({byte}) (@)
{{{
    Number  line number at byte count {byte}
    }}}
call({func}, {arglist} [, {dict}]) @(@)
{{{
    any call {func} with arguments {arglist}
    }}}
ch_close({handle}) (@)
{{{
    none    close {handle}
    }}}
ch_getbufnr({handle}, {what}) (@)
{{{
    Number  get buffer number for {handle}/{what}
    }}}
ch_getjob({channel}) @
{{{
    Job get the Job of {channel}
    }}}
ch_info({handle}) (@)
{{{
    String  info about channel {handle}
    }}}
ch_log({msg} [, {handle}]) (@)
{{{
    none    write {msg} in the channel log file
    }}}
ch_open({address} [, {options}]) (@)
{{{
    Channel open a channel to {address}
    }}}
ch_setoptions({handle}, {options}) @(@)
{{{
    none    set options for {handle}
    }}}
ch_status({handle} [, {options}]) (@)
{{{
    String  status of channel {handle}
    }}}
    ----

    ----
char2nr({expr} [, {utf8}]) (@)
{{{
    Number  ASCII/UTF8 value of first char in {expr}
    }}}
chdir({dir}) @
{{{
    String  change current working directory
    }}}
col({expr}) @
{{{
    Number  column nr of cursor or mark
    }}}
complete({startcol}, {matches}) none (@) @@
{{{
    set Insert mode completion
    }}}
confirm({msg} [, {choices} [, {default} [, {type}]]]) (@)
{{{
    Number  number of choice picked by user
    }}}
cursor({lnum}, {col} [, {off}]) @
{{{
    Number  move cursor to {lnum}, {col}, {off}
    }}}
deepcopy({expr} [, {noref}]) (@)
{{{
    any make a full copy of {expr}
    }}}
deletebufline({expr}, {first} [, {last}]) @
{{{
    Number  delete lines from buffer {expr}
    }}}
did_filetype() (@)
{{{
    Number  |TRUE| if FileType autocmd event used
    }}}
    ----

    ----
escape({string}, {chars}) @@(@)
{{{
    String  escape {chars} in {string} with '\'
    }}}
eval({string}) @(@)
{{{
    any evaluate {string} into its value
    }}}
eventhandler() (@)
{{{
    Number  |TRUE| if inside an event handler
    }}}
execute({command}) @
{{{
    String  execute {command} and get the output
    }}}
exists({expr}) (@)
{{{
    Number  |TRUE| if {expr} exists
    }}}
extend({expr1}, {expr2} [, {expr3}]) @
{{{
    List/Dict insert items of {expr2} into {expr1}
    }}}
expand({expr} [, {nosuf} [, {list}]]) @@(@@)
{{{
    any expand special keywords in {expr}
    }}}
expandcmd({expr}) (sss @@)
{{{
    String  expand {expr} like with `:edit`
    }}}
filereadable({file}) (@)
{{{
    Number  |TRUE| if {file} is a readable file
    }}}
    ----

    ----
filter({expr1}, {expr2}) @@(@)
{{{
    List/Dict  remove items from {expr1} where  {expr2} is 0
    }}}
fnameescape({fname}) @(@)
{{{
    String  escape special characters in {fname}
    }}}
foldclosed({lnum}) (@)
{{{
    Number  first line of fold at {lnum} if closed
    }}}
foldlevel({lnum}) (@)
{{{
    Number  fold level at {lnum}
    }}}
foldtext() @@ @(@)
{{{
    String  line displayed for closed fold
    }}}
foldtextresult({lnum}) (@)
{{{
    String  text for closed fold at {lnum}
    }}}
funcref({name} [, {arglist}] [, {dict}]) @(ssss @)
{{{
    Funcref reference to function {name}
    }}}
function({name} [, {arglist}] [, {dict}]) @(@)
{{{
    Funcref named reference to function {name}
    }}}
    ----

    ----
get({list}, {idx} [, {def}]) @(@)
{{{
    any get item {idx} from {list} or {def}
    }}}
get({func}, {what}) @
{{{
    any get property of funcref/partial {func}
    }}}
getbufvar({expr}, {varname} [, {def}]) (@)
{{{
    any variable {varname} in buffer {expr}
    }}}
getcharsearch() (@)
{{{
    Dict    last character search
    }}}
getcmdline() (@)
{{{
    String  return the current command-line
    }}}
getcmdtype() @
{{{
    String  return current command-line type
    }}}
getcmdwintype() @
{{{
    String  return current command-line window type
    }}}
getcompletion({pat}, {type} [, {filtered}]) @(@)
{{{
    List    list of cmdline completion matches
    }}}
getcurpos() @
{{{
    List    position of the cursor
    }}}
getfontname([{name}]) @@
{{{
    String  name of font being used
    }}}
    ----

    ----
getjumplist([{winnr} [, {tabnr}]]) @
{{{
    List    list of jump list items
    }}}
getline({lnum}) @(@)
{{{
    String  line {lnum} of current buffer
    }}}
getmatches([{win}]) @@(@)
{{{
    List    list of current matches
    }}}
getpos({expr}) @(@)
{{{
    List    position of cursor, mark, etc.
    }}}
getqflist([{what}]) (@)
{{{
    List    list of quickfix items
    }}}
getreg([{regname} [, 1 [, {list}]]]) @(@)
{{{
    String or List   contents of register
    }}}
gettagstack([{nr}]) (@)
{{{
    Dict    get the tag stack of window {nr}
    }}}
    ----

    ----
getwinpos([{timeout}]) (@)
{{{
    List    X and Y coord in pixels of the Vim window
    }}}
getwinvar({nr}, {varname} [, {def}]) @
{{{
    any variable {varname} in window {nr}
    }}}
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]]) @(@)
{{{
    any expand file wildcards in {expr}
    }}}
glob2regpat({expr}) @@
{{{
    String  convert a glob pat into a search pat
    }}}
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]]) (@)
{{{
    String  do glob({expr}) for all dirs in {path}
    }}}
has({feature}) (!@)
{{{
    Number  |TRUE| if feature {feature} supported
    }}}
has_key({dict}, {key}) @
{{{
    Number  |TRUE| if {dict} has entry {key}
    }}}
haslocaldir([{winnr} [, {tabnr}]]) @
{{{
    Number  |TRUE| if the window executed |:lcd| or |:tcd|
    }}}
hasmapto({what} [, {mode} [, {abbr}]]) @
{{{
    Number  |TRUE| if mapping to {what} exists
    }}}
histadd({history}, {item}) @(@)
{{{
    String  add an item to a history
    }}}
    ----

    ----
iconv({expr}, {from}, {to}) (@@)
{{{
    String  convert encoding of {expr}
    }}}
indent({lnum}) @
{{{
    Number  indent of line {lnum}
    }}}
index({object}, {expr} [, {start} [, {ic}]]) (@)
{{{
    Number  index in {object} where {expr} appears
    }}}
input({prompt} [, {text} [, {completion}]]) @@(@)
{{{
    String  get input from the user
    }}}
inputlist({textlist}) @
{{{
    Number  let the user pick from a choice list
    }}}
insert({object}, {item} [, {idx}]) List @
{{{
    insert {item} in {object} [before {idx}]
    }}}
islocked({expr}) (@)
{{{
    Number  |TRUE| if {expr} is locked
    }}}
    ----

    ----
items({dict}) @(@)
{{{
    List    key-value pairs in {dict}
    }}}
join({list} [, {sep}]) (@)
{{{
    String  join {list} items into one String
    }}}
js_decode({string}) (@)
{{{
    any decode JS style JSON
    }}}
keys({dict}) @
{{{
    List    keys in {dict}
    }}}
len({expr}) @(@)
{{{
    Number  the length of {expr}
    }}}
libcall({lib}, {func}, {arg}) (@)
{{{
    String  call {func} in library {lib} with {arg}
    }}}
line({expr} [, {winid}]) @@(@)
{{{
    Number  line nr of cursor, last line or mark
    }}}
lispindent({lnum}) (@)
{{{
    Number  Lisp indent for line {lnum}
    }}}
list2str({list} [, {utf8}]) @(@)
{{{
    String  turn numbers in {list} into a String
    }}}
listener_add({callback} [, {buf}]) @
{{{
    Number  add a callback to listen to changes
    }}}
listener_flush([{buf}]) @(@)
{{{
    none    invoke listener callbacks
    }}}
    ----

    ----
localtime() (@)
{{{
    Number  current time
    }}}
luaeval({expr} [, {expr}]) @(@)
{{{
    any evaluate |Lua| expression
    }}}
map({expr1}, {expr2}) @@(@)
{{{
    List/Dict  change each item in {expr1} to {expr}
    }}}
mapcheck({name} [, {mode} [, {abbr}]]) (@)
{{{
    String  check for mappings matching {name}
    }}}
match({expr}, {pat} [, {start} [, {count}]]) @(@)
{{{
    Number  position where {pat} matches in {expr}
    }}}
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]]) (@)
{{{
    Number  highlight {pattern} with {group}
    }}}
matchlist({expr}, {pat} [, {start} [, {count}]]) @(@)
{{{
    List    match and submatches of {pat} in {expr}
    }}}
matchstr({expr}, {pat} [, {start} [, {count}]]) (@)
{{{
    String  {count}'th match of {pat} in {expr}
    }}}
matchstrpos({expr}, {pat} [, {start} [, {count}]]) @
{{{
    List    {count}'th match of {pat} in {expr}
    }}}
    ----

    ----
mkdir({name} [, {path} [, {prot}]]) (@)
{{{
    Number  create directory {name}
    }}}
mode([expr]) @
{{{
    String  current editing mode
    }}}
nextnonblank({lnum}) @(@)
{{{
    Number  line nr of non-blank line >= {lnum}
    }}}
or({expr}, {expr}) (@)
{{{
    Number  bitwise OR
    }}}
popup_beval({what}, {options}) (@)
{{{
    Number  create popup window for 'ballooneval'
    }}}
popup_getoptions({id}) (@)
{{{
    Dict    get options of popup window {id}
    }}}
popup_getpos({id}) (@)
{{{
    Dict    get position of popup window {id}
    }}}
popup_hide({id}) (@)
{{{
    none    hide popup menu {id}
    }}}
popup_menu({what}, {options}) (@)
{{{
    Number  create a popup window used as a menu
    }}}
popup_move({id}, {options}) (@)
{{{
    none    set position of popup window {id}
    }}}
    ----

    ----
popup_setoptions({id}, {options}) (@)
{{{
    none    set options for popup window {id}
    }}}
popup_settext({id}, {text}) (@)
{{{
    none    set the text of popup window {id}
    }}}
printf({fmt}, {expr1}...) (@)
{{{
    String  format text
    }}}
prompt_setcallback({buf}, {expr}) none @
{{{
    set prompt callback function
    }}}
pumvisible() (@)
{{{
    Number  whether popup menu is visible
    }}}
py3eval({expr}) @
{{{
    any evaluate |python3| expression
    }}}
range({expr} [, {max} [, {stride}]]) (@)
{{{
    List    items from {expr} to {max}
    }}}
readdir({dir} [, {expr}]) (@)
{{{
    List    file names in {dir} selected by {expr}
    }}}
readfile({fname} [, {type} [, {max}]]) @
{{{
    List    get list of lines from file {fname}
    }}}
reg_recording() @
{{{
    String  get the recording register name
    }}}
reltime([{start} [, {end}]]) ss @@(@)
{{{
    List    get time value
    }}}
    ----

    ----
remove({list}, {idx} [, {end}]) (@)
{{{
    any/List    remove items {idx}-{end} from {list}
    }}}
remove({dict}, {key}) (@)
{{{
    any remove entry {key} from {dict}
    }}}
rename({from}, {to}) (@)
{{{
    Number  rename (move) file from {from} to {to}
    }}}
repeat({expr}, {count}) ((@)
{{{
    String  repeat {expr} {count} times
    }}}
resolve({filename}) (@)
{{{
    String  get filename a shortcut points to
    }}}
reverse({list}) @
{{{
    List    reverse {list} in-place
    }}}
screenchar({row}, {col}) @
{{{
    Number  character at screen position
    }}}
screenrow() (@)
{{{
    Number  current cursor row
    }}}
search({pattern} [, {flags} [, {stopline} [, {timeout}]]]) @
{{{
    Number  search for {pattern}
    }}}
    ----

    ----
searchdecl({name} [, {global} [, {thisblock}]]) (@)
{{{
    Number  search for variable declaration
    }}}
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]]) (@@)
{{{
    Number  search for other end of start/end pair
    }}}
searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]]) (@)
{{{
    List    search for {pattern}
    }}}
setbufline({expr}, {lnum}, {text}) (@)
{{{
    Number  set line {lnum} to {text} in buffer {expr}
    }}}
setbufvar({expr}, {varname}, {val}) @
{{{
    none    set {varname} in buffer {expr} to {val}
    }}}
setcmdpos({pos}) @
{{{
    Number  set cursor position in command-line
    }}}
setfperm({fname}, {mode}) (@)
{{{
    Number  set {fname} file permissions to {mode}
    }}}
setline({lnum}, {line}) @
{{{
    Number  set line {lnum} to {line}
    }}}
setloclist({nr}, {list} [, {action} [, {what}]]) @
{{{
    Number  modify location list using {list}
    }}}
setmatches({list} [, {win}]) (@)
{{{
    Number  restore a list of matches
    }}}
setpos({expr}, {list}) (@)
{{{
    Number  set the {expr} position to {list}
    }}}
    ----

    ----
setqflist({list} [, {action} [, {what}]]) @
{{{
    Number  modify quickfix list using {list}
    }}}
setreg({n}, {v} [, {opt}]) @(@)
{{{
    Number  set register to value and type
    }}}
setwinvar({nr}, {varname}, {val}) none @
{{{
    set {varname} in window {nr} to {val}
    }}}
sha256({string}) (@)
{{{
    String  SHA256 checksum of {string}
    }}}
shellescape({string} [, {special}]) @@(@)
{{{
    String  escape {string} for use as shell command argument
    }}}
shiftwidth([{col}]) @(@@)
{{{
    Number  effective value of 'shiftwidth'
    }}}
simplify({filename}) (??@)
{{{
    String  simplify filename as much as possible
    }}}
sort({list} [, {func} [, {dict}]]) (@)
{{{
    List    sort {list}, using {func} to compare
    }}}
sound_clear() (@)
{{{
    none    stop playing all sounds
    }}}
split({expr} [, {pat} [, {keepempty}]]) @
{{{
    List    make |List| from {pat} separated {expr}
    }}}
    ----

    ----
state([{what}]) (@)
{{{
    String  current state of Vim
    }}}
strchars({expr} [, {skipcc}]) (@)
{{{
    Number  character length of the String {expr}
    }}}
strftime({format} [, {time}]) (@)
{{{
    String  time in specified format
    }}}
strgetchar({str}, {index}) @
{{{
    Number  get char {index} from {str}
    }}}
string({expr}) (@)
{{{
    String  String representation of {expr} value
    }}}
strlen({expr}) @
{{{
    Number  length of the String {expr}
    }}}
strpart({str}, {start} [, {len}]) (@)
{{{
    String  {len} characters of {str} at {start}
    }}}
strwidth({expr}) (@)
{{{
    Number  display cell length of the String {expr}
    }}}
submatch({nr} [, {list}]) @@(@)
{{{
    String or List  specific match in ":s" or substitute()
    }}}
substitute({expr}, {pat}, {sub}, {flags}) @
{{{
    String  all {pat} in {expr} replaced with {sub}
    }}}
swapinfo({fname}) (@)
{{{
    Dict    information about swap file {fname}
    }}}
swapname({expr}) (@)
{{{
    String  swap file of buffer {expr}
    }}}
synID({lnum}, {col}, {trans}) (@)
{{{
    Number  syntax ID at {lnum} and {col}
    }}}
    ----

    ----
system({expr} [, {input}]) @@(!!@@)
{{{
    String  output of shell command/filter {expr}
    }}}
systemlist({expr} [, {input}]) @@
{{{
    List    output of shell command/filter {expr}
    }}}
tabpagebuflist([{arg}]) @
{{{
    List    list of buffer numbers in tab page
    }}}
taglist({expr} [, {filename}]) @(@)
{{{
    List    list of tags matching {expr}
    }}}
tagfiles() (@@)
{{{
    List    tags files used
    }}}
tempname() (@)
{{{
    String  name for a temporary file
    }}}
term_dumpload({filename} [, {options}]) (@)
{{{
    Number  displaying a screen dump
    }}}
term_dumpwrite({buf}, {filename} [, {options}]) (@)
{{{
    none    dump terminal window contents
    }}}
term_getansicolors({buf}) (@)
{{{
    List    get ANSI palette in GUI color mode
    }}}
term_gettitle({buf}) (@)
{{{
    String  get the title of a terminal
    }}}
    ----

    ----
term_gettty({buf}, [{input}]) @
{{{
    String  get the tty name of a terminal
    }}}
term_scrape({buf}, {row}) (@)
{{{
    List    get row of a terminal screen
    }}}
term_sendkeys({buf}, {keys}) (@)
{{{
    none    send keystrokes to a terminal
    }}}
term_setkill({buf}, {how}) (@)
{{{
    none    set signal to stop job in terminal
    }}}
term_start({cmd} [, {options}]) (@(@)
{{{
    Number  open a terminal window and run a job
    }}}
test_null_blob() (@)
{{{
    Blob    null value for testing
    }}}
test_null_job() (@)
{{{
    Job null value for testing
    }}}
test_null_list() (@)
{{{
    List    null value for testing
    }}}
test_refcount({expr}) (@@)
{{{
    Number  get the reference count of {expr}
    }}}
test_setmouse({row}, {col}) (@)
{{{
    none    set the mouse position for testing
    }}}
test_settime({expr}) (@)
{{{
    none    set current time for testing
    }}}
    ----

    ----
timer_start({time}, {callback} [, {options}]) (@)
{{{
    Number  create a timer
    }}}
tolower({expr}) (@)
{{{
    String  the String {expr} switched to lowercase
    }}}
tr({src}, {fromstr}, {tostr}) @
{{{
    String  translate chars of {src} in {fromstr}   to chars in {tostr}
    }}}
trim({text} [, {mask}]) (@)
{{{
    String  trim characters in {mask} from {text}
    }}}
type({name}) (@)
{{{
    Number  type of variable {name}
    }}}
undofile({name}) (@)
{{{
    String  undo file name for {name}
    }}}
uniq({list} [, {func} [, {dict}]]) (@)
{{{
    List    remove adjacent duplicates from a list
    }}}
values({dict}) @
{{{
    List    values in {dict}
    }}}
virtcol({expr}) (@)
{{{
    Number  screen column of cursor or mark
    }}}
visualmode([expr]) @
{{{
    String  last visual mode used
    }}}
    ----

    ----
wildmenumode() (@(@)
{{{
    Number  whether 'wildmenu' mode is active
    }}}
win_execute({id}, {command} [, {silent}]) (@(@)
{{{
    String  execute {command} in window {id}
    }}}
win_findbuf({bufnr}) (@(@)
{{{
    List    find windows containing {bufnr}
    }}}
win_getid([{win} [, {tab}]]) @
{{{
    Number  get window ID for {win} in {tab}
    }}}
win_gotoid({expr}) (@)
{{{
    Number  go to window with ID {expr}
    }}}
win_screenpos({nr}) (@)
{{{
    List    get screen position of window {nr}
    }}}
win_splitmove({nr}, {target} [, {options}]) (@)
{{{
    Number  move window {nr} to split of {target}
    }}}
winbufnr({nr}) @
{{{
    Number  buffer number of window {nr}
    }}}
    ----

    ----
wincol() (@)
{{{
    Number  window column of the cursor
    }}}
winlayout([{tabnr}]) @
{{{
    List    layout of windows in tab {tabnr}
    }}}
winline() (@)
{{{
    Number  window line of the cursor
    }}}
winnr([{expr}]) (@)
{{{
    Number  number of current window
    }}}
winrestcmd() (@)
{{{
    String  returns command to restore window sizes
    }}}
wordcount() (@)
{{{
    Dict    get byte/char/word statistics
    }}}
writefile({object}, {fname} [, {flags}]) (@)
{{{
    Number  write |Blob| or |List| of lines to file
    }}}
    ----


    }}}
    [excmds-vimfuncts samsnotes]  ~/Dropbox/rsc/data/lists/learnqna/vanki/vim2021.twothirds.tagged/v-practexfuncts_samsnotes.txt {{{

    g&
    :&&  (but w. diff. range)
    :&

    :c-commands
     :cscope
    :fold-commands *
      :ijump|ilist   isearch  isplit
     :keep (etc)
    :l-commands (=loc-lists) **(!)
     :lmap (????? | *********)
    :copy, :move, :delete  etc (**)
        :mark, :k
    ( :menutranslate  ???)
         netbeans
    :sbnext (etc)
         :syncbind
    ----
    assert_(  *(*)
     ...
     ...
    complete_
    copy(       count(
    ch_**(,  job_**(
    delete(    
     empty(
    fnamemodify(
     fold**(
    getbufline(
    get(=charsearch etc)(
    has**(
    is**(
     x2y(   str2list(  (etc)
    match**(
     popup**(
    prompt**(
        text prop.s (?)  prop_**(  prop_type_**(
    ( remote_**(
    screen**(
     sign_**(
    ( sound_**(
       'needle',   'concealing'
    tab**(
    term_**(
    test_**(
    (timer_**(
    win_**(
    winsave(  winrest(
      --  reflists (*)
    flat,  topical  (=or generated w. tags) (!!)
    ----
    List and Browse '-example's (**!)




    BlendPy Books  (++++??)

    lvimscrharw.txt

    Scott M Seccop
    DB + Xml + Forums Stora(!)



    }}}


}}}

. 'Cookbook/Önskelista Vanliga Uppgifter' [LEGACY = PULL EXAMPLES + REFERENCE GOOD HEADINGS AS AOI-LIST(!!)] {{{

        options
        ???? {{{

            % #             '#' samma som #0
            #1, #2 ...      buffer 1, 2 osv ***
            ##              hela arglistan, space-sep.
            #<1, #<2 ...    oldfile 1, 2 osv
                            (:oldfiles / v:oldfiles för nummer)

            :h filename-modifiers
            :p
            :~
            :.
            :h
            :t
            :r
            :e
            :s?regexpat?sub?        =subst. första
            :gs?regexpat?sub?
                :p:gs?/?\\?     \home\mool\vim\src\version.c
            :S                      =likn. shellescape() *
                :!dir <cfile>:S
                :call system('chmod +w -- ' . expand('%:S'))

            tecken som indikerar typ av cmdrad
            (= t.ex. au CmdwinEnter [:>] iunmap <Tab> )
              :h cmdwin-char



            :silent ****

            :redir[!]  ___SEMER2019 ___PICKOUT
              @a>>
              => {var}


            ersätt tecken m. ^M (=rikt.         r c-v Ent ***       #el gr
              tecknet <CR>/spec. tecken ***
            tecken/10 tecken fr. rad under      r c-e / r 10 c-e    #el gr
              (=med 'r' (=ersätt))



            --nofork        lägg programmet i foreground
            :runtime! plugin/**/*.vim

            :checktime


            In case you need the value of $VIMRUNTIME in a shell (e.g., for a script that
            greps in the help files) you might be able to use this: >
                VIMRUNTIME=`vim -e -T dumb --cmd 'exe "set t_cm=\<C-M>"|echo $VIMRUNTIME|quit' | tr -d '\015' `

            After restoring the Session, the full filename of your current Session is
            available in the internal variable "v:this_session" |this_session-variable|.
            An example mapping: >
                :nmap <F2> :wa<Bar>exe "mksession! " . v:this_session<CR>:so ~/sessions/
            This saves the current Session, and starts off the command to load another.

            To automatically save and restore views for *.c files: >
            au BufWinLeave *.c mkview
            au BufWinEnter *.c silent loadview


            'Switch between languages, as follows:'         c-_
                                                        + c-^
            the 'keymap' option  #=install language mappings

            i_CTRL-]


            <sfile>         :source <sfile>:h/other.vimrc


            :h profile (profiling)      reltime()

        }}}
        ????macro {{{

            eval. expression +              @= (+enter expression) **??
              run result as macro **

            :@z         :h :@
            :@@
            :@:

        }}}
        ----
        teoriterm {{{

            vim package             dir. that contains one or more plugin
                                     # :h packages *****

            vim winguidisplay-      :h definitions
              terms and terminol. *

        }}}
        te:grundsyntax {{{

            line continuations              :h line-continuation  *******

            ordning opt. och args               går att blanda ordn. flaggor o filnamn ***  #utom om fl.
              (=när startar vim i term.) *                                                  # som tar arg. (**)

        }}}
        help  #+äv. tags tselect(=???)**** {{{

            loc. filer help         'helpfile' (**)
            mail-list + irc??
            notering i help         :h notation ***
              (='[]' mm) ***
            h.notation: mandat. *** {mandat + text ev mm}   #el. 'not in vi'
            h.notation: {motion}    (t.ex. w, 4j, /The<CR>)
            (h. annat språk*)       :h helphelp@fr      #+spa, ru, mm
            h. med glob (*)         :h ?[a-ce-h]*   #+anv. c-d ************* !!
            sök h. med regex ****   :help| :tag patt {{{

                grundsök h.         :help index| :tag /r.*  #=regexpatt. ****
                  m. regex ****
                next r.match ***    :tnext
                lista matches       :tselect    #:help index| :tse z.
                  för val **
                :tselect för tag    g]      **** ___SEMER2019
                  under markören ****
                (('komb.'))         :help so<C-V><CR>only   #(ovanför *:helpc*      ?????

            }}}
            helpgrep **             :helpgrep /p.*/[@it]    #cnext, cwin, cc, mm        #SE EV D.NEILL VIMCASTS(*)
                                        #ci; \c för "ic"
                                    :helpgrep uganda\c
            hgrep + loc.list ****   :lh[elpgrep] patt   #** lopen, mm (ll)

            man 2 word (fr. i vim)  2K  #=på ordet 'word'   #***

        }}}
        inställn instfiler config (**) {{{

            remove val. from        :set option-=val
              option (**)

            sätt filtyp unix(mm) **         :h Unix-format (**)
                                              #går att sätta lista/flera (**)

            starta m specifik rc-fil        alias vimc vim -u ~/.c_vimrc !*     #obs! sätter 'compatible'   *****
            tips: local options             vimrc m cmd.s spec. för den mappen, i mappen    #+sätt exrc (obs: tips =se :h trojan-horse)

            (SPARA UT NUV. INSTÄLLN.+ÄNDR.  :h save-settings    #:mkvimrc[!] fil (=def. .vimrc i wdir*)
              TILL FIL (=SOM NY RCFIL MM))*   #+'A common method'**
            tips: skriv in ändrad               o:set guifont=<C-R>=&guifont<CR><Esc>  ***
              font(=inställn.) i rc-filen ***

        }}}
        info messages status log {{{

            visa num. för rader         :#  := (?) / :number        #def. nuv. raden ****
              (=temporärt***)
            :print  :list
              :z (m. tecken '+-^.=')        visa rad/range + kontext runt
              :z#
              := (t.ex. :.=)

            VISA LOGG/MESS. IGEN        g< ****** ___PICKOUT
              (=T.EX. :REG EL. :MESS) ******
            movem. i :mess mm(:reg      f, b, j, k,, q
              +andra långa listor) *****
            KOP. TEXT FR. :MESS, :REG   vklickdra-markera + c-y     #=till "+  **** ___PICKOUT
              O.LIKN. LOGGS *****

            show filename               :f[ile] / c-g
            visa filnamn: hel sökv.     1 c-g   ___PICKOUT ***
            visa buf.num nuv. fil *     2 c-g   ___PICKOUT ***

                +TESTA EV OM FINNS FLER (=T.EX. 3 c-g) (***)

        }}}
        session grundspara termstartexecvim(??) {{{

            open file (not txt)             gx
              (=w. assoc. progr.) ****
                                https://stackoverflow.com/questions/30662334/how-to-get-list-of-programs-which-can-open-a-particular-file-extension-in-linux
                                https://unix.stackexchange.com/questions/144047/how-does-xdg-open-do-its-work

            spec. storl./plac. fönstret ***         :h gui-start mm  #:winpos :winsize mm ****
            ----
            öppna fil m. def. av                    vim -t tagname      #:h starting
              tag (=t.ex. funct. i c-kodfil)*
            öppna fil i qf (=fr. sparad             vim -q errorfile    #:h starting
              errorlist/file?)*

            start v. 'clean' (='bare
              bones'): -rc+plug/-rc/-plug           -u NONE, -u NORC, --noplugin
            alt./egen rc-fil (=annan                -u (??) ****
              sökväg)*
                        ar.mode     -A
                        farsi-mode  -F
                        hebr.mode   -H
            compatible/nocompatible             -C/N    #t.ex. om ej rcfil

        START VIM + ACTION (****)
            till rad 15 av fil                      vim +15 fil
            till patt. 'ord' i fil                  vim +/ord fil   #+1 +/ord (om markör ej start fil (viminfo))
            kör cmd när start. fil *****            +cmd / -c cmd   #<10st, körs när fil 1 lästs
                                                                    # (+dess auc.s/modlines körts(!))  OBS: KAN VARA STÄLLET ATT LÄGGA OBEGR. MED KOMMANDON (????/****)
                                                       vim  "+set si"  main.c
                                                      vim  "+find stdio.h"
                                                      vim  -c "set ff=dos"  -c wq  mine.mak
            (anv. cmd: körs innan vimrc)            --cmd komm  *   #10 st (=utöver -c) **
            source file (skript mm)                 vim -S script.vim   #<10 =räknas tills. med(!) -c

        =================

            :lcd[!]??   (+lurigheter m cd??)

            edit file                       :e ++opt(t.ex. ff) +cmd  *******    #cmd =esc. whsp + doub. b.slash
                                              #opt: ff, enc, bin, nobin, bad el. edit,, t.ex. ++ff=unix/dos/mac
                                              # ++bad=c/keep/drop
            red. ny fil                     :enew   ___PICKOUT ___SEMER2019
            ----
            EDIT FILE: EVAL. SHELL          :n `{commands}`  ***** ___PICKOUT ___SEMER2019
              COMMANDS (T.EX. FIND) *******
                                            :next `find . -name ver\\*.c -print`    #OBS: VIKT. SYNTAX ='\\' MM
                                            :view `ls -t *.patch  \| head -n1`
            EDIT FILE: EVAL. VIM            :e `={vfunct/vexpr}`  ***** ___PICKOUT ___SEMER2019
              EXPRESSION (funct(), concats mm) ******* ********
                                            :e `=tempname()`
                                            :e `=$HOME . '/.vimrc'`

              :q
              :confirm q

            :browse +'browsedir' o g:/b:browsefilter **** ___SEMER2019  :h browsefilter  (only vimfiles in dial.)

        }}}
        grundred ** {{{

            klistra in + pekaren            gp gP
              till efter text
              (=ist.för på
              sista/första bokstaven)               #första =för line-wise pastes

            klistra in + justera            ]p ]P *****     ___PICKOUT ___SEMER2019
              indent enl. nuv. rad ****

            kasta om två ord                deep    #pekaren på blank innan     ___PICKOUT ___SEMER2019
              (=likn. xp för tecken) **             # ord 1 **

        }}}
        .  insmode {{{

            Make cmd break/not          c-g u / c-g U       ___PICKOUT ___SEMER2019
              break undo ****            # se 'An example for using CTRL-G u' i :h insert (***)

            last inserted text          c-a, c-@, c-r .     #@: =+leave i-mode

            Ev Se Mer (=sätt att        CTRL-G U    don't break undo with next left/right cursor *****
              anv. piltangenter(el.      # :h i_CTRL-G_U        ___PICKOUT ___SEMER2019
              andra maps i i-mode)
              utan att bryta undo-
              seq ****                  insert.txt 'The CTRL-O command takes you to Normal mode'


            ent./- i insmode            c-g j/k

        }}}
        files args buffers {{{

                gå till altfil 3            3 c-^ // :e #3      #var. två fung. ej om alt.f. ej har namn(!)
                ändra namn på fil           :file! nyttnamn     #gamla namnet sparas i unlist.buf.

                lokal arglist (=i ett       arglocal
                  fönster/window) **

            args arglist
                ls arglist              :args   **
                def. arglist            :arglist (++opt +cmd) *filer*
                  :args! {arglist}
                fil till arglist        :[count]argedit Fil 1.txt       #count: add after file N in list    ___PICKOUT ___SEMER2019
                filer till arglist**    :[count]argadd filnamn ...      #if no name: add curr. editfile     ___PICKOUT ___SEMER2019

                ADD ITEM X +SORT ALIST  :args ## x      ___PICKOUT ___SEMER2019
                  :argdelete {patt} ..
                  :[range]argd[elete]
                                        :10,$argdel
                                        :%argd          #rem. whole arglist (**)
                  :5argu(ment)
                  :2n
                  :N
                  :prev
                  :rew
                  :first
                  :last
                  :wn
                  :wN :wp

            ------

                  :arglocal
                   :argglobal

                  +SE MER ARGLISTS ('There can be several argument lists.' mm   #=strax ovanför :h :argdo   ___PICKOUT ___SEMER2019

                :argdo ************* ___PICKOUT ___SEMER2019
                            :args *.c
                            :argdo set ff=unix | update
                            --
                            :args *.[ch]
                            :argdo %s/\<my_foo\>/My_Foo/ge | update  ___PICKOUT ___SEMER2019

        }}}
        . NY: findfile path recursedir {{{

             TRICK RECURS. SÖKV. *****      **/*.c  ******      :h starstar-wildcard    ___PICKOUT ___SEMER2019
                                              # +t.ex.  :n /usr/inc**/types.h  ******
             STARSTAR-SÖK MAX 2 DIR NER     /usr/**2    #def. 30; max 100   ___PICKOUT ___SEMER2019
               UNDER /USR ****
                                                /usr/**/sys/*
                                                /usr/*tory/sys/**
                                                /usr/**2/sys/*

            öppna fil nere i dirstrukt.     :find ++opt +cmd dir/**/*.sh
              *****                           :next `find . -name \\*.c -print`
            fil nr två som hittas av f.     :2find filnamnsök   ___PICKOUT

            +SE MER FILESEARCHING           :h file-searching   # ='backw. search' m. ';'-sep. ****  ___PICKOUT ___SEMER2019

        }}}
        search jump {{{

            snabbsök fram/bak           * / #   s-vklick/s-hklick ******2019  ___PICKOUT
             ' + ej change j.list       g'
             ` + ej change j.list       g`
            next match + vselect ***    gn/gN ****      ___PICKOUT ___SEMER2019

                .+3
            /-adresser (=$, 'm, % osv**): *****     ___PICKOUT ___SEMER2019
                nästa/förra rad där     \/  \?
                  prev. sök matchar
                nästa/förra rad där     \&
                  prev. subst. matchar
            + -
            'dubbeladresser' ****       /pat1//pat2/    #=sök el adress     ___SEMER EV
                                                     #innan sök def. **

            om incsearch: bygg på       c-l **  ___PICKOUT ___SEMER2019
              nuv. förslag ***

            5;/that line/               ("; flyttar markören")  ___SEMER2019


            :keepjumps

        }}}
        history undo  changelist {{{

            visa changelist         :changes    ___PICKOUT ___SEMER2019
            gå till första i        999g;   #999gg (=om egna drs-map hade funkat direkt)**!
              changelist
            tips: gå till viss      kolla listan m. :changes + t.ex. 3g;  ,,  2g,  osv  ___PICKOUT
              change (*)

            older/newer text        g-/g+       #undo-tree (**) ___PICKOUT
              state N times (****)


            :u[ndo]
            :u {N}      #t.ex. '88' i listan nedan  ___PICKOUT
            5 c-r   ___PICKOUT
            :redo
             :undojoin | delete  ___SEMER EV

            split undo ***          c-g u  +/el.  sätt 'undolevels'     ___SEMER

            :undolist

            :later / :earlier       #t.ex '7' i listan nedan

            :earlier 10s/m/h/d 1f   #1f =before last file write **  ___PICKOUT ___SEMER2019

        -----------

            te:tree (the undo tree)
            te:leaves (the instances/edits)

           number changes  when               saved ~
               88      88  2010/01/04 14:25:53
              108     107  08/07 12:47:51
              136      46  13:33:01             7
              166     164  3 seconds ago


            läs/skriv undo history          :wundo / :rundo     ___PICKOUT ___SEMER2019
              (=uttryckl.) till fil

            vad händer(=reg.) när       läggs i reg 1 + fortsätter skiftas
              suddar(delete)?             för varje del. **
            klistar in senaste/ti.re    "1P, "3p  osv
              deletes
            Plocka tillbaks senaste     "1p, ., ., ., .    #om dd. . . . innan *****    ___PICKOUT
              del. + fortsätt
              (=repeterande idiom) ***
            y.ligare ett idiom          "1P  om ej rätt reg(=längre tillbaks)   ___PICKOUT ( ___SEMER2019 )     #EV. VSCR/VIMRC-DRS_LÖSN(...)
                                             'u.'  #kollar nr 2, osv tills hittat

        }}}
        (backup recover) {{{

            backupoptions(**)                   backup, backupext(=.bak), patchmode=.orig, backupdir (**)
                                                 +backupskip (**)

            visa/lista swap/recov-filer         vim -r      ___PICKOUT
            starta vim med recov-fil            vim -r file.swp     #:h crash-recovery
            :swapname
            :recover file.swp

        }}}
        movement (+motions =vid 'operators') {{{

            :1  :'m  :'>  :2,6      pekaren till sista rad i range (***)    #obs: ändrar inte jumplist ****
                                      #el. första om pekaren innan range (###)
            ----
            till rad 12 **          12gg / 12G **
            (till byte 50)          (50go)  ( ___PICKOUT )
            zt + pek. 0 (**)        z Ent       ___PICKOUT EV
                                        z+ z^ z.  z-

            rulla bild vä/hö        zl/zL       #=om ej wrap satt       #+zh/zH ??
                                   +z-hö/z-vä   # :h scroll-horizontal
              zs ze  ( ___SEMER EV )    ????


            bind så två (el.        scrollbind      #sätts per fönster ***  #=sätt ev ny shortcut ___SEMER2019
              fler) fönster             #+:syncbind
              rullar tillsammans. ***
            tips: rulla fö.         rulla m. scrollbar/mhj i fönstret utan(!!*) fokus ***
              separ. (=äv. om
              scrlb satt) (**)

        }}}
         (vselect) {{{

             next match + vselect ***    gn/gN ****
             skifta mellan nuv. o       gv (=när v-område) *    ___PICKOUT ___SEMER2019
               förra v-område *******

             välj N x förra val         [count]v(m.fl.)     #NY!    ___PICKOUT ___SEMER2019

             kort för :'<,'>            :*      ___PICKOUT ___SEMER2019

         }}}
        (spectecken) {{{

            digraph                 c-k  +c1 c2
            UNICODE                 c-v u/U 10fa/10fa2d16
            ch.ins. m. key-code ******          :h i_CTRL-V_digit (=dec 3, oct 3, hex 2, uU  hex 4/8)

            direct ins. spec-       c-v/c-q + char.     #tab, esc, enter mm
              tang.
            nul-char                c-v c-@ / c-v 000

            INFOGA SPEC.TECKEN      =se exempel uppe under :substitute ****     ___PICKOUT ___SEMER2019 ___SEMER2019   ********
              M. SUBST. ****

        }}}
        block textobj {{{

            aw
            as      ************* ___PICKOUT
            ap
            a]
            ab a(
            a< ****     <'edit'> '<edit>'   =inner all ___PICKOUT ___SEMER2019
             at
            aB a{
            a" a' a`

            ciw
            vas

            dgn **      #delete next search pattern (=inte t.o.m. **)   ___PICKOUT ___SEMER2019

        }}}
        mark {{{ ___SEMER2019

            to next/prev l.case     ]` / ['  ******  ___PICKOUT
              mark ****

            curs.                   "       # :h last-position-jump
            jump                    `
            last insert             ^
             to edit lastinsert ***  gi     #='cont. where last edited' *****   ___PICKOUT
            sentence                (
            highl.area              <
            oper.text(y/pu) **      [       ****
            paragr.                 {

            går också att sätta följande manuellt: ****     ___PICKOUT ___SEMER2019
            ' ` [ ] < >     # ' = sätt hoppmärken manuellt **
                            # [ = simulera operator mm(??/**)
                            # < = ändra vad gv väljer *

            sätt mark vid slut      :2,6mark {a-zA-Z'}      ___PICKOUT ___SEMER2019
              av range              :2,6k{a-zA-Z'}
            lista marks             :marks      :marks aB
            sudda märken            :delmarks {marks}       #se :delm
                                    :delmarks!

            (tip:) keep marks       :lockmarks {cmd}        #ev semer  ___SEMER2019
              wh. changing text
              (but line-no.s
              same after change)
            +                       :keepmarks {cmd}

            edit(t.ex. uppdat.      :keepjumps {cmd}        #se vimscrkod m komm. :keepjumps ***
              timestamp) utan
              att ändra jumplist ****

        }}}
        wintabsplit {{{

            2 splits vid startup            gvim -o2 *.txt      #+ -O/-p        ___PICKOUT ___SEMER2019
              (=äv. om fler filer**)

            c-w p
            c-w r ????
             c-w ]          split + jump to t.              #+c-w c-]       ___PICKOUT ___SEMER2019
             c-w g c-]      split + :tjump to t.
             c-w g ]        split + :tselect to t.
            c-w ^
            ----
            c-w d   ????
            c-w i   ????

            c-w }   ????    ___SEMER2019 EV
            c-w z
            progr.code movem. ****(semer)       =sect. 2.3 i :h index       ___PICKOUT ___SEMER2019 EV


            :help leftabove , :help rightbelow , :help :split , and :help :vsplit

        }}}
        folding {{{

            (SE MER OM FOLD-KOMMANDON)          :h index (z-kommandon) (**)

            öppna tillr. m. folds               zv      ___PICKOUT
              för att se markören (*)

        }}}
        format indent ___PICKOUT ___SEMER2019 (=DREW NEILL Ultisnips-Vide: '=ip') **** {{{

            format(=indent) motion ****         ={motion}   #+EV. EQ.PROG.      ___PICKOUT
            intent line(s) ****                 ==, 3==     #mm/o.likn.
            indrag (fr. cline) *            :[range]> {count}
              :[range]left [num of indents] ???
            format(?) text                  gq      #=enl. 'wrap', 'textwidth' o.likn. (**)  t.ex. gqap
                (+ SE EV MER :h gq +gw  ___SEMER2019 ) *
                (+ SE MER  'formatoptions'  :h fo-table :h auto-format *****)

            f. hel rad (*)                  gqq     ___PICKOUT
            format, minus formatprg/        gw, gww     #+pekaren till bö. text     ___PICKOUT ___SEMER2019
              /formatexpr
            formatera text + pekaren        gw{motion}
              kvar (***)

            retab(=tab/whsp-mix till        :retab!  /  >><<    ___PICKOUT
              enbart ena **


                    :<<<        move current line 3 indents to the left
                    :>> 5       move 5 lines 2 indents to the right
                    :5>>        move line 5 2 indents to the right


            0 c-d       ___PICKOUT
            ^ c-d   'useful when inserting a' 'label'  =??


            :center
            :right
            :left

            ev ___SEMER2019     :h cino  :h java-cinoptions

            indent vimscript        :h indent+främst ft-vim-indent
             #'Three times shiftwidth is the default value'

        }}}
        complet {{{

            expandera ex-cmd + arg.s ***    c-x c-v     #som på cline; när skriver skript (***)
                                             #el c-q om c-v ej fung.        ___PICKOUT ___SEMER2019

            completion i compl. =när        c-l   #plocka fler ch. =avgränsar listan  ___PICKOUT ___SEMER2019
              flera alt. visas
            avbryt/ångra inmatn.            c-e     ___PICKOUT
              (+ta bort om nyss slutf.) **
            accept. visade alternativet     c-y     #el. bara forts. skriva

            c-x c-l - flera rader           c-x c-l direkt igen (+vidare)       ___PICKOUT ___SEMER2019
              (=efter varandra)

            KEDJ.EXPANSION *****    DUBBLERA EXP. EFTER FÖRSTA MATCH ******     ___PICKOUT ___PICKOUT ___SEMER2019  *********
            ex: expandera långa             c-x c-p/c-n     #c-n/c-p först
              krångl. ord (M&eacute;xico                    # ('bara M')
              o.likn. **)                                   # , sen c-x c-p t.ex. ****

            SEMER ___SEMER2019 (=ev)        HTML COMPLETION (:h insert) + xml-omni-datafile
                                             #=vissa datafiler finns på vims hemsida
                +'filetype' o &ft==javascript (mm)


            spell check/compl.              c-x s, c-x c-s  ___PICKOUT

            SEMER COMPL. XML **** ___SEMER2019      :h ft-xml-omni  ***********
                    (xml-omni-datafile + :XMLns o :XMLent


            visa aktiva syntaxgroups            syntax list     ___SEMER
              för viss pr.lang-fil (php t.ex.)      (=mer/kan vara intress. för
                                                     plugin-developers **)
                                                     :h ft-syntax-omni)         

            cmd-raden:      ___SEMER
                c-r c-w/c-a     #+äv. c-r c-r
                c-r c-f/c-p

            completions c-raden **          c-d, c-a, c-l       ___SEMER

        }}}
        spellcheck {{{
            stavn.förslag               z=
            mark w. as good/bad spell.  zg zG
            mark w. as good/wrong       zw zW
        }}}
        registers viminfo(?) {{{

            "-      last small(!) delete        #mindre än en rad
            "_
            "~      drop register  (=sparar drag/drop-text till gvim **)    ___SEMER EV
                                        + '<Drop> pseudo key'

            c-r {reg}
            c-r c-r
             c-r c-o    ___SEMER    ????
            c-r c-p (**)    ????

            :reg[isters] {arg} / :display [arg]     ___PICKOUT ___SEMER2019


            tips/idé viminfo:           spara redigera egen fil, typ ~/.my_viminfo  #=alltid starta m vissa
                                                                            # /kunna ladda in olika för-inställn. + t.ex. ladda m. autocmd ber. på filtyp(**)

            SE MER:VIMINFO: 'viminfo' flags (r m.fl. *****)  :h viminfo (options) +viminfo i refm_starting      ___SEMER2019
                '       store jumplist **

        }}}
        hyperlink moduleinclude(??=ev egen) {{{

            file in/out                 gf/c-w f/c-w gf  c-i/c-o  NY:  Tab (=c-i) ******
            TAGS IN/OUT ****            C-] / C-VKLICK / g_VKLICK   /   C-T/C-O / C-HKLICK *********
            ----
            file in + till radnr. *****  [count]gF  =på filnamn m. num. efter  #t.ex. fil.c 40  (:h gF) *****       ___PICKOUT ___SEMER2019


             idé/test: red. fil 2        (=testa: 2gf på mappnamn)      ___PICKOUT ___SEMER2019
               i path(??)

        }}}
         (textmode mm/olikn)
        gitcvs {{{
            fugitive
        }}}
        diff {{{

            trick: sätta diff (mm)              'When a window also has the 'diff' option set'  mm (**)
              när redan startat vanl.       (=diffpatch mm) *
              session (*)

        }}}
        netrw projfilemanagbrowse nerdtree      (=LÄGG EV TILL FRÅN GENOML. AV REFMAN-NETRW (****))
        debug {{{

            :h debug-scripts

                    'verbose'
                    vim -D file.txt
                    :debug
                     :breakadd      #+ :h breaka
                            cont
                            quit
                            next
                            step
                            interrupt
                            finish
                            backtrace
                            frame N
                            up
                            down
                     :breakdel

                     :breaklist
                     (:debuggreedy)

        }}}
        egcmd
        .   specialavanc {{{
        }}}
          ---- (#feoav =funct ex opt au vvars) ----
        tagscscope {{{

            If you want to complete system functions you can do something like this.  Use   ___SEMER2019 EV
            ctags to generate a tags file for all the system header files: >
                % ctags -R -f ~/.vim/systags /usr/include /usr/local/include
            In your vimrc file add this tags file to the 'tags' option: >
                set tags+=~/.vim/systags

        }}}
        argwintabbufdo
        tipstricks scripttricks     #infoga stigande räknare mm* {{{

            intress. litet tips/        'om vill att Y ska fung. som D t.ex.
              /idiom ***                  (vilket är mer logiskt):
                                            :map Y y$"  ****

            Som Modeline =utför     ___PICKOUT ___SEMER2019
              action (=annat än att
              sätta option) if _ ****   au BufReadPost * if getline(1) =~ "VAR" | call SetVar() | endif

            cmd med | emellan       :execute 'r !ls' | '[   ___SEMER2019 ___SEMER2019
              =spec.
                    :%g/foo/p|>     moves all matching lines one shiftwidth  **************************

            inställn
                kolla/red. fil på mkt           :h starting +'very slow medium'     ___SEMER
                  långsamt medium (t.ex. floppy)
                reduce access to disk           :h starting +'very slow medium'
                  (e.g. for laptop**)*
                trick: winheight 5 lines        z5 Ent      #maxa igen m. z222 Ent (el likn)
                  (ed-likt =om term/koppl.
                  för långsam att visa mer)


            C-A-ÖKA SIFFRA =HELT BLOCK          1. =markera hela + g c-a **********     ___PICKOUT ___SEMER2019
              ************                      1.  ___PICKOUT
                                                1.
            SÄTT SÅ KAN GÖRA LIKN. LISTOR       nrformats=alpha  (t.ex.)
              M. BOKSTÄVER, HEX MM ****          =äv. bin(0b), octal(01), hex(0x) ****

            räkna saker i vim       :h tips     #'counting words, lines etc.'       ___PICKOUT ___SEMER2019
              (bokst, ord, rader                # +förstås: {vis.}g c-g
               'the' i ord, 'the'
               som ord) ****

            tips: går att spara ut krads/sök-historik till fil *    ___SEMER2019

            If you like to keep a lot of backups, you could use a BufWritePre       ___PICKOUT ___SEMER2019
            autocommand to change 'backupext' just before writing the file to
            include a timestamp. >
                :au BufWritePre * let &bex = '-' . strftime("%Y%b%d%X") . '~'


        }}}
         writeread {{{

            read file (into buf.)           :$r [++opt] name    #start fil =0
            läs in cmds stdout **           :[range]r [++opt] !ls   #shellredir styr hur outp. sparas, inkl. om inkl. stderr el inte **
            läs in cmds out =förra igen *   :[range]r [++opt] !!  **

            read =läs/plocka in ftinfo mm   :r ++edit rfilename     EV ___SEMER
              till editfilen från readfilen
              (???? ***)

         }}}
        substitute  {{{

            :s/patt/str/fl [count]      (count =repl. in c. lines
                                         starting w. last line in range.
                                         if no range =start in curr. line
            (+SE EXEMPEL x2, 2 STYCKEN NEDANF. :h :s% )
                :s/x/X/g 5      ___SEMER2019

            :&              last subst w. same patt/subst (but not flags)
             :&&            Same patt/subst and(!) flags ****
            :~  :&r
            senaste :s igen         &
                        obs: flags not remembered
            senaste :s igen på      g&  ****
              hela(!) filen (**)
                    &&(=??)

            SUBST: UPCASE/LCASE-FLAGS           :s/\v<(.)(\w*)/\u\1\L\2/g       ___SEMER2019
              ******

            subst.string
              &   ******
             ~              samma repl. som förra       #samma patt. som förra; % =samma replacement som förra (**??)
             \u         nästa tecken ucase
             \U         kommande t. ucase, tills \E
             \l         nästa t. lcase
             \L         kommande t. lcase, tills \E
             \e         samma som \E (utom <Esc>! ??)
            flaggor
             e          DO NOT STOP ON ERRORS
             r

            Ersätt bara i vis.mark              /\%V  ****      ___PICKOUT ___SEMER2019
              om området =v.block-mode ***

            Subst. w. Expr. ****        ___PICKOUT ___SEMER2019  ******
            subst. eol w. nl.       :s@\n@\="\r" . expand("$HOME") . "\r"@
              +$HOME-val.
            subst. 'E' w. euro      s/E/\="\<Char-0x20ac>"/g  #:h <Char-> ***
              sign ****

            https://stackoverflow.com/questions/17319557/search-and-replace-in-vim-in-specific-lines        ___PICKOUT ___SEMER2019
                    https://vi.stackexchange.com/questions/3267/how-to-replace-specific-lines-with-regex
             :5,12s/\(\%5l\|\%12l\)foo/bar/g


        }}}
        global {{{

            def.cmd för global          :p  **

        }}}
        filter {{{

            grundsyntax*            address(symbol/rader)!cmd
            ('FILTER NONDESTRUCT.') :[range]w !cmd      #t.ex. :10,30w !sort    #=send lines to cmd
            motion(G) till          !G+cmd<CR>
              !-filtrering ***
            5 rader till !-f. ***   5!!

        }}}
        maps {{{

            :lmap och digraph/unicode-char(???)         se mer :h f
              #+ i_c-^  ???



              1.4 LISTING MAPPINGS                  *map-listing*

              When listing mappings the characters in the first two columns are:

                    CHAR    MODE    
                   <Space>  Normal, Visual, Select and Operator-pending
                  n Normal
                  v Visual and Select
                  s Select
                  x Visual
                  o Operator-pending
                  ! Insert and Command-line
                  i Insert
                  l ":lmap" mappings for Insert, Command-line and Lang-Arg
                  c Command-line

             Bygg kombo för ej fördef. läges-kombo ** -- Def. inkluderande + ta bort mapping för ett läge
                (='ett/flera lägen för mycket + extrahera ej önskade lägen' ***)    ___PICKOUT

              Just before the {rhs} a special character can appear:     ___PICKOUT ___SEMER2019
                  * indicates that it is not remappable
                  & indicates that only script-local mappings are remappable
                  @ indicates a buffer-local mapping

        }}}
        oppending (+operat) {{{

            .operators {{{
                c
                d
                y
                ~, g~
                gu, gU
                !, =
                gq, g?
                >, <
                zf
            }}}
            g@      call function for mapping   #=se mer 'egna skript/vimskript' ****       ___PICKOUT ___SEMER2019
            gn  (=kan ev. ses som en sorts operator(**))    ___SEMER EV

            TIPS OP.+MOTION: :-KOMM.        semer :h exclusive-linewise (tre stycken ner) ___SEMER2019
              FÖR MOTION ***                    # d:call search("f")<CR>  t.ex.

            Sudda fr. c. till c.            dvj     # :h o_v (upp till: 'forcing a motion to be linewise,')
              raden rakt under **** (=NY)
                                            d<c-v>j
            ----
            tips: $ och g_                  2$ (el. fler) går till nästa rad

            mid. line                       gm

        }}}
        execute
        vimscript {{{

            villkorl. körning: beroende         if has("browsefilter")      ___SEMER2019
              på version/features *              has('crypt-blowfish2')
                                                 v:version >= 703
                                                 v:version > 704 || (v:version == 704 && has('patch401'))

            operator:
            g@      call function for mapping   #=se mer 'egna skript/vimskript' *****      ___SEMER2019

        }}}
        vfunction(*) {{{

                expand()

                fnameescape()
                shellescape()
                 glob(nåt)()???

                getline('.')
                col()
                prompt????
                getchar()

                sort()
                uniq()

                substitute() ??
                submatch(0), submatch(1)

                bufnr()

                str2float()

                filereadable()
                isdirectory()
                mkdir()


                has()


                undotree()      =talar om namn vim skulle anv. för u-file
                                 för aktuella filen

        }}}
         egdef
        keybshortc keyspecnot egdef {{{

            LISTA K.SHORTC. I VIM ****              :h index (=refman index ****)

            .(lediga tangenter (=för mappings)) {{{

                TPOPE: NO LEADER (=???)     ___SEMER2019 EV
                            http://vimcasts.org/blog/2014/02/follow-my-leader/

                    idé för att kolla lediga mappings: keydb-drs(___nomap ___map(ped))

                ,(leader)  -(localleader)

                i_c-h       #emmet 2019?
                i_c-l
                 i_c-q
                c-b
                ----
                n_<BS>
                n_c-h
                n_c-k
                n_c-n/p
                n_c-q/s
                n_c-_

                S/cc **
                U (??)
                X (??)
                '_'
                zX??
                pageup/dn
                c-end (m.fl.)
                del
                Piltang.    #Idén2019: 'Resize splits' ********************* (c-w +/-/>/< ***)
                insert *
                 vklick(??)     #=idéer av typen 'klicka ord för att grepa/söka det' **/??
                ----
                g c-k (mm =l, m osv)
                c_c-g
                c_c-q(?)
                c_c-t *
                + / c-m

            }}}
            namn spec.keys/keys     :h key-notation
              i script ***              <Space>, \< <lt>, \\ <Bslash>, <Bar>, <EOL>, <S-Up>, <S-F12>, <Insert>, <PageDown>, <kHome> <kPlus>  <k0>, <M- > <D- >, 
                                        <T-F5>      https://stackoverflow.com/questions/327415/can-windows-key-be-mapped-in-vim
                                        <ScrollWheelUp> <ScrollWheelDown>  <S-LeftMouse> <MiddleMouse> <RightMouse> <2-LeftMouse>


            te: screen repres. of   stycket under :h wrap-off
              spec char.s (t.ex. Tab =^[) ***
            \<Home>, <lt>lt>        ___SEMER2019        #precis ovanför :h vim-modes

        }}}
            NY IDÉ 2019 GENOMGÅNG/DOKUMENTATION/INLÄRNING EXC/VOPT/AUCMD/AUEVENT/VVARS *****    ___PICKOUT ___SEMER2019
                =LÄGG INLÄRDA/ANVÄNDA/PERS.KÄNDA CMD MM I SEPARAT LISTA ÖVERST
                (+LÄS IN O TESTKÖR M. NÅGRA EXEMPEL, SÅ VET HUR DE FUNKAR **********)       2019++: +SKRIV EN SAMMANFATTNINGSFRÅGA/FRAS
                                                                                            FÖR VARJE (=visa nummer för bokstav/tecken t.ex. 
                                                                                            (=def. från uppgifter som förekommer i programmeringen i VimL ****))
        cmdrad excommands(*) {{{

            cline/search-hist win ***           q: q/  //  c-f

            history                 :history / 6,12j    # ?:/= @>
                                    :history all -5     #senaste 5
            keeppatterns cmd        kör cmd utan att ändra history


              'ex-flags'            l, #, p (+kombo)    #:list, numbers, :print

            num.range till ex-cmd ****      10: *****
            cline compl.                    tab/c-i     #c-a matar in alla(!) matches
            nä./förra cmd-hist (ej filtr.)  s-upp/ner
            flera ex-cmd på en ex-rad **    :verbose set compatible? // |

            append text below lines         :20append!      #!=toggle autoindent
            insert text above lines         :10insert!      # =tills rad m bara '.'
                        :startinsert[!]
                        :stopinsert
                        :startreplace[!]
                        :startgreplace[!]

            :[range]delete [x]
                    :23d 4
                :[range]delete [x] {count}
              :dl
              :dp
            :[range]join[!] {count} [flags]

            :{range}change[!]           replace lines w. diff. text
                                         #!=toggle autoind.; +=tills rad m bara '.'
            :[range]yank [x] {count-lines}
            :[line]put [x]              :put! =klistra in innan(!) rad
                :put ='path' . \",/test\"
            :[range]copy {targetline-address}
            :[range]move {targetline-address}




            :[range]sort[!] [iubfnox][r] /{pattern}/  ___PICKOUT ___SEMER2019
                ! =reversed
                patt =bortse fr. text som matchar /pattern/
                        :sort /[^,]*,/      #sortera på andra ,-sep. fältet
                r =sortera enbart(!) efter text som matchar /patt./
                        :sort /\a\a\a/ r    #sortera på enb. tre första ch. i rad
            TIPS ANG. PATTERN ******        GÅR ATT GÖRA // (=FÖRRA PATT.)
                                              SOM VANL. =TESTA SÖKMÖNSTER FÖRST ********


            :setfiletype {filetype}

        }}}
        voptions(*) {{{

            :options // :browse set
            mer detalj. info =fr.   Ent på korta hjälptexten till hö. **
              :options-fönstret **
            red./sätt option fr.    red. värdet + ent  #=när pek. på set-raden
              :options-fönstret ***

            visa satta options      set         :h set-option
              (=ej def. value)
            visa värde option       set option? / set option= + Tab
            toggle option           set option! / set invoption
            återställ o. till def.  set option&     #+&vi &vim
            (återställ alla(!) o.   set all&)
                += -=
                ^=
            sätt så varifr. o.      :verbose set option1 o2?
              satts visas

            visa local-o.           setlocal
            ----
            setlocal                ev semer :h :setlocal
            setlocal all
             återställ l.o. m.      setlocal makeprg=
               värde till global/def.   #obs: ovan =kopierar g.värdet(!!)
            setlocal option<        återställ bool-opt. till def. =global-o.värdet
            set option<
            setglobal
            setglobal all

            kolla om option stöds/  if exists('&foo') / if exists('+foo')
              /faktiskt är 'hidden'   (=existerar inte men går att sätta utan err.)

              arabicshape
              browsedir

                cpoptions  ???

                buftype
                bufhidden
                buflisted
                charconvert  iconv()

                wildchar
                wildignorecase
                wildmode        (t.ex. longest, list)
                suffixes        (refman cmdline completion)
                wildignore      helt ignorera filer m vissa ändelser

                undofile        =spara u-trädet i fil *** (+:h undo-persistence för ex. för skippa för vissa filer)
                undodir         =var undofile sparas

                nrformats       bin, octal, hex, alpha
                comments        =specar format för kommentarer i pr.lang

                shellredir

                complete
                    completeopt  ___zzzz
                 completefunc   =def. för hur c-x c-u (userdef. compl) expanderar **
                 omnifunc       =def. för omnifunc. :h compl-omni-filetypes
                dictionary
                thesaurus
                infercase
                    ignorecase
                    smartcase
                 showfulltag    =add context from around tag def. (vid c-x c-]-compl.)
                iskeyword
                isfname         =anv. för gf mm **
                ----
                define      =vad räknas som def. (c-x c-d)
                include     =format för include-files (*)
                tags ***  =likn. path =sökväg för tags-filer ????
                path

                cmdheight   ='helps avoiding hit-enter prompts' *
                cmdwinheight    num of screenlines for cmdwin
            (lines break display wrap mm)
                scrolloff       #scroll-offset =extra rader runt markör när går utanför skärmen ***

                scrollbind      +scrollopt(=hur scrollbind beter sig mm)
                ----
                list
                showcmd
                 ruler
                wrap
                textwidth
                    formatexpr
                wrapmargin
                  whichwrap     =del. linebreaks/joining lines
                linebreak
                  display
                helpheight      #def. 20
                highlight(+@)
                showbreak
                    tips: 'nu' o breaks     (='showbreak till 8 blanksteg')
                    sidescroll
                columns         hor.maxa fönster = :set columns=9999 i gvimrc

                comments
                commentstring

                ----
                 equalprg
                 makeprg
                shiftwidth **
                softtabstop
                tabstop
                expandtab
                 smarttab
                 smartindent
                 cindent
                  cinkeys
                  cinoptions
                  cinwords
                 autoindent         =anv. samma som förra raden
                (:h indent)
                 indentexpr
                breakindent
                breakindentopt

                breakat

                colorscheme
                background          (dark/light)

                lisp
                lispwords


                runtimepath
                helplang

                clipboard (=BufEnter och html mm) **

                autowrite
                autowriteall

                backup
                backupcopy
                writebackup
                backupext
                patchmode
                backupdir
                backupskip

                binary      ++bin

                ballon*(=options) + v:beval_

        }}}
        aucmd {{{

            exempel (för retab! av kodfiler) vid  :h retab-example

        }}}
        auevents(*) {{{

            complet
                CompleteDone            compl.match done
            filebufread mm
                BufReadPost
                BufWritePre
                BufWritePost
                BufNewFile
            scriptsource
                SourcePre               innan :source

        }}}
        abbrev
        vvars(*) {{{

            v:searchforward                 sökriktn. för senaste sök (+ "/ ??)

        }}}
        ftplugins * {{{



        }}}
        grepagvimgrep
        redprogrkod editsourcecode******** (gd, gD, [I mm mm) *****  TODO: PROVA MED JAVA/C** + ÖVERFÖR TILL LILY**** {{{

            vim som server mm, för
              netbeans(*), , Lista/Sammanst. bra tips           :h tips
              +interna länkar ='Tips
              redigera C-kod i Vim' ****
            TIPS/IDÉ(TODO): RED. C-KOD ***      PLOCKA UT KOD FÖR NÅGRA PROJEKT (T.EX. NEOVIM)
                                                 +TESTA/SÄTT ATT NAVIGERA RUNT I KODEN *****
            skapa databas över f/var-defs       mkid + lid ___SEMER2019     #grep går, men långsamt
              (=tags)

            ]]
            []
            ][
            [[

            ])
            ]}

            ]m ]M           #java mm-methods    +t.ex.  3[m

            ]#
            ]* el. ]/

            tips/idé: 'if your.*are not in the first column' {{{
                se mer: refman motion:
                    'If your '{' or '}' are not in the first column, and you would like to use "[[" and "]]" anyway, try these mappings:' =???/***
            }}}

        }}}
        makecompile
        qfloclist
        vimscr plugindoc {{{

            :h :<cword>     (cmdline.txt)
            word            <cword>, <cWORD>
            fname           <cfile>
            aucmd           <afile>, <abuf>, <amatch>
            script/source   <sfile>, <slnum>

            IDÉ TESTA VIMSCR.KOD(****)      kör i exmode (el. enhanced exmode)      ( ___SEMER2019 EV )
             'DRS 2019'                     = vim -E (-e standard)  +gQ (**** testa)

            :redraw
            :redrawstatus

            ==================================

            markup för tag          *{tag}*     #ger '{tag}' i bold colored (*)

            lägg till/skapa         se :h add-local-help / write-local-help
              eg. dokum./helpfil **     el.(?) se :h help-writing *****  (+RUNTIME/syntax/help.vim )
            lägg till/bygg alla     :helptags dir(??) ___SEMER2019 (=ev)
              tags (*ord*) från
              eg. dokumentation *****
                    (+se precis ovanför  :h debug-scripts)
            söka h. på egen dok(??)  t.ex. sök på 'LOCAL ADDITIONS'
            ----
            översätt h. till        help.lgx    #mm
              språk (*)

        }}}
        sourcerecrunscript {{{

            kör fil m. vimred.komm.s (t.ex.         vim -e -s procfile.txt < vimkommfil.vim     #exmode silent
              :sXXXXXXX, :write, :quit)             #el.  vim -e -s  <thefilter  thefile
              som ett skript ****
            skript m. keystrokes                    vim -s keycommskriptfil
              (='normal'-commands) **                 :source! keycommskriptfil
            spela in -s-skript(append)*             vim -w scriptoutfil
            spela in -s-skript(overwrite)*          vim -W scriptoutfil
            ----
            kör skript i debug-läge *               vim -D skriptnamn(?)


            source excommands-script            :source {file}      ___PICKOUT ___SEMER2019
            source normalcommands-script        :source! {file}

            läs in skript/plugin(s)         :runtime! syntax/c.vim
              =från path(s) (****)           # !=alla som hittas anv.
                                             #  =första som hittas anv.


            :packadd!
            :packloadall!
            (:scriptencoding)
            :scriptnames (***)
              :finish



            :h package-create           #=plugins-package, github mm ***

        }}}
        modeline
         convert **         #txt2html,pdf
        menu
        ----
        dev {{{

            coll. info ab. your     :so $VIMRUNTIME/bugreport.vim
              system (=for bugreport(*))

            --startuptime
            -V[N]           #verbose **
            -v[N]logfilnamn

        }}}

}}}
.   ((.plocka)) {{{
   GENOMGÅNG/ANKISOURCEFRÅGOR (lista att lägga rätt mm) {{{
    pppp
    U
    undo trees
    byt ut ett ord/en sträng i flera filer
    This can be done with just one command: >
    :%s/\([^,]*\), \(.*\)/\2 \1/
    kasta om rader (=vänd bak och fram på en fil)
    :g/^/m 0
    :'t+1,.g/^/m 't
    g ctrl+g
    For other ways to count words, lines and other items, see |count-items|.  SE MER :D
    While editing a shell script or C program, you are using a command or function{{{
    that you want to find the man page for (this is on Unix). Let's first use a
    simple way: Move the cursor to the word you want to find help on and press >
    K
    Vim will run the external "man" program on the word. If the man page is
    found, it is displayed. This uses the normal pager to scroll through the text
    (mostly the "more" program). When you get to the end pressing <Enter> will
    get you back into Vim.
    aaaa aaaa
    A disadvantage is that you can't see the man page and the text you are working
    on at the same time. There is a trick to make the man page appear in a Vim
    window. First, load the man filetype plugin: >
    :runtime! ftplugin/man.vim
    Put this command in your vimrc file if you intend to do this often.
    can use the ":Man" command to open a window on a man page: >
    Now you
    :Man csh
    You can scroll around and the text is highlighted. This allows you to find
    the help you were looking for. Use CTRL-W w to jump to the window with the
    text you were working on.
    To find a man page in a specific section, put the section number first.
    For example, to look in section 3 for "echo": >
    :Man 3 echo
    To jump to another man page, which is in the text with the typical form
    "word(1)", press CTRL-] on it. Further ":Man" commands will use the same
    window.

    To display a man page for the word under the cursor, use this: >
    \K

    (If you redefined the <Leader>, use it instead of the backslash).
    For example, you want to know the return value of "strstr()" while editing
    this line:
    if ( strstr (input, "aap") == ) ~
    Move the cursor to somewhere on "strstr" and type "\K".
    A window will open
    to display the man page for strstr().
}}}
    vim `grep -l frame_counter *.c`
    VIMGREP (Hitta ord inne i filer i buffertlistan i vim :DDD )
    ctrl+z
    {andra kommandon i skalet mm}
    fg
    o
    :shell
    :!xterm&
    gå direkt till nån av nio filer som red.ades innan nuvarande = '1-'9 :D   se var du hamnar m hj av :marks :)
    SESSIONS :){{{
    session = en sittning (=alla fönster som var öppna, filer i buffertlistan mm) :D
    SESSIONS AND VIMINFO :DD
    Sessions store many things, but not the position of marks, contents of registers and the command line history. You need to use the viminfo feature for these things.
    In most situations you will want to use sessions separately from viminfo.
    This can be used to switch to another session, but keep the command line history. And yank text into registers in one session, and paste it back in another session.
    You might prefer to keep the info with the session. You will have to do this yourself then. Example: >
    :mksession! ~/.vim/secret.vim
    :wviminfo! ~/.vim/secret.viminfo
    And to restore this again: >
    :source ~/.vim/secret.vim
    :rviminfo! ~/.vim/secret.viminfo
    o
    Exempel på användning :D
    :wall
    :mksession! ~/.vim/secret.vim
    :source ~/.vim/boring.vim
    If you open help windows, split and close various window, and generally mess up the window layout, you can go back to the last saved session: >
    :source ~/.vim/boring.vim


    For example, this is a nice layout to use (s102):
    This has a help window at the top, so that you can read this text. The narrow vertical window on the left contains a file explorer. This is a Vim plugin that lists the contents of a directory. You can select files to edit there.
    More about this in the next chapter.
    Create this from a just started Vim with: >
    :help
    CTRL-W w
    :vertical split ~/
    You can resize the windows a bit to your liking. Then save the session with: >
    :mksession ~/.vim/mine.vim
    Now you can start Vim with this layout: >
    vim -S ~/.vim/mine.vim
    VIEWS :] (s103)
    grund


   zzzz
    view med namn
    (s149)
    :mkview
    This will store the settings and other things that influence the view on the file. You can change what is stored with the 'viewoptions' option.
    :loadview
    When you come back to the same file later, you can load the view again: >
}}}

    MODELINES (=sätta options för en speciell fil) :DD (s104) SE MER
    (som första el sista 5 rader i en fil) /* vim:set shiftwidth=4: */
    skifta mellan unix och windows (s103) se mer ev
    WRITE :D
    o
    spara ut nuvarande rad till filen 'nyfil.txt'
    :.w /tmp/nyfil.txt
    :.write otherfile
    :.,$
    lägg till hela nuvarande fils innehåll till sist i filen 'loggfil' :DD
    :w >> logfile
    skriv över utfil med nuvarande rad från nufil
    :.w! utfil
    o
    spara som :)
    :sav filkopia.txt
    Vim will mark the file as "not edited". This means that Vim knows this is not the file you started editing. When you try to write the file, you might get this message:
    E13: File exists (use ! to override) ~
    This protects you from accidentally overwriting another file.
    skriv ut vad filen heter
    :f
    REDIGERA KOMMANDOHISTORIK :DDDDDDD
    o
    SUBSTITUERING [:s///]
    The general form of this command is as follows: >
    :[range]substitute/from/to/[flags]
    from' är i själva verket ett mönster/regex :DDD (t ex \<from)
    g/mönster1/s//mönster2/
    flaggor/växlar för substituering
    g
    global (=ersätt på alla ställen i raden)
    p
    print
    :s/this/that/p
    e
    Error setting the text for the following input: =att inte hitta ordet för utbytet är inte error (=stoppar inte inspelade kommandosekvenser när inget hittas :). <#ID_576869931>
    c
    confirm
    y
    yes
    n
    no
    a
    all
    q
    quit
    l (litet L)
    last
    ctrl+e
    rulla ner bilden en rad
    ctrl+y
    rulla upp bilden en rad
    n
    byt ut saker som innehåller snedstreck :)
    :s+one/two+one or two+
    :s:one/two:one or two:
    osv
    gör utbyte bara inom range :)
    :1,5s/this/that/g
    :.+3,$-5
    tre rader efter markörsraden till fem rader ovanför filens sista rad
    gör utbyte i range mellan märke t och märke b :DD
    :'t,'b
    visiual range-märkning
    :'<,'>
    från slutet av markering till slutet av filen :]
    :'>,$
    gör utbyte bara på en viss rad
    :54s/President/Fool/
    byt ut i nuvarande raden t o m sista raden
    :.,$s/yes/no/
    mönster som adress-range: byt ut grey mot gray i nuvarande kapitlet
    :?^Chapter?,/^Chapter/s=grey=gray=g
    rad-offsets :DDD
    o
    Then you can specify an offset.
    To search for a pattern and then use the line above it: >
    /Chapter/-1
    o
    You can use any number instead of the 1.
    To address the second line below the match: >
    /Chapter/+2
    ange 5 rader fr o m nuvarande :DDD
    When you know how many lines you want to change, you can type the number and then ":". For example, when you type "5:", you will get: >
    :.,.+4
    byt ful mot snygg på alla ställen i nuvarande kapitlet
    :?^Chapter?,/^Chapter/s=ful=snygg=g
    Ta bort helt tomma rader
    :%s/\s\+$//g
    o
    skifta plats på två ord
    använd fångande parenteser + byt plats på innehållet med \2 och \1
    o
    :s
    o
    ???????????????
    öppna man-sida från ord i text inne i vim
    ta bort helt tomma rader i filen
    vänd bak och fram på fil :D
    :g/^/m0
    o
    READ :D
    läs in innehållet i filen patch.txt till sist i nuvarande filen
    :$r patch.txt
    läs in resultatet från kommandot ls i filen (=hamnar raden under markören) :)
    :r !ls
    not från anteckningarna: kommandot till höger ska också kunna ha växlar :D
    läs in resultatet från kommandot 'date -u' till överst i filen
    :0r !date -u  :)
    placera in fil a efter raden med 'mönster'
    :/mönster/r mapp/a
    läs in innehållet från alternativa filen i nuvarande filen :]
    :e #
    FILTRERA TEXT MED BASHKOMMANDON :DDDDD
    REGLER::
    x.Textblock måste vara mer än en rad
    x. Hela raderna påverkas :)
    Filtrera textblock genom kommando :DDDD
    ![blockadress][kommando]
    !{motion/rows}{program}
    t ex: !)kommando  :)
    textblocksoperatorer: :)
    gg
    G
    { }
    ( )
    [[  ]]  (?)
    +
    -
    skicka från nuvarande rad till rad 20 för filtrering av kommando
    :.,.+20!kommando
    filtrera t o m rad 5 med sort
    !5Gsort<Enter>
    Error setting the text for the following input: =filtrera från nuvarande rad till rad 5 med sort och sätt in på orginalplats :).
    Filtrera hela filen
    :!%sort
    Filtrera hela filen (numerisk sort)
    :!%sort -n
    filtrera texten i filen med cat och sätt in radnummer:
    :%!cat -n %
    sortera baklänges
    :sort!
    filtrera från nuvarande rad till raden innan tom rad genom sort
    :.,/^$/-1!sort
    filtrera från nuvarande rad till rad 20 med sort och sätt in på orginalplats
    20!!sort
    :)
    !20!sort
    :.,.+20!sort
    filtrera nästa 10 rader med sort och sätt in på orginalplats
    !10+sort
    :)
    10!+sort
    filtrera nuvarande rad genom filter
    !!kommando :)
    (=samma som :.!kommando :)
    byt ut nuvarande rad mot resultatet för kommandot date
    !!date
    räkna antalet ord i nuvarande fil m hj av wc
    :w !wc  :DD
    gg, !Gwc     =INTE! (räknar men ersätter hela filen med resultatet.
    skicka all text från nuvarande filen till specat kommando
    :w !kommando
    Repetera föregående filtreringskommando
    ! objekt !
    ??????? :]
    o
    :96,99!sort
    skicka nästa mening genom kommando x
    !)kommando
    kör nuvarande rad genom kommando x
    !!kommando
    kör nuvarande rad+4 genom kommando x
    5!!kommando
    kör nuvarande rad+3 genom sort
    4!!sort
    !4!sort
    kör kommando på nästa 10 rader
    !10+kommando
    10+!kommando
    -----
    skicka nuvarande rad+4 rader framåt till kommando t ex för redigering (förbered för redigering) :)
    5: (=ger :.,.+4)
    :)
    . förbered nästa mening för redigering
    !)
    . ändra allt i fil från gemener till versaler
    tr '[a-z]' 
    Options för extern kommando-filtrering
    s79 i vim user manual
    skillnaden mellan !!date och :r !date :DDD
    vim softtabstops :) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim--converting_tabs_to_spaces.html>
    Error setting the text for the following input: =kolla med abbe och krister om vilka inställningar de använder (för python mm) :D.
    dra in block en shiftwidth
    >
    ta bort en shiftwidth för block
    <
    :se autoindent
    :se smartindent
    :se expandtab
    :se tabstop=4
    :retab
    :.retab
    :retab 8 (??)
    :se shiftwidth=4
    :se softtabstop=4
    backspace kommer att hantera 4 spaces som en tab :)
    (+det kanske finns färdiga extra filer och paket att installera för python och vim?? (testkörning mm=? :)
    TABS OCH INDENTERA/DRA IN BLOCK
    dra in fyra rader en indent :DD
    4>>
    dra in block en shiftwidth
    >
    ta bort en shiftwidth för block
    <
    mata in/ta bort tab [insertmode]
    ctrl+t/ctrl+d
    :se autoindent
    :se smartindent
    CONVERTING TABS TO SPACES och SOFTTABSTOPS :DDD (25.3 s129)
    :se expandtab
    :se tabstop=4
    :retab
    :.retab
    lägg om tabstop till 
    :set tabstop=3
    :retab 8
    (s129)
    :se shiftwidth=4
    :se softtabstop=4
    backspace kommer att handera 4 spaces som en tab :)
    vim colorschemes <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+color+schemes&ie=utf-8&oe=utf-8>
    THE GUI
    status på filen :)
    -
    cannot be modified (e.g., a help file)
    +
    contains changes
    =
    is read-only
    Error setting the text for the following input: =+.
    is read-only, contains changes anyway
    If nothing is shown you have an ordinary, unchanged file.
    -- s65
    clipboard - s66
    options
    :set selectmode+=mouse
    s67
    BLANDADE EX-KOMMANDON :)
    skicka x antal rader till kommandoraden för redigering
    :.,.+4
    5:
    SKRIV UT
    :ha(rdcopy)
    You can specify that a different printer is used with :set pdev=printer. For example, :set pdev=usblp1
    skriva ut/ange printrange (=????) :)))
    mer om printing :) <http://vim.runpaint.org/basics/printing/>
    If you have a PDF printer installed1, you can use this technique to print a file to PDF. For example, assuming your PDF printer is called pdf:
    set pdev=pdf
    set printoptions=paper:A4,syntax:y,wrap:y
    The printoptions line is a comma separated list of values that affect how Vim formats the document before it sends it to the printer. A list of options is at :help popt. The paper option sets the paper size. It accepts values such as A3, letter, and legal. The syntax option determines whether the document is printed with syntax highlighting. By default it has the value a which means that Vim only uses highlighting for colour printers. A value of y forces highlighting. Lines are wrapped when wrap:y, which is the default. If wrap has the value n, long lines are truncated. Other useful options are header:0 to stop a header from being printed, number:y to number lines, duplex:off to print on only one side of the page.
    FLYTTA, KOPIERA MM :)
    ??? flytta raderna 13-14 till överst i filen ???
    ???
    SPELA IN KOMMANDOSEKVENSER :)
    spela in kommando-sekvens till a-registret
    qa
    kör inspelade kommandot i a-registret
    @a
    kör senast körda inspelade kommandosekvensen igen
    @@
    utför inspelade kommandosekvensen a 3 gånger
    3@a
    avsluta inspelning av kommandosekvensen
    kör senast körda q-kommandot igen
    lägg till sökning efter 'mönster' med / sist i kommandoregistret c
    anv C (se mer)
    kopiera och lägg till rad sist i register a
    anv C (se mer)
    VISUAL MODE
    v
    V
    Ctrl+v
    o
    gå till hörn diagonalt mittemot :D
    O
    gå till hörn HORISONTELLT mittemot
    VIMRC
    syntax för kommando, t ex :set incsearch i .vimrc-filen :]
    set incsearch
    s36+ [kolla options]
    set nocompatible
    set backspace=indent,eol,start
    set autoindent
    sätt backup (+extra)
    if has("vms")
    set nobackup
    else
    set backup
    endif
    set history=50
    set ruler
    set showcmd
    set incsearch
    mappings
    map Q gq  :)
    This defines the "Q" command to do formatting with the "gq" operator. This is how it worked before Vim 5.0.
    vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>
    This mapping yanks the visually selected text and searches for it in C files.
    This switches on syntax highlighting, but only if colors are available
    if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
    endif
    filetype plugin indent on
    This switches on three very clever mechanisms:
    Filetype detection.
    Using filetype plugin files
    Using indent files
    autocmd FileType text setlocal textwidth=78
    This makes Vim break text to avoid lines getting longer than 78 characters. But only for files that have been detected to be plain text.
    sök i :h på line-continuation
    sed -ie 's/.*/the_heart_asks_pleasure_first/' .dfs2rc
    MAPPINGS
    listade vid .vimrc :)
    :map <F5> i{<Esc>ea}<Esc>
    mapping för att omge ett ord med måsvingar
    :map Q gq
    o
    :map \p i(<Esc>ea)<Esc>
    :map \c i{<Esc>ea}<Esc>
    lista alla angivna mappings
    :map
    :)
    :vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/*.c *.h"<CR> (s37 i user manual) :)
    Namn på vanliga tangenter i mappings :DDD
    o
    specialnamn för F-tangenter mm <http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_2%29>
    specialnamn för F-tangenter mm <http://vimdoc.sourceforge.net/htmldoc/map.html#mapping>
    f5
    <F5>
    escape
    <Esc>
    enter
    backspace
    <BS>
    bra tangentkombinationer för nya mappings
    F2-12
    \p
    _x
    ,x
    (-x)?
    SYNTAX HIGHLIGHTING = se mer ev s44
    slå på syntax highlighting
    :syntax enable
    PLUGINS
    listade vid .vimrc :)
    var lägga plugins
    lägg i pluginmappen :)
    två sorternas plugins
    global plugin: Used for all kinds of files
    filetype plugin: Only used for a specific type of file
    plugin directory
    Unix
    ~/.vim/plugin/
    :)
    Instead of putting plugins directly into the plugin/ directory, you may better organize them by putting them into subdirectories under plugin/. As an example, consider using "~/.vim/plugin/perl/*.vim" for all your Perl plugins.
    The Vim distribution comes with a set of plugins for different filetypes that you can start using with this command: >
    :filetype plugin on
    The scripts in $VIMRUNTIME/macros are global ones, the filetype plugins are in $VIMRUNTIME/ftplugin.
    *lägga till nya help-filer för en plugin :) (s41 manualen)
    Copy the help file to the "doc" directory. >
    :!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc
    Now comes the trick, which allows you to jump to the subjects in the new help file: Generate the local tags file with the |:helptags| command. >
    :helptags ~/.vim/doc(=sökväg till dokumentationen)
    Now you can use the > :help g% command to find help for "g%" in the help file you just added.
    You can see an entry for the local help file when you do: >
    :help local-additions
    ((se ev även write-local-help))
    FORMATERA TEXT (=t ex alla rader lika långa mm)
    sätt textbredd till 72 tecken
    :se textwidth=72
    formatera om nuvarande stycke så det rättar sig efter formatering (t ex 72 teckens radbredd)
    gq ap
    formatera om hela filen så det rättar sig efter formatering
    gggqG
    formatera nuvarande rad och gå till nästa
    gqj
    gU/gu
    ord till stora bokstäver
    gUw
    ord till små bokstäver
    guw
    byt case på tecken
    g tilde
    Dubblera ovanstående för att påverka hel rad :DDDD !!!!!
    g tilde
    g~
    gUgU(gUU)
    gugu(guu)
    g tilde x2(g tilde tilde)
    g~~
    byta case på visual-markerad text (till upper)
    U
    :set wrapmargin=4 (=bryt rad med hård radbrytning när är 4 tecken från terminalkanten)
    ÅTERHÄMTA EFTER EN KRASCH
    öppna fil help.txt som redigerades när syst. kraschade
    vim -r help.txt :)
    (därefter)
    To be on the safe side, write this file under another name: >
    :write help.txt.recovered
    Compare the file with the original file to check if you ended up with what you expected. Vimdiff is very useful for this |08.7|. For example: >
    :write help.txt.recovered
    :edit #
    :diffsp help.txt
    options
    updatetime'
    updatecount'
    If you were editing without a file name, give an empty string as argument: >
    vim -r ""
    Vim can store the swap file in several places. Normally it is in the same directory as the original file. To find it, change to the directory of the file, and use: >
    vim -r
    mm SE MER EV EV SENARE
    o
    o
    o
    o
    Editing formatted text - s126
    REDIGERA KOMMANDORADEN
    gå ur kommandoraden
    Esc/Ctrl+c
    gå ett ord åt vänster/höger
    ctrl+vänster/höger :]
    komm.radskommando: gå till början av :-kommandorad
    Ctrl+b
    komm.radskommando: gå till slutet av :-kommandorad
    Ctrl+e
    komm.radskommando: sudda ord
    Ctrl+w
    komm.radskommando: ta bort allt inskrivet fram till slutet på :-kommandoraden :) [=TESTA]
    Ctrl+u :)
    komm.radskommando: sudda allt hittills inskrivet på :-kommandoraden
    ??
    i :-kommandorad: slutför ord så långt det går för gå igenom alternativ ett efter ett
    Tab (ev x2)
    gå tillbaks till förra ordet (motsatt tab)
    ctrl+p
    i :-kommandorad: lista alla alternativ för påbörjat ord (samma som 2T i skal när flera alternativ finns)
    Ctrl+d
    samma som tab i detta sammanhang :)
    Ctrl+L
    gå till senaste :-kommandot som börjar m 'se'
    :se + pil upp :]
    ta reda på nuvarande värden på options m hj av tab :DDDD
    Gives: >
    :set iskeyword
    Now type "=" and press <Tab>: >
    :set iskeyword=@,48-57,_,192-255
    What happens here is that Vim inserts the old value of the option. Now you can edit it.
    What is completed with <Tab> is what Vim expects in that place. Just try it out to see how it works. In some situations you will not get what you want. That's either because Vim doesn't know what you want, or because completion was not implemented for that situation. In that case you will get a <Tab> inserted (displayed as ^I).
    o
    lista slutföringsträffar för ett ord :D (som 2x tab i skalet)
    ctrl+d :)
    slutför ord till längsta möjliga icke tvetydiga sträng :)
    ctrl+L
    More about all of this here: |cmdline-completion|
    visa history för :-kommandona
    :history
    visa history för /-sök
    :history /
    visa history för
    öppna fönster och redigera kommandoradshistoriken :DDDD
    *20.5* Command line window
    Typing the text in the command line works different from typing text in Insert mode. It doesn't allow many commands to change the text. For most commands that's OK, but sometimes you have to type a complicated command. That's where the command line window is useful.
    Open the command line window with this command: >
    q:
    Vim now opens a (small) window at the bottom.
    It contains the command line history, and an empty line at the end:
    FOLDS
    :se foldmethod=indent(/syntax)
    gå till föregående/nästa undanvikning :DDDDD
    zk/zj
    fold – grund: skapa fold i vim
    zf
    fold – grund: öppna/stäng alla folds direkt :)
    zi
    om foldmethod satt till indent: vik undan indenterat block
    zM
    o
    o
    o
    o
    o
    When in insertmode, the fold at the cursorline is never closed. That allows you to see what you type!
    o
    The folding is local to the window. This allows you to open two windows on the same buffer, one with folds and one without folds. Or one with all folds closed and one with all folds open.
    VYER
    SENAST REDIGERADE FILER :)
    MATA IN :)
    mata in samma text i början av fyra rader m hj av Ctrl+V :)
    C-v; I (stort i); mata in; Esc
    SÖKMÖNSTER/REGEX/REGULAR EXPRESSIONS :DD (se också /-sök ovan)
    Error setting the text for the following input: =Lägg till sist från eminenta Vim-tips-filen advanced + Regexavsnittet från user-manual.
    o
    KRYPTERING - manualen s114
    REDIGERA BINÄRFILER - manualen s115
    Redigera komprimerade filer - manualen s116
    o
    zzzz <#ID_555479922>
    nästa= s108 (current directory) :)
    +börja nästa session med att mata in kvarvarande kategorierna + börja sen med att gå på de viktigaste :)
    plocklista senaste <../Desktop/New%20Mindmap.mm>
    vim user manual
    NYA
    characterclasses
    printable characters
    printable characters utom siffror
    INTRESSANTA VIMRECIPES
    ack, s16
    vim -S sessionfilnamn och :so(urce) sessionfilnamn
    osäker
    # vim: syntax=make
    öppna flera filer för redigering med vim
    vim fil1 fil2 fil3
    :ar(gs)
    Ctrl+^
    {x}%
    "13yy
    o
    PLUGINS MM:
    xmledit (=för att redigera xml) <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+plugin+check+xml&ie=utf-8&oe=utf-8>
    xmlwf (=kolla och rätta till wellformedness för xml) <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+plugin+check+xml+well+formed&ie=utf-8&oe=utf-8>
    googlesök: tools for editing xml in vim
    o
    vim outliner
    ladda ner zippad fil
    ./install.sh
    sammanfattning av vanliga kommandon finns under :h vo_cheatsheet.txt
    SE MER + TESTA
    o
    <http://www.linux.com/learn/tutorials/424395:weekend-project-learn-vimoutliner-on-linux>
    <https://www.google.com/search?client=ubuntu&channel=fs&q=vimoutliner+tutorial&ie=utf-8&oe=utf-8>
    o
    options för fönster = s57 i user-manual
    vim user manual complete :D (258 sidor) xx/258 <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_user_manual.pdf>
    options för fönster = s57 i user-manual
    föreläsning: "More instantly better vim" <http://www.youtube.com/watch?v=aHm36-na4-4>
    surround.vim (makron för html- och xml-matchning mm) <http://www.vim.org/scripts/script.php?script_id=1697>
    vimplugins: matchit <www.vim.org/scripts/script.php?script_id=39>
    vimplugins: xmledit <www.vim.org/scripts/script.php?script_id=301>
    vim-latex
    Vimcasts.org :D <http://vimcasts.org/>
    o
    vimscripting: :D
    vimdoc.sourceforge.net/htmldoc/usr_41.html
    till LISTA_Ex-kommandon, Vim-funktioner mm :DDD <#ID_1833914625>
    ex-funktioner i vim <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--komm-rad_ex-komm_functions.odt>
    plocka_från_till_sista_vimsammanställningen.txt :DDD <./plockfil_sista_vimsammanställn/>
    Vim recipes mm <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+recipes+pdf&ie=utf-8&oe=utf-8>
    o
    o
    LISTA_Exkommandon <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_exkommandon.mm>
    LISTA_Vimfunktioner <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_vimfunktioner.mm>
    LISTA_Autocommands <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_autocommands.mm>
    LISTA_Options <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_options.mm>
    LISTA_Skalväxlar <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_skalväxlar.mm>
    LISTA_kompileringsväxlar <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_kompileringsväxlar.mm>
    vim-recipes (Bram Beer-boken) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-recipes.pdf>
    o
    Basics
    Choosing the Right Mode ............................................................................................................. 12
    Basic Navigation ............................................................................................................................... 14
    Opening Files .................................................................................................................................... 16
    Saving a File ....................................................................................................................................... 20
    Quitting Vim...................................................................................................................................... 22
    Deleting Text .................................................................................................................................... 24
    Visually Selecting Text.................................................................................................................... 26
    Copying, Cutting, and Pasting ...................................................................................................... 28
    Configuring Vim................................................................................................................................ 30
    Printing................................................................................................................................................ 34
    Getting Help...................................................................................................................................... 36
    Editing
    Indenting Lines.................................................................................................................................. 41
    Selecting Text with Motions......................................................................................................... 44
    Repeating Commands ..................................................................................................................... 48
    Changing the Case of Text........................................................................................................... 50
    Sorting Text ...................................................................................................................................... 52
    Executing External Commands .................................................................................................... 55
    Managing Sessions ............................................................................................................................ 57
    Formatting with an External Program ....................................................................................... 60
    Working with Different File Formats ........................................................................................ 62
    Typing
    Spell Checking................................................................................................................................... 65
    Using Templates............................................................................................................................... 67
    Undoing Mistakes............................................................................................................................. 71
    Auto-Completing Text ................................................................................................................... 73
    Abbreviating Common Strings ..................................................................................................... 76
    Inserting Accented or “Foreign” Characters ........................................................................... 78
    Opening the File .............................................................................................................................. 81
    Inserting the Date............................................................................................................................ 84
    Inserting Snippets............................................................................................................................. 86
    Navigation
    Navigating Text Files....................................................................................................................... 91
    Navigating Source Code ................................................................................................................ 93
    Navigating the Viewport ................................................................................................................ 95
    Navigating Buffers ............................................................................................................................ 96
    Navigating Tabs ................................................................................................................................ 98
    Manually Creating Folds...............................................................................................................100
    Navigating Folds ............................................................................................................................. 102
    Splitting the Screen .......................................................................................................................104
    Navigating Marks............................................................................................................................106
    Navigating Tags............................................................................................................................... 108
    Bookmarking Lines with Visible Markers (Signs) ..................................................................111
    GUI
    Changing the Font .........................................................................................................................115
    Maximising Screen Space .............................................................................................................117
    Creating Menus and Toolbar Buttons .....................................................................................119
    Searching
    Searching for any Word ..............................................................................................................122
    Searching Over Multiple Files.....................................................................................................123
    Searching and Replacing ...............................................................................................................126
    Searching for the Word Beneath the Cursor.......................................................................128
    Creating Regular Expressions.....................................................................................................129
    Looking up Documentation for the Keyword Under the Cursor ..................................134
    Display
    Working with Long Lines............................................................................................................136
    Displaying Line Numbers.............................................................................................................138
    Working with Remote Files .......................................................................................................139
    Changing the Status Line .............................................................................................................141
    Redefining Highlight Groups .......................................................................................................144
    Modifying the Cursor ...................................................................................................................147
    Changing the Window Title .......................................................................................................149
    Extending
    Creating Keyboard Shortcuts with Key Mappings ...............................................................153
    Changing the Colour Scheme ....................................................................................................155
    Creating Command-Line Commands .......................................................................................157
    Extending Vim with Scripts and Plugins ..................................................................................159
    Integrating Vim with Git ..............................................................................................................162
    Other Uses of Vim
    Browsing Directories....................................................................................................................167
    Using Vim as a File Manager ......................................................................................................169
    Viewing Differences Between Files ...........................................................................................172
    Outlining a Document..................................................................................................................174
    o
    vim-avanc tips och tricks.txt <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_avanc_tips_och_tricks.txt>
    vimtips.pdf <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimtips.pdf>
    Learn Vimscript the hard way :DDDD <http://learnvimscriptthehardway.stevelosh.com/chapters/00.html>
    56 delar :DD
    Quickref Vim :DDD <http://vimdoc.sourceforge.net/htmldoc/quickref.html>
    o
    o
    vimgenomgång 2010-2011.odt <file:/home/bluelegend/gdrive/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010-2011.odt>
    <vim2011-totalgenomgånggrund_ankisource.txt>
    vimgenomgång_2010-2011--h_index.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--h_index.odt>
    vimgenomgång_2010-2011--komm-rad_ex-komm_functions.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--komm-rad_ex-komm_functions.odt>
    vimtips_avanc.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimtips_avanc.odt>
    vim_avanc_tips_och_tricks.txt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_avanc_tips_och_tricks.txt>
    vimtips.pdf <file:/home/bluelegend/gdrive/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimtips.pdf>
    register x: mav$hdgg/;$^Mp'add
    vimgenomgång_utklipp_h-index <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_utklipp_h-index>
    vim_regex_avanc--lookahead_och_lookbehind <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_regex_avanc--lookahead_och_lookbehind>
    vimgenomgång5 <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång5>
    vim_user_manual.pdf <file:/home/bluelegend/gdrive/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_user_manual.pdf>
    vimgenomgång 2010.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010.odt>
    VIM REFERENCE MANUAL :] <http://heather.cs.ucdavis.edu/~matloff/Vim/Doc.html>
    +fler länkar :) <http://www.google.com/search?client=ubuntu&channel=fs&q=vim+complete+reference&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=U2U&tbo=d&channel=fs&sclient=psy-ab&q=vim+complete+reference+manual&oq=vim+complete+reference+ma&gs_l=serp.3.0.33i21.8344.9753.0.10730.3.3.0.0.0.0.94.253.3.3.0.les%3B..0.0...1c.1.0ca6sNJDGYs&pbx=1&bav=on.2,or.r_gc.r_pw.r_qf.&fp=e8932cf2edd4a476&bpcl=38897761&biw=1366&bih=634>
    o
    plocka från .mm för vim :) <plocka_från_till_sista_vimsammanställningen.mm>
    vimgenomgång2010.odt (första stora 4-5-sidors-grundsammanställningen) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010.odt>
    vimgenomgång2010-2011.odt (senaste stora 35-sidors) :) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010-2011.odt>
    stora 'tips i vim'-bladet :DDDD !!!!!
    genomgång :h__index-lista :D <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--h_index.odt>
    ctrl-w(=fönster)kommandon :) [kortkort lista] <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_utklipp_h-index>
    samma som till vänster (.txt) <plocka_från_till_sista_vimsammanställningen.txt>
    hemsida: vim completing mm :) <http://www.cs.oberlin.edu/~kuperman/help/vim/completion.html> 
    o
    lilypondvim_f6.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f6.png>
    lilypondvim_s-f6.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_s-f6.png>
    lilypondvim_f5.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f5.png>
    lilypondvim_f10.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f10.png>
    vim_options <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_options>
    lista_vim_options <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lista_vim_options>
    lilypondvim_f9.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f9.png>
    vim--converting_tabs_to_spaces.html <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim--converting_tabs_to_spaces.html>
    lilypondvim_f4.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f4.png>
    vim hacking :DD <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/Hacking%20Vim.pdf>
    o
    zzzz
    kap2 - Personalizing Vim (s26)
    o
    Getting started
    1
    2
    |usr_03.txt| Moving around
    |usr_04.txt| Making small changes
    |usr_05.txt| Set your settings
    |usr_06.txt| Using syntax highlighting
    |usr_07.txt| Editing more than one file
    |usr_08.txt| Splitting windows
    |usr_09.txt| Using the GUI
    |usr_10.txt| Making big changes
    |usr_11.txt| Recovering from a crash
    |usr_12.txt| Clever tricks
    Editing Effectively
    |usr_20.txt| Typing command-line commands quickly
    |usr_21.txt| Go away and come back
    |usr_22.txt| Finding the file to edit
    current directory
    s108
    window-local directory :DD
    finding a file (gf mm)
    s109
    lägga till mappar i path så vim hittar dem :D (vid gf-sök mm) **
    visa path
    :echo &path
    o
    o
    öppna fil i ny flik m gf
    Error setting the text for the following input: = ctrl+w gf :D.
    öppna fil i nytt fönster
    ctrl+w f
    o
    When you know the file name, but it's not to be found in the file, you can type it: >
    :find inits.h
    Vim will then use the 'path' option to try and locate the file. This is the same as the ":edit" command, except for the use of 'path'.
    o
    A nice way to directly start Vim to edit a file somewhere in the 'path': >
    vim "+find stdio.h"
    This finds the file "stdio.h" in your value of 'path'. necessary to have one argument |-+c|.
    buffer-list
    AHA! :DD
    active
    hidden
    inactive
    hidden buffers
    inactive buffers
    listing buffers
    :buffers
    :ls
    :files
    redigera buffer 2
    :buffer 2
    redigera buffer som innehåller ordet 'help'
    :buffer help
    öppna buffer 3 i nytt fönster
    :sbuffer 3
    ta bort buffer 3 från buffer-listan
    :bdelete 3
    o
    :bnext
    o
    :bprevious
    o
    :bfirst
    o
    :blast
    o
    Even after removing the buffer with ":bdelete" Vim still remembers it.
    It's actually made "unlisted", it no longer appears in the list from
    ":buffers". The ":buffers!" command will list unlisted buffers (yes,
    Vim can do the impossible). To really make Vim forget about a buffer,
    use ":bwipe". Also see the 'buflisted' option.
    tecken för bufferlist :DD ***
    u
    Buffer is unlisted |unlisted-buffer|.
    %
    Current buffer.
    #
    Alternate buffer.
    a
    Buffer is loaded and displayed.
    h
    Buffer is loaded but hidden.
    =
    Buffer is read-only.
    -
    Buffer is not modifiable, the 'modifiable' option is off.
    +
    Buffer has been modified.
    |usr_23.txt| Editing other files
    o
    :set fileformat?
    The three names that Vim uses are:
    unix
    dos
    mac
    <LF>
    <CR><LF>
    <CR>
    +s112
    o
    Vim assumes that on Unix you probably won't edit a Mac file, and doesn't check
    for this type of file. To check for this format anyway, add "mac" to
    fileformats': >
    :set fileformats+=mac
    +se mer s113
    öppna filer på internet :D
    Someone sends you an e-mail message, which refers to a file by its URL.
    example:
    For
    You can find the information here: ~
    ftp://ftp.vim.org/pub/vim/README ~ <ftp://ftp.vim.org/pub/vim/README>
    You could start a program to download the file, save it on your local disk and
    then start Vim to edit it.
    There is a much simpler way. Move the cursor to any character of the URL.
    Then use this command: >
    gf
    With a bit of luck, Vim will figure out which program to use for downloading
    the file, download it and edit the copy. To open the file in a new window use
    CTRL-W f.
    o
    Accessing files over the internet works with the netrw plugin. Currently URLs with these formats are recognized:
    ftp://
    uses ftp
    rcp://
    uses rcp
    scp://
    uses scp
    http://
    uses wget (reading only)
    encryption
    s114
    binary files
    s115
    |usr_24.txt| Inserting quickly
    COMPLETION
    sök före/efter
    ctrl+p
    SÖK TIDIGARE/SENARE ORD :)
    *slutför ord redan i fil
    *slutför var eller funkt.namn i skript du jobbar med
    Ctrl+p
    Ctrl+n
    sökställen =var letar ctrl+n/p
    1.current file
    2.files in other windows
    3.other loaded files (hidden buffers)
    4.files which are not loaded (inactive buffers)
    5.tagfiles
    6.all files #included by the current file
    ctrl+n
    o
    The Vim editor goes through a lot of effort to find words to complete. By default, it searches the following places:
    1
    Current file
    2
    Files in other windows
    3
    Other loaded files (hidden buffers)
    4
    Files which are not loaded (inactive buffers)
    5
    Tag files
    6
    All files #included by the current file
    OPTIONS
    You can customize the search order with the 'complete' option.
    även 'ignorecase' och 'infercase'
    COMPLETING SPECIFIC ITEMS
    If you know what you are looking for, you can use these commands to complete with a certain type of item:
    CTRL-X CTRL-F
    file names
    COMPLETING FILE NAMES
    Let's take CTRL-X CTRL-F as an example. This will find file names. It scans the current directory for files and displays each one that matches the word in front of the cursor.
    Suppose, for example, that you have the following files in the current directory:
    main.c
    sub_count.c
    sub_done.c
    sub_exit.c
    Now enter Insert mode and start typing:
    The exit code is in the file sub ~
    At this point, you enter the command CTRL-X CTRL-F.
    Vim now completes the current word "sub" by looking at the files in the current dir ectory.
    The first match is sub_count.c.
    This is not the one you want, so you match the next file by typing CTRL-N. This match is sub_done.c. Typing CTRL-N again takes you to sub_exit.c.
    The results:
    The exit code is in the file sub_exit.c ~
    the file is found in /usr/ ~
    If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all files in the file system. For example, type "/u" and CTRL-X CTRL-F. This will match "/usr" (this is on Unix):
    If you now press CTRL-N you go back to "/u". Instead, to accept the "/usr/"
    and go one directory level deeper, use CTRL-X CTRL-F again:
    the file is found in /usr/X11R6/ ~
    The results depend on what is found in your file system, of course.
    matches are sorted alphabetically.
    The
    SE MER s119
    CTRL-X CTRL-L
    whole lines
    CTRL-X CTRL-D
    macro definitions (also in included files)
    CTRL-X CTRL-I
    current and included files
    CTRL-X CTRL-K
    words from a dictionary
    CTRL-X CTRL-T
    words from a thesaurus
    CTRL-X CTRL-]
    tags
    CTRL-X CTRL-V
    Vim command line
    After each of them CTRL-N can be used to find the next match, CTRL-P to find the previous match. :DDD
    More information for each of these commands here: |ins-completion|.
    o
    completing in source code :DDD
    ctrl+x ctrl+o
    s120
    +explained |ft-c-omni|
    placera in det som skrevs in senast i i-mode :DDD
    Ctrl+a
    Ctrl+@
    Mata in tecknet ovanför/nedanför (på raden ovanför/nedanför) markören :D
    ctrl+y
    ctrl+e
    MATA IN INNEHÅLLET FRÅN REGISTER X
    CTRL+R {x}
    CTRL+R CTRL+R
    mata in direkt (=tolka inte t ex backspace utan mata in som <BS>)
    INSERTMODE-KOMMANDON :D
    [+SE OCKSÅ COMPLETION :D ]
    o
    ctrl+d
    ta bort indentering inne i insertmode
    ctrl+t
    indentera inne i insertmode
    o
    backspace
    ctrl+h :)
    samma som tab
    ctrl+i
    enter
    ctrl+m; ctrl+j
    pausa ins-mode
    ctrl+o
    mata in enter m fl tecken 'verbatim' :]
    ctrl+v
    zzzz2
    FÖRKORTNINGAR
    s122
    :abbreviate
    :iabbrev
    :cabbrev
    :unabbreviate
    :abclear (iabclear, cabclear)
    :noreabbrev
    (t ex)
    :iabbrev ad advertisement
    Now, when you type "ad", the whole word "advertisement" will be inserted into the text. This is triggered by typing a character that can't be part of a word, for example a space:
    I saw the ad<Space>
    o
    As a programmer, I use two rather unusual abbreviations: >
    :iabbrev #b /****************************************
    :iabbrev #e <Space>****************************************/
    The ":abbreviate" command lists the abbreviations:
    +++S 123
    entering special characters
    s124
    digraphs :))) [t ex Copyright-tecknet]
    s124
    pausa insertmode för ett kommando
    |usr_25.txt| Editing formatted text
    breaking lines
    :set textwidth=30
    reformatting
    s127
    gq
    *25.2* Aligning text
    To center a range of lines, use the following command: >
    :{range}center [width]
    s127
    Similarly, the ":right" command right-justifies the text: >
    :1,5right 37
    gives this result:
    left alignment
    Finally there is this command: >
    :{range}left [margin]
    Unlike ":center" and ":right", however, the argument to ":left" is not the length of the line. Instead it is the left margin. If it is omitted, the text will be put against the left side of the screen (using a zero margin would do the same). If it is 5, the text will be indented 5 spaces. For example, use these commands: >
    :1left 5
    :2,5left
    This results in the following:
    I taught for a while. One ~ time, I was stopped by the ~ Fort Worth police, because my ~ homework was too hard. True ~ story. ~
    justifying text
    Vim has no built-in way of justifying text. However, there is a neat macro package that does the job. To use this package, execute the following command: >
    :runtime macros/justify.vim
    An alternative is to filter the text through an external program.
    :%!fmt
    scroll :) (s130)
    If you don't have a scrollbar or don't want to use it, use these commands to scroll the text. The cursor will stay in the same place, but it's moved back into the visible text if necessary.
    zh
    right
    4zh
    four characters right
    zH
    half a window width right
    ze
    right to put the cursor at the end
    zl
    left
    4zl
    four characters left
    zL
    half a window width left
    zs
    left to put the cursor at the start
    :D
    g0
    to first visible character in this line
    g^
    to first non-blank visible character in this line
    gm
    to middle of this line
    g$
    to last visible character in this line
    :set linebreak
    (s131 - se till att ord inte bryts mitt i) :]
    :)
    gk
    gj
    :map <Up> gk
    :map <Down> gj
    turning the paragraph into one line :)
    :g/./,/^$/join
    That looks complicated.
    Let's break it up in pieces:
    :g/./
    A ":global" command that finds all lines that contain at least one character.
    ,/^$/
    A range, starting from the current line (the non-empty line) until an empty line.
    join
    The ":join" command joins the range of lines together into one line.
    EDITING TABLES s132 :) SE MER
    |usr_26.txt| Repeating
    markera förra markeringen igen
    gv :DDDD
    addera/subtrahera nummer
    ctrl+a/ctrl+x
    Making a change in many files - s136
    :DDD
    :args *.c
    lägg alla filer som slutar på .c i mappen i argslistan
    This finds all C files and edits the first one. Now you can perform a substitution command on all these files: >
    :argdo %s/\<x_cnt\>/x_counter/ge | update
    The ":argdo" command takes an argument that is another command. That command will be executed on all files in the argument list
    kör kommando(n) på alla fönster
    :windo
    kör kommandon på alla buffrar
    :bufdo (obs! kolla först buf-listan med ls)
    Using Vim from a shell script s136 :DDD
    SE MER SE MER
    använda vim från ett shellscript
    %s/--person--/Jones/g write tempfile quit
    for file in * .txt; do vim -e -s $file < change.vim lpr -r tempfile done
    if you use the standard input to read text from, you can use the -S argument to read a script
    producer | vim -S change.vim -
    redigera std.out från kommandot ls direkt med vim
    ls | vim -
    s137: vim -s file.txt ...
    Error setting the text for the following input: = -s has a different meaning when it is used without -e. here itt means to source the "script" as Normalmodecommands. when used with -e it means to be silent, and doesnt use the next argument as a filename.
    another way is to record the commands while you perform them manually. this is how you do that:
    vim -w script file.txt ...
    Error setting the text for the following input: =all typed keys will be written to "script". if you make a small mistake you can just continue and remember to edit the script later..
    the -w argument appends to an existing script. that is good when you want to record the script bit by bit.
    if you want to start from scratch and start all over, use the -W argument. it overwrites any existing file
    NORMAL MODE SCRIPTS
    If you really want to use Normal mode commands in a script, you can use it like this: >
    vim -s script file.txt ...
    Note:
    "-s" has a different meaning when it is used without "-e". Here it means to source the "script" as Normal mode commands. When used with "-e" it means to be silent, and doesn't use the next argument as a file name.
    +++SE MER :DDD
    Spela in script i farten/on the fly :DD s137
    To create the script you can edit the script file and type the commands. You need to imagine what the result would be, which can be a bit difficult.
    Another way is to record the commands while you perform them manually. This is how you do that: >
    vim -w script file.txt ...
    All typed keys will be written to "script". If you make a small mistake you can just continue and remember to edit the script later.
    The "-w" argument appends to an existing script. That is good when you want to record the script bit by bit. If you want to start from scratch and start all over, use the "-W" argument. It overwrites any existing file.
    |usr_27.txt| Search commands and patterns (s139-
    ignore case
    case in one pattern
    offsets
    t ex 
    /default/2
    This command searches for the pattern "default" and then moves to the beginning of the second line past the pattern.
    character offsets :) (s141)
    e=end; b=beginning
    /const/e
    /const/e+1
    /const/e-1
    /const/b+2
    repeating searches :DD
    To repeat searching for the previously used search pattern, but with a different offset, leave out the pattern: >
    /that
    //e
    Is equal to: >
    /that/e
    To repeat with the same offset: >
    /
    "n" does the same thing.
    To repeat while removing a previously used offset: >
    //
    Också förstås för ?-sökningar (gällande båda röda ovan) :)
    ?const?e-2
    matching multiple (* mm) :D
    ange exakt hur många multiple
    matcha så lite som möjligt
    alternativ
    \|
    \& (s143) :D
    character ranges
    [a-bfx-y]
    o
    +SE MER s144
    \e
    <Esc>
    \t
    <Tab>
    \r
    <CR>
    \b
    <BS>
    [tak "] :)
    fördefinierade
    \d
    digit
    [0-9]
    \D
    non-digit
    [^0-9]
    \x
    hex digit
    [0-9a-fA-F]
    \X
    non-hex digit
    [^0-9a-fA-F]
    \s
    white space
    [          ]  (tabs och blanks)
    \S
    non-white characters
    [^        ]  (not tabs och blanks)
    \l
    lowercase alpha
    [a-z]
    \L
    non-lowercase alpha
    [^a-z]
    \u
    uppercase alpha
    [A-Z]
    \U
    non-uppercase alpha
    [^A-Z]
    character classes
    \i
    identifier characters
    isident'
    \I
    like \i, excluding digits
    \k
    keyword characters
    iskeyword'
    \K
    like \k, excluding digits
    \p
    printable characters
    isprint'
    \P
    like \p, excluding digits
    \f
    file name characters
    isfname'
    \F
    like \f, excluding digits
    matching a line break :)
    t ex
    whitespace eller linebreak :)
    \_s
    any character or a linebreak
    \_.
    o
    + \n och \r :DD
    EXEMPEL REGEX s146
    |usr_28.txt| Folding
    SE MER s147
    o
    zfap
    zo
    zc
    zr
    zm
    zR
    zM
    o
    zn
    zN
    zi
    :set foldcolumn=4
    zO
    zC
    zd
    zD
    o
    (+fler options)
    o
    o
    folding by indent **** (s149)
    folding with markers
    folding by syntax (s151)
    folding by expression
    folding unchanged lines (vimdiff)
    |usr_29.txt| Moving through programs <#ID_922606698>
    ctags och skapa tags :DDD - SE MER s154
    To split the current window and jump to the tag under the cursor use this command:  :)
    CTRL-W ]
    the preview window :)) - SE MER s157
    t ex
    If the name of a function appears in the text, you can get its definition in the preview window with: >
    CTRL-W }
    Show tag under cursor in preview window
    Stäng preview-fönstret
    Ctrl+w z
    fr s26 :) ;; moving through programs :) (manual s158) <#ID_1575994988>
    [ Ctrl+d
    [ Ctrl+i
    hoppa till första raden i nuvurande och inkluderade filer som innehåller ordet under markören; starta sökning i början av nuvarande filen
    [#
    hoppa till början av #if --- #endif
    ]#
    [{
    hoppa till { på samma nivå :] = TESTA
    ]}
    hoppa till } på samma nivå :] = TESTA
    [[
    hoppa till yttersta {
    flytta till början av nuvarande sektion
    ][
    hoppa till yttersta }
    i C/Java = yttre { } är klassen och nästa nivå av { } är metoden :D
    [m
    hoppa till def av metod (= { inne i klass)
    ]m
    []
    gå till slutet av förra funktionen :)
    ]]
    gå till början av nästa funktion :)
    [(
    hoppa till ( på samma nivå :] = TESTA
    ])
    hoppa till ) på samma nivå :] = TESTA
    {/ ,, [/
    gå till början av kommentar
    ]/
    gå till slutet av kommentar :} (testa)
    [I (=stort i)
    You are editing a C program and wonder if a variable is declared as "int" or "unsigned". A quick way to find this is with the "[I" command.
    zzzz s161
    [+tab
    [i
    ]I (=stort i)
    ]i
    [D
    [d
    ]D
    ]d
    finding local identifiers
    gD
    gd
    locating included files + path :DDD !! s160 =SE MER :)
    |usr_30.txt| Editing programs
    compiling
    +errorcheck :)
    använda extern kompilator :)
    o
    äldre errorlists
    switching compilers
    output redirection
    indentering mm i C :)
    formatera kommentarer - s170 :DD
    definiera hur en kommentar ser ut
    |usr_31.txt| Exploiting the GUI
    s176 - redigera epostmeddelanden i vim :) - se mer ev
    |usr_32.txt| The undo tree
    s177
    +timetravel och earlier :)
    Tuning Vim
    |usr_40.txt| Make new commands
    key mapping - s180
    defining command-line--commands - s183
    autocommands - s186
    events :)
    patterns
    (mm)
    o
    o
    o
    |usr_41.txt| Write a Vim script (s190-224)
    |usr_42.txt| Add new menus
    |usr_43.txt| Using filetypes
    |usr_44.txt| Your own syntax highlighted
    |usr_45.txt| Select your language
    o
    Making Vim Run + Reference manual :)
    |usr_90.txt| Installing Vim
    Reference manual
    |reference_toc|
    Error setting the text for the following input: = More detailed information for all commands :).
    The user manual is available as a single, ready to print HTML and PDF file here:
    vimdoc.sf.net <http://vimdoc.sf.net>
    SENASTE = placera in <#ID_926325771>
    PLACERA IN
    placera in tab (??) :]
    Ctrl+d
    Ctrl+t
    INSERT MODE
    samma som backspace
    Ctrl+h
    samma som tab
    Ctrl+i
    samma som enter
    Ctrl+j, Ctrl+m
    samma som Esc :DD !!!!!!
    Ctrl+AltGr+8
    kör ett kommando i ex-mode
    Ctrl+o
    sudda alla inmatade tecken på nuv. raden :] (TESTA)
    Ctrl+u
    mata in tecken enligt sin 3-siffriga kod
    Ctrl+v +3-siffrigt tal
    Ctrl-w =????
    höj/sänk tal med 1
    INDENTERING
    ta bort all indentering på nuvarande raden :)
    0 Ctrl+d
    ta bort all indentering på nuvarande raden + återställ på nästa raden :)
    ^ Ctrl+d

    tags
    o
    Ctrl+e
    stoppa ovanläge när inne i (?)
    REGISTERS
    mata in innehållet ur angivet register :D
    Ctrl+r [0-9a-z"%#*:=]
    mata in innehållet ur angivet register (bokstavligt)
    Ctrl+r Ctrl+r
    mata in innehållet ur angivet register (bokstavligt + autoindentera INTE)
    Ctrl+r Ctrl+o
    mata in innehållet ur angivet register (bokstavligt + fixera indentering)
    Ctrl+r Ctrl+p
    mata in radbrytn.tecken m fl uttryckligen
    Ctrl+v :D
    tvinga systemet att spara bufferten även om inte strömstopp o likn
    :pre
    3 sätten att specificera radadresser :)
    - med uttryckliga radnummer
    - med symboler som anger relativt till nuvarande position (t ex $, .+1 osv)
    - som sökmönster som adress som anger rader som ska påverkas
    kommandoradshistorik
    visa history för /-sökningar
    o
    öppna kommandoradsfönster med :-kommandohistorik + tom kommandorad längst ner
    q:
    Error setting the text for the following input: =redigera som vanlig text + tryck sen enter :DD.
    öppna kommandoradsfönster med /-sökhistorik + tom kommandorad längst ner
    q/
    öppna kommandoradsfönster med ?-sökhistorik + tom kommandorad längst ner
    q?
    ändra kommando från kommandohistoriken inne i kommandofönstret
    [[titta över regex]]
    ---
    kör skalprogram och läs in resultatet i filen
    :r !skalkommando :D
    slå på liten kolumn till vänster som visar folds
    vyer
    spara fil med folds mm = view
    öppna sparad vy
    se lista på filer du redigerat senaste gångerna inne i vim
    kolla listan på filer redigerat senaste gångerna + gå ut och redigera m hj av siffra ***
    s100 i vim user manual :D
    dela fönster för att också kunna redigera fil 3 från oldfileslistan :)
    skapa en 'session' = spara fönster och filer från ett redigeringstillfälle
    återställ session
    1. från inne i vim
    2. från kommandoraden
    namn på registret text sparades i förra gången suddades med d (delete)
    visa innehållet i delete- och bokstavsbuffrarna
    klistra in namnet på filen i filens text
    ---------------------------------------
    indentera i kommandoläge
    ta bort indentering i kommandoläge
    repetera förra kommandolägeskommandot
    ge full sökväg m hj av %
    x4
    o
    gå tillbaks till hur fil såg ut för 20 min sedan
    gå tillbaks till hur fil såg ut för 1 timme sedan
    SE MER: kör kommando i flera flikar
    skapa fold från markören 5 rader ner
    öka storlek på split m Ctrl-kommando
    sök fram/nästan fram till nästa bokstaven s
    gör 10 rader neråt redo för kommandorads-kommando
    o
    följ hyperlänk i hjälpfil ****
    gå tillbaks efter följt länk i hjälpfil
    gå framåt igen efter gått tillbaks från följt länk
    gå till nästa/föregående undanvikning ***
    gj/gk ????? :]
    o
    blandat
    sudda t o m sista raden = dG :D
    I
    A
    ändra case på tecken = tilde :)
    konvertera en text till html :)
    Convert the current file to HTML with this command: >
    :TOhtml
    In case that doesn't work: >
    :source $VIMRUNTIME/syntax/2html.vim
    :so /usr/share/vim/vim72/syntax/2html.vim
    :TOhtml 
    You will see it crunching away, this can take quite a while for a large file. Some time later another window shows the HTML code. Now write this somewhere (doesn't matter where, you throw it away later): >
    :write main.c.html
    Open this file in your favorite browser and print it from there. If all goes well, the output should look exactly as it does in Vim. See |2html.vim| for details. Don't forget to delete the HTML file when you are done with it.
    öppna fil i readonly-läge
    A.
    vim -R fil
    view fil
    (lägg till ! för att tvinga write :)
    B.
    vim -M fil
    (:se modifiable och :se write för att kunna ändra filen :)
    o
    lägg ihop två rader
    J
    lägg ihop två rader utan att ändra mellanslag :)
    gJ
    o
    o
    höst2013:
    :set guifont={Andale\ Mono\ 11}
    xlsfonts ==visa tillgängliga fonts i gvim
    ???
    :echo &path
    några intressanta plugins:
    sessionman
    SuperTab
    VimOutliner + otl2html + otl2docbook
    vims inbyggda sort
    i
    u
    n
    :sort /mönster/
    skifta mellan de olika visuallägena
    lägga till t ex ':set number' i sin vimrc + kommentar ovanför
    sätta a2ps för att hantera utskrifter - s36 i Bram Beer-boken
    sätta så osynliga tecken (som Linebreak) syns - :se list
    output redirection to a file - s57 i Bram Beer-boken
    Enkel map för att spara sessions - s59 i Bram Beer-boken
    g- för undogrenar
    boilerplatecode och templates - s68 i Bram Beer-boken
    ctrl+k för accenttecken, t ex långt japanskt o
    o
    gf öppnar fil i samma fönster som standard. öppna i ny tab med ctrl+w+gf. remap för att göra till default = :nnoremap gf <C-W>gf
    om namnet på din fil följs av ett radnummer, t ex foo.txt:10 så kan du hoppa till den givna raden med gF  (=???)
    snipMate - s88 i Bram Beer-boken
    Navigating sourcecode - s95 i Bram Beer-boken = TESTA!
    :b f på s99 i Bram Beer-boken
    (=??) :)
    Sätta synliga markörer och bokmärken - s113 i Bram Beer-boken
    Skapa menyer och verktygsknappar - s121 i Bram Beer-boken
    ** och *.txt för att söka 'neråt- efter filer (när jobbar med vimgrep mm)
    = sXX i Bram Beer-boken (??)
    :help pattern för mer om regular expressions
    :set keywordprg=pydoc (typ) ist. för 'man' för att kunna jobba med py och 'K'
    - s57 i Bram Beer-boken
    - s57 i Bram Beer-boken
    mer från user manual:
    vimscript <http://vimdoc.sourceforge.net/htmldoc/usr_41.html>
    Help FAQ Both
    Vim documentation: usr_41
    main help file
    *usr_41.txt*        For Vim version 7.3.  Last change: 2011 Feb 15
    VIM USER MANUAL - by Bram Moolenaar
    Write a Vim script
    The Vim script language is used for the startup vimrc file, syntax files, and
    many other things.  This chapter explains the items that can be used in a Vim
    script.  There are a lot of them, thus this is a long chapter.
    |41.1|        Introduction
    |41.2|        Variables
    |41.3|        Expressions
    |41.4|        Conditionals
    |41.5|        Executing an expression
    |41.6|        Using functions
    |41.7|        Defining a function
    |41.8|        Lists and Dictionaries
    |41.9|        Exceptions
    |41.10|        Various remarks
    |41.11|        Writing a plugin
    |41.12|        Writing a filetype plugin
    |41.13|        Writing a compiler plugin
    |41.14|        Writing a plugin that loads quickly
    |41.15|        Writing library scripts
    |41.16|        Distributing Vim scripts
    Next chapter: |usr_42.txt|  Add new menus
    Previous chapter: |usr_40.txt|  Make new commands
    Table of contents: |usr_toc.txt|
    Error setting the text for the following input: ==============================================================================.
    *41.1*        Introduction                                *vim-script-intro* *script*
    Your first experience with Vim scripts is the vimrc file.  Vim reads it when
    it starts up and executes the commands.  You can set options to values you
    prefer.  And you can use any colon command in it (commands that start with a
    ":"; these are sometimes referred to as Ex commands or command-line commands).
    Syntax files are also Vim scripts.  As are files that set options for a
    specific file type.  A complicated macro can be defined by a separate Vim
    script file.  You can think of other uses yourself.
    Let's start with a simple example:
    :let i = 1
    :while i < 5
    :  echo "count is" i
    :  let i += 1
    :endwhile
    Note:
    The ":" characters are not really needed here.  You only need to use
    them when you type a command.  In a Vim script file they can be left
    out.  We will use them here anyway to make clear these are colon
    commands and make them stand out from Normal mode commands.
    Note:
    You can try out the examples by yanking the lines from the text here
    and executing them with :@"
    The output of the example code is:
    count is 1
    count is 2
    count is 3
    count is 4
    In the first line the ":let" command assigns a value to a variable.  The
    generic form is:
    :let {variable} = {expression}
    In this case the variable name is "i" and the expression is a simple value,
    the number one.
    The ":while" command starts a loop.  The generic form is:
    :while {condition}
    :  {statements}
    :endwhile
    The statements until the matching ":endwhile" are executed for as long as the
    condition is true.  The condition used here is the expression "i < 5".  This
    is true when the variable i is smaller than five.
    Note:
    If you happen to write a while loop that keeps on running, you can
    interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).
    The ":echo" command prints its arguments.  In this case the string "count is"
    and the value of the variable i.  Since i is one, this will print:
    count is 1
    Then there is the ":let i += 1" command.  This does the same thing as
    ":let i = i + 1".  This adds one to the variable i and assigns the new value
    to the same variable.
    The example was given to explain the commands, but would you really want to
    make such a loop it can be written much more compact:
    :for i in range(1, 4)
    :  echo "count is" i
    :endfor
    We won't explain how |:for| and |range()| work until later.  Follow the links
    if you are impatient.
    THREE KINDS OF NUMBERS
    Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts
    with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number starts
    with a zero.  "017" is decimal 15.  Careful: don't put a zero before a decimal
    number, it will be interpreted as an octal number!
    The ":echo" command always prints decimal numbers.  Example:
    :echo 0x7f 036
    127 30
    A number is made negative with a minus sign.  This also works for hexadecimal
    and octal numbers.   A minus sign is also used for subtraction.  Compare this
    with the previous example:
    :echo 0x7f -036
    97
    White space in an expression is ignored.  However, it's recommended to use it
    for separating items, to make the expression easier to read.  For example, to
    avoid the confusion with a negative number above, put a space between the
    minus sign and the following number:
    :echo 0x7f - 036
    Error setting the text for the following input: ==============================================================================.
    *41.2*        Variables
    A variable name consists of ASCII letters, digits and the underscore.  It
    cannot start with a digit.  Valid variable names are:
    counter
    _aap3
    very_long_variable_name_with_underscores
    FuncLength
    LENGTH
    Invalid names are "foo+bar" and "6var".
    These variables are global.  To see a list of currently defined variables
    use this command:
    :let
    You can use global variables everywhere.  This also means that when the
    variable "count" is used in one script file, it might also be used in another
    file.  This leads to confusion at least, and real problems at worst.  To avoid
    this, you can use a variable local to a script file by prepending "s:".  For
    example, one script contains this code:
    :let s:count = 1
    :while s:count < 5
    :  source other.vim
    :  let s:count += 1
    :endwhile
    Since "s:count" is local to this script, you can be sure that sourcing the
    "other.vim" script will not change this variable.  If "other.vim" also uses an
    "s:count" variable, it will be a different copy, local to that script.  More
    about script-local variables here: |script-variable|.
    There are more kinds of variables, see |internal-variables|.  The most often
    used ones are:
    b:name                variable local to a buffer
    w:name                variable local to a window
    g:name                global variable (also in a function)
    v:name                variable predefined by Vim
    DELETING VARIABLES
    Variables take up memory and show up in the output of the ":let" command.  To
    delete a variable use the ":unlet" command.  Example:
    :unlet s:count
    This deletes the script-local variable "s:count" to free up the memory it
    uses.  If you are not sure if the variable exists, and don't want an error
    message when it doesn't, append !:
    :unlet! s:count
    When a script finishes, the local variables used there will not be
    automatically freed.  The next time the script executes, it can still use the
    old value.  Example:
    :if !exists("s:call_count")
    :  let s:call_count = 0
    :endif
    :let s:call_count = s:call_count + 1
    :echo "called" s:call_count "times"
    The "exists()" function checks if a variable has already been defined.  Its
    argument is the name of the variable you want to check.  Not the variable
    itself!  If you would do this:
    :if !exists(s:call_count)
    Then the value of s:call_count will be used as the name of the variable that
    exists() checks.  That's not what you want.
    The exclamation mark ! negates a value.  When the value was true, it
    becomes false.  When it was false, it becomes true.  You can read it as "not".
    Thus "if !exists()" can be read as "if not exists()".
    What Vim calls true is anything that is not zero.  Zero is false.
    Note:
    Vim automatically converts a string to a number when it is looking for
    a number.  When using a string that doesn't start with a digit the
    resulting number is zero.  Thus look out for this:
    :if "true"
    The "true" will be interpreted as a zero, thus as false!
    STRING VARIABLES AND CONSTANTS
    So far only numbers were used for the variable value.  Strings can be used as
    well.  Numbers and strings are the basic types of variables that Vim supports.
    The type is dynamic, it is set each time when assigning a value to the
    variable with ":let".  More about types in |41.8|.
    To assign a string value to a variable, you need to use a string constant.
    There are two types of these.  First the string in double quotes:
    :let name = "peter"
    :echo name
    peter
    If you want to include a double quote inside the string, put a backslash in
    front of it:
    :let name = "\"peter\""
    :echo name
    "peter"
    To avoid the need for a backslash, you can use a string in single quotes:
    :let name = '"peter"'
    :echo name
    "peter"
    Inside a single-quote string all the characters are as they are.  Only the
    single quote itself is special: you need to use two to get one.  A backslash
    is taken literally, thus you can't use it to change the meaning of the
    character after it.
    In double-quote strings it is possible to use special characters.  Here are
    a few useful ones:
    \t                <Tab>
    \n                <NL>, line break
    \r                <CR>, <Enter>
    \e                <Esc>
    \b                <BS>, backspace
    \"                "
    \\                \, backslash
    \<Esc>                <Esc>
    \<C-W>                CTRL-W
    The last two are just examples.  The  "\<name>" form can be used to include
    the special key "name".
    See |expr-quote| for the full list of special items in a string.
    Error setting the text for the following input: ==============================================================================.
    *41.3*        Expressions
    Vim has a rich, yet simple way to handle expressions.  You can read the
    definition here: |expression-syntax|.  Here we will show the most common
    items.
    The numbers, strings and variables mentioned above are expressions by
    themselves.  Thus everywhere an expression is expected, you can use a number,
    string or variable.  Other basic items in an expression are:
    $NAME                environment variable
    &name                option
    @r                register
    Examples:
    :echo "The value of 'tabstop' is" &ts
    :echo "Your home directory is" $HOME
    :if @a > 5
    The &name form can be used to save an option value, set it to a new value,
    do something and restore the old value.  Example:
    :let save_ic = &ic
    :set noic
    :/The Start/,$delete
    :let &ic = save_ic
    This makes sure the "The Start" pattern is used with the 'ignorecase' option
    off.  Still, it keeps the value that the user had set.  (Another way to do
    this would be to add "\C" to the pattern, see |/\C|.)
    MATHEMATICS
    It becomes more interesting if we combine these basic items.  Let's start with
    mathematics on numbers:
    a + b                add
    a - b                subtract
    a * b                multiply
    a / b                divide
    a % b                modulo
    The usual precedence is used.  Example:
    :echo 10 + 5 * 2
    20
    Grouping is done with parentheses.  No surprises here.  Example:
    :echo (10 + 5) * 2
    30
    Strings can be concatenated with ".".  Example:
    :echo "foo" . "bar"
    foobar
    When the ":echo" command gets multiple arguments, it separates them with a
    space.  In the example the argument is a single expression, thus no space is
    inserted.
    Borrowed from the C language is the conditional expression:
    a ? b : c
    If "a" evaluates to true "b" is used, otherwise "c" is used.  Example:
    :let i = 4
    :echo i > 5 ? "i is big" : "i is small"
    i is small
    The three parts of the constructs are always evaluated first, thus you could
    see it work as:
    (a) ? (b) : (c)
    Error setting the text for the following input: ==============================================================================.
    *41.4*        Conditionals
    The ":if" commands executes the following statements, until the matching
    ":endif", only when a condition is met.  The generic form is:
    :if {condition}
    {statements}
    :endif
    Only when the expression {condition} evaluates to true (non-zero) will the
    {statements} be executed.  These must still be valid commands.  If they
    contain garbage, Vim won't be able to find the ":endif".
    You can also use ":else".  The generic form for this is:
    :if {condition}
    {statements}
    :else
    {statements}
    :endif
    The second {statements} is only executed if the first one isn't.
    Finally, there is ":elseif":
    :if {condition}
    {statements}
    :elseif {condition}
    {statements}
    :endif
    extra ":endif".
    A useful example for your vimrc file is checking the 'term' option and
    This works just like using ":else" and then "if", but without the need for an
    doing something depending upon its value:
    :if &term == "xterm"
    :  " Do stuff for xterm
    :elseif &term == "vt100"
    :  " Do stuff for a vt100 terminal
    :else
    :  " Do something for other terminals
    :endif
    LOGIC OPERATIONS
    We already used some of them in the examples.  These are the most often used
    ones:
    a == b                equal to
    a != b                not equal to
    a >  b                greater than
    a >= b                greater than or equal to
    a <  b                less than
    a <= b                less than or equal to
    The result is one if the condition is met and zero otherwise.  An example:
    :if v:version >= 700
    :  echo "congratulations"
    :else
    :  echo "you are using an old version, upgrade!"
    :endif
    Here "v:version" is a variable defined by Vim, which has the value of the Vim
    version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is
    very useful to write a script that works with multiple versions of Vim.
    |v:version|
    The logic operators work both for numbers and strings.  When comparing two
    strings, the mathematical difference is used.  This compares byte values,
    which may not be right for some languages.
    When comparing a string with a number, the string is first converted to a
    number.  This is a bit tricky, because when a string doesn't look like a
    number, the number zero is used.  Example:
    :if 0 == "one"
    :  echo "yes"
    :endif
    This will echo "yes", because "one" doesn't look like a number, thus it is
    converted to the number zero.
    For strings there are two more items:
    a =~ b                matches with
    a !~ b                does not match with
    The left item "a" is used as a string.  The right item "b" is used as a
    pattern, like what's used for searching.  Example:
    :if str =~ " "
    :  echo "str contains a space"
    :endif
    :if str !~ '\.$'
    :  echo "str does not end in a full stop"
    :endif
    Notice the use of a single-quote string for the pattern.  This is useful,
    because backslashes would need to be doubled in a double-quote string and
    patterns tend to contain many backslashes.
    The 'ignorecase' option is used when comparing strings.  When you don't want
    that, append "#" to match case and "?" to ignore case.  Thus "==?" compares
    two strings to be equal while ignoring case.  And "!~#" checks if a pattern
    doesn't match, also checking the case of letters.  For the full table see
    |expr-==|.
    MORE LOOPING
    The ":while" command was already mentioned.  Two more statements can be used
    in between the ":while" and the ":endwhile":
    :continue                Jump back to the start of the while loop; the
    loop continues.
    :break                        Jump forward to the ":endwhile"; the loop is
    discontinued.
    Example:
    :while counter < 40
    :  call do_something()
    :  if skip_flag
    :    continue
    :  endif
    :  if finished_flag
    :    break
    :  endif
    :  sleep 50m
    :endwhile
    The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty
    milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.
    Even more looping can be done with the ":for" command, see below in |41.8|.
    Error setting the text for the following input: ==============================================================================.
    *41.5*        Executing an expression
    So far the commands in the script were executed by Vim directly.  The
    ":execute" command allows executing the result of an expression.  This is a
    very powerful way to build commands and execute them.
    An example is to jump to a tag, which is contained in a variable:
    :execute "tag " . tag_name
    The "." is used to concatenate the string "tag " with the value of variable
    "tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that
    will be executed is:
    :tag get_cmd
    The ":execute" command can only execute colon commands.  The ":normal" command
    executes Normal mode commands.  However, its argument is not an expression but
    the literal command characters.  Example:
    :normal gg=G
    This jumps to the first line and formats all lines with the "=" operator.
    To make ":normal" work with an expression, combine ":execute" with it.
    Example:
    :execute "normal " . normal_commands
    The variable "normal_commands" must contain the Normal mode commands.
    Make sure that the argument for ":normal" is a complete command.  Otherwise
    Vim will run into the end of the argument and abort the command.  For example,
    if you start Insert mode, you must leave Insert mode as well.  This works:
    :execute "normal Inew text \<Esc>"
    This inserts "new text " in the current line.  Notice the use of the special
    key "\<Esc>".  This avoids having to enter a real <Esc> character in your
    script.
    If you don't want to execute a string but evaluate it to get its expression
    value, you can use the eval() function:
    :let optname = "path"
    :let optval = eval('&' . optname)
    A "&" character is prepended to "path", thus the argument to eval() is
    "&path".  The result will then be the value of the 'path' option.
    The same thing can be done with:
    :exe 'let optval = &' . optname
    Error setting the text for the following input: ==============================================================================.
    *41.6*        Using functions
    Vim defines many functions and provides a large amount of functionality that
    way.  A few examples will be given in this section.  You can find the whole
    list here: |functions|.
    A function is called with the ":call" command.  The parameters are passed in
    between parentheses separated by commas.  Example:
    :call search("Date: ", "W")
    This calls the search() function, with arguments "Date: " and "W".  The
    search() function uses its first argument as a search pattern and the second
    one as flags.  The "W" flag means the search doesn't wrap around the end of
    the file.
    A function can be called in an expression.  Example:
    :let line = getline(".")
    :let repl = substitute(line, '\a', "*", "g")
    :call setline(".", repl)
    The getline() function obtains a line from the current buffer.  Its argument
    is a specification of the line number.  In this case "." is used, which means
    the line where the cursor is.
    The substitute() function does something similar to the ":substitute"
    command.  The first argument is the string on which to perform the
    substitution.  The second argument is the pattern, the third the replacement
    string.  Finally, the last arguments are the flags.
    The setline() function sets the line, specified by the first argument, to a
    new string, the second argument.  In this example the line under the cursor is
    replaced with the result of the substitute().  Thus the effect of the three
    statements is equal to:
    :substitute/\a/*/g
    Using the functions becomes more interesting when you do more work before and
    after the substitute() call.
    FUNCTIONS                                                *function-list*
    There are many functions.  We will mention them here, grouped by what they are
    used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on
    the function name to jump to detailed help on it.
    String manipulation:                                        *string-functions*
    nr2char()                get a character by its ASCII value
    char2nr()                get ASCII value of a character
    str2nr()                convert a string to a Number
    str2float()                convert a string to a Float
    printf()                format a string according to % items
    escape()                escape characters in a string with a '\'
    shellescape()                escape a string for use with a shell command
    fnameescape()                escape a file name for use with a Vim command
    tr()                        translate characters from one set to another
    strtrans()                translate a string to make it printable
    tolower()                turn a string to lowercase
    toupper()                turn a string to uppercase
    match()                        position where a pattern matches in a string
    matchend()                position where a pattern match ends in a string
    matchstr()                match of a pattern in a string
    matchlist()                like matchstr() and also return submatches
    stridx()                first index of a short string in a long string
    strridx()                last index of a short string in a long string
    strlen()                length of a string
    substitute()                substitute a pattern match with a string
    submatch()                get a specific match in a ":substitute"
    strpart()                get part of a string
    expand()                expand special keywords
    iconv()                        convert text from one encoding to another
    byteidx()                byte index of a character in a string
    repeat()                repeat a string multiple times
    eval()                        evaluate a string expression
    List manipulation:                                        *list-functions*
    get()                        get an item without error for wrong index
    len()                        number of items in a List
    empty()                        check if List is empty
    insert()                insert an item somewhere in a List
    add()                        append an item to a List
    extend()                append a List to a List
    remove()                remove one or more items from a List
    copy()                        make a shallow copy of a List
    deepcopy()                make a full copy of a List
    filter()                remove selected items from a List
    map()                        change each List item
    sort()                        sort a List
    reverse()                reverse the order of a List
    split()                        split a String into a List
    join()                        join List items into a String
    range()                        return a List with a sequence of numbers
    string()                String representation of a List
    call()                        call a function with List as arguments
    index()                        index of a value in a List
    max()                        maximum value in a List
    min()                        minimum value in a List
    count()                        count number of times a value appears in a List
    repeat()                repeat a List multiple times
    Dictionary manipulation:                                *dict-functions*
    get()                        get an entry without an error for a wrong key
    len()                        number of entries in a Dictionary
    has_key()                check whether a key appears in a Dictionary
    empty()                        check if Dictionary is empty
    remove()                remove an entry from a Dictionary
    extend()                add entries from one Dictionary to another
    filter()                remove selected entries from a Dictionary
    map()                        change each Dictionary entry
    keys()                        get List of Dictionary keys
    values()                get List of Dictionary values
    items()                        get List of Dictionary key-value pairs
    copy()                        make a shallow copy of a Dictionary
    deepcopy()                make a full copy of a Dictionary
    string()                String representation of a Dictionary
    max()                        maximum value in a Dictionary
    min()                        minimum value in a Dictionary
    count()                        count number of times a value appears
    Floating point computation:                                *float-functions*
    float2nr()                convert Float to Number
    abs()                        absolute value (also works for Number)
    round()                        round off
    ceil()                        round up
    floor()                        round down
    trunc()                        remove value after decimal point
    log10()                        logarithm to base 10
    pow()                        value of x to the exponent y
    sqrt()                        square root
    sin()                        sine
    cos()                        cosine
    tan()                        tangent
    asin()                        arc sine
    acos()                        arc cosine
    atan()                        arc tangent
    atan2()                        arc tangent
    sinh()                        hyperbolic sine
    cosh()                        hyperbolic cosine
    tanh()                        hyperbolic tangent
    Variables:                                                *var-functions*
    type()                        type of a variable
    islocked()                check if a variable is locked
    function()                get a Funcref for a function name
    getbufvar()                get a variable value from a specific buffer
    setbufvar()                set a variable in a specific buffer
    getwinvar()                get a variable from specific window
    gettabvar()                get a variable from specific tab page
    gettabwinvar()                get a variable from specific window & tab page
    setwinvar()                set a variable in a specific window
    settabvar()                set a variable in a specific tab page
    settabwinvar()                set a variable in a specific window & tab page
    garbagecollect()        possibly free memory
    Cursor and mark position:                *cursor-functions* *mark-functions*
    col()                        column number of the cursor or a mark
    virtcol()                screen column of the cursor or a mark
    line()                        line number of the cursor or mark
    wincol()                window column number of the cursor
    winline()                window line number of the cursor
    cursor()                position the cursor at a line/column
    getpos()                get position of cursor, mark, etc.
    setpos()                set position of cursor, mark, etc.
    byte2line()                get line number at a specific byte count
    line2byte()                byte count at a specific line
    diff_filler()                get the number of filler lines above a line
    Working with text in the current buffer:                *text-functions*
    getline()                get a line or list of lines from the buffer
    setline()                replace a line in the buffer
    append()                append line or list of lines in the buffer
    indent()                indent of a specific line
    cindent()                indent according to C indenting
    lispindent()                indent according to Lisp indenting
    nextnonblank()                find next non-blank line
    prevnonblank()                find previous non-blank line
    search()                find a match for a pattern
    searchpos()                find a match for a pattern
    searchpair()                find the other end of a start/skip/end
    searchpairpos()                find the other end of a start/skip/end
    searchdecl()                search for the declaration of a name
    *system-functions* *file-functions*
    System functions and manipulation of files:
    glob()                        expand wildcards
    globpath()                expand wildcards in a number of directories
    findfile()                find a file in a list of directories
    finddir()                find a directory in a list of directories
    resolve()                find out where a shortcut points to
    fnamemodify()                modify a file name
    pathshorten()                shorten directory names in a path
    simplify()                simplify a path without changing its meaning
    executable()                check if an executable program exists
    filereadable()                check if a file can be read
    filewritable()                check if a file can be written to
    getfperm()                get the permissions of a file
    getftype()                get the kind of a file
    isdirectory()                check if a directory exists
    getfsize()                get the size of a file
    getcwd()                get the current working directory
    haslocaldir()                check if current window used |:lcd|
    tempname()                get the name of a temporary file
    mkdir()                        create a new directory
    delete()                delete a file
    rename()                rename a file
    system()                get the result of a shell command
    hostname()                name of the system
    readfile()                read a file into a List of lines
    writefile()                write a List of lines into a file
    Date and Time:                                *date-functions* *time-functions*
    getftime()                get last modification time of a file
    localtime()                get current time in seconds
    strftime()                convert time to a string
    reltime()                get the current or elapsed time accurately
    reltimestr()                convert reltime() result to a string
    *buffer-functions* *window-functions* *arg-functions*
    Buffers, windows and the argument list:
    argc()                        number of entries in the argument list
    argidx()                current position in the argument list
    argv()                        get one entry from the argument list
    bufexists()                check if a buffer exists
    buflisted()                check if a buffer exists and is listed
    bufloaded()                check if a buffer exists and is loaded
    bufname()                get the name of a specific buffer
    bufnr()                        get the buffer number of a specific buffer
    tabpagebuflist()        return List of buffers in a tab page
    tabpagenr()                get the number of a tab page
    tabpagewinnr()                like winnr() for a specified tab page
    winnr()                        get the window number for the current window
    bufwinnr()                get the window number of a specific buffer
    winbufnr()                get the buffer number of a specific window
    getbufline()                get a list of lines from the specified buffer
    Command line:                                        *command-line-functions*
    getcmdline()                get the current command line
    getcmdpos()                get position of the cursor in the command line
    setcmdpos()                set position of the cursor in the command line
    getcmdtype()                return the current command-line type
    Quickfix and location lists:                        *quickfix-functions*
    getqflist()                list of quickfix errors
    setqflist()                modify a quickfix list
    getloclist()                list of location list items
    setloclist()                modify a location list
    Insert mode completion:                                *completion-functions*
    complete()                set found matches
    complete_add()                add to found matches
    complete_check()        check if completion should be aborted
    pumvisible()                check if the popup menu is displayed
    Folding:                                        *folding-functions*
    foldclosed()                check for a closed fold at a specific line
    foldclosedend()                like foldclosed() but return the last line
    foldlevel()                check for the fold level at a specific line
    foldtext()                generate the line displayed for a closed fold
    foldtextresult()        get the text displayed for a closed fold
    Syntax and highlighting:          *syntax-functions* *highlighting-functions*
    clearmatches()                clear all matches defined by |matchadd()| and
    the |:match| commands
    getmatches()                get all matches defined by |matchadd()| and
    the |:match| commands
    hlexists()                check if a highlight group exists
    hlID()                        get ID of a highlight group
    synID()                        get syntax ID at a specific position
    synIDattr()                get a specific attribute of a syntax ID
    synIDtrans()                get translated syntax ID
    synstack()                get list of syntax IDs at a specific position
    synconcealed()                get info about concealing
    diff_hlID()                get highlight ID for diff mode at a position
    matchadd()                define a pattern to highlight (a "match")
    matcharg()                get info about |:match| arguments
    matchdelete()                delete a match defined by |matchadd()| or a
    |:match| command
    setmatches()                restore a list of matches saved by
    |getmatches()|
    History:                                        *history-functions*
    histadd()                add an item to a history
    histdel()                delete an item from a history
    histget()                get an item from a history
    histnr()                get highest index of a history list
    Spelling:                                        *spell-functions*
    spellbadword()                locate badly spelled word at or after cursor
    spellsuggest()                return suggested spelling corrections
    soundfold()                return the sound-a-like equivalent of a word
    Interactive:                                        *interactive-functions*
    browse()                put up a file requester
    browsedir()                put up a directory requester
    confirm()                let the user make a choice
    getchar()                get a character from the user
    getcharmod()                get modifiers for the last typed character
    feedkeys()                put characters in the typeahead queue
    input()                        get a line from the user
    inputlist()                let the user pick an entry from a list
    inputsecret()                get a line from the user without showing it
    inputdialog()                get a line from the user in a dialog
    inputsave()                save and clear typeahead
    inputrestore()                restore typeahead
    GUI:                                                *gui-functions*
    getfontname()                get name of current font being used
    getwinposx()                X position of the GUI Vim window
    getwinposy()                Y position of the GUI Vim window
    Vim server:                                        *server-functions*
    serverlist()                return the list of server names
    remote_send()                send command characters to a Vim server
    remote_expr()                evaluate an expression in a Vim server
    server2client()                send a reply to a client of a Vim server
    remote_peek()                check if there is a reply from a Vim server
    remote_read()                read a reply from a Vim server
    foreground()                move the Vim window to the foreground
    remote_foreground()        move the Vim server window to the foreground
    Window size and position:                        *window-size-functions*
    winheight()                get height of a specific window
    winwidth()                get width of a specific window
    winrestcmd()                return command to restore window sizes
    winsaveview()                get view of current window
    winrestview()                restore saved view of current window
    Various:                                        *various-functions*
    mode()                        get current editing mode
    visualmode()                last visual mode used
    hasmapto()                check if a mapping exists
    mapcheck()                check if a matching mapping exists
    maparg()                get rhs of a mapping
    exists()                check if a variable, function, etc. exists
    has()                        check if a feature is supported in Vim
    changenr()                return number of most recent change
    cscope_connection()        check if a cscope connection exists
    did_filetype()                check if a FileType autocommand was used
    eventhandler()                check if invoked by an event handler
    getpid()                get process ID of Vim
    libcall()                call a function in an external library
    libcallnr()                idem, returning a number
    getreg()                get contents of a register
    getregtype()                get type of a register
    setreg()                set contents and type of a register
    taglist()                get list of matching tags
    tagfiles()                get a list of tags files
    mzeval()                evaluate |MzScheme| expression
    Error setting the text for the following input: ==============================================================================.
    *41.7*        Defining a function
    Vim enables you to define your own functions.  The basic function declaration
    begins as follows:
    :function {name}({var1}, {var2}, ...)
    :  {body}
    :endfunction
    Note:
    Function names must begin with a capital letter.
    Let's define a short function to return the smaller of two numbers.  It starts
    with this line:
    :function Min(num1, num2)
    This tells Vim that the function is named "Min" and it takes two arguments:
    "num1" and "num2".
    The first thing you need to do is to check to see which number is smaller:
    :  if a:num1 < a:num2
    The special prefix "a:" tells Vim that the variable is a function argument.
    Let's assign the variable "smaller" the value of the smallest number:
    :  if a:num1 < a:num2
    :    let smaller = a:num1
    :  else
    :    let smaller = a:num2
    :  endif
    The variable "smaller" is a local variable.  Variables used inside a function
    are local unless prefixed by something like "g:", "a:", or "s:".
    Note:
    To access a global variable from inside a function you must prepend
    "g:" to it.  Thus "g:today" inside a function is used for the global
    variable "today", and "today" is another variable, local to the
    function.
    You now use the ":return" statement to return the smallest number to the user.
    Finally, you end the function:
    :  return smaller
    :endfunction
    The complete function definition is as follows:
    :function Min(num1, num2)
    :  if a:num1 < a:num2
    :    let smaller = a:num1
    :  else
    :    let smaller = a:num2
    :  endif
    :  return smaller
    :endfunction
    For people who like short functions, this does the same thing:
    :function Min(num1, num2)
    :  if a:num1 < a:num2
    :    return a:num1
    :  endif
    :  return a:num2
    :endfunction
    A user defined function is called in exactly the same way as a built-in
    function.  Only the name is different.  The Min function can be used like
    this:
    :echo Min(5, 8)
    Only now will the function be executed and the lines be interpreted by Vim.
    If there are mistakes, like using an undefined variable or function, you will
    now get an error message.  When defining the function these errors are not
    detected.
    When a function reaches ":endfunction" or ":return" is used without an
    argument, the function returns zero.
    To redefine a function that already exists, use the ! for the ":function"
    command:
    :function!  Min(num1, num2, num3)
    USING A RANGE
    The ":call" command can be given a line range.  This can have one of two
    meanings.  When a function has been defined with the "range" keyword, it will
    take care of the line range itself.
    The function will be passed the variables "a:firstline" and "a:lastline".
    These will have the line numbers from the range the function was called with.
    Example:
    :function Count_words() range
    :  let lnum = a:firstline
    :  let n = 0
    :  while lnum <= a:lastline
    :    let n = n + len(split(getline(lnum)))
    :    let lnum = lnum + 1
    :  endwhile
    :  echo "found " . n . " words"
    :endfunction
    You can call this function with:
    :10,30call Count_words()
    It will be executed once and echo the number of words.
    The other way to use a line range is by defining a function without the
    "range" keyword.  The function will be called once for every line in the
    range, with the cursor in that line.  Example:
    :function  Number()
    :  echo "line " . line(".") . " contains: " . getline(".")
    :endfunction
    If you call this function with:
    :10,15call Number()
    The function will be called six times.
    VARIABLE NUMBER OF ARGUMENTS
    Vim enables you to define functions that have a variable number of arguments.
    The following command, for instance, defines a function that must have 1
    argument (start) and can have up to 20 additional arguments:
    :function Show(start, ...)
    The variable "a:1" contains the first optional argument, "a:2" the second, and
    so on.  The variable "a:0" contains the number of extra arguments.
    For example:
    :function Show(start, ...)
    :  echohl Title
    :  echo "start is " . a:start
    :  echohl None
    :  let index = 1
    :  while index <= a:0
    :    echo "  Arg " . index . " is " . a:{index}
    :    let index = index + 1
    :  endwhile
    :  echo ""
    :endfunction
    This uses the ":echohl" command to specify the highlighting used for the
    following ":echo" command.  ":echohl None" stops it again.  The ":echon"
    command works like ":echo", but doesn't output a line break.
    You can also use the a:000 variable, it is a List of all the "..." arguments.
    See |a:000|.
    LISTING FUNCTIONS
    The ":function" command lists the names and arguments of all user-defined
    functions:
    :function
    function Show(start, ...)
    function GetVimIndent()
    function SetSyn(name)
    To see what a function does, use its name as an argument for ":function":
    :function SetSyn
    1     if &syntax == ''
    2       let &syntax = a:name
    3     endif
    endfunction
    The line number is useful for when you get an error message or when debugging.
    DEBUGGING
    See |debug-scripts| about debugging mode.
    You can also set the 'verbose' option to 12 or higher to see all function
    calls.  Set it to 15 or higher to see every executed line.
    DELETING A FUNCTION
    To delete the Show() function:
    :delfunction Show
    You get an error when the function doesn't exist.
    FUNCTION REFERENCES
    Sometimes it can be useful to have a variable point to one function or
    another.  You can do it with the function() function.  It turns the name of a
    function into a reference:
    :let result = 0                " or 1
    :function! Right()
    :  return 'Right!'
    :endfunc
    :function! Wrong()
    :  return 'Wrong!'
    :endfunc
    :
    :if result == 1
    :  let Afunc = function('Right')
    :else
    :  let Afunc = function('Wrong')
    :endif
    :echo call(Afunc, [])
    Wrong!
    Note that the name of a variable that holds a function reference must start
    with a capital.  Otherwise it could be confused with the name of a builtin
    function.
    The way to invoke a function that a variable refers to is with the call()
    function.  Its first argument is the function reference, the second argument
    is a List with arguments.
    Function references are most useful in combination with a Dictionary, as is
    explained in the next section.
    Error setting the text for the following input: ==============================================================================.
    *41.8*        Lists and Dictionaries
    So far we have used the basic types String and Number.  Vim also supports two
    composite types: List and Dictionary.
    A List is an ordered sequence of things.  The things can be any kind of value,
    thus you can make a List of numbers, a List of Lists and even a List of mixed
    items.  To create a List with three strings:
    :let alist = ['aap', 'mies', 'noot']
    The List items are enclosed in square brackets and separated by commas.  To
    create an empty List:
    :let alist = []
    You can add items to a List with the add() function:
    :let alist = []
    :call add(alist, 'foo')
    :call add(alist, 'bar')
    :echo alist
    ['foo', 'bar']
    List concatenation is done with +:
    :echo alist + ['foo', 'bar']
    ['foo', 'bar', 'foo', 'bar']
    Or, if you want to extend a List directly:
    :let alist = ['one']
    :call extend(alist, ['two', 'three'])
    :echo alist
    ['one', 'two', 'three']
    Notice that using add() will have a different effect:
    :let alist = ['one']
    :call add(alist, ['two', 'three'])
    :echo alist
    ['one', ['two', 'three']]
    The second argument of add() is added as a single item.
    FOR LOOP
    One of the nice things you can do with a List is iterate over it:
    :let alist = ['one', 'two', 'three']
    :for n in alist
    :  echo n
    :endfor
    one
    two
    three
    This will loop over each element in List "alist", assigning the value to
    variable "n".  The generic form of a for loop is:
    :for {varname} in {listexpression}
    :  {commands}
    :endfor
    To loop a certain number of times you need a List of a specific length.  The
    range() function creates one for you:
    :for a in range(3)
    :  echo a
    :endfor
    0
    1
    2
    Notice that the first item of the List that range() produces is zero, thus the
    last item is one less than the length of the list.
    You can also specify the maximum value, the stride and even go backwards:
    :for a in range(8, 4, -2)
    :  echo a
    :endfor
    8
    6
    4
    A more useful example, looping over lines in the buffer:
    :for line in getline(1, 20)
    :  if line =~ "Date: "
    :    echo matchstr(line, 'Date: \zs.*')
    :  endif
    :endfor
    This looks into lines 1 to 20 (inclusive) and echoes any date found in there.
    DICTIONARIES
    A Dictionary stores key-value pairs.  You can quickly lookup a value if you
    know the key.  A Dictionary is created with curly braces:
    :let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
    Now you can lookup words by putting the key in square brackets:
    :echo uk2nl['two']
    twee
    The generic form for defining a Dictionary is:
    {<key> : <value>, ...}
    An empty Dictionary is one without any keys:
    {}
    The possibilities with Dictionaries are numerous.  There are various functions
    for them as well.  For example, you can obtain a list of the keys and loop
    over them:
    :for key in keys(uk2nl)
    :  echo key
    :endfor
    three
    one
    two
    You will notice the keys are not ordered.  You can sort the list to get a
    specific order:
    :for key in sort(keys(uk2nl))
    :  echo key
    :endfor
    one
    three
    two
    But you can never get back the order in which items are defined.  For that you
    need to use a List, it stores items in an ordered sequence.
    DICTIONARY FUNCTIONS
    The items in a Dictionary can normally be obtained with an index in square
    brackets:
    :echo uk2nl['one']
    een
    A method that does the same, but without so many punctuation characters:
    :echo uk2nl.one
    een
    This only works for a key that is made of ASCII letters, digits and the
    underscore.  You can also assign a new value this way:
    :let uk2nl.four = 'vier'
    :echo uk2nl
    {'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'}
    And now for something special: you can directly define a function and store a
    reference to it in the dictionary:
    :function uk2nl.translate(line) dict
    :  return join(map(split(a:line), 'get(self, v:val, "???")'))
    :endfunction
    Let's first try it out:
    :echo uk2nl.translate('three two five one')
    drie twee ??? een
    The first special thing you notice is the "dict" at the end of the ":function"
    line.  This marks the function as being used from a Dictionary.  The "self"
    local variable will then refer to that Dictionary.
    Now let's break up the complicated return command:
    split(a:line)
    The split() function takes a string, chops it into whitespace separated words
    and returns a list with these words.  Thus in the example it returns:
    :echo split('three two five one')
    ['three', 'two', 'five', 'one']
    This list is the first argument to the map() function.  This will go through
    the list, evaluating its second argument with "v:val" set to the value of each
    item.  This is a shortcut to using a for loop.  This command:
    :let alist = map(split(a:line), 'get(self, v:val, "???")')
    Is equivalent to:
    :let alist = split(a:line)
    :for idx in range(len(alist))
    :  let alist[idx] = get(self, alist[idx], "???")
    :endfor
    The get() function checks if a key is present in a Dictionary.  If it is, then
    the value is retrieved.  If it isn't, then the default value is returned, in
    the example it's '???'.  This is a convenient way to handle situations where a
    key may not be present and you don't want an error message.
    The join() function does the opposite of split(): it joins together a list of
    words, putting a space in between.
    This combination of split(), map() and join() is a nice way to filter a line
    of words in a very compact way.
    OBJECT ORIENTED PROGRAMMING
    Now that you can put both values and functions in a Dictionary, you can
    actually use a Dictionary like an object.
    Above we used a Dictionary for translating Dutch to English.  We might want
    to do the same for other languages.  Let's first make an object (aka
    Dictionary) that has the translate function, but no words to translate:
    :let transdict = {}
    :function transdict.translate(line) dict
    :  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
    :endfunction
    It's slightly different from the function above, using 'self.words' to lookup
    word translations.  But we don't have a self.words.  Thus you could call this
    an abstract class.
    Now we can instantiate a Dutch translation object:
    :let uk2nl = copy(transdict)
    :let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
    :echo uk2nl.translate('three one')
    drie een
    And a German translator:
    :let uk2de = copy(transdict)
    :let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
    :echo uk2de.translate('three one')
    drei ein
    You see that the copy() function is used to make a copy of the "transdict"
    Dictionary and then the copy is changed to add the words.  The original
    remains the same, of course.
    Now you can go one step further, and use your preferred translator:
    :if $LANG =~ "de"
    :  let trans = uk2de
    :else
    :  let trans = uk2nl
    :endif
    :echo trans.translate('one two three')
    een twee drie
    Here "trans" refers to one of the two objects (Dictionaries).  No copy is
    made.  More about List and Dictionary identity can be found at |list-identity|
    and |dict-identity|.
    Now you might use a language that isn't supported.  You can overrule the
    translate() function to do nothing:
    :let uk2uk = copy(transdict)
    :function! uk2uk.translate(line)
    :  return a:line
    :endfunction
    :echo uk2uk.translate('three one wladiwostok')
    three one wladiwostok
    Notice that a ! was used to overwrite the existing function reference.  Now
    use "uk2uk" when no recognized language is found:
    :if $LANG =~ "de"
    :  let trans = uk2de
    :elseif $LANG =~ "nl"
    :  let trans = uk2nl
    :else
    :  let trans = uk2uk
    :endif
    :echo trans.translate('one two three')
    one two three
    For further reading see |Lists| and |Dictionaries|.
    Error setting the text for the following input: ==============================================================================.
    *41.9*        Exceptions
    Let's start with an example:
    :try
    :   read ~/templates/pascal.tmpl
    :catch /E484:/
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry
    The ":read" command will fail if the file does not exist.  Instead of
    generating an error message, this code catches the error and gives the user a
    nice message.
    For the commands in between ":try" and ":endtry" errors are turned into
    exceptions.  An exception is a string.  In the case of an error the string
    contains the error message.  And every error message has a number.  In this
    case, the error we catch contains "E484:".  This number is guaranteed to stay
    the same (the text may change, e.g., it may be translated).
    When the ":read" command causes another error, the pattern "E484:" will not
    match in it.  Thus this exception will not be caught and result in the usual
    error message.
    You might be tempted to do this:
    :try
    :   read ~/templates/pascal.tmpl
    :catch
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry
    This means all errors are caught.  But then you will not see errors that are
    useful, such as "E21: Cannot make changes, 'modifiable' is off".
    Another useful mechanism is the ":finally" command:
    :let tmp = tempname()
    :try
    :   exe ".,$write " . tmp
    :   exe "!filter " . tmp
    :   .,$delete
    :   exe "$read " . tmp
    :finally
    :   call delete(tmp)
    :endtry
    This filters the lines from the cursor until the end of the file through the
    "filter" command, which takes a file name argument.  No matter if the
    filtering works, something goes wrong in between ":try" and ":finally" or the
    user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
    always executed.  This makes sure you don't leave the temporary file behind.
    More information about exception handling can be found in the reference
    manual: |exception-handling|.
    Error setting the text for the following input: ==============================================================================.
    *41.10*        Various remarks
    Here is a summary of items that apply to Vim scripts.  They are also mentioned
    elsewhere, but form a nice checklist.
    The end-of-line character depends on the system.  For Unix a single <NL>
    character is used.  For MS-DOS, Windows, OS/2 and the like, <CR><LF> is used.
    This is important when using mappings that end in a <CR>.  See |:source_crnl|.
    WHITE SPACE
    Blank lines are allowed and ignored.
    Leading whitespace characters (blanks and TABs) are always ignored.  The
    whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in
    the example below) are reduced to one blank character and plays the role of a
    separator, the whitespaces after the last (visible) character may or may not
    be ignored depending on the situation, see below.
    For a ":set" command involving the "=" (equal) sign, such as in:
    :set cpoptions    =aABceFst
    the whitespace immediately before the "=" sign is ignored.  But there can be
    no whitespace after the "=" sign!
    To include a whitespace character in the value of an option, it must be
    escaped by a "\" (backslash)  as in the following example:
    :set tags=my\ nice\ file
    The same example written as:
    :set tags=my nice file
    will issue an error, because it is interpreted as:
    :set tags=my
    :set nice
    :set file
    COMMENTS
    The character " (the double quote mark) starts a comment.  Everything after
    and including this character until the end-of-line is considered a comment and
    is ignored, except for commands that don't consider comments, as shown in
    examples below.  A comment can start on any character position on the line.
    There is a little "catch" with comments for some commands.  Examples:
    :abbrev dev development                " shorthand
    :map <F3> o#include                " insert include
    :execute cmd                        " do it
    :!ls *.c                        " list C files
    The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
    mapping of <F3> will actually be the whole line after the 'o# ....' including
    the '"' insert include'.  The "execute" command will give an error.  The "!"
    command will send everything after it to the shell, causing an error for an
    unmatched '"'' character.
    There can be no comment after ":map", ":abbreviate", ":execute" and "!"
    commands (there are a few more commands with this restriction).  For the
    ":map", ":abbreviate" and ":execute" commands there is a trick:
    :abbrev dev development|" shorthand
    :map <F3> o#include|" insert include
    :execute cmd                        |" do it
    With the '|' character the command is separated from the next one.  And that
    next command is only a comment.  For the last command you need to do two
    things: |:execute| and use '|':
    :exe '!ls *.c'                        |" list C files
    Notice that there is no white space before the '|' in the abbreviation and
    mapping.  For these commands, any character until the end-of-line or '|' is
    included.  As a consequence of this behavior, you don't always see that
    trailing whitespace is included:
    :map <F4> o#include
    To spot these problems, you can set the 'list' option when editing vimrc
    files.
    For Unix there is one special way to comment a line, that allows making a Vim
    script executable:
    #!/usr/bin/env vim -S
    echo "this is a Vim script"
    quit
    The "#" command by itself lists a line with the line number.  Adding an
    exclamation mark changes it into doing nothing, so that you can add the shell
    command to execute the rest of the file. |:#!| |-S|
    PITFALLS
    Even bigger problem arises in the following example:
    :map ,ab o#include
    :unmap ,ab
    Here the unmap command will not work, because it tries to unmap ",ab ".  This
    does not exist as a mapped sequence.  An error will be issued, which is very
    hard to identify, because the ending whitespace character in ":unmap ,ab " is
    not visible.
    And this is the same as what happens when one uses a comment after an 'unmap'
    command:
    :unmap ,ab     " comment
    Here the comment part will be ignored.  However, Vim will try to unmap
    ,ab     '', which does not exist.  Rewrite it as:
    :unmap ,ab|    " comment
    RESTORING THE VIEW
    Sometimes you want to make a change and go back to where cursor was.
    Restoring the relative position would also be nice, so that the same line
    appears at the top of the window.
    This example yanks the current line, puts it above the first line in the
    file and then restores the view:
    map ,p ma"aYHmbgg"aP`bzt`a
    What this does:
    ma"aYHmbgg"aP`bzt`a
    ma                        set mark a at cursor position
    "aY                        yank current line into register a
    Hmb                go to top line in window and set mark b there
    gg                go to first line in file
    "aP                put the yanked line above it
    `b                go back to top line in display
    zt        position the text in the window as before
    `a        go back to saved cursor position
    PACKAGING
    others, use this scheme:
    To avoid your function names to interfere with functions that you get from
    - Prepend a unique string before each function name.  I often use an
    abbreviation.  For example, "OW_" is used for the option window functions.
    - Put the definition of your functions together in a file.  Set a global
    variable to indicate that the functions have been loaded.  When sourcing the
    file again, first unload the functions.
    Example:
    " This is the XXX package
    if exists("XXX_loaded")
    delfun XXX_one
    delfun XXX_two
    endif
    function XXX_one(a)
    ... body of function ...
    endfun
    function XXX_two(b)
    ... body of function ...
    endfun
    let XXX_loaded = 1
    Error setting the text for the following input: ==============================================================================.
    *41.11*        Writing a plugin                                *write-plugin*
    You can write a Vim script in such a way that many people can use it.  This is
    called a plugin.  Vim users can drop your script in their plugin directory and
    use its features right away |add-plugin|.
    There are actually two types of plugins:
    global plugins: For all types of files.
    filetype plugins: Only for files of a specific type.
    In this section the first type is explained.  Most items are also relevant for
    writing filetype plugins.  The specifics for filetype plugins are in the next
    section |write-filetype-plugin|.
    NAME
    First of all you must choose a name for your plugin.  The features provided
    by the plugin should be clear from its name.  And it should be unlikely that
    someone else writes a plugin with the same name but which does something
    different.  And please limit the name to 8 characters, to avoid problems on
    old Windows systems.
    A script that corrects typing mistakes could be called "typecorr.vim".  We
    will use it here as an example.
    For the plugin to work for everybody, it should follow a few guidelines.  This
    will be explained step-by-step.  The complete example plugin is at the end.
    BODY
    Let's start with the body of the plugin, the lines that do the actual work:
    14        iabbrev teh the
    15        iabbrev otehr other
    16        iabbrev wnat want
    17        iabbrev synchronisation
    18                \ synchronization
    19        let s:count = 4
    The actual list should be much longer, of course.
    The line numbers have only been added to explain a few things, don't put them
    in your plugin file!
    HEADER
    You will probably add new corrections to the plugin and soon have several
    versions laying around.  And when distributing this file, people will want to
    know who wrote this wonderful plugin and where they can send remarks.
    Therefore, put a header at the top of your plugin:
    1        " Vim global plugin for correcting typing mistakes
    2        " Last Change:        2000 Oct 15
    3        " Maintainer:        Bram Moolenaar <Bram@vim.org> <mailto:Bram@vim.org>
    About copyright and licensing: Since plugins are very useful and it's hardly
    worth restricting their distribution, please consider making your plugin
    either public domain or use the Vim |license|.  A short note about this near
    the top of the plugin should be sufficient.  Example:
    4        " License:        This file is placed in the public domain.
    LINE CONTINUATION, AVOIDING SIDE EFFECTS                *use-cpo-save*
    In line 18 above, the line-continuation mechanism is used |line-continuation|.
    Users with 'compatible' set will run into trouble here, they will get an error
    message.  We can't just reset 'compatible', because that has a lot of side
    effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
    value and restore it later.  That will allow the use of line-continuation and
    make the script work for most people.  It is done like this:
    11        let s:save_cpo = &cpo
    12        set cpo&vim
    ..
    42        let &cpo = s:save_cpo
    We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
    the end of the plugin this value is restored.
    Notice that a script-local variable is used |s:var|.  A global variable could
    already be in use for something else.  Always use script-local variables for
    things that are only used in the script.
    NOT LOADING
    It's possible that a user doesn't always want to load this plugin.  Or the
    system administrator has dropped it in the system-wide plugin directory, but a
    user has his own plugin he wants to use.  Then the user must have a chance to
    disable loading this specific plugin.  This will make it possible:
    6        if exists("g:loaded_typecorr")
    7          finish
    8        endif
    9        let g:loaded_typecorr = 1
    This also avoids that when the script is loaded twice it would cause error
    messages for redefining functions and cause trouble for autocommands that are
    added twice.
    The name is recommended to start with "loaded_" and then the file name of the
    plugin, literally.  The "g:" is prepended just to avoid mistakes when using
    the variable in a function (without "g:" it would be a variable local to the
    function).
    Using "finish" stops Vim from reading the rest of the file, it's much quicker
    than using if-endif around the whole file.
    MAPPING
    Now let's make the plugin more interesting: We will add a mapping that adds a
    correction for the word under the cursor.  We could just pick a key sequence
    for this mapping, but the user might already use it for something else.  To
    allow the user to define which keys a mapping in a plugin uses, the <Leader>
    item can be used:
    22          map <unique> <Leader>a  <Plug>TypecorrAdd
    The "<Plug>TypecorrAdd" thing will do the work, more about that further on.
    The user can set the "mapleader" variable to the key sequence that he wants
    this mapping to start with.  Thus if the user has done:
    let mapleader = "_"
    the mapping will define "_a".  If the user didn't do this, the default value
    will be used, which is a backslash.  Then a map for "\a" will be defined.
    Note that <unique> is used, this will cause an error message if the mapping
    already happened to exist. |:map-<unique>|
    But what if the user wants to define his own key sequence?  We can allow that
    with this mechanism:
    21        if !hasmapto('<Plug>TypecorrAdd')
    22          map <unique> <Leader>a  <Plug>TypecorrAdd
    23        endif
    This checks if a mapping to "<Plug>TypecorrAdd" already exists, and only
    defines the mapping from "<Leader>a" if it doesn't.  The user then has a
    chance of putting this in his vimrc file:
    map ,c  <Plug>TypecorrAdd
    Then the mapped key sequence will be ",c" instead of "_a" or "\a".
    PIECES
    If a script gets longer, you often want to break up the work in pieces.  You
    can use functions or mappings for this.  But you don't want these functions
    and mappings to interfere with the ones from other scripts.  For example, you
    could define a function Add(), but another script could try to define the same
    function.  To avoid this, we define the function local to the script by
    prepending it with "s:".
    We will define a function that adds a new typing correction:
    30        function s:Add(from, correct)
    31          let to = input("type the correction for " . a:from . ": ")
    32          exe ":iabbrev " . a:from . " " . to
    ..
    36        endfunction
    Now we can call the function s:Add() from within this script.  If another
    script also defines s:Add(), it will be local to that script and can only
    be called from the script it was defined in.  There can also be a global Add()
    function (without the "s:"), which is again another function.
    <SID> can be used with mappings.  It generates a script ID, which identifies
    the current script.  In our typing correction plugin we use it like this:
    24        noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
    ..
    28        noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
    Thus when a user types "\a", this sequence is invoked:
    \a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()
    If another script would also map <SID>Add, it would get another script ID and
    thus define another mapping.
    Note that instead of s:Add() we use <SID>Add() here.  That is because the
    mapping is typed by the user, thus outside of the script.  The <SID> is
    translated to the script ID, so that Vim knows in which script to look for
    the Add() function.
    This is a bit complicated, but it's required for the plugin to work together
    with other plugins.  The basic rule is that you use <SID>Add() in mappings and
    s:Add() in other places (the script itself, autocommands, user commands).
    We can also add a menu entry to do the same as the mapping:
    26        noremenu <script> Plugin.Add\ Correction      <SID>Add
    The "Plugin" menu is recommended for adding menu items for plugins.  In this
    case only one item is used.  When adding more items, creating a submenu is
    recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
    CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.
    Note that in line 28 ":noremap" is used to avoid that any other mappings cause
    trouble.  Someone may have remapped ":call", for example.  In line 24 we also
    use ":noremap", but we do want "<SID>Add" to be remapped.  This is why
    "<script>" is used here.  This only allows mappings which are local to the
    script. |:map-<script>|  The same is done in line 26 for ":noremenu".
    |:menu-<script>|
    <SID> AND <Plug>                                        *using-<Plug>*
    Both <SID> and <Plug> are used to avoid that mappings of typed keys interfere
    with mappings that are only to be used from other mappings.  Note the
    difference between using <SID> and <Plug>:
    <Plug>        is visible outside of the script.  It is used for mappings which the
    user might want to map a key sequence to.  <Plug> is a special code
    that a typed key will never produce.
    To make it very unlikely that other plugins use the same sequence of
    characters, use this structure: <Plug> scriptname mapname
    In our example the scriptname is "Typecorr" and the mapname is "Add".
    This results in "<Plug>TypecorrAdd".  Only the first character of
    scriptname and mapname is uppercase, so that we can see where mapname
    starts.
    <SID>        is the script ID, a unique identifier for a script.
    Internally Vim translates <SID> to "<SNR>123_", where "123" can be any
    number.  Thus a function "<SID>Add()" will have a name "<SNR>11_Add()"
    in one script, and "<SNR>22_Add()" in another.  You can see this if
    you use the ":function" command to get a list of functions.  The
    translation of <SID> in mappings is exactly the same, that's how you
    can call a script-local function from a mapping.
    USER COMMAND
    Now let's add a user command to add a correction:
    38        if !exists(":Correct")
    39          command -nargs=1  Correct  :call s:Add(<q-args>, 0)
    40        endif
    The user command is defined only if no command with the same name already
    exists.  Otherwise we would get an error here.  Overriding the existing user
    command with ":command!" is not a good idea, this would probably make the user
    wonder why the command he defined himself doesn't work.  |:command|
    SCRIPT VARIABLES
    When a variable starts with "s:" it is a script variable.  It can only be used
    inside a script.  Outside the script it's not visible.  This avoids trouble
    with using the same variable name in different scripts.  The variables will be
    kept as long as Vim is running.  And the same variables are used when sourcing
    the same script again. |s:var|
    The fun is that these variables can also be used in functions, autocommands
    and user commands that are defined in the script.  In our example we can add
    a few lines to count the number of corrections:
    19        let s:count = 4
    ..
    30        function s:Add(from, correct)
    ..
    34          let s:count = s:count + 1
    35          echo s:count . " corrections now"
    36        endfunction
    First s:count is initialized to 4 in the script itself.  When later the
    s:Add() function is called, it increments s:count.  It doesn't matter from
    where the function was called, since it has been defined in the script, it
    will use the local variables from this script.
    THE RESULT
    Here is the resulting complete example:
    1        " Vim global plugin for correcting typing mistakes
    2        " Last Change:        2000 Oct 15
    3        " Maintainer:        Bram Moolenaar <Bram@vim.org> <mailto:Bram@vim.org>
    4        " License:        This file is placed in the public domain.
    5
    6        if exists("g:loaded_typecorr")
    7          finish
    8        endif
    9        let g:loaded_typecorr = 1
    10
    11        let s:save_cpo = &cpo
    12        set cpo&vim
    13
    14        iabbrev teh the
    15        iabbrev otehr other
    16        iabbrev wnat want
    17        iabbrev synchronisation
    18                \ synchronization
    19        let s:count = 4
    20
    21        if !hasmapto('<Plug>TypecorrAdd')
    22          map <unique> <Leader>a  <Plug>TypecorrAdd
    23        endif
    24        noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
    25
    26        noremenu <script> Plugin.Add\ Correction      <SID>Add
    27
    28        noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
    29
    30        function s:Add(from, correct)
    31          let to = input("type the correction for " . a:from . ": ")
    32          exe ":iabbrev " . a:from . " " . to
    33          if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
    34          let s:count = s:count + 1
    35          echo s:count . " corrections now"
    36        endfunction
    37
    38        if !exists(":Correct")
    39          command -nargs=1  Correct  :call s:Add(<q-args>, 0)
    40        endif
    41
    42        let &cpo = s:save_cpo
    Line 33 wasn't explained yet.  It applies the new correction to the word under
    the cursor.  The |:normal| command is used to use the new abbreviation.  Note
    that mappings and abbreviations are expanded here, even though the function
    was called from a mapping defined with ":noremap".
    Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
    then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
    Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
    writing the file:
    :set fileformat=unix
    DOCUMENTATION                                                *write-local-help*
    It's a good idea to also write some documentation for your plugin.  Especially
    when its behavior can be changed by the user.  See |add-local-help| for how
    they are installed.
    Here is a simple example for a plugin help file, called "typecorr.txt":
    1        *typecorr.txt*        Plugin for correcting typing mistakes
    2
    3        If you make typing mistakes, this plugin will have them corrected
    4        automatically.
    5
    6        There are currently only a few corrections.  Add your own if you like.
    7
    8        Mappings:
    9        <Leader>a   or   <Plug>TypecorrAdd
    10                Add a correction for the word under the cursor.
    11
    12        Commands:
    13        :Correct {word}
    14                Add a correction for {word}.
    15
    16                                                        *typecorr-settings*
    17        This plugin doesn't have any settings.
    The first line is actually the only one for which the format matters.  It will
    be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
    help.txt |local-additions|.  The first "*" must be in the first column of the
    first line.  After adding your help file do ":help" and check that the entries
    line up nicely.
    You can add more tags inside ** in your help file.  But be careful not to use
    existing help tags.  You would probably use the name of your plugin in most of
    them, like "typecorr-settings" in the example.
    Using references to other parts of the help in || is recommended.  This makes
    it easy for the user to find associated help.
    FILETYPE DETECTION                                        *plugin-filetype*
    If your filetype is not already detected by Vim, you should create a filetype
    detection snippet in a separate file.  It is usually in the form of an
    autocommand that sets the filetype when the file name matches a pattern.
    Example:
    au BufNewFile,BufRead *.foo                        set filetype=foofoo
    Write this single-line file as "ftdetect/foofoo.vim" in the first directory
    that appears in 'runtimepath'.  For Unix that would be
    "~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the
    filetype for the script name.
    You can make more complicated checks if you like, for example to inspect the
    contents of the file to recognize the language.  Also see |new-filetype|.
    SUMMARY                                                        *plugin-special*
    Summary of special things to use in a plugin:
    s:name                        Variables local to the script.
    <SID>                        Script-ID, used for mappings and functions local to
    the script.
    hasmapto()                Function to test if the user already defined a mapping
    for functionality the script offers.
    <Leader>                Value of "mapleader", which the user defines as the
    keys that plugin mappings start with.
    :map <unique>                Give a warning if a mapping already exists.
    :noremap <script>        Use only mappings local to the script, not global
    mappings.
    exists(":Cmd")                Check if a user command already exists.
    Error setting the text for the following input: ==============================================================================.
    *41.12*        Writing a filetype plugin        *write-filetype-plugin* *ftplugin*
    A filetype plugin is like a global plugin, except that it sets options and
    defines mappings for the current buffer only.  See |add-filetype-plugin| for
    how this type of plugin is used.
    First read the section on global plugins above |41.11|.  All that is said there
    also applies to filetype plugins.  There are a few extras, which are explained
    here.  The essential thing is that a filetype plugin should only have an
    effect on the current buffer.
    DISABLING
    If you are writing a filetype plugin to be used by many people, they need a
    chance to disable loading it.  Put this at the top of the plugin:
    " Only do this when not done yet for this buffer
    if exists("b:did_ftplugin")
    finish
    endif
    let b:did_ftplugin = 1
    This also needs to be used to avoid that the same plugin is executed twice for
    the same buffer (happens when using an ":edit" command without arguments).
    Now users can disable loading the default plugin completely by making a
    filetype plugin with only this line:
    let b:did_ftplugin = 1
    This does require that the filetype plugin directory comes before $VIMRUNTIME
    in 'runtimepath'!
    If you do want to use the default plugin, but overrule one of the settings,
    you can write the different setting in a script:
    setlocal textwidth=70
    Now write this in the "after" directory, so that it gets sourced after the
    distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be
    "~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set
    "b:did_ftplugin", but it is ignored here.
    OPTIONS
    To make sure the filetype plugin only affects the current buffer use the
    :setlocal
    command to set options.  And only set options which are local to a buffer (see
    the help for the option to check that).  When using |:setlocal| for global
    options or options local to a window, the value will change for many buffers,
    and that is not what a filetype plugin should do.
    When an option has a value that is a list of flags or items, consider using
    "+=" and "-=" to keep the existing value.  Be aware that the user may have
    changed an option value already.  First resetting to the default value and
    then changing it is often a good idea.  Example:
    :setlocal formatoptions& formatoptions+=ro
    MAPPINGS
    To make sure mappings will only work in the current buffer use the
    :map <buffer>
    command.  This needs to be combined with the two-step mapping explained above.
    An example of how to define functionality in a filetype plugin:
    if !hasmapto('<Plug>JavaImport')
    map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
    endif
    noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>
    |hasmapto()| is used to check if the user has already defined a map to
    <Plug>JavaImport.  If not, then the filetype plugin defines the default
    mapping.  This starts with |<LocalLeader>|, which allows the user to select
    the key(s) he wants filetype plugin mappings to start with.  The default is a
    backslash.
    "<unique>" is used to give an error message if the mapping already exists or
    overlaps with an existing mapping.
    |:noremap| is used to avoid that any other mappings that the user has defined
    interferes.  You might want to use ":noremap <script>" to allow remapping
    mappings defined in this script that start with <SID>.
    The user must have a chance to disable the mappings in a filetype plugin,
    without disabling everything.  Here is an example of how this is done for a
    plugin for the mail filetype:
    " Add mappings, unless the user didn't want this.
    if !exists("no_plugin_maps") && !exists("no_mail_maps")
    " Quote text by inserting "> "
    if !hasmapto('<Plug>MailQuote')
    vmap <buffer> <LocalLeader>q <Plug>MailQuote
    nmap <buffer> <LocalLeader>q <Plug>MailQuote
    endif
    vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
    nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
    endif
    Two global variables are used:
    no_plugin_maps                disables mappings for all filetype plugins
    no_mail_maps                disables mappings for a specific filetype
    USER COMMANDS
    To add a user command for a specific file type, so that it can only be used in
    one buffer, use the "-buffer" argument to |:command|.  Example:
    :command -buffer  Make  make %:r.s
    VARIABLES
    A filetype plugin will be sourced for each buffer of the type it's for.  Local
    script variables |s:var| will be shared between all invocations.  Use local
    buffer variables |b:var| if you want a variable specifically for one buffer.
    FUNCTIONS
    When defining a function, this only needs to be done once.  But the filetype
    plugin will be sourced every time a file with this filetype will be opened.
    This construct makes sure the function is only defined once:
    :if !exists("*s:Func")
    :  function s:Func(arg)
    :    ...
    :  endfunction
    :endif
    UNDO                                                        *undo_ftplugin*
    When the user does ":setfiletype xyz" the effect of the previous filetype
    should be undone.  Set the b:undo_ftplugin variable to the commands that will
    undo the settings in your filetype plugin.  Example:
    let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
    \ . "| unlet b:match_ignorecase b:match_words b:match_skip"
    Using ":setlocal" with "<" after the option name resets the option to its
    global value.  That is mostly the best way to reset the option value.
    This does require removing the "C" flag from 'cpoptions' to allow line
    continuation, as mentioned above |use-cpo-save|.
    FILE NAME
    The filetype must be included in the file name |ftplugin-name|.  Use one of
    these three forms:
    .../ftplugin/stuff.vim
    .../ftplugin/stuff_foo.vim
    .../ftplugin/stuff/bar.vim
    "stuff" is the filetype, "foo" and "bar" are arbitrary names.
    SUMMARY                                                        *ftplugin-special*
    Summary of special things to use in a filetype plugin:
    <LocalLeader>                Value of "maplocalleader", which the user defines as
    the keys that filetype plugin mappings start with.
    :map <buffer>                Define a mapping local to the buffer.
    :noremap <script>        Only remap mappings defined in this script that start
    with <SID>.
    :setlocal                Set an option for the current buffer only.
    :command -buffer        Define a user command local to the buffer.
    exists("*s:Func")        Check if a function was already defined.
    Also see |plugin-special|, the special things used for all plugins.
    Error setting the text for the following input: ==============================================================================.
    *41.13*        Writing a compiler plugin                *write-compiler-plugin*
    A compiler plugin sets options for use with a specific compiler.  The user can
    load it with the |:compiler| command.  The main use is to set the
    errorformat' and 'makeprg' options.
    Easiest is to have a look at examples.  This command will edit all the default
    compiler plugins:
    :next $VIMRUNTIME/compiler/*.vim
    Use |:next| to go to the next plugin file.
    There are two special items about these files.  First is a mechanism to allow
    a user to overrule or add to the default file.  The default files start with:
    :if exists("current_compiler")
    :  finish
    :endif
    :let current_compiler = "mine"
    When you write a compiler file and put it in your personal runtime directory
    (e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
    make the default file skip the settings.
    *:CompilerSet*
    The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
    ":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
    older Vim versions don't, thus your plugin should define it then.  This is an
    example:
    if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
    endif
    CompilerSet errorformat&                " use the default 'errorformat'
    CompilerSet makeprg=nmake
    When you write a compiler plugin for the Vim distribution or for a system-wide
    runtime directory, use the mechanism mentioned above.  When
    "current_compiler" was already set by a user plugin nothing will be done.
    When you write a compiler plugin to overrule settings from a default plugin,
    don't check "current_compiler".  This plugin is supposed to be loaded
    last, thus it should be in a directory at the end of 'runtimepath'.  For Unix
    that could be ~/.vim/after/compiler.
    Error setting the text for the following input: ==============================================================================.
    *41.14*        Writing a plugin that loads quickly        *write-plugin-quickload*
    A plugin may grow and become quite long.  The startup delay may become
    noticeable, while you hardly ever use the plugin.  Then it's time for a
    quickload plugin.
    The basic idea is that the plugin is loaded twice.  The first time user
    commands and mappings are defined that offer the functionality.  The second
    time the functions that implement the functionality are defined.
    It may sound surprising that quickload means loading a script twice.  What we
    mean is that it loads quickly the first time, postponing the bulk of the
    script to the second time, which only happens when you actually use it.  When
    you always use the functionality it actually gets slower!
    Note that since Vim 7 there is an alternative: use the |autoload|
    functionality |41.15|.
    The following example shows how it's done:
    " Vim global plugin for demonstrating quick loading
    " Last Change:        2005 Feb 25
    " Maintainer:        Bram Moolenaar <Bram@vim.org> <mailto:Bram@vim.org>
    " License:        This file is placed in the public domain.
    if !exists("s:did_load")
    command -nargs=* BNRead  call BufNetRead(<f-args>)
    map <F19> :call BufNetWrite('something')<CR>
    let s:did_load = 1
    exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
    finish
    endif
    function BufNetRead(...)
    echo 'BufNetRead(' . string(a:000) . ')'
    " read functionality here
    endfunction
    function BufNetWrite(...)
    echo 'BufNetWrite(' . string(a:000) . ')'
    " write functionality here
    endfunction
    When the script is first loaded "s:did_load" is not set.  The commands between
    the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
    the rest of the script is not executed.
    The second time the script is loaded "s:did_load" exists and the commands
    after the "endif" are executed.  This defines the (possible long)
    BufNetRead() and BufNetWrite() functions.
    If you drop this script in your plugin directory Vim will execute it on
    startup.  This is the sequence of events that happens:
    1. The "BNRead" command is defined and the <F19> key is mapped when the script
    is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
    ":finish" command causes the script to terminate early.
    2. The user types the BNRead command or presses the <F19> key.  The
    BufNetRead() or BufNetWrite() function will be called.
    3. Vim can't find the function and triggers the |FuncUndefined| autocommand
    event.  Since the pattern "BufNet*" matches the invoked function, the
    command "source fname" will be executed.  "fname" will be equal to the name
    of the script, no matter where it is located, because it comes from
    expanding "<sfile>" (see |expand()|).
    4. The script is sourced again, the "s:did_load" variable exists and the
    functions are defined.
    Notice that the functions that are loaded afterwards match the pattern in the
    |FuncUndefined| autocommand.  You must make sure that no other plugin defines
    functions that match this pattern.
    Error setting the text for the following input: ==============================================================================.
    *41.15*        Writing library scripts                        *write-library-script*
    Some functionality will be required in several places.  When this becomes more
    than a few lines you will want to put it in one script and use it from many
    scripts.  We will call that one script a library script.
    Manually loading a library script is possible, so long as you avoid loading it
    when it's already done.  You can do this with the |exists()| function.
    Example:
    if !exists('*MyLibFunction')
    runtime library/mylibscript.vim
    endif
    call MyLibFunction(arg)
    Here you need to know that MyLibFunction() is defined in a script
    "library/mylibscript.vim" in one of the directories in 'runtimepath'.
    To make this a bit simpler Vim offers the autoload mechanism.  Then the
    example looks like this:
    call mylib#myfunction(arg)
    That's a lot simpler, isn't it?  Vim will recognize the function name and when
    it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
    That script must define the "mylib#myfunction()" function.
    You can put many other functions in the mylib.vim script, you are free to
    organize your functions in library scripts.  But you must use function names
    where the part before the '#' matches the script name.  Otherwise Vim would
    not know what script to load.
    If you get really enthusiastic and write lots of library scripts, you may
    want to use subdirectories.  Example:
    call netlib#ftp#read('somefile')
    For Unix the library script used for this could be:
    ~/.vim/autoload/netlib/ftp.vim
    Where the function is defined like this:
    function netlib#ftp#read(fname)
    "  Read the file fname through ftp
    endfunction
    Notice that the name the function is defined with is exactly the same as the
    name used for calling the function.  And the part before the last '#'
    exactly matches the subdirectory and script name.
    You can use the same mechanism for variables:
    let weekdays = dutch#weekdays
    This will load the script "autoload/dutch.vim", which should contain something
    like:
    let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
    \ 'donderdag', 'vrijdag', 'zaterdag']
    Further reading: |autoload|.
    Error setting the text for the following input: ==============================================================================.
    *41.16*        Distributing Vim scripts                        *distribute-script*
    Vim users will look for scripts on the Vim website:        http://www.vim.org. <http://www.vim.org.>
    If you made something that is useful for others, share it!
    Vim scripts can be used on any system.  There might not be a tar or gzip
    command.  If you want to pack files together and/or compress them the "zip"
    utility is recommended.
    For utmost portability use Vim itself to pack scripts together.  This can be
    done with the Vimball utility.  See |vimball|.
    It's good if you add a line to allow automatic updating.  See |glvs-plugins|.
    Error setting the text for the following input: ==============================================================================.
    Next chapter: |usr_42.txt|  Add new menus
    Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
    top - main help file
    Help FAQ Both
    adding new menus <http://vimdoc.sourceforge.net/htmldoc/usr_42.html>




    FORMERSTART
    source file from the commandline;-S
    split file from commandline;-o
    vertical split from the command line;-O
    tabsplit from the command line;-p
    open filename under the cursor in this window;gf
    ;+se ev också gF i Vimrecipes
    öppna fil under markören i nytt fönster;Ctrl-w f
    öppna fil under markören i ny tab :DDDDDD;Ctrl-w gf
    öppna mansida för ordet under markören;K
    cH
    ändra till toppen
    cL
    ändra till botten
    c+
    [lägg till]
    c5|
    ändra till kol. 5
    dH
    d2)
    2y)
    c{
    ändra till föregående stycke
    xxxx <#ID_677267623>
    o
    PRACTICAL VIM (tecknade pennfiguren :) <../gdrive/PRACTICAL_VIM.pdf>
    1 <#ID_1398700069>
    yyyy
    Practical Vim******::
    / - sök från kommandoraden
    Error setting the text for the following input: = - utvärdera ett vimskript i kommandoradsläge.
    välja inne i en xml-etikett: it :D*******
    Error setting the text for the following input: =till Inkscapekodredigering förmodl..
    Se till att vim startas utan specialinställningar:
    $ vim -u NONE -N
    +fil med:
    set nocompatible
    filetype plugin on
    +$ vim -u code/essential.vim
    :version (kolla vilka features som är inladdade (huge))
    -----------------------------------------------------------
    SUPERKOMMANDO 1:
    .-kommandot(=mikromakro)::
    >G (punkt ökar indrag igen) :D
    +när går in i insert = alla tryckn. sparas +kan sen spelas upp med .
    A:Esc j. :)
    RECEPT s33 ******************
    ++Tips 4: make motion and change repeatable.
    @:
    & (=kör :substitute igen)
    SUPERKOMMANDO 2:
    * + n +. :DD
    THE DOT-FORMULA:: s11
    en flytt + ett utförande/ändring
    ------ Normalmode
    Skriv en el två meningar t ex (en tanke/ansats typ), kika + u om inte nöjd
    +Esc-o-tricket ist.för Return
    Vimgolf och daw
    Höj “0px” till “-180px.” i bit css-kod = 180<C-a> (oavsett var på raden)************
    C-x och oktalt
    (set nrformats=octal mm (blank: allt tolkas decimalt)
    u går förstås också att använda med count :)
    ----
    Combine and conquer::
    daw
    gUaw ******
    dap
    gUap
    Dubblering av operator gör = på hel rad:
    dd, gUU
    s50
    >
    <
    =
    !
    commentary.vim
    textobj-entire
    gg=G
    s51
    Egna operatorpending uttryck :) ??
    " custom mappings that initiate or target Operator-Pending mode."
    <C-h>
    <C-w>
    <C-u>
    Effect
    Delete back one character (backspace)
    Delete back one word
    Delete back to start of line
    <C-[>
    Switch to Normal mode
    <C-o>
    Switch to Insert Normal mode
    C-r + 0 =klistra in just utklippt :)
    The <C-r><C-p>{register} command is smarter. It inserts text literally and fixes
    any unintended indentation (see :h i_CTRL-R_CTRL-P
    The Expressionregister:
    A
    6 chairs, each costing $35, totals $
    <C-r>=6*35<CR>
    6 chairs, each costing $35, totals $210
    If you want to find out the numeric code for any character in your document,
    just place the cursor on it and trigger the ga command. This outputs a mes-
    sage at the bottom of the screen, revealing the character code in decimal and
    hexadecimal notations (see :h ga ).
    <C-k>{char1}{char2}
    Insert character represented by {char1}{char2} digraph
    The character pairs that make up a digraph are chosen to be descriptive,
    making them easier to remember or even guess. For example, the double-
    angle quotation marks « and » are represented by the digraphs << and >>;
    the vulgar (or common) fractions 1⁄2, 1⁄4, and 3⁄4 are represented by the digraphs
    12, 14, and 34, respectively. The default set of digraphs that ship with Vim
    follows certain conventions, which are summarized under :h digraphs-default .
    We can view a list of the available digraphs by running :digraphs, but the output
    of this command is difficult to digest. A more usable list can be found by
    looking up :h digraph-table .
    Virtual replace-mode: s60
    Samma för ett tecken: r och gr
    s63 = Selectmode ***
    gv
    o
    O
    Python och indentering
    When we use the dot command to repeat a Visual mode command, it acts on
    the same amount of text as was marked by the most recent visual selection.
    We can use Ex commands to read and write files (:edit and :write), to create
    tabs (:tabnew) or split windows (:split), or to interact with the argument list
    (:prev/:next) or the buffer list (:bprev/:bnext). In fact, Vim has an Ex command
    for just about everything (see :h ex-cmd-index for the full list).
    In this chapter, we’ll focus mainly on the handful of Ex commands we can
    use to edit text. Table 9, Ex Commands That Operate on the Text in a Buffer,
    on page 52, shows a selection of some of the most useful ones.
    Most of these commands can accept a range. We’ll find out what this means
    in Tip 28, on page 54. The :copy command is great for quickly duplicating a
    line, as we’ll see in Duplicate Lines with the ‘:t’ Command, on page 59. The
    :normal command provides a convenient way to make the same change on a
    range of lines, as we’ll see in Tip 30, on page 61.
    We’ll learn more about :delete, :yank, and :put commands in Chapter 10,
    Copy
    and Paste, on page 141. The :substitute and :global commands are very powerful,
    so they each get a chapter of their own. See Chapter 14, Substitution, on page
    215, and Chapter 15, Global Commands, on page 237.
    gå till rad 1
    :1
    :p
    :3p
    :2,5p
    :2,5d
    :%p
    . These marks persist even when we leave Visual mode. If
    you try running :'<,'>p straight from Normal mode, it will always act on the
    lines that most recently formed a Visual mode selection.
    :/mö/,/mä/p
    :/mö/+1,/mä/-1p
    The general form for an offset goes like this:
    :{address}+n
    If n is omitted, it defaults to 1. The {address} could be a line number, a mark,
    or a pattern.
    Discussion
    The syntax for defining a range is very flexible. We can mix and match line
    numbers, marks, and patterns, and we can apply an offset to any of them.
    This table summarizes a few of the symbols that can be used to create
    addresses and ranges for Ex commands:
    :t och :m
    mer=s83
    (s81)
    Visual + m$
    @:
    If we want to run a Normal mode command on a series of consecutive lines,
    we can do so using the :normal command. When used in combination with the
    dot command or a macro, we can perform repetitive tasks with very little effort.
    jVG +
    :'<,'>normal. ********
    . For example, we could have
    solved the problem above with this single command:
    ➾
    :%normal A;
    The % symbol is used as a range representing the entire file. So :%normal A;
    instructs Vim to append a semicolon at the end of every line of the file. Making
    this change involves switching into Insert mode, but Vim automatically reverts
    to Normal mode afterward
    This single
    command could be used to comment out an entire JavaScript file:
    ➾
    :%normal i//
    :normal @q **************
    :normal @: (??=bör funka va?) :)
    Tab och Ctrl+d *****
    In many scenarios, Vim’s tab-completion does the right thing. If we type a
    command that expects a filepath as an argument (such as :edit or :write), then
    <Tab> will complete directories and filenames relative to the current working
    directory. With the :tag command we can autocomplete tag names. The :set
    and :help commands know about every configuration option in Vim.
    We can even define the tab-completion behavior when creating our own custom
    Ex commands. To see what’s possible, check out :h :command-complete .
    Even in Command-Line mode, Vim always knows where the cursor is positioned
    and which split window is active. To save time, we can insert the current word
    (or WORD) from the active document onto our command prompt.
    At Vim’s command line, the <C-r><C-w> mapping copies the word under the
    cursor and inserts it at the command-line prompt. We can use this to save
    ourselves a bit of typing.
    ****************:DD
    We’ll carry out the remaining changes using a :substitute command. Since our
    cursor is on the word “counter,” we don’t need to type it out again. We can
    just use the <C-r><C-w> mapping to populate the replacement field:
    ➾
    :%s//<C-r><C-w>/g
    That command doesn’t look very succinct when written down, but two
    keystrokes to insert a word ain’t bad. We didn’t have to type the search pattern
    either, thanks to the * command. Refer to Tip 90, on page 220, to see why we
    can leave the search field blank like that.
    For another application, try opening your vimrc file, place your cursor on a
    setting, and then type :help <C-r><C-w> to look up the documentation for that
    setting.
    By default, Vim records the last twenty commands. With memory becoming
    ever cheaper in today’s computers, we can probably afford to up this limit by
    changing the ‘history’ option. Try adding this line to your vimrc:
    set history=200
    We can get the best of both by creating the following custom mappings:
    ex_mode/history-scrollers.vim
    cnoremap <C-p> <Up>
    cnoremap <C-n> <Down>
    q: ************
    :write | !ruby %
    Each of these commands is already in our history, so we shouldn’t have to
    type the entire command line from scratch. But how can we merge two records
    from our history into one? Press q: and meet the command-line window (see
    :h cmdwin ).
    -
    stäng med :q (el ctrl+w-c, ZQ)
    Command
    q/
    q:
    ctrl-f
    Action
    Open the command-line window with history of searches
    Open the command-line window with history of Ex commands
    Switch from Command-Line mode to the command-line window***************
    We can easily invoke external programs without leaving Vim. Best of all, we
    can send the contents of a buffer as standard input to a command or use the
    standard output from an external command to populate our buffer.
    The commands discussed in this tip work best when used from Vim inside a
    terminal. If you’re using GVim (or MacVim), then things may not work quite
    as smoothly. That shouldn’t come as a great surprise. It’s much easier for
    Vim to delegate work to the shell if Vim itself is already running inside a shell.
    GVim does some things better, but this is one area where terminal Vim has
    the edge.
    On Vim’s command line, the % symbol is shorthand for the current file name
    (see :h cmdline-special ). We can exploit this to run external commands that do
    something with the current file. For example, if we’re working on a Ruby file,
    we could execute it by running this:
    ➾
    :!ruby %
    The :!{cmd} syntax is great for firing one-off commands, but what if we want
    to run several commands in the shell? In that case, we can use Vim’s :shell
    command to start an interactive shell session (see :h :shell ):
    ➾
    :shell
    ➾
    $ pwd
    ❮
    /Users/drew/books/PracticalVim/code/ex_mode
    ➾
    $ ls
    ❮
    duplicate.todo
    loop.js
    emails.csv
    practical-vim.html
    foobar.js
    shopping-list.todo
    history-scrollers.vim
    ➾
    $ exit
    Suppose that we’re running Vim inside a bash shell and we want to execute a series
    of shell commands. Pressing Ctrl - z suspends the process that’s running Vim and
    returns control to bash. The Vim process sits idle in the background, allowing us to
    interact with our bash session as normal. We can inspect the list of jobs by running
    this command:
    ➾
    $ jobs
    ❮
    [1]+ Stopped
    vim
    In bash, we can use the fg command to resume a suspended job, bringing it back
    into the foreground. That brings Vim back to life exactly as we left it. The Ctrl - z and
    fg commands are quicker and easier to use than Vim’s equivalent :shell and exit com-
    mands. For more information, run man bash and read the section on job control.
    The :read !{cmd} command lets us direct standard output into a buffer. As you
    might expect, the :write !{cmd} does the inverse: it uses the contents of the buffer as standard input for the specified {cmd} (see :h :write_c ).
    The effect of the :write !sh command is that each line of the current buffer is
    executed in the shell. Refer to :h rename-files for a nice example of this com-
    mand in use.
    ex_mode/emails.csv
    first name,last name,email
    john,smith,john@example.com <mailto:john@example.com>
    drew,neil,drew@vimcasts.org <mailto:drew@vimcasts.org>
    jane,doe,jane@example.com <mailto:jane@example.com>
    We’ll sort the records by the second field: last name. We can use the -t',' option
    to tell the sort command that fields are separated with commas, and we can
    use the -k2 flag to indicate that the second field is to be used for the sort.
    The first line of the file contains header information. We want to leave it at
    the top of the file, so we’ll exclude it from the sort operation by using a range
    of :2,$. This command line does what we want:
    ➾
    :2,$!sort -t',' -k2
    Vim provides a convenient shortcut for setting the range of a :[range]!{filter}
    command such as this. The !{motion} operator command drops us into Com-
    mand-Line mode and prepopulates the [range] with the lines covered by the
    specified {motion} (see :h ! ). For example, if we place our cursor on line 2 and
    then invoke !G , Vim opens a prompt with the :.,$! range set up for us.
    :[range]!{filter}
    Filter the specified [range] through external program {filter}
    5!! =liknande som ovan (tror den skickar aktuell rad +4 till kommandoraden för filtrering) :)
    Vim gives special treatment to some commands. For example, both make and
    grep have wrapper commands. Not only are they easy to execute from inside
    Vim, but their output is parsed and used to populate the quickfix list.
    Bind om.Ctrl+^ (=byt mellan % och #)
    Consider remaps av bn mfl
    :argdo och bufdo
    s101 TimPopes unimpaired.vim
    Error setting the text for the following input: =ger flera bra mappings för bn mfl.
    . If we wanted to delete buffers numbered 5
    through 10 inclusive, we could do so by running :5,10bd . But if we wanted to
    keep buffer number 8, then we’d instead have to run :bd 5 6 7 9 10.
    splitwindows
    tabpages
    the argumentlist
    In Tip 36, on page 77, we saw that the :ls command provides a listing of buffers.
    Now let’s examine the argument list:
    ➾
    :args
    ❮
    [a.txt] b.txt c.txt. d.txt e.txt
    The argument list represents the list of files that was passed as an argument
    when we ran the vim command. In our case, we provided a single argument,
    *.txt, but our shell expanded the * wildcard, matching the five files that we see
    in our argument list. The [] characters indicate which of the files in the
    argument list is active.
    . We can change the contents
    of the argument list at any time, which means that the :args listing doesn’t
    necessarily reflect the values that were passed to the vim command when we
    launched the editor. Don’t take the name literally!
    Populate the Argument List - s103
    Populate the Argument List
    When the :args Ex command is run without arguments, it prints the contents
    of the argument list. We can also set the contents of the argument list using
    this form (:h :args_f ):
    :args {arglist}
    The {arglist} can include filenames, wildcards, or even the output from a shell
    command.
    T ex:
    :args index.html app.js
    Specify Files by Glob
    Wildcards are placeholders that can stand in for characters in the name of a
    file or directory. The * symbol will match zero or more characters, but only
    in the scope of the specified directory (:h wildcard ). The ** wildcard also
    matches zero or more characters, but it can recurse downward into directories
    below the specified directory (:h starstar-wildcard ).
    Glob
    :args *.*
    :args **/*.js
    :args **/*.*
    Files Matching the Expansion
    index.html
    app.js
    app.js
    lib/framework.js
    app/controllers/Mailer.js
    ...etc
    app.js
    index.js
    lib/framework.js
    lib/theme.css
    app/controllers/Mailer.js
    ...etc
    :args **/*.js **/*.css
    As I wrote this book, I sometimes wanted to populate the argument list with
    the chapters in the same order that they appear in the table of contents. For
    this purpose, I maintained a plain-text file that contains one filename per
    line. Here’s an excerpt from it:
    files/.chapters
    the_vim_way.pml
    normal_mode.pml
    insert_mode.pml
    visual_mode.pml
    I can populate the argument list from this file by running this:
    ➾
    :args `cat .chapters`
    Vim executes the text inside the backtick characters in the shell, using the
    output from the cat command as the argument for the :args command.
    The argument list is simpler to manage than the buffer list, making it the
    ideal place to group our buffers into a collection. With the :args {arglist} com-
    mand, we can clear the argument list and then repopulate it from scratch
    with a single command. We can traverse the files in the argument list using
    :next and :prev commands. Or we can use :argdo to execute the same command
    on each buffer in the set.
    The way I see it, the buffer list is like my desktop: it’s always messy. The
    argument list is like a separate workspace that I always keep tidy, just in
    case I need space to stretch out. We’ll see a few examples of how the argument
    list can be used in other tips, such as Tip 69, on page 169, and Tip 96, on page
    233
    Hidden buffers mm: (:cnext??)
    :quit
    :write
    :edit!
    :qall!
    :wall
    :first
    :next
    If we enable the ‘hidden’ setting (see :h 'hidden' ), then we can use the :next,
    :bnext, :cnext (and so on) commands without a trailing bang. If the active buffer
    is modified, Vim will automatically hide it when we navigate away from it.
    The ‘hidden’ setting makes it possible to use :argdo and :bufdo to change a collec-
    tion of buffers with a single command.
    After running :argdo {cmd}, we’ll want to save the changes that were made to
    each item in the argument list. We could do it one at a time by running :first
    and then :wn, which would give us the opportunity to eyeball each file. Or if
    we’re confident that everything is in order, we could run :argdo write (or :wall) to
    save all buffers.
    We can use the :edit command to load another buffer into the active window.
    If we run <C-w>s followed by :edit {filename}, we can divide our workspace and
    then open another buffer in one split window while keeping the existing buffer
    visible in the other split. Alternatively, we could use the command :split {file-
    name}, which combines those two steps into one. This table summarizes the
    ways of dividing our workspace into split windows:
    Command
    <C-w>s
    <C-w>v
    :sp[lit] {file}
    :vsp[lit] {file}
    Effect
    Split the current window horizontally, reusing the current buffer
    in the new window
    Split the current window vertically, reusing the current buffer
    in the new window
    Split the current window horizontally, loading {file} into the new
    window
    Split the current window vertically, loading {file} into the new
    window
    Ex Command
    Normal Command
    Effect
    :cl[ose]
    <C-w>c
    Close the active window
    :on[ly]
    <C-w>o
    Keep only the active window, closing all others
    s110 - :h window-resize . This table summarizes a handful of the most useful
    commands: (men lättast med musen)
    Vim includes commands for rearranging windows, but rather than describing
    them here, I’d like to point you toward a screencast on Vimcasts.org that
    demonstrates the possibilities.1 Y
    1
    <http://vimcasts.org/e/7>
    Tabs = s111********
    The :lcd {path} command lets us set the working directory locally for the current
    window. If we create a new tab page and then use the :lcd command to switch
    to another directory, we can then comfortably scope each tab page to a differ-
    ent project. Note that :lcd applies locally to the current window, not to the
    current tab page. If we have a tab page containing two or more split windows,
    we could set the local working directory for all of them by running :windo lcd
    2
    {path}. Check out episode 9 of Vimcasts for more information.
    ***************
    <http://vimcasts.org/e/9>
    Opening and Closing Tabs
    We can open a new tab page with the :tabedit {filename} command. If we omit
    the {filename} argument, then Vim creates a new tab page containing an
    empty buffer.
    Alternatively, if the current tab page contains more than one window, we can
    use the <C-w>T command, which moves the current window into a new tab
    page (see :h CTRL-W_T ).
    If the active tab page contains only a single window, the :close command will
    close the window and the tab page with it. Or we can use the :tabclose com-
    mand, which closes the current tab page no matter how many windows it contains. Finally, if we want to close all tab pages except for the current one,
    we can use the :tabonly command.
    Command
    :tabe[dit] {filename}
    <C-w>T
    :tabc[lose]
    :tabo[nly]
    Effect
    Open {filename} in a new tab
    Move the current window into its own tab
    Close the current tab page and all of its windows
    Keep the active tab page, closing all others
    Ex Command
    Normal Command
    Effect
    :tabn[ext] {N}
    {N}gt
    Switch to tab page number {N}
    :tabn[ext]
    gt
    Switch to the next tab page
    :tabp[revious]
    gT
    Switch to the previous tab page
    Rearranging Tabs
    We can use the :tabmove [N] Ex command to rearrange tab pages. When [N] is
    0, the current tab page is moved to the beginning, and if we omit [N], the
    current tab page is moved to the end. If your terminal supports the mouse
    or if you’re using GVim, reordering tab pages by drag and drop is also possible.
    s114
    2
    Practical Vim 2*******::
    :e kan använda relativa sökvägar
    :edit %:h <Tab>
    The %:h expansion is so useful that you might want to consider creating a
    mapping for it. Check out Easy Expansion of the Active File Directory, on page
    95, for a suggestion.
    Easy Expansion of the Active File Directory
    Try sourcing this line in your vimrc file:
    cnoremap <expr> %%
    getcmdtype() == ':' ? expand('%:h').'/' : '%%'
    Now when we type %% on Vim’s : command-line prompt, it automatically expands to
    the path of the active buffer, just as though we had typed %:h <Tab> . Besides working
    nicely with :edit, this can come in handy with other Ex commands such as :write, :saveas,
    and :read.
    For more ideas on how to use this mapping, see the Vimcasts episode on the :edit
    a
    command.a.
    <http://vimcasts.org/episodes/the-edit-command/>
    The ‘path’ option allows us to specify a set of directories inside of which Vim
    will search when the :find command is invoked (see :h 'path' ). In our case, we
    want to make it easier to look up files in the app/controllers and app/views directo-
    ries. We can add these to our path simply by running this:
    ➾
    :set path+=app/**
    The ** wildcard matches all subdirectories beneath the app/ directory. We
    discussed wildcards in Populate the Argument List, on page 81, but the
    treatment of * and ** is slightly different in the context of the ‘path’ setting (see
    :h file-searching ). The wildcards are handled by Vim rather than by the shell.
    Smart Path Management with rails.vim
    Tim Pope’s rails.vim plugin does some clever things to make navigating around a
    Rails project easier.a The plugin automatically configures the ‘path’ setting to include
    all the directories found in a conventional Rails project. This means that we can use
    the :find command without having to worry about setting up the ‘path’.
    But rails.vim doesn’t stop there. It also provides convenience commands, such as
    :Rcontroller, :Rmodel, :Rview, and others. Each of these acts as a specialized version of the
    :find command, scoping its search to the corresponding directory.
    a.
    <https://github.com/tpope/vim-rails>
    netrw
    vim .
    C-R, -(=till mapp ovanför)
    +alla vanliga motionsc
    :e. explorer för cwd
    :E explorer för aktiva bufferns mapp
    **********
    Även :Sexplore and :Vexplore
    if we decide that we want to switch back to the
    buffer we were already editing, we can do so using the <C-^> command.
    The netrw plugin doesn’t just let us explore the file system. We can create
    new files (:h netrw-% ) or directories (:h netrw-d ), rename existing ones
    (:h netrw-rename ), or delete them (:h netrw-del ). For a demonstration, watch
    episode 15 of Vimcasts.1
    <http://vimcasts.org/e/15>
    We haven’t even touched on the killer feature that gives the plugin its name:
    netrw makes it possible to read and write files across a network. The plugin
    can use many protocols, including scp, ftp, curl, and wget, depending on what’s
    available on your system. To find out more, look up :h netrw-ref .
    :edit madeup/dir/doesnotexist.yet
    :!mkdir -p %:h
    :write
    The -p flag tells mkdir to create intermediate directories. See Open a File Relative
    to the Active File Directory, on page 95,
    ev remap av Go
    :w !sudo tee % > /dev/null
    -------
    Vim has a vast number of motions. We can’t cover them all in this chapter,
    so I recommend that you look up the :h motion.txt
    noremap <Up> <Nop>
    m fl g0 och g$
    nnoremap k gk
    nnoremap gk k
    nnoremap j gj
    nnoremap gj j
    w
    b
    e
    ge
    W , B , E , and gE
    Don’t Throw Away the Reverse Character Search Command
    Vim assigns a function to almost every key on the keyboard. If we want to create our
    own custom mappings, which keys should we bind them to? Vim provides the <Leader>
    key as a namespace for our own user-defined commands. Here is how we can create
    our own custom mappings using <Leader> :
    noremap <Leader>n nzz
    noremap <Leader>N Nzz
    The default leader key is \ , so we could trigger these custom mappings by pressing
    \n and \N . If you want to know what these mappings do, look up :h zz .
    On some keyboards, the \ command is inconvenient to reach, so Vim makes it easy
    to set the leader key to something else (see :h mapleader ). A common choice is to set
    the comma key as leader. If you take this route, I strongly recommend mapping the
    reverse character search command to another key. Here’s an example:
    let mapleader=","
    noremap \ ,
    The ; and , commands complement each other. If you take one of them away, then
    the whole family of character search commands becomes much less useful.
    dt.
    f;-pair och /n-pair
    Here, we use the /ge <CR> search motion to tell the d{motion} command what
    to delete. The search command is an exclusive motion. That means that even
    though our cursor ends up on the “g” at the start of the word “gets,” that
    character is excluded from the delete operation (see :h exclusive ).
    ab (, aB krull, och at tags ************
    d, c och y
    textobjects: i/aw,s,p
    Keystrokes
    ******
    Vim provides a motion that lets us move between opening and closing pairs of
    parentheses. By enabling the matchit.vim plugin, we can extend this behavior
    to work on pairs of XML tags as well as on keywords in some programming
    languages.
    ******
    Error setting the text for the following input: =se s147-148.
    Ändra matchande måsvingar till klamrar-tricket med %
    +++
    Note that in this case, the <C-o> command would work just as well as the ``
    motion (see Tip 55, on page 131). The surround.vim plugin provides commands
    that would make this task even easier. Find out more in Surround.vim, on
    page 129.
    Error setting the text for the following input: =se s148*****.
    Jumps::
    Ctrl+o, Ctrl+i
    :jumps
    <C-]> - Jump to definition of keyword under the cursor (m fl)
    Vim can maintain multiple jump lists at the same time. In fact, each separate
    window has its own jump list. If we’re using split windows or multiple tab
    pages, then the <C-o> and <C-i> commands will always be scoped to the jump
    list of the active window.
    uCtrl+r (=tillb. till senaste ändring)
    changelist och :changes :)

    Buffer Contents
    ``
    Position before the last jump within current file
    `.
    Location of last change
    `^
    Location of last insertion
    `[
    Start of last change or yank
    `]
    End of last change or yank
    `<
    Start of last visual selection
    `>
    End of last visual selection




    Vim treats filenames in our document as a kind of hyperlink. When configured
    properly, we can use the gf command to go to the filename under the cursor.
    , I recommend using the -u NONE -N flags to ensure
    that Vim starts up without loading any no plugins:
    :set suffixesadd+=.rb (i detta fallet)
    +Ctrl+o och Ctrl+i ************
    Specify the Directories to Look Inside
    In this example, each of the files referenced with the require statement was
    located relative to the working directory. But what if we referenced function-
    ality that was provided by a third-party library, such as a rubygem?
    That’s where the ‘path’ option comes in (:h 'path' ). We can configure this to
    reference a comma-separated list of directories.
    We can inspect the value of the path by running this command:
    ➾
    :set path?
    ❮
    path=.,/usr/include,,
    For example, it would be useful if the ‘path’ included the directories for all
    rubygems used in a Ruby project. Then we could use the gf command to
    open up the modules referenced by any require statements. For an automated
    solution, check out Tim Pope’s bundler.vim plugin,1 which uses the project
    Gemfile to populate the ‘path’ setting.
    The ‘suffixesadd’ and ‘path’ options can be set locally for each buffer, so they can
    be configured in different ways for different file types. Vim is distributed with
    file-type plugins for many other languages besides Ruby, so in practice you
    won’t often have to set these options yourself. Even so, it’s worth understand-
    ing how the gf command works. It makes each filepath in our document
    behave like a hyperlink, which makes it easier to navigate through a codebase.
    1
    2
    <https://github.com/tpope/vim-bundler>
    <https://github.com/vim-ruby/vim-ruby>
    While the jump list and change list are like breadcrumb trails that allow us
    to retrace our steps, the gf and <C-]> commands provide wormholes that
    transport us from one part of our codebase to another.
    mark + `{letter}**
    . By default, global marks are
    persisted between editing sessions (although this behavior can be configured;
    see :h 'viminfo' ). Now you can always open up your vimrc file with two
    keystrokes
    Global marks can be especially useful when we need to browse through a set
    of files and then quickly snap back to where we started.*****
    *********
    :vimgrep /fooBar/ **
    By default, :vimgrep jumps directly to the first match that it finds, which could
    mean switching to another file. At this point, we can use the <C-o> command
    to get back to where we were prior to running :vimgrep.
    Try to get into a habit of setting a global mark before using any commands
    that interact with the quickfix list, such as :grep, :vimgrep, and :make. The same
    goes for the commands that interact with the buffer and argument lists, such
    as :args {arglist} and :argdo (see Tip 37, on page 80).
    Delete, yank and put::
    Not clobbering unnamed register = "_d *****
    . We could cut the current line into register
    c by running :delete c, and then we could paste it below the current line with
    the :put c command. These may seem verbose in comparison with the Normal
    mode commands, but they’re useful in combination with other Ex commands
    and in Vim scripts. For example, Tip 99, on page 240, shows how :yank can be
    used with the :global command.
    The Unnamed Register ("")
    The Yank Register ("0)
    When we use the y{motion} command, the specified text is copied not only
    into the unnamed register but also into the yank register, which is addressed
    by the 0 symbol (see :h quote0 ).
    ***************
    :reg (registers) ****
    "* och middle-mouse :)
    Vim can be compiled with or without support for X11 clipboard integration.
    To find out whether your version of Vim has the feature enabled, run the
    :version command and look for xterm_clipboard. If it’s prefixed with a minus sign,
    then your version of Vim does not support this feature. A plus sign means
    that the feature is available.
    The Expression Register ("=)
    Vim’s registers can be thought of simply as containers that hold a block of
    text. The expression register, referenced by the = symbol (:h quote= ), is an
    exception. When we fetch the contents of the expression register, Vim drops
    into Command-Line mode, showing an = prompt. We can enter a Vim script
    expression and then press <CR> to execute it. If the expression returns a string
    (or a value that can be easily coerced into a string), then Vim uses it.
    For examples of the expression register in action, check out Tip 16, on page
    31, Tip 95, on page 230, Tip 94, on page 229, and Tip 70, on page 174.
    ***************** SE MER !
    In addition, Vim provides a handful of
    registers whose values are set implicitly. These are known collectively as the
    read-only registers (:h quote. ). The following table summarizes them:
    Register
    "%
    "#
    ".
    ":
    "/
    Contents
    Name of the current file
    Name of the alternate file
    Last inserted text
    Last Ex command
    Last search pattern
    Technically, the "/ register is not read-only—it can be set explicitly using the
    :let command (see :h quote/ )—but it’s included in this table for convenience.
    Clobber visual selection with conts of the unnamed register
    ++??
    ****
    Keystrokes
    Buffer Contents
    {start}
    I like chips and fish.
    fc
    I like chips and fish.
    de
    I like
    and fish.
    mm
    I like
    and fish.
    ww
    I like
    and fish.
    ve
    I like
    and fish.
    p
    I like
    and chips.
    `m
    I like
    and chips.
    P
    I like fish and chips.
    In this case, it would be quicker to delete “chips and fish” and then type out
    “fish and chips” instead, using the c3w command for example. But this same
    technique can also be used to swap the order of longer phrases.
    When pasting from a line-wise register, the p and P commands put the text
    below or above the current line. This is more intuitive than the character-wise
    behavior.
    It’s worth noting that Vim also provides gp and gP commands. These also put
    the text before or after the current line, but they leave the cursor positioned
    at the end of the pasted text instead of at the beginning. The gP command is
    especially useful when duplicating a range of lines, as demonstrated here:
    +html-table-exemplet s170**
    Paste from systemclipboard i standard-vim
    When the ‘paste’ option is enabled,
    Vim turns off all Insert mode mappings and abbreviations and resets a host
    of options, including ‘autoindent’ (look up :h 'paste' for the full list). That allows
    us to safely paste from the system clipboard with no surprises.
    When we’re finished using the system paste command, we should disable the
    ‘paste’ option again. That means switching back to Normal mode and then
    running the Ex command :set paste!. Don’t you think it would be handy if there
    were a way of toggling this option without leaving Insert mode?
    The way that Vim behaves when ‘paste’ is enabled means that the usual
    methods for creating custom mappings won’t work in Insert mode. Instead,
    we can assign a key to the ‘pastetoggle’ option (:h 'pastetoggle' ):
    ➾
    :set pastetoggle=<f5>
    Macros::
    Spela in en punktformel som ett one off-makro *** s180
    Kör makro på flera heterogena rader (som kan bryta makrot) med
    :'<,'>normal @a ********* = köra i kedja som kan sen innan ELLER (då) parallellt :
    If we type qa , then Vim will record our keystrokes, saving them into register
    a by overwriting the existing contents of that register. If we type qA , then Vim
    will record our keystrokes, appending them to the existing contents of register
    a. We can amend our mistake: s186
    s187
    Source these lines of configuration to reproduce the examples in this tip:
    macros/rc.vim
    set nocompatible
    filetype plugin indent on
    set hidden
    if has("autocmd")
    autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
    endif
    Mer om :args (mest repetition) :D s187
    Köra makro över flera filer - s187+ ****
    To prevent this, we’ll revert all of the changes we just made to the first buffer
    in the argument list by running :edit! (see :h :edit! ):
    ➾
    :edit!
    Now we can go ahead and execute the macro in all of the buffers in the
    argument list:
    ➾
    :argdo normal @a
    +att istället lägga till :next som sista steg och skippa :e
    :argdo write och :wall (och :wnext)
    + :argdo normal @a (=kör parallellt över filer)
    We can do that
    using the expression register. In Tip 16, on page 31, we saw that the expres-
    sion register can be used to do simple sums and to insert the result into the
    document. We can insert the value stored in variable i just by running
    <C-r>=i<CR> in Insert mode.
    :put a
    . For example, we
    could use the substitute() function (which is not the same as the :substitute com-
    mand! See :h substitute() ) to perform the same edit as before:
    ➾
    :let @a=substitute(@a, '\~', 'vU', 'g')
    :substitute, which allows us to
    find occurrences of one pattern and replace them
    with something else, and :global , which lets us run
    any Ex command on each line that matches a par-
    ticular pattern.
    Patterns:: s198
    very magic, very nomagic
    Note that these items can be used anywhere in a pattern. If you realize that you need a case sensitive search after you typed out the full pattern, just tack \C on at the end, and it will affect everything that went before it. *****
    smartcase
    lösning på grundinställningen magic (som kräver många backslashtecken)
    /\v#([0-9a-fA-F]{}|[0-9a-fA-F]{})
    (=very magic ger perl/python/ruby-lik syntax)
    /\v#(\x{}|\x{}) ********
    Use the \V Literal Switch for Verbatim Searches.
    The special characters used for defining regular expressions are handy when searching for patterns, but they can get in the way if we want to search for text verbatim. Using the verynomagic literal switch, we can cancel out most of the special meanings attached to characters such as ., *, and ?.
    /\Va.k.a.<CR>
    As a general rule, if you want to search for a regular expression, use the \v pattern switch, and if you want to search for verbatim text, use the \V literal switch.
    Here’s a regular expression that matches duplicate words:
    ➾
    /\v<(\w+)\_s+\1>
    Now try searching for this pattern on the springtime excerpt, and you should
    see “the the” light up as a search match. Now try joining the two lines
    together ( vipJ will do it), and you should find that it still matches. Best of all,
    this pattern doesn’t just match “the the,” it works for any pair of duplicate
    words.
    There aren’t many scenarios where submatches are useful in a search pattern.
    One more example springs to mind: matching opening and closing pairs of
    XML or HTML tags. But as we’ll see in Tip 93, on page 228, we can also use
    submatches in the replacement {string} of the :substitute command.
    Combining these, we could approximate the < item as \W\zs\w, and the > item
    as \w\ze\W.
    Stake the Boundaries of a Match - s207
    Sometimes we might want to specify a broad pattern and then focus on a subset of the match. Vim’s \zs and \ze items allow us to do just that.
    Here’s another example, this time using both \zs and \ze to tweak the start
    and end of the match:
    Keystrokes
    {start}
    /\v"[^"]+" <CR>
    /\v"\zs[^"]+\ze"<CR>
    Buffer Contents
    Match "quoted words"---not quote marks.
    Match "quoted words"---not quote marks.
    Match "quoted words"---not quote marks.
    We can tell Vim not to bother assigning it to the \1 register by prepending a % in front
    of the parentheses, like this:
    What difference does this make? Well, it’s a smidge faster, not that you’re likely to
    notice. But it can be useful if you find yourself using several sets of parentheses.
    Suppose we wanted to replace all occurrences of FIRSTNAME LASTNAME with LASTNAME,
    FIRSTNAME for both forms of my name. We could do so like this:
    ➾
    /\v(%(And|D)rew) (Neil)
    ➾
    :%s//\2, \1/g
    The search pattern assigns either “Andrew” or “Drew” to capture register \1 and assigns
    “Neil” to register \2. If we hadn’t used %() for the second set of parentheses, then it
    would have captured a fragment of text unnecessarily, cluttering up our replacement
    field.
    Instead of using \zs and \ze, we could rewrite the /\v"\zs[^"]+\ze" <CR> pattern from Tip
    77, on page 192, using Vim’s positive lookaround items, like so:
    ➾
    /\v"@<=[^"]+"@=
    Advanced: s209
    Suppose that we want to search for all instances of the URL http://vim-doc.net/search?q=/\\. Rather than typing it out in full, we’ll just yank it into a register so that we can paste it into our search field. We want to match this text exactly as is, so we’ll use the \V literal switch.
    In our example text, we’re searching for a URL that includes two consecutive
    backslashes. We have to include two backslashes in the search field for each
    of them. Searching forward, we end up with this:
    ➾
    /\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\
    At last! Our search query matches the entire URL:
    Escaping characters by hand is laborious, error-prone work. Fortunately,
    Vim script includes a library function that can do the hard work for us:
    escape({string}, {chars}) (see :h escape() ).
    s211
    In Vim script, the . operator performs string concatena-
    tion, *************
    212, Gvim och :promptfind
    s213
    Search
    Having studied Vim’s regular expression engines in the previous chapter, let’s
    see how we can put them to use with the search command. We’ll start with
    the basics: how to execute a search, highlight matches, and jump between
    them. Then we’ll learn a couple of tricks that exploit Vim’s incremental search
    feature, which not only gives us instant feedback but can also save us typing
    by autocompleting our match. We’ll also learn how to count the number of
    matches that occur in a document.
    Composing a regular expression—and getting it right—often takes a few
    attempts, so developing a workflow that allows us to iterate on a pattern is
    important. We’ll learn about two methods for doing this: calling up our search
    history and working in the command-line window.
    Have you ever wished for a simple way of searching for text that’s already
    present in your document? We’ll finish by devising a simple customization
    that overrides the * command to search for the current visual selection.
    /+Enter =samma mönster för sökning igen=även efter '?' :D **********
    In Tip 84, on page 206, we’ll meet a more complex example where we change
    the offset each time we repeat a search. (//e tex)
    hlsearch' causes all matches
    to be highlighted throughout the active document as well as in any other open
    split windows.
    we could run :set nohlsearch to disable the feature entirely (:se
    nohls and :se hls! also work).
    Create a Shortcut to Mute Highlighting
    Typing :noh <CR> to mute search highlighting is laborious. We can speed things up by
    creating a mapping such as this:
    nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>
    Normally, <C-l> clears and redraws the screen (see :h CTRL-L ). This mapping builds
    on top of the usual behavior by muting search highlighting.
    S216********SE MER
    Vim’s search command is much more useful when the incremental search feature
    is enabled. Here are a couple of ways that this option can improve your work-
    flow.
    Esc eller CR
    Of course, we could simply type out the “carrot” in full. But here’s a handy
    shortcut: <C-r><C-w> . This autocompletes the search field using the remainder
    of the current preview match. If we used this command after entering “carr”
    into the search field, it would append “ot,” causing the match to encompass
    the entire word “carrot.”
    Note that the <C-r><C-w> autocompletion is slightly brittle in this context. If
    you prefix your search with the \v item, then <C-r><C-w> will complete the entire
    word under the cursor (creating /\vcarrcarrot <CR> , for example) instead of the
    remainder of the word. As long as you are searching for words and not
    patterns, the autocomplete feature of incremental search can be a nice little
    time-saver.
    There’s no way of making the search command report the number of matches
    in the current document. But here’s a command that does:
    ➾
    :%s///gn
    ❮
    117 matches on 65 lines
    *********
    ea
    /lang/e -exemplet ******
    In the real world, it won’t always be obvious when a search offset will come
    in handy. Suppose that we started off by executing the search command
    without the offset. Then, after pressing n a couple of times, we realize that
    we’d prefer to place the cursor at the end of the match. That’s no problem:
    we could simply run //e <CR> . When we leave the search field blank like this,
    Vim reuses the pattern from the previous search. So this repeats the last
    search but with an offset.
    To begin with, we write a regular expression to match either “Xml” or “Xhtml.”
    That’s easy enough: /\vX(ht)?ml\C <CR> does the job.
    The \C item enforces case
    sensitivity, so this should work regardless of whether ‘ignorecase’ and/or
    ‘smartcase’ are enabled. A
    (+RESTEN PÅ S222**********************)
    [ A Text Object for
    Search Matches, on page 209, discusses a more optimal solution, which requires
    a plugin.]
    BLUE, S223 (ny plugin för ovan)
    Create Complex Patterns by Iterating upon Search History ***********
    This is our final
    pattern:
    ➾
    /\v'(([^']|'\w)+)'
    We could either run /<Up> and edit the search field, or we could run q/ and
    make the change in the command-line window. Use whichever you feel is
    more appropriate. The search highlighting won’t look any different from the
    last time, but for each match, the text inside quotes will be assigned to the
    \1 capture register. That means we can run the following substitute command:
    ➾
    :%s//“\1”/g
    What we’ve done here is effectively identical to this:
    ➾
    :%s/\v'(([^']|'\w)+)'/“\1”/g
    Would you trust yourself to type that out correctly in one go?
    Don’t worry about getting a search pattern right the first time. Vim keeps our
    most recent search pattern two keystrokes away, so it’s easy to refine a pat-
    tern. Start with a broad match; then take as many steps as you need to focus
    on your target.
    Being able to edit the command line directly is great for simple edits. If we
    have the ‘incsearch’ setting enabled, then we get the added bonus of live feedback
    as we edit the command line. We lose this perk as soon as we call up the
    command-line window. But with the full power of Vim’s modal editing at our
    fingertips, this is a fair trade-off.
    In Normal mode, the * command lets us search for the word under the cursor.
    Using a small amount of Vim script, we can redefine the * command in Visual
    mode so that, instead of searching for the current word, it searches for the
    current selection.
    s226
    It always felt to me
    that triggering the * command from Visual mode should search for the current
    selection, not the current word. With a small amount of Vim script, we can
    add this feature to Vim.
    :vmap X y/<C-R>"<CR>
    (+hela visual star-search-plugin)
    (((=s229)))
    3
    Practical Vim 3:: *************
    The substitute command has many parts to it. The rules for the [range] are
    just the same as for every other Ex command, which we covered in-depth in
    Tip 28, on page 54.
    If we run the substitute command using a pattern that has no matches in
    the current file, Vim will report an error saying “E486: Pattern not found.”
    We can silence these errors by including the e flag, as we’ll see in Tip 96, on
    page 233.
    The & flag simply tells Vim to reuse the same flags from the previous substitute
    command. Tip 92, on page 224, shows a scenario where it comes in handy.
    \r
    \t
    \\
    \1
    \2
    \0
    &
    ~
    \={Vim script}
    Represents
    Insert a carriage return
    Insert a tab character
    Insert a single backslash
    Insert the first submatch
    Insert the second submatch (and so on, up to \9)
    Insert the entire matched pattern
    Insert the entire matched pattern
    Use {string} from the previous invocation of :substitute
    Evaluate {Vim script} expression; use result as replacement
    {string}
    The \={Vim script} token is very powerful. It allows us to execute code and use
    the result as our replacement {string} ************
    Substitutemetoden eller punktmetoden - Välj vad som känns bäst :)
    ➾
    :%s/\v'(([^']|'\w)+)'/“\1”/g
    It’s equivalent to these two separate commands:
    ➾
    /\v'(([^']|'\w)+)'
    ➾
    :%s//“\1”/g
    So what? One way or another, we’ll still have to type out the full pattern,
    right? That’s not the point. The substitute command involves two steps:
    composing a pattern and devising a suitable replacement string. This tech-
    nique allows us to decouple those two tasks.
    ****************
    Besides, who says we have to type out the pattern? In Tip 86, on page 212, we
    used a smidgen of Vim script to add a Visual mode equivalent of the * com-
    mand. This mapping allows us to select any text in our document and then
    hit the * key to search for the selection. We could then run the substitute
    command with an empty search field to replace our selection (and any similar
    matches) with something else. Talk about being lazy!
    I’m not saying that you should never fill out the search field of the substitute
    command. Here, for example, we have a substitute command that joins every
    line of a file by replacing newlines with commas:
    ➾
    :%s/\n/,
    It’s such a simple command that you won’t gain anything by splitting it in
    two. In fact, doing so would probably add work.
    If you think that you’ll want to recall a substitute command in its complete
    form from history, you can always fill out the search field explicitly. Pressing
    <C-r>/ at the command line pastes the contents of the last search register in
    place. Typing out the following would create a complete entry in our command
    history:
    ➾
    :%s/<C-r>//“\1”/g
    If the text in register 0 contains any characters that have special meaning
    within the replacement field (such as & or ~, for example), we would have to
    edit the string by hand to escape those characters. Also, if register 0 contained
    a multiline excerpt of text, it might not fit on the command line.
    To avoid these problems, we could simply pass a reference to the register
    containing the text we want to use in the substitution field.
    Pass by Reference
    Suppose that we’ve yanked a multiline selection of text, and it’s stored in
    register 0. Now we want to use that text as the replacement field of the sub-
    stitute command. We could do so by running this:
    ➾
    :%s//\=@0/g <mailto:=@0>
    In the replacement field, the \= item tells Vim to evaluate a Vim script
    expression. In Vim script, we can reference the contents of a register as
    @{register}. @0 returns the contents of the yank register, while @" returns the
    contents of the default register. So the expression :%s//\=@0/g tells Vim to <mailto:=@0>
    substitute the last pattern with the contents of the yank register.
    ➾
    :%s/Pragmatic Vim/Practical Vim/g
    Compare it with this sequence of commands:
    ➾
    :let @/='Pragmatic Vim'
    ➾
    :let @a='Practical Vim'
    ➾
    :%s//\=@a/g <mailto:=@a>
    :let @/='Pragmatic Vim' is a programmatic way of setting the search pattern. It
    has the same effect as executing the search /Pragmatic Vim <CR> (except that
    running :let @/='Pragmatic Vim' does not create a record in the search history).
    We could exploit this. We could search for the text we want to act upon and
    yank its replacement into register a. Then we could replay the :%s//\=@a/g <mailto:=@a>
    command, and it would use the values of @/ and @a that we had just prepared.
    Next we could search for something else and yank another replacement string
    into register a, and when we replayed the :%s//\=@a/g command, it would do <mailto:=@a>
    something else entirely.
    Try it out. You might love it or you might hate it. But either way, it’s a pretty
    neat trick!
    Suppose that we’ve just executed this command, which acts upon the current
    line:
    ➾
    :s/target/replacement/g
    We realize our mistake at once: we should have prepended %. No harm done.
    We can repeat the command across the entire file just by pressing g& (see
    :h g& ), which is equivalent to running the following:
    ➾
    :%s//~/&
    The :&& command requires some explanation, since the first and second &
    symbols have different meanings. The first one forms the :& Ex command,
    which repeats the last :substitute command (see :h :& ), while the second one
    indicates that the flags from the previous :s command should be reused.
    Discussion
    We can always specify a new range and replay the substitution using the :&&
    command. It doesn’t matter what range was used the last time. :&& by itself
    acts on the current line, :'<,'>&& acts on the visual selection, and :%&& acts
    on the entire file. As we saw already, the g& command is a handy shortcut
    for :%&&.
    Fixing the & Command
    The & command is a synonym for :s, which repeats the last substitution. Unfortunately,
    if any flags were used, the & command disregards them, meaning that the outcome
    could be quite different from the previous substitution.
    Making & trigger the :&& command is more useful. It preserves flags and therefore
    produces more consistent results. These mappings fix the & command in Normal
    mode and create a Visual mode equivalent:
    nnoremap & :&&<CR>
    xnoremap & :&&<CR>
    Now suppose that we want to swap the order of the fields so that the email
    comes first, then the first name, and finally the last name. We could use this
    substitute command to do it:
    ➾
    ➾
    /\v^([^,]*),([^,]*),([^,]*)$
    :%s//\3,\2,\1
    Perform Arithmetic on the Replacement
    The replacement field needn’t be a simple string. We can evaluate a Vim script
    expression and then use the result as the replacement string. Thus with a single
    command, we can promote every HTML header tag in a document.
    We’ll harness the substitute command to do it. Here’s the general idea: we
    write a pattern that matches the numeral portion of HTML header tags. Then
    we write a substitute command that uses a Vim script expression to subtract
    one from the number that was captured. When we run the substitute com-
    mand globally across the entire file, all HTML header tags will be changed
    with that single command.
    We only want to match the ones that
    immediately follow <h or </h. This pattern should do the trick:
    ➾
    /\v\<\/?h\zs\d
    s246 - abolish.vim mm *******
    250++ Qargs :)
    We can invert the behavior of the :global command either by running :global! or
    :vglobal (mnemonic: invert). Each of these tells Vim to execute [cmd] on each
    line that doesn’t match the specified pattern.
    Combining the :global and :delete commands allows us to cut down the size of a
    file rapidly. We can either keep or discard all lines that match a {pattern}.
    :g/TODO
    ➾
    :g/TODO/yank A
    ➾
    :reg a
    We could even combine the :global command with either :bufdo or :argdo to collect
    all TODO items from a set of files. I’ll leave that as an exercise for you, but
    look to Tip 96, on page 233, for a hint at the workflow.
    aOne of my favorite plugins from Tim Pope is called Abolish.
    Search across multiple files mm:
    ➾
    :argdo %s//Practical/ge
    ➾
    /Pragmatic\ze Vim
    ➾
    :vimgrep /<C-r>// **/*.txt
    Pressing <C-r>/ inserts the last search pattern.
    Each match returned by vimgrep is recorded in the quickfix list (see Chapter 17, Compile Code and Navigate Errors with the Quickfix List, on page 259). We can browse the results by running :copen, which opens the quickfix window. But instead of stepping through the results, one at a time, we want to run the substitute command on every file that appears in the quickfix list.
    It would be convenient if Vim included a :quickfixdo command, but there is no such thing. So instead we’ll use this small snippet of Vim script: s249
    Note that the last three commands could be combined into one,
    like this:
    ➾
    :Qargs | argdo %s//Practical/g | update
    The [cmd] could be any Ex command except for another :global command. In
    practice, Ex commands that interact with the text in the document prove
    most useful, such as those in Table 9, Ex Commands That Operate on the Text
    in a Buffer, on page 52. If we don’t specify a [cmd], then Vim will use :print by
    default.
    We can invert the behavior of the :global command either by running :global! or
    :vglobal (mnemonic: invert).
    Combining the :global and :delete commands allows us to cut down the size of a
    file rapidly. We can either keep or discard all lines that match a {pattern}.
    So if we can devise a pattern that matches HTML tags, we could use it with
    the :global command to reject any lines that match the pattern.
    These commands would do the trick:
    ➾
    /\v\<\/?\w+>
    ➾
    :g//d
    :v/href/d
    :g/TODO
    We’ll use the a register. First we’ll need to clear it by running qaq .
    ➾
    :g/TODO/yank A
    ➾
    :reg a
    but in Vim it actually shows a ^J symbol
    for newlines.)
    We could even combine the :global command with either :bufdo or :argdo to collect
    all TODO items from a set of files. I’ll leave that as an exercise for you, but
    look to Tip 96, on page 233, for a hint at the workflow.
    Here’s an alternative solution:
    ➾
    :g/TODO/t$
    Sort Properties for Every Block of Rules
    We can sort the properties for every block of rules in the file with a single
    :global command. Say we run this command on our style sheet:
    ➾
    :g/{/ .+1,/}/-1 sort
    The [range] for our [cmd] can be set dynamically using the match from :g/{pattern}
    as a reference point. Normally the . address stands for the line that the cursor
    is positioned on. But in the context of a :global command, it stands for each
    line in turn that matches the specified {pattern}.
    We can break our command into two separate Ex commands. Let’s work our
    way backward from the end. This is a valid Ex command:
    ➾
    :.+1,/}/-1 sort
    :.+1,/}/-1 sort
    That places our cursor at the top of a {} block, right where we need it. Now
    let’s put our :global and [cmd] Ex commands back together:
    ➾
    :g/{/ .+1,/}/-1 sort
    Note that the :> command echoes a message each time it is invoked, whereas
    :sort doesn’t. We can mute these messages by prefixing our [cmd] with :silent
    (see :h :sil ):
    ➾
    :g/{/sil .+1,/}/-1 >
    s261
    CHAPTER 16
    Index and Navigate
    Source Code with ctags
    Vim’s ctags support allows us to navigate around a codebase by quickly
    jumping to definitions of functions and classes.
    As a secondary benefit, we can also use the output from ctags to
    generate a word list for autocompletion, a
    ➾
    $ sudo apt-get install exuberant-ctags
    Tell Vim Where to Find the Tags File
    The ‘tags’ option specifies where Vim should look to find a tags file (:h 'tags' ).
    When ./ is used in the ‘tags’ option, Vim replaces it with the path of the cur-
    rently active file. We can inspect the defaults:
    ➾
    :set tags?
    ❮
    tags=./tags,tags
    With these settings, Vim looks for a tags file in the directory of the current file
    and in the working directory. U
    We can invoke ctags directly from Vim by running the following:
    ➾
    :!ctags -R
    :nnoremap <f5> :!ctags -R<CR>
    That lets us rebuild the index just by pressing the <F5> key, but we still have
    to remember periodically to generate the tags file. Now let’s consider a couple
    of options for automating this process.
    Automatically Execute ctags Each Time a File is Saved
    Vim’s autocommand feature allows us to invoke a command on each occur-
    rence of an event, such as a buffer being created, opened, or written to file.
    +++Git-integrering mm
    Re-indexing our codebase on each commit strikes a good balance. Sure, the
    tags file might fall out of step with our working copy, but the errors are toler-
    able.
    S269 - Navigating code mm*******
    Compile Code and Navigate Errors
    with the Quickfix List
    Vim’s quickfix list is a core feature that allows us to integrate external tools
    into our workflow. At its simplest, it maintains a sequence of annotated
    addresses comprising the filename, line number, column number (optional),
    and a message. Traditionally, these addresses would be a list of error messages
    generated by a compiler, but they could just as well be warnings from a syntax
    checker, linter, or any other tool that emits such output.
    We’ll start off by looking at an example workflow: running make in an external
    shell and navigating to error messages by hand. Then we’ll introduce the :make
    command, seeing how it can streamline our workflow by parsing error mes-
    sages from the compiler and making them navigable in the form of the
    quickfix list.
    Compile the Project from Inside Vim
    s271
    :make, och förberedelser inför mm :]
    ➾
    :args $VIMRUNTIME/compiler/*.vim
    One down side to using external programs is that their regex syntax may be
    incompatible with the one we use for most Vim searches. We’ll see that the
    :vimgrep command allows us to use Vim’s native search engine to find patterns
    in multiple files. This convenience comes at a cost: vimgrep isn’t nearly as fast
    as dedicated programs.
    284 = VIMGREP **********
    S289 *******
    S290 ************
    Filenamecompletion + :cd - *******
    s296 - OMNICOMPLETION
    s298 Spellcheck
    s306 (set settings)*****
    s307 ++++
    s307
    o
    TIPS, TRICKS OCH BÄSTAKOMMANDON! :D <#ID_1195520506>
    några nya länkar:
    vimtips (essential vim) <http://www.pixelbeat.org/vim.tips.html>
    o
    gå direkt till nån av nio sessionerna innan nuvarande = '1-'9 :D
    BÄSTABÄSTA :]
    grundmärken :)
    ] - slut av senaste ändring
    " - markörposition när senast ändrade filen
    . - pos. där senaste ändring gjordes
    )
    }
    block
    t - (tagblocks = < > )
    b - ( )
    B - { }
    a"
    a'
    a`
    a<
    a]
    1: /four  2:cw five  3:n  4:.  :DDDD
    mata in unicodetecken/specialtecken :DD
    Testa: mata in Enter som tecken (med t ex Ctrl+v (???)) för att kunna lägga flerradstext i ett register %]
    mata in unicode-tecken
    mata in Del m fl tecken via siffror - ctrl+v 127
    mata in hexadecimala tecknet x7f - ctrl+v x7f
    mata in oktala tecken - ctrl+v o123
    Error setting the text for the following input: =Ctrl+v u +unicode-tal :).
    u1234
    Error setting the text for the following input: =16-bit.
    U12345678
    Error setting the text for the following input: =32-bit.
    o
    Digraphs (t ex copywrighttecknet) - ctrl+k Co
    se vilka digraphs som är tillgängliga - :digraphs
    +s125
    öppna fil under markören i ny tab :DDDDDD !!! --- Ctrl-w gf
    Ändra färgschema :D ***
    o
    förena rader (i exemplet, blanka rader)
    :g/./,/^$/join
    gå direkt till senaste sessionen :D == '0 (klar2014)
    o
    klistra in senast kopierade (med y t.ex.) med Ctrl+r när i insertmode (klar2014)
    Ctrl+r, 0
    placera in det som skrevs in senast i i-mode :DDD (klar2014)
    Ctrl+a
    Ctrl+@
    ++i insertmode = Ctrl+r, i
    skicka x antal rader till kommandoraden för redigering (klar2014)
    5:
    :.,.+4
    o
    tags i vim <http://vim.wikia.com/wiki/Browsing_programs_with_tags>
    o
    Ctrl-]
    For example, the command ':stag func1' will open the func1 definition in a new window.
    You can position the cursor over a tag name and then press Ctrl-W ]. This will open the tag location in a new window.
    o
    :tselect func1' will list all the locations where func1 is defined. You can then enter the number of a tag match to jump to that location.
    You can position the cursor over the tag name and press g] to get a list of matching tags.
    You can visually select a text and press g] to get a list of matching tags.
    You can use the 'stselect' ex command. This will open the selected tag from the tag list in a new window.
    You can position the cursor over the tag name and press Ctrl-W g] to do a :stselect.
    o
    gå tillbaks:
    :pop
    Ctrl+t
    o
    How do I jump again to a previously jumped tag location?
    You can use the 'tag' ex command to jump to a previously jumped tag location, which is stored in the tag stack.
    Help: tag
    How do I list the contents of the tag stack?
    Vim remembers the location from which you jumped to a tag in the tag stack. You can list the current tag stack using the 'tags' ex command.
    TILL TAG OM BARA EN MATCH, ANNARS VISA LISTA
    BROWSE THROUGH LIST OF MULTIPLE TAGMATCHES
    o
    ANVÄNDA PREVIEWFÖNSTRET OCH VISA TAG
    o
    You can position the cursor on a tag name and press Ctrl-W } to open the tag in the preview window.
    o
    o
    You can position the cursor on the tag and press Ctrl-W g} to do a :ptjump on the tag.
    BROWSE THROUGH LIST OF TAGS =I PREVIEWFÖNSTRET !! (:ptselect, :ptjump osv)
    o
    $ vim -t
    Error setting the text for the following input: = öppna vim för redigering utifrån en tag-match i en fil :).
    LIST ALL THE TAGS MATCHING A SEARCHPATTERN
    DRS VIMHÄFTE 2 (folds till autocommand (och precis innan 'add new menus')
    TAGS - s25-26
    A tag is a location where an identifier is defined. An example is a functiondefinition in a C- or C++-program
    Generate c-tags for all c-files in the current directory: ctags *.c
    CONFIGURE CTAGS FOR PYTHON AND VIM <Configuring%20ctags%20for%20Python%20and%20Vim>
    o
    o
    o
    o
    o
    mm
    PREVIEWWINDOW - s157 i usermanual
    HOPPA I PROGRAM - s26-27
    KODFELMEDDELANDEN - s27-28
    INDENTERING - s(28)-29 (+softtabstops och annat)
    formatering
    browse (30-31)
    UNDO OCH UNDOTREE - s31
    MAPS - s31-33
    EGENDEFINIERADE KOMMANDON :) - s33-34
    AUTOCOMMAND - s34-35
    ADD NEW MENUS - s225 i usermanual
    färgkod KLAR 2014
    c/mönster
    ändra framåt till mönster
    c?mönster
    ändra bakåt till mönster
    cn
    ändra framåt till nästa mönster
    cG
    ändra till slutet
    d13G
    sudda framåt till (och med?) rad 13
    o
    öppna ny rad under nuvarande = o
    öppna ny rad över nuvarande = O :D
    :e
    redigera annan fil
    :e annan_fil
    byt till filen x.txt +gå till rad 100
    :e +100 x.txt
    byt till filen x.txt +gå till mönstret 'mönster'
    :e +/mönster x.txt
    :e /zzz y.txt
    återgå till sparade versionen av nuvarande fil
    :e!  :)
    öppna alternativa filen
    :e #
    :e(!) $MYVIMRC
    o
    :w
    :q
    :x
    uppdatera filen och gå ut ur vi (samma som wq)
    :20
    gå till rad 20 :)
    :d3
    ta bort 3 rader från den där markören stod
    :r fil_x.txt
    se nedan :]
    o
    vim nyfil3.txt :]
    skapa ny fil direkt i skalet :]
    vim \+30 fil.txt :]
    gå till rad 30 i en fil
    vim \+ fil.txt :]
    gå till sista raden i en fil
    o
    vim \+/ord fil.txt :]
    gå till rad med ordet 'ord' i en fil
    vim +/^References file.txt
    o
    p
    P
    Error setting the text for the following input: = klistra in innan :).
    o
    r
    replace
    ersätt || med &&
    2r& [markör på första | ] :)
    o
    |
    gå till kolumn 3 på nuvarande rad
    3|
    kolumner och virtualmode: s133
    undo/redo = u / Ctrl+r :DD
    revert line :D = U
    undo last U = ett U till
    o
    slå ihop markerade rader :DDDD = J
    slå ihop 3 rader
    3J
    UNDO/REDO
    u
    Error setting the text for the following input: =undo :).
    U (=stort u) :)
    ångra alla ändringar på nuvarande raden :D
    Ctrl+r
    Error setting the text for the following input: =redo :).
    byt namn på filen, men spara inte än
    :file nyttnamn.txt
    FLYTTA RUNT :)
    flytta mellan ord
    o
    gå till början på nästa ord
    w
    Error setting the text for the following input: =fortsätter på början av nästa rad om når slutet av nuvarande :).
    gå till början av förra ordet
    b
    Error setting the text for the following input: =fortsätter på början av förra raden om når början av nuvarande :).
    o
    gå till slutet av nuvarande ordet
    e
    gå till ins-läge vid slutet av ord :)
    ea
    gå till slutet av förra ordet :)
    ge
    o
    gE
    räknar in skiljetecken i ord :DDDD
    W
    B
    E
    gE
    gå till början/slutet på rad
    o
    0
    $ (1$ är samma sak :)
    gå till slutet på nästa rad :DDDD
    2$
    ^
    o
    gå till första tecknet på nästa rad
    Enter // +
    gå till första tecknet på förra raden
    -
    gå till nästa tecken ÄVEN om på nästa rad :)
    blanksteg
    gå till mitten på rad
    gm
    gå ner/upp VISUELL rad (inte LOGISK rad, som standard)
    gj/gk
    sök till/till och med ett tecken :DD
    F T t f  :)
    ,  ;
    :DD
    repetera sökkommando (ftFT) i samma riktning
    ;
    repetera sökkommando (ftFT) i andra riktningen
    ,
    exempel
    ändra fram till (men inte med) punkt
    ct.
    o
    flytta mellan matchande parenteser :DD
    %
    tillåtna parenteser:
    (
    [
    {
    <  (??) :}
    flytta till nästa parentes från vanlig text
    %
    gå till rad n :)
    gå till rad 15
    15G
    gå till första raden
    gg
    gå till sista raden
    G
    gå till halva filen (50 %) :D
    50%
    o
    o
    H
    gå till 3 rader under översta raden på skärmen
    3H  :DD
    o
    M
    o
    L
    gå till 3 rader över nedersta raden på skärmen
    3L  :DD
    visa var du är i filen :)
    o
    :se ruler :))
    o
    Ctrl-g [=infon ges redan om linjalen är påslagen] :DD
    o
    :se nu
    FLYTTA UPP/NER-KOMMANDON D :D
    rad upp = Ctrl+y
    halvskärm upp = Ctrl+u
    helskärm upp = Ctrl+b
    rad ner = Ctrl+e
    halvskärm ner = Ctrl+d
    helskärm ner = Ctrl+f
    flytta ner/upp 5 rader :D
    5 ctrl+d/u
    :DD
    o
    zt
    o
    zz
    200zz / 200zRetur
    flytta rad 200 till toppen av skärmen
    o
    zb
    o
    grundläggande flyttkommanden i ex
    o
    :d
    sudda alla rader i en fil :)
    :%d
    :m
    flytta rad 226 t om slutrad till två rader innan nuvarande
    :226,$m.-2
    :t / :co
    kopiera alla rader i filen och placera in på slutet av filen
    :%t$
    o
    :160,224m23
    flytta 150 t om 224 till efter rad 23
    :23,29co100
    o
    :p
    visa rad 100 och 5 rader framåt
    :100;+5p
    visa första rad där 'mönster' förekommer + 10 rader framåt :D
    :/mönster/;+10p
    OBS!
    vim (d)
    raderar fram till angivet ord på rad
    ex (:d)
    raderar hela raden
    :ya
    som p men anv. med radadresser och namngivna buffrar :)
    :pu
    som p men anv. med radadresser och namngivna buffrar :)
    o
    :160,224ya a
    o
    :pu a
    VISA RADNUMMER, visa filinfo MM
    visa radnummer i filen temporärt :]
    :#
    visa radnummer för rad 1-10 temporärt :]
    :1,10#
    visa radnummer för markerade rader temporärt :)
    - markerade med visual mode
    - markerade med sökmönster
    - markerade med marks ('t mm) :)
    visa radnummer för nuvarande raden
    Ctrl+g
    :.=
    skriv ut totalt antal rader (förutom g Ctrl+g)
    skriv ut totalt antal rader
    visa radnummer för första linjen där 'mönster' förekommer
    :/mönster/=
    KOLLA MER PÅ DETTA KOMMANDOT
    visa filnamn mm info
    :file
    info om fil
    -
    fil kan inte modifieras (t ex hjälpfilerna)
    +
    filen innehåller ändringar
    =
    filen är read-only enbart
    Error setting the text for the following input: =+.
    filen är read-only men innehåller ändå ändringar
    pppp
    OPERATORER OCH RÖRELSER(motions) :) (se ev mer + öva i usr_04)
    w
    e
    skillnad mellan e och w = w bevarar ett blanksteg :)
    b
    $
    o
    gå till slutet av nästa rad
    2$
    5$
    0
    t ex d4w :)
    r
    även t ex 5rx = xxxxx
    ersätt tecken med radbryt = r<Enter>
    repetera senaste ändring = .
    SE MER EV
    obs! fungerar inte för
    u
    Ctrl+r
    :-kommandon :)
    gå till tidigare ändringar i text (förra/nästa) :D
    g, / g;
    u
    Ctrl+r
    TEXTOBJEKT/BLOCK-IDENTIFIERARE :DDDDD
    aw ==> t ex daw = sudda ett ord :D
    aw
    iw
    aW
    iW
    as
    kopiera mening man står i till minne f, var man än står i meningen :)) = "fyas
    sudda mening + blanksteg efter
    das
    is
    ap
    ip
    a], a[  (=???)  = [ ] + text inne i :)
    i], i[  = text inne i [ ] :D
    o
    3 sorternas block :)
    (
    <
    {
    ab
    a), a(
    ib
    i), i(  (=??)
    at
    a>, a< (=???)
    block från <a> till <a/>
    it
    i>, i< (=???)
    aB
    a}, a{
    block från { till } :] = TESTA
    iB
    text inne i { }-block :D OCH [ ]-block tydligen :] =testa
    a"
      = citerad text :D [+se nedan].
    a'
    a`
    (i")
    (i')
    (i`)
    RÄKNA ORD/RÄKNA TECKEN mm :)
    visa info om filen (rad, antal tecken mm)
    gCtrl+g
    HELP (:h) :)
    öppna hjälpen
    :h, <F1>
    kolla upp kommandot o för visualmode
    v_o; v_O  :)
    o
    o
    To get help on the "x" command, for example, enter the following: >
    :help x
    To find out how to delete text, use this command: >
    :help deleting
    To get a complete index of all Vim commands, use the following command: >
    :help index
    When you need to get help for a control character command (for example, CTRL-A), you need to spell it with the prefix "CTRL-". >
    :help CTRL-A
    For example, the following command displays help for the normal-mode CTRL-H command: >
    :help CTRL-H
    insert-mode version of a command, use "i_". following command: > If you want the help for the For CTRL-H this gives you the
    :help i_CTRL-H
    o
    When you start the Vim editor, you can use several command-line arguments. These all begin with a dash (-). To find what the -t argument does, for example, use the command: >
    :help -t
    The Vim editor has a number of options that enable you to configure and customize the editor. If you want help for an option, you need to enclose it in single quotation marks. To find out what the 'number' option does, for example, use the following command: >
    :help 'number'
    The table with all mode prefixes can be found here: |help-context|.
    Special keys are enclosed in angle brackets. To find help on the up-arrow key in Insert mode, for instance, use this command: >
    :help i_<Up>
    If you see an error message that you don't understand, for example: E37: No write since last change (use ! to override) ~ You can use the error ID at the start to find help about it: >
    :help E37
    Summary:
    :help
    Gives you very general help. Scroll down to see a list of all helpfiles, including those added locally (i.e. not distributed with Vim). >
    :help user-toc.txt
    Table of contents of the User Manual. >
    Ex-command "subject", for instance the following: >
    :help :subject
    Help on getting help. >
    :help :help
    normal-mode command "abc". >
    :help abc
    The same in Insert mode. >
    :help i_abc
    :help v_abc
    :)
    Control key <C-B> in Normal mode. >
    :help CTRL-B
    The same in Insert mode. >
    :help i_CTRL-B
    The same in Visual mode. >
    :help v_CTRL-B
    The same in Command-line mode. >
    :help c_abc
    :help c_CTRL-B
    Option 'subject'. >
    :help 'subject'
    Function "subject". >
    :help subject()
    Command-line option "-subject". >
    :help -subject
    Compile-time feature "+subject". >
    :help +subject
    Autocommand event "EventName". >
    :help EventName
    The top of the helpfile "digraph.txt".
    :help digraphs.txt
    Similarly for any other helpfile. >
    Find a help tag starting with "pattern". Repeat <Tab> for others. >
    :help pattern<Tab>
    See all possible help tag matches "pattern" at once. >
    :help pattern<Ctrl-D>
    :)
    HELPGREP
    Search the whole text of all help files for pattern "pattern".
    :helpgrep pattern
    Jumps to the first match. Jump to other matches with: > next match >
    :cn
    previous match >
    :cprev
    :cN
    first or last match >
    :cfirst
    :clast
    QUICKFIX-FÖNSTRET
    open/close the quickfix window; press <Enter> to jump to the item under the cursor
    :copen
    :cclose
    1. Using QuickFix commands
    *quickfix* *Quickfix* *E42*
    Vim has a special mode to speedup the edit-compile-edit cycle.  This is inspired by the quickfix option of the Manx's Aztec C compiler on the Amiga. The idea is to save the error messages from the compiler in a file and use Vim to jump to the errors one by one.  You can examine each problem and fix it, without having to remember all the error messages. In Vim the quickfix commands are used more generally to find a list of positions in files.  For example, |:vimgrep| finds pattern matches.  You can use the positions in a script with the |getqflist()| function.  Thus you can do a lot more than the edit/compile/fix cycle!
    If you are using Manx's Aztec C compiler on the Amiga look here for how to use it with Vim: |quickfix-manx|.  If you are using another compiler you should save the error messages in a file and start Vim with "vim -q filename".  An easy way to do this is with the |:make| command (see below).  The 'errorformat' option should be set to match the error messages from your compiler (see |errorformat| below).
    LOCATION-LIST :)
    SE MER!! <http://vimdoc.sourceforge.net/htmldoc/quickfix.html>
    *location-list* *E776*
    A location list is similar to a quickfix list and contains a list of positions in files.  A location list is associated with a window and each window can have a separate location list.  A location list can be associated with only one window.  The location list is independent of the quickfix list. When a window with a location list is split, the new window gets a copy of the location list.  When there are no references to a location list, the location list is destroyed.
    The following quickfix commands can be used.  The location list commands are similar to the quickfix commands, replacing the 'c' prefix in the quickfix command with 'l'.
    vimgrep: vimcasts.org drew neil : !!! <http://vimcasts.org/episodes/search-multiple-files-with-vimgrep/>
    JUMPS
    visa lista på senaste jumps :) == :jumps
    gå tillbaks till där senaste hoppet gjordes :D
    o
    Ctrl+t (pop tags)
    Ctrl+o :)
    följ en länk(=jump to tag) :DD
    Ctrl+]
    MARKS :)
    o
    gå till rad 20
    G20 :)
    hoppa tillbaks till raden där du hoppade från :)
    '
    hoppa tillbaks till exakta positionen där du hoppade från :DDD
    Error setting the text for the following input: =två backticks :DD.
    hoppa tillbaks till positionen man hoppade från
    ' el 2 backticks IGEN :DD
    definition av ett hopp: alla kommandon som flyttar markören längre än inom en rad :DDD
    undantag:
    fFtT
    w och e
    j och k
    gå tillbaks till äldre/nyare hopp
    Ctrl+o / Ctrl+i
    visa lista på jumps
    :jumps
    o
    visa lista på alla marks
    :marks
    hoppa till märke a
    backtick a :)
    hoppa till märke a:s rad
    a
    :DDDD
    Error setting the text for the following input: =funkar inte för u, Ctrl+r och :-kommandon :].
    REGISTERS :D
    visa vad som finns i registers :D == :reg(isters)
    OLIKA SORTERNA REGISTER :) <vim-registers_super.txt>
    ALLMÄNT OM REGISTERS :DDDD !!!!
    klistra in från urklipp (inte bokstavregister)
    1. från kommandoläge
    "+p
    2. från insertläge
    Ctrl+r, +
    "a/"A - "z/"Z -- 26 registren med namn :]
    o
    lägg till sökning efter ordet 'mönster' sist register c
    qC/mönster<Enter>q
    kopiera och lägg till sist i register a
    "Ay
    o
    "-  -- lilla delete-registret
    Error setting the text for the following input: =det senast suddade, om mindre än en rad :D.
    "0 - "9 -- 10 numrerade registren :]
    Error setting the text for the following input: =senast suddade (och 1-9 bakåt), om mer än en rad.
    förra suddade (mer än en rad)
    "1
    "_ -- black hole register :)
    sudda ut ett ord till blackhole-registret
    "_dw
    SKILLNAD MELLAN " OCH 0-registren :D
    I was pleased when I discovered the 0 register. If you yank text without assigning it to a particular register, then it will be assigned to the 0 register, as well as being saved in the default " register. The difference between the 0 and " registers is that 0 is only populated with yanked text, whereas the the default register is also populated with text deleted using d/D/x/X/c/C/s/S commands.
    I find this useful when I want to copy some text, delete something and replace it with the copied text. The following steps illustrate an example:
    Yank the text you want to copy with y[motion] - this text is saved in " and 0 registers
    Delete the text you want to replace with d[motion] - this text is saved in " register
    Paste the yanked text with "0p
    On the final step, if you were to paste from the default register (with p), it would use the text that you had just deleted (probably not what you intended).
    o
    ":
    Error setting the text for the following input: =senaste exkommandot.
    2. från insertläge
    Ctrl+r, :
    kör senaste registerkommandot igen
    @:
    ".
    Error setting the text for the following input: =senast inmatat :D.
    2. från insertläge
    Ctrl+r, .
    o
    o
    "% -- namn på nuvarande filen :)
    2. från insertläge
    Ctrl+r, %
    klistra in fils namn i texten
    "%p
    ge full sökväg till fil med %
    %:p (t ex :e %:p)
    /full/sök/väg/fil.txt
    %:p
    /full/sök/väg/fil.txt
    /full/sök/väg/fil.txt
    %:.
    (om står i mappen sök) väg/fil.txt
    /full/sök/väg/fil.txt
    %:e
    (.)txt
    /full/sök/väg/fil.txt
    %:h
    /full/sök/väg/
    /full/sök/väg/fil.txt
    %:t
    fil.txt
    "# -- namn på alt-filen :)
    2. från insertläge
    Ctrl+r, #
    "=
    Vim expression register :) <http://stackoverflow.com/questions/7027741/what-is-the-purpose-of-the-expression-register>
    SE MER
    "" -- the unnamed register
    o
    "* -- selection :)
    Error setting the text for the following input: =används enklast med Shift+Insert :D.
    2. från insertläge
    Ctrl+r, *
    "+ -- clipboard
    2. från insertläge
    Ctrl+r, +
    "~
    "/ -- senaste sökmönster-registret :]
    Error setting the text for the following input: =för både /- och ?-sökningar :).
    2. från insertläge
    Ctrl+r, /
    :let @/ = "the"
    inskrivet på kommandorad-registret ::]
    SÖKNING MED / och ?
    o
    tecknen att se upp med vid sökning = /  :)
    .
    *
    [
    ]
    ^
    %
    /
    \
    ?
    ~
    $
    hitta ordet ord i texten
    /ord
    hitta första '#include' efter pekaren
    /#include
    hitta första '#include' innan pekaren
    ?#include
    hitta nästa/förra
    n/N
    :)
    gå tillbaks ett steg i /-sökhistoriken
    / + pil upp :)
    o
    hitta nästa förra ordet 'x' med snabbtryck :DDD
    # // *
    hitta nästa förra ordet som ordet 'x' ingår i; = med snabbtryck :DDD
    g# // g*
    sök tredje ordet framåt med knapptryck :)
    3*
    början/slutet på ord
    hitta ordet the (=inte i nåt annat ord) :D
    /\<the\>
    början/slutet på rad
    byt ut screen mot line på rad 12
    :12s/screen/line/
    TIPS! n går att göra om igen efter ett litet tag = går att använda för intressant redigering :D
    sudda från markören bakåt till och med ordet 'move' :D
    d?move
    sök textsträng med ic/noic för just den sökningen
    ignore case
    \c (gement c)
    match case
    \C
    sök efter mönstret 'mönster' med ignorecase på :)
    /\cmönster
    smartcase <http://linuxcommando.blogspot.se/2008/06/smart-case-insensitive-incremental.html>
    (tillsammans med ic =sök ic om bara gemener matas in, annars matchcase :DDD )
    ev också tillsammans med incsearch
    också tillsammans med ignorecase (t ex :set ignorecase smartcase)
    använda regex i / /-sökning :D
    /\(ab\)*
    /ab\+
    /folders\=
    /ab\{,5}
    o
    \{,4}
    \{,}
    \{,1}
    \{,}
    \{,}
    \{}
    /ab\{-1,3}
    \{-}
    /a.\{-}b
    /foo\|bar
    /one\|two\|three
    /\(foo\|bar\)
    this matches "foo", "foobar", "foofoo", "barfoobar" etc
    /end\(if\|foo\|bar\)
    A related item is "\&". this requires that both alternatives match in the same place. the resulting match uses the last alternative.
    example: /forever\&.....
    this matches "for" in "forever". it will not match "fortuin", for example
    /[1236aoeus]
    /[0-9a-f]
    /"[^"]*"
    o
    /\a
    klass=alpha (bokstäver)
    se fler vid regular expressions
    o
    o
    o
    o
    o
    ******
    \zs, \ze
    sök med ignorecase
    /\csökord
    /sökord/i
    ?
    EFTER KRASCH
    öppna en fil du redigerade vid datorkrasch
    vim -r help.txt
    tips: +=spara först återhämta filen under annat namn för att kunna jämföra m orig.filen
    :w help.txt.recov :e # :diffsp(lit) help.txt
    om redigerade fil utan namn vid krasch
    vim -r ""
    lista alla swapfiler som finns i en viss mapp
    vim -r i en mapp :)
    CLIPBOARD OCH MARKERAD_TEXT
    "+
    "* / Shift+Insert
    SKRIVA UT**
    :ha(rdcopy)
    There are several options that change the way Vim prints:
    printdevice'
    printheader'
    printfont'
    printoptions'
    skriv ut bara vissa rader :)
    v100j:hardcopy
    REDIGERA MER ÄN EN FIL (på samma gång :))
    hm ??
    :pre
    :wpre
    :last
    :first
    :2n
    :2pre
    redigera en fil
    :e fil.txt
    ((om får felmeddelande, t ex E37 = :h E37)) :))
    :]
    redigera ny fil utan att stänga eller spara nuvarande filen :DD
    :hide edit foo.txt
    ev kortform=
    :hid e foo.txt
    öppna fil när inne i vim men ligg kvar i filen du redigerar just nu
    :hide edit foo.txt
    ev kortform=
    :hid e foo.txt
    redigera nästa fil i bufferlistan
    :n
    gå två filer framåt i bufferlistan
    :2n
    :)
    gå till förra filen i b-listan
    :prev
    redigera nästa fil i bufferlistan även om nuvarande har ändringar
    :n!
    spara och gå till nästa fil
    :wn
    se lista på filer som redigeras
    :ar((gs))
    :ls
    spara och gå till förra filen i listan
    :wp
    gå till sista/första filen i b-listan
    :la
    :fir
    obs!
    There is no ":wlast" or ":wfirst" command though!
    sätta autowrite :)
    :set autowrite
    ange annan lista på filer att redigera :DDD


    zzzz
    ZZZZ
    ZZZZ

    VIMINFO (=spara märken, innehåll i registers mm med en fil******;s99 :) [se mer detaljerna]
    Öppna fil under markören (i detta fönstret);gf
    Öppna fil under markören i split*****;Ctrl-w f
    Öppna fil under markören i tab*****;Ctrl-w gf
    Öppna fil under markören (i detta fönstret) + till radnummer n;gF
    Öppna fil under markören i split***** + till radnummer n;Ctrl-w F
    Öppna fil under markören i tab***** + till radnummer n;Ctrl-w gF
    sudda 3 ord till höger;3daw
    ändra till toppen;cH
    ändra till botten;cL
    ändra till kolon 5;c5|
    sudda två meningar;d2)
    ändra till föregående stycke;c{
    sudda ner t.o.m. rad 13,, sudda upp t.o.m. rad 2;d13G,, d2gg
    byt till fil x.txt +till rad 100;:e +100 x.txt
    byt till fil x.txt +till mönstret 'mönster';:e +/mönster x.txt
    öppna sin rc-fil;:e(!) $MYVIMRC
    gå till rad 20 med ex-läge :);:20
    sudda 3 rader (=från ex-läge);:d3
    gå till sista raden i en fil;vim \+ fil.txt :]
    gå till första raden i en fil, som börjar med ordet 'ord';vim +/^References file.txt
    ersätt || med &&;2r& [markör på första | ] :)
    revert line :);U
    undo last U;ett U till
    slå ihop markerade rader :);J
    slå ihop 3 rader;3J
    till slut av ord ('ord.x' t.ex.);gE
    gå till slutet på rad;(1)$
    gå till slutet på nästa rad :);2$
    gå till första tecknet på nästa rad;Enter // +
    gå till första tecknet på förra raden;-
    gå till mitten på rad;gm
    flytta mellan matchande parenteser;%
    flytta till nästa parentes från vanlig text;%
    gå till 3 rader under översta raden på skärmen;3H
    flytta ner/upp 5 rader;5 ctrl+d/u
    flytta rad 200 till toppen av skärmen;200zt
    sudda alla rader i en fil (från ex);:%d
    flytta rad 226 t om slut till två rader innan nuvarande;:226,$m.-2
    kopiera allt i filen + placera in på slutet av filen;:%t$
    flytta 150 t om 224 till efter rad 23;:160,224m23
    visa rad 100 + 5 rader framåt;:100;+5p
    visa första rad där 'mönster' förekommer + 10 rader framåt;:/mönster/;+10p
    kopiera rad 160-224 till buffer a;:160,224ya a
    klistra in innehållet från buffer a (ifrån ex-läge);:pu a
    visa radnummer i filen temporärt;:# ***
    visa radnummer för rad 1-10 temporärt;:1,10# ***
    visa radnummer för markerade rader (visualmode)/markerade med sökmönster/markerade med marks temporärt;:'a,'b#
    visa radnummer för nuvarande raden;Ctrl+g,, :.=
    skriv ut totalt antal rader (förutom g Ctrl+g)
    visa radnummer för första raden där 'mönster' förekommer;:/mönster/=
    slutet av nästa rad;2$
    ersätt 5 nästa tecken med x;5rx (=xxxxx)
    vad funkar inte rep.punkt för?;u,, Ctrl+r,, :-kommandon
    gå till förra/nästa ändring i text;g, // g;  ****
    text inne i { }-block :D OCH [ ]-block tydligen :);iB
    kolla upp (help) visualmode-kommandot o;v_o; v_O
    help för C-a-kommandot;:help CTRL-A
    kolla help för pil-upp i insertläge;:help i_<Up>
    help för exkommandot update;:help :update
    Help on getting help;:help :help
    help on normal-mode command "c";:help c
    olika lägena för helpsökning;i(nsertmode), v(isualmode), c(ommandmode)
    help för Autocommand event "EventName";:help EventName
    help: go to top of helpfile "digraph.txt";:help digraphs.txt
    Find a help tag starting with "pattern". Repeat <Tab> for others;:help pattern<Tab>
    See all possible help tag matches "pattern" at once;:help pattern<Ctrl-D>

    Search all text of help files for pattern "mönster";:helpgrep mönster
    jumps to next/prev. filematch in q-fixlist;:cn // :cprev,, :cN
    first or last match;:cfirst / :clast
    open/close the quickfix window (+press <Enter> to jump to item under cursor);:copen // :cclose
    1. Using QUICKFIX !!! commands;Vim has a special mode to speedup the edit-compile-edit cycle.  This is inspired by the quickfix option of the Manx's Aztec C compiler on the Amiga. The idea is to save the error messages from the compiler in a file and use Vim to jump to the errors one by one.  You can examine each problem and fix it, without having to remember all the error messages. In Vim the quickfix commands are used more generally to find a list of positions in files.  For example, |:vimgrep| finds pattern matches.  You can use the positions in a script with the |getqflist()| function.  Thus you can do a lot more than the edit/compile/fix cycle!  If you are using Manx's Aztec C compiler on the Amiga look here for how to use it with Vim: |quickfix-manx|.  If you are using another compiler you should save the error messages in a file and start Vim with "vim -q filename".  An easy way to do this is with the |:make| command (see below).  The 'errorformat' option should be set to match the error messages from your compiler (see |errorformat| below).
    LOCATIONLIST;A location list is similar to a quickfix list and contains a list of positions in files.  A location list is associated with a window and each window can have a separate location list.  A location list can be associated with only one window.  The location list is independent of the quickfix list. When a window with a location list is split, the new window gets a copy of the location list.  When there are no references to a location list, the location list is destroyed.
    Hur känner man igen locationlist-kommandon i förhållande till quickfixkommandon;replacing the 'c' prefix in the quickfix command with 'l'.
    VIMGREP;=se ev mer
    lista senaste jumps;:jumps
    följ en länk(=jump to tag;Ctrl+]
    öppna fil som redigerades vid krasch;vim -r help.txt
    tips: spara,, återhämta filen m annat namn;:w help.txt.recov :e # :diffsp(lit) help.txt
    om redigerade fil utan namn vid krasch;vim -r ""
    lista alla swapfiler som finns i en viss mapp;vim -r i en mapp :)
    GÅ FRAM/TILLBAKS I JUMPLIST;C-i,, C-o
    hoppa tillbaks till exakt pos. hoppade från;``
    hoppa tillbaks till positionen man hoppade från
    definition av ett hopp;alla kommandon som flyttar markör längre än inom en rad (utom fFtT)

    (till) start/slutpos av nuvarande mening :D == `(  //  `)
    till start/slutrad av nuvarande stycke == '{  //  '}  :)
    markör-position när senast redigerade filen;`"
    GÅ TILL NÄSTA MÄRKE;]`
    POS. INS.MODE STOPPADES;`^  :)
    till första/sista pos. av senast ändrad(?)/kopierad text;`[ // `]
    hoppa till markörbokstav (t ex a) MEN ändra inte i jump-list :DDD = g`a
    sudda märken = :delm
    sudda ett visst märke (t ex a) = :delm a
    ta bort alla markeringar i texten;:delm!
    LÄGG TILL SÖKNING EFTER ORDET 'MÖNSTER' SIST REGISTER C;qC/mönster<Enter>q
    KOPIERA OCH LÄGG TILL SIST I REGISTER A;"Ay
    sudda ut ett ord till blackhole-registret;"_dw
    SKILLNAD MELLAN " OCH 0-REGISTREN;I was pleased when I discovered the 0 register. If you yank text without assigning it to a particular register, then it will be assigned to the 0 register, as well as being saved in the default " register. The difference between the 0 and " registers is that 0 is only populated with yanked text, whereas the the default register is also populated with text deleted using d/D/x/X/c/C/s/S commands.  I find this useful when I want to copy some text, delete something and replace it with the copied text. The following steps illustrate an example:    Yank the text you want to copy with y[motion] - this text is saved in " and 0 registers. Delete the text you want to replace with d[motion] - this text is saved in " register.   Paste the yanked text with "0p.   On the final step, if you were to paste from the default register (with p), it would use the text that you had just deleted (probably not what you intended).
    Senaste exkommandot-register;":
    kör senaste register-kommandot igen;@:
    senast inmatat-registret;".
    2. från insertläge;Ctrl+r, .
    ge full sökväg till fil med %;%:p (t ex :e %:p)
    /full/sök/väg/fil.txt;%:p
    (om står i mappen sök) väg/fil.txt;%:.
    /full/sök/väg/fil.txt
    (.)txt;%:e
    /full/sök/väg/;%:h
    fil.txt;%:t
    "# -- namn på alt-filen :)
    EXPRESSION REGISTER
    "" -- THE UNNAMED REGISTER
    "~
    "/ -- senaste sökmönster-registret :]
    :let @/ = "the"
    SKICKA 5 ST RADER TILL KOMMANDORAD FÖR REDIGERINg;5: :.,.+4
    skriv ut;:ha(rdcopy)
    SKRIVA UT/ANGE PRINTRANGE (=????) :)))
    IF YOU HAVE A PDF PRINTER INSTALLED1, YOU CAN USE THIS TECHNIQUE TO PRINT A FILE TO PDF. FOR EXAMPLE, ASSUMING YOUR PDF PRINTER IS CALLED PDF;SET PDEV=PDF
    utför inspelade kommandosekvensen a 3 gånger;3@a
    tecknen att se upp med vid sökning;. * [ ] ^ % / \ ? ~ $
    gå tillbaks ett steg i /-sökhistoriken;/ + pil upp
    hitta nästa förra ordet som ordet 'x' ingår i;g# // g*
    sök tredje ordet framåt med knapptryck;3*
    hitta egna ordet 'the';/\<the\>
    byt ut screen mot line på rad 12;:12s/screen/line/
    sudda bakåt t.o.m. ordet 'move';d?move
    ic för /-sökning;\c,,  /\csökord,,  /sökord/i
    START/SLUT AV REGEXMATCHNING***;\zs, \ze
    if has("vms")   ???
    map Q gq  :)
    <F5>
    <Esc>
    <BS>
    \p
    _x
    ,x
    (-x)?
    There are several options that change the way Vim prints:
    skriv ut bara vissa rader;v100j:hardcopy
    gå två filer framåt i bufferlistan;:2n
    sätt globala märket F;mF
    To make a window as high as it can be;CTRL-W _ (=without a count.)
    öppna ny tom fil i vertikal split;:vnew,, :vertical new
    MOVE TO THE WINDOW ABOVE;CTRL-W k
    MOVE TO THE TOP/BOTTOM WINDOW;CTRL-W t // CTRL-W b
    MOVE TO THE BOTTOM WINDOW
    BYT FÖNSTRET MOT FÖNSTER N (DEF. NÄSTA :);CTRL-W x
    GÅ TILL FÖREGÅENDE ANVÄNT FÖNSTER;CTRL-W p
    FLYTTA SPLITFÖNSTER (=ARRANGERA OM UPPSTÄLLNING)****;CTRL--W J/K/H/L
    MINSKA FÖNSTERBREDD N KOLUMNER****;CTRL-W <
    SÄTT FÖNSTERVIDD TILL N KOLUMNER;CTRL-W |
    SÄTT SAMMA BREDD OCH HÖJD PÅ ALLA FÖNSTER;CTRL-W =
    rotera fönster uppåt/neråt n gånger;CTRL-W R/r
    fönster till höjd n; default highest possible :];CTRL-W _
    stäng nuvarande fönster;CTRL-W q, CTRL-W c
    stäng alla fönster utom nuvarande (=samma som :only) :);CTRL-W o
    flytta nuvarande fönster till ny tab;CTRL-W T
    gå till (n) nästa fönster;CTRL-W w
    gå till n föregående fönster;CTRL-W W
    dela fönster och hoppa till länk under markören;CTRL-W ]
    split window and jump to definition under cursor;CTRL-W d
    split window and jump to declaration of identifier under cursor;CTRL-W i
    dela fönster och redigera filnamn under markören;CTRL-W f
    dela fönster och redigera filnamn under markören + gå till rad n;CTRL-W F
    *****REDIGERA FILNAMN UNDER MARKÖREN I NY TABPAGE :);CTRL-W g f
    ******redigera filnamn under markören i ny tabpage + gå till rad n efter filnamnet :D;CTRL-W g F
    öppna nytt fönster n rader högt;CTRL-W n
    (stänga alla splitfönster och vim;:qall :qa)
    (öppna splitfönster för alla öppna filer när inne i vim;:all)
    Öppna diff från inne i vim: :edit main.c  :vertical diffsplit main.c~
    ******If you have a patch or diff file, you can use the third way to start diff mode. First edit the file to which the patch applies. Then tell Vim the name of the patch file:;:edit main.c  :vertical diffpatch main.c.diff   WARNING: The patch file must contain only one patch, for the file you are editing. Otherwise you will get a lot of error messages, and some files might be patched unexpectedly.  The patching will only be done to the copy of the file in Vim. The file on your harddisk will remain unmodified (until you decide to write the file).
    alternativa variant(er??) att starta diff på patch från inne i vim; :vert diffsplit fil  :diffthis  :vert diffpatch fil   =se mer s60 och :help :D.
    Gå till tredje ändring framåt i vimdiff;3]c
    Spara(??) när i diffläge;:diffupdate :)
    Tips om kommandon som öppnar och redigerar en annan fil, och splits;"Many commands that edit another file have a variant that splits the window. t ex :stag
    When splitting a window you can prepend a modifier command to tell where the window is to appear;t.ex. :leftabove {cmd}
    skapa flik (tab) på SAMMA fil som kommandot körs ifrån :DDD;:tab split
    You can put ":tab" before any Ex command that opens a window. The window will be opened in a new tab page. Another example;:tab help gt
    Öppna ny tab med muspekaren;double click with the mouse in the top line
    stäng alla flikar utom nuvarande;tabonly :DDD
    stäng nuvarande tab;:tabclose
    gå till förra tab;:tabprevious
    gå 5 tabs framåt;5gt ; :tabnext 5
    ******utför kommando cmd i alla öppna flikar;:tabdo cmd
    cannot be modified;- 
    is read-only;=
    Lägg till (med q) till inspelat i register c;qC/word<Enter>q   This works both with recording and with yank and delete commands. 
    ******Använd register som insamlingsplats för rader;Yank the first line with: "aY. Now move to the second line, and type: "AY
    ändra ett namn i alla filer i en argslista = med q-recording  *****;vim *.cpp qq :%s/\<getResp\>/getAnswer/g :wnext q @q 999@q
    mata in samma text i slutet av flera rader :D;markera raderna med ctrl+v, tryck A, mata in text, tryck Esc
    sudda block +fras till slutet på alla rader;The "C" command deletes text from the left edge of the block to the end of line. It then puts you in Insert mode so that you can type in a string, which is added to the end of each line.
    byt case för 5 tecken;5~
    två sorternas plugins;global and filetype plugin (~/.vim/plugin/)
    Start using preinstalled filetype plugins;:filetype plugin on
    Två mapparna i v-runtime för plugins;$VIMRUNTIME/macros are global ones, the filetype plugins are in $VIMRUNTIME/ftplugin.
    helptags;:helptags ~/.vim/doc(=sökväg till dokumentationen)
    substitute;:[range]substitute/from/to/[flags]
    substitute på alla rader som matchar 'mönster';g/mönster1/s//mönster2/
    substituteväxel: print = gör sub-byten och visa alla ställen där saker byts ut;:s/this/that/p
    hitta och visa alla rader i fil som innehåller mönster;:g/mönster/p
    Hitta och visa alla rader i fil som inte innehåller mönster + visa radnummer;:g!/mönster/nu
    hitta och visa alla rader mellan 60 och 124 som innehåller 'mönster';:60,124g/mönster/p
    substituteväxel last;l (litet L)
    substituteväxel: no substitute;n
    gör utbyte bara inom range rad 1-5;:1,5s/this/that/g
    *****Offset: Search for pattern and use line above it;/Chapter/-1
    Searchoffset: Address second line below match;/Chapter/+2
    Ta bort helt tomma rader;:%s/\s\+$//g
    hela matchade mönstret (i sökning och substitute) (\1 är matchade parenteser nr 1);\0
    *****Ändra tecken till stor/liten bokstav I SÖK OCH SUBSTITUTE;:s/\(That\) or \(this\)/\u\2 or \l\1/ [näst sista= litet L!]
    ändra alla tecken fram till \e / \E till versal;\U
    ändra alla tecken fram till \e / \E till gemen;\L
    Gör om senaste Substitute;&
    Gör om senaste Substitute - I hela filen;g&
    "Spela upp" hela det matchade i substitutefält 1;:%s/Kalle/& Stropp/
    Senaste ersättningen (=från förra Substitutefält 2);:s/honoms/hans/ :s/hanses/~/
    Räkna ord i hela filen;Kör substitute med /n sist
    kör på alla rader där mönster INTE förekommer;:g!, :v
    Kör två kommandon på raken;Sudda rad 1 till 3, byt sedan ut deres mot deras (på rad 1);:1,3d | s/deres/deras/
    Vänd bak och fram (=upp och ner) på fil;:g/^/m0
    Spara ut nuvarande rad till filen 'nyfil.txt';:.w /tmp/nyfil.txt
    Lägg till hela nuvarande fils innehåll till sist i filen 'loggfil';:w >> logfile
    skriv ut vad filen heter;:f(ile)
    Annat sätt att skriva :w filnamn.kopia;:w %.kopia :)
    Läs in innehållet i filen patch.txt till sist i nuvarande filen;:$r patch.txt
    Läs in resultatet från kommandot 'date -u' till överst i filen;:0r !date -u  :)
    Placera in fil a efter raden med 'mönster';:/mönster/r mapp/a
    Läs in innehållet från alternativa filen i nuvarande filen;:r #
    FILTRERA TEXT MED BASHKOMMANDON: REGLER; 1.Textblock måste vara mer än en rad.  2. Hela raderna påverkas
    FILTRERA TEXTBLOCK GENOM KOMMANDO;![blockadress][kommando]  !{motion/rows}{program}  t ex: !)kommando  textblocksoperatorer mm:  gg, G, {, }, (, ), [[,  ]], 
    SKICKA FRÅN NUVARANDE RAD TILL RAD 20 FÖR FILTRERING AV KOMMANDO;:.,.+20!kommando
    filtrera t o m rad 5 med sort (=filtrera från nuvarande rad till rad 5 med sort och sätt in på orginalplats);!5Gsort<Enter>
    FILTRERA HELA FILEN;:!%sort
    FILTRERA HELA FILEN (NUMERISK SORT);:!%sort -n
    FILTRERA TEXTEN I FILEN MED CAT OCH SÄTT IN RADNUMMER;:%!cat -n %
    SORTERA BAKLÄNGES;:sort!
    FILTRERA FRÅN NUVARANDE RAD TILL RAD INNAN TOM RAD, GENOM SORT;:.,/^$/-1!sort
    FILTRERA FRÅN NUVARANDE RAD TILL RAD 20 MED SORT OCH SÄTT IN PÅ ORGINALPLATS;20!!sort,, !20!sort,, :.,.+20!sort
    FILTRERA NÄSTA 10 RADER MED SORT OCH SÄTT IN PÅ ORGINALPLATS;!10+sort,, 10!+sort
    filtrera nuvarande rad genom filter;!!kommando :),, (=samma som :.!kommando :)
    byt ut nuvarande rad mot resultatet för kommandot date;!!date
    räkna antalet ord i nuvarande fil m hj av wc;:w !wc   gg, !Gwc,, =INTE! (räknar men ersätter hela filen med resultatet.
    skicka all text från nuvarande filen till specat kommando;:w !kommando
    Repetera föregående filtreringskommando;! objekt !   ??????? :]
    rad96-99 genom ytterkommandot sort;:96,99!sort
    skicka nästa mening genom kommando x;!)kommando
    kör nuvarande rad genom kommando x;!!kommando
    kör nuvarande rad+4 genom kommando x;5!!kommando
    kör nuvarande rad+3 genom sort;4!!sort   !4!sort
    kör kommando på nästa 10 rader;!10+kommando   10+!kommando
    skicka nuvarande rad+4 rader framåt till kommando t ex för redigering;5: (=ger :.,.+4)
    förbered nästa mening för redigering;!)
    ändra allt i fil från gemener till versaler; tr '[a-z]' 
    sätt textbredd till 72 tecken + formatera om nuvarande stycke efter formatering (t ex 72 teckens radbredd);:se textwidth=72  +  gq ap
    Formatera om hela filen så den rättar sig efter formatering;gggqG
    formatera nuvarande rad och gå till nästa;gqj
    Bryt rad med hård radbrytning när är 4 tecken från terminalkanten);:set wrapmargin=4 (=
    öppna fil help.txt som redigerades när syst. kraschade;vim -r help.txt    vim -r ""
    Sortera en lista (som slutar vid en blank rad :DDD (s88);To sort this list, filter the text through the external sort command: /^OBJS   j   :.,/^$/-1!sort
    Alternativ kasta om filen via märken;:'t+1,.g/^/m 't
    Sätt så mansidefil kan visas samtidigt som man redigerar text;:runtime! ftplugin/man.vim  +lägg ev i .vimrc        Put this command in your vimrc file if you intend to do this often. Now you can use the ":Man" command to open a window on a man page:  :Man csh    You can scroll around and the text is highlighted. This allows you to find   the help you were looking for. Use CTRL-W w to jump to the window with the text you were working on.
    To find a man page in a specific section;, put the section number first. For example, to look in section 3 for "echo": > :Man 3 echo
    To jump to another man page, which is in the text with the typical form "word(1)";, press CTRL-] on it. Further ":Man" commands will use the same window.
    To display a man page for the word under the cursor, use this: ; \K
    VIMGREP (Hitta ord inne i filer i buffertlistan i vim :DDD;:grep error_string *.c    This causes Vim to search for the string "error_string" in all the specified files (*.c). The editor will now open the first file where a match is found and position the cursor on the first matching line.
    To go to the next/previous matching line (no matter in what file it is), use the ":cnext" command.;:cnext
    Use ":clist" to see all the matches and where they are.;:clist
    Find all occurrences of "vindruvor" in all files;:vimgrep /vindruvor/ inköpslista   :vimgrep /vindruvor/ *.txt  (=sök i flera filer och mappar??)
    Visa nästa/förra match för vimgrep;:cn  /  :cN
    Gå till post nr 5 i lista över responses från senaste vimgrepsökning;:cc 5
    Sätt så att t.ex. Ack används istället för grep av vim :);":Setting the option 'grepprg'
    Vimgrep: list (+/-n för börja vid <offset>);:cl
    REDIGERA KOMMANDORADEN
    Gå ur kommandoraden;Esc/Ctrl+c
    Gå ett ord åt vänster/höger;Ctrl+vänster/höger :]
    Komm.radskommando: gå till början av raden;Ctrl+b
    Mata in specialtecken (som t.ex Delete) när i kommandoraden;Ctrl+k
    Komm.radskommando: gå till slutet av :-kommandorad;Ctrl+e
    Komm.radskommando: sudda ord;Ctrl+w
    Komm.radskommando: sudda till slutet på :-kommandorad :);Ctrl+u :)
    i :-kommandorad: slutför ord så långt det går + gå igenom alternativ ett efter ett;Tab (ev x2)
    Förra kommandoraden;ctrl+p
    *****i :-kommandorad: lista alla alternativ för påbörjat ord (samma som 2T i skal när flera alternativ finns);Ctrl+d
    samma som tab på kommandoraden (???);Ctrl+L
    Ta reda på nuvarande värden på options m hj av tab;:set iskeyword + = och sen Tab ++ What happens here is that Vim inserts the old value of the option. Now you can edit it.
    Visa history för :-kommandon;:history
    Visa history för /-sök;:history /
    ÖPPNA KOMMANDOHISTORIK-FÖNSTRET****;q:   Typing the text in the command line works different from typing text in Insert mode. It doesn't allow many commands to change the text. For most commands that's OK, but sometimes you have to type a complicated command. That's where the command line window is useful.
    Gå ur vim temporärt till skalet + kör kommandon + sen tillbaks;ctrl+z   {andra kommandon i skalet mm}   fg
    Starta nytt skal från inne i vim;:shell   :!xterm&
    execute {program} and send text to its input;:w !{program}
    filter text through {program};:[range]!{program}
    visa numrerad lista på senaste redigerade filerna;:oldfiles
    redigera 2 från :oldfiles-listan;:e #<2
    #<2 olikn kan användas med alla kommandon som tar ett filnamn som argument, T.EX. KÖR SPLIT MED FIL 2 I OLD FILES;:split #<2
    UTBYTA REGISTER-INNEHÅLL MM MELLAN TVÅ INSTANSER AV VIM;Use the ":wviminfo" and ":rviminfo" commands. In the first Vim do:  :wviminfo! ~/tmp/viminfo     And in the second Vim do:  :rviminfo! ~/tmp/viminfo (SE MER EV s101 :) )
    SKAPA SESSION (=alla fönster som var öppna när session skapades, filer i buffertlistan mm) :D;:mksession session.vim
    öppna en sparad session;:so(urce) session.vim    vim -S session.vim
    Options för sessions: keep empty windows;blank
    Options för sessions: all buffers, not only the ones in a window;buffers
    Options för sessions: the current directory;curdir
    Options för sessions: folds, also manually created ones;folds
    Options för sessions: the help window;help
    Options för sessions: all options and mappings;options
    Options för sessions: window sizes;winsize
    Change this to your liking. To also restore the size of the Vim window;use:  :set sessionoptions+=resize
    Sessions store many things, but not ...;the position of marks, contents of registers and the command line history. You need to use the viminfo feature for these things.  In most situations you will want to use sessions separately from viminfo.  This can be used to switch to another session, but keep the command line history. And yank text into registers in one session, and paste it back in another session.
    You might prefer to keep the info with the session; You will have to do this yourself then. Example:  :mksession! ~/.vim/secret.vim   :wviminfo! ~/.vim/secret.viminfo     And to restore this again:  :source ~/.vim/secret.vim    :rviminfo! ~/.vim/secret.viminfo    :wall     :mksession! ~/.vim/secret.vim     :source ~/.vim/boring.vim
    For example, this is a nice layout to use (s102);This has a help window at the top, so that you can read this text. The narrow vertical window on the left contains a file explorer. This is a Vim plugin that lists the contents of a directory. You can select files to edit there. More about this in the next chapter. Create this from a just started Vim with:  :help   CTRL-W w   :vertical split ~/     You can resize the windows a bit to your liking. Then save the session with:     :mksession ~/.vim/mine.vim.      Now you can start Vim with this layout: >     vim -S ~/.vim/mine.vim
    VIEWS :] (s103)  grund,,  view med namn  (s149)    :mkview    This will store the settings and other things that influence the view on the file. You can change what is stored with the 'viewoptions' option.
    When you come back to the same file later, you can load the view again;:loadview
    ***You can store up to ten views on one file. For example, to save the current setup as the third view and load the second view;:mkview 3  :loadview 2
    *****MODELINES (=sätta options för en speciell fil) :DD (s104) SE MER;(som första el sista 5 rader i en fil) /* vim:set shiftwidth=4: */
    skifta mellan unix och windows (s103);se mer ev
    NETRW/VIM-EXPLORER: Öppna filbläddraren (i nuvarande mappen);:e . // :Exp
    NETRW/VIM-EXPLORER: Dela fönster och öppna explorer i splitfönstret;:Sex
    NETRW/VIM-EXPLORER: Dela fönster och öppna explorer i Vertical split;:Vex
    NETRW/VIM-EXPLORER: Dela fönster och öppna explorer i Tab;:Tex
    NETRW/VIM-EXPLORER: ppna vim explorer
    NETRW/VIM-EXPLORER: Hjälp för VimExplorer;<F1>
    NETRW/VIM-EXPLORER: Öppna mapp/fil inne i Vimexplorer;<CR>
    NETRW/VIM-EXPLORER: Gå uppåt(bakåt) i trädet;-
    NETRW/VIM-EXPLORER: Visa/gömma filer/mappar [norm. hiding o show];a
    NETRW/VIM-EXPLORER: sätt bokmärke (b) i mapp;mb
    NETRW/VIM-EXPLORER: gå till mapp med bokmärke;gb
    NETRW/VIM-EXPLORER: gör mappen du är i till aktiv mapp i vim;c
    NETRW/VIM-EXPLORER: skapa ny mapp (delete);d
    NETRW/VIM-EXPLORER: sudda filer eller mappar;D, <Del>
    NETRW/VIM-EXPLORER: flippa mellan tunn, lång, bred el trädlistning;i
    NETRW/VIM-EXPLORER: refresh listing;C-l (=L)
    NETRW/VIM-EXPLORER: browse with horizontal split;o (??)
    NETRW/VIM-EXPLORER: visa/göm gömda filer (.fil)****;gh
    NETRW/VIM-EXPLORER: copy marked files to marked-file target directory;mc
    NETRW/VIM-EXPLORER: kör diff på markerade filer (max 3);md
    NETRW/VIM-EXPLORER: placera markerade filer i args-listan och redigera;me  :)
    NETRW/VIM-EXPLORER: move marked files to marked-file target directory;mm
    NETRW/VIM-EXPLORER: skriv ut markerade filer;mp
    NETRW/VIM-EXPLORER: mark files satisfying a shell-style regex (glob);mr
    NETRW/VIM-EXPLORER: current browsing-dir becomes markfile target;mt  :)
    NETRW/VIM-EXPLORER: avmarkera alla markerade filer;mu
    NETRW/VIM-EXPLORER: apply arbitrary shell command to marked files;mx
    NETRW/VIM-EXPLORER: obtain file specified under cursor;O
    NETRW/VIM-EXPLORER: lista mappar markerade med bokmärken;qb
    NETRW/VIM-EXPLORER: visa info om fil;qf
    NETRW/VIM-EXPLORER: omvänd sorteringsordning;r
    NETRW/VIM-EXPLORER: rename files;R
    NETRW/VIM-EXPLORER: välj sorteringssätt: namn, fil el filstorlek;s
    NETRW/VIM-EXPLORER: öppna fil/mapp under markören i ny flik;t
    NETRW/VIM-EXPLORER: change to recently visited directory (back);u
    NETRW/VIM-EXPLORER: change to subsequently visited directory (forw);U
    NETRW/VIM-EXPLORER: enter the file/directory under the cursor in a new browser window - vsplit is used;v
    NETRW/VIM-EXPLORER: view file with associated program;x
    NETRW/VIM-EXPLORER: open a new file in netrw's current directory;%
    NETRW/VIM-EXPLORER: setting the editing-window;C
    NETRW/VIM-EXPLORER: speca hide-lista :);C-h
    NETRW/VIM-EXPLORER: preview ??;p
    NETRW/VIM-EXPLORER: edit in preview-window ??;P
    NETRW/VIM-EXPLORER: kör ctags på markerade filer  :) <http://www.google.com/search?client=ubuntu&channel=fs&q=ctags&ie=utf-8&oe=utf-8>;mT
    NETRW/VIM-EXPLORER: compress/decompress marked files;mz
    NETRW/VIM-EXPLORER: speca suffixprioritet för namnsortering;S
    FOLDS,, sätta foldmetod till indent eller syntax;:se foldmethod=indent(/syntax)
    gå till föregående/nästa undanvikning;zk/zj
    fold – grund: skapa fold i vim;zf
    fold – grund: öppna/stäng alla folds direkt :);zi
    om foldmethod satt till indent: vik undan indenterat block;zM
    Om folds och insertmode;When in insertmode, the fold at the cursorline is never closed. That allows you to see what you type!Om folds och windows;The folding is local to the window. This allows you to open two windows on the same buffer, one with folds and one without folds. Or one with all folds closed and one with all folds open.
    dra in block en shiftwidth;>
    ta bort en shiftwidth för block;<
    indents;:se autoindent,, :se smartindent,, :se expandtab,, :se tabstop=4
    Olika indentkommandon: 01;:retab
    Olika indentkommandon: 02;:.retab
    Olika indentkommandon: 03;:retab 8 (??)
    Olika indentkommandon: 04;:se shiftwidth=4
    Olika indentkommandon: 05;:se softtabstop=4 (=backspace kommer att hantera 4 spaces som en tab :)
    DRA IN FYRA RADER EN INDENT*****;4>>
    mata in/ta bort tab [insertmode];ctrl+t/ctrl+d
    Fler indendkommandon;:se expandtab  :se tabstop=4  :retab  :.retab  lägg om tabstop till   :set tabstop=3  :retab 8   (s129)  :se shiftwidth=4  :se softtabstop=4
    KRYPTERING;manualen s114
    REDIGERA BINÄRFILER;manualen s115
    Redigera komprimerade filer;manualen s116
    ny modeline;# vim: syntax=make
    öppna flera filer för redigering med vim;vim fil1 fil2 fil3
    ???;:ar(gs)  Ctrl+^ {x}%  "13yy
    PLUGINS MM:
    (=för att redigera xml);xmledit <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+plugin+check+xml&ie=utf-8&oe=utf-8>
    (=kolla och rätta till wellformedness för xml); xmlwf <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+plugin+check+xml+well+formed&ie=utf-8&oe=utf-8>
    vim outliner;kolla mer :)  sammanfattning av vanliga kommandon finns under :h vo_cheatsheet.txt
    (makron för html- och xml-matchning mm);surround.vim <http://www.vim.org/scripts/script.php?script_id=1697>
    matchit; <www.vim.org/scripts/script.php?script_id=39>
    lägga till mappar i path så vim hittar dem :D (vid gf-sök mm) **;??
    visa path;:echo &path
    When you know the file name, but it's not to be found in the file, you can type it: >;:find inits.h
    vim, find och path;Vim will then use the 'path' option to try and locate the file. This is the same as the ":edit" command, except for the use of 'path'.
    A nice way to directly start Vim to edit a file somewhere in the 'path';vim "+find stdio.h"    This finds the file "stdio.h" in your value of 'path'. necessary to have one argument |-+c|.
    zzzz
        Buffer-list: 
        AHA! :DD
        active
        hidden
        inactive
        hidden buffers
        inactive buffers
        listing buffers
        :buffers
        :ls
        :files
    redigera buffer 2;:buffer 2
    redigera buffer som innehåller ordet 'help';:buffer help
    öppna buffer 3 i nytt (split?)fönster;:sbuffer 3
    ta bort buffer 3 från buffer-listan;:bdelete 3
    gå till nästa/förra buffer//första/sista;:bnext  :bprevious :bfirst :blast
    Vad händer med buffer när man kört bdelete på den;Even after removing the buffer with ":bdelete" Vim still remembers it. It's actually made "unlisted", it no longer appears in the list from ":buffers". The ":buffers!" command will list unlisted buffers (yes,
    Ta bort en buffer helt från b-listan***;Vim can do the impossible). To really make Vim forget about a buffer, use ":bwipe". Also see the 'buflisted' option.
    tecken för bufferlist :DD ***
        u
        Buffer is unlisted |unlisted-buffer|.
        %
        Current buffer.
        #
        Alternate buffer.
        a
        Buffer is loaded and displayed.
        h
        Buffer is loaded but hidden.
        =
        Buffer is read-only.
        -
        Buffer is not modifiable, the 'modifiable' option is off.
        +
        Buffer has been modified.
        |usr_23.txt| Editing other files
        o
        :set fileformat?
        The three names that Vim uses are:
        unix
        dos
        mac
        <LF>
        <CR><LF>
        <CR>
        +s112
        o
        Vim assumes that on Unix you probably won't edit a Mac file, and doesn't check
        for this type of file. To check for this format anyway, add "mac" to
        fileformats': >
        :set fileformats+=mac
        +se mer s113
        öppna filer på internet :D
        Someone sends you an e-mail message, which refers to a file by its URL.
        example:
        For
        You can find the information here: ~
        ftp://ftp.vim.org/pub/vim/README ~ <ftp://ftp.vim.org/pub/vim/README>
        You could start a program to download the file, save it on your local disk and
        then start Vim to edit it.
        There is a much simpler way. Move the cursor to any character of the URL.
        Then use this command: >
        gf
        With a bit of luck, Vim will figure out which program to use for downloading
        the file, download it and edit the copy. To open the file in a new window use
        CTRL-W f.
        o
        Accessing files over the internet works with the netrw plugin. Currently URLs with these formats are recognized:
        ftp://
        uses ftp
        rcp://
        uses rcp
        scp://
        uses scp
        http://
        uses wget (reading only)
        encryption
        s114
        binary files
        s115
        |usr_24.txt| Inserting quickly
        COMPLETION
        sök före/efter
        ctrl+p
        SÖK TIDIGARE/SENARE ORD :)
        *slutför ord redan i fil
        *slutför var eller funkt.namn i skript du jobbar med
        Ctrl+p
        Ctrl+n
        sökställen =var letar ctrl+n/p
        1.current file
        2.files in other windows
        3.other loaded files (hidden buffers)
        4.files which are not loaded (inactive buffers)
        5.tagfiles
        6.all files #included by the current file
        ctrl+n
        o
        The Vim editor goes through a lot of effort to find words to complete. By default, it searches the following places:
        1
        Current file
        2
        Files in other windows
        3
        Other loaded files (hidden buffers)
        4
        Files which are not loaded (inactive buffers)
        5
        Tag files
        6
        All files #included by the current file
        OPTIONS
        You can customize the search order with the 'complete' option.
        även 'ignorecase' och 'infercase'
        COMPLETING SPECIFIC ITEMS
        If you know what you are looking for, you can use these commands to complete with a certain type of item:
    zzzz
    COMPLETION I INSERTMODE: FILNAMN;CTRL-X CTRL-F       It scans the current directory for files and displays each one that matches the word. Insert mode and start typing: "exit code is in file sub ~" +CTRL-X CTRL-F   Vim now completes the current word "sub" by looking at the files in the current dir ectory. The first match not the one you want, so you match the next file by typing CTRL-N. This match is sub_done.c. Typing CTRL-N again takes you to sub_exit.c.    If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all files in the file system. For example, type "/u" and CTRL-X CTRL-F. This will match "/usr" (this is on Unix):   If you now press CTRL-N you go back to "/u". Instead, to accept the "/usr/"   and go one directory level deeper, use CTRL-X CTRL-F again:   the file is found in /usr/X11R6/ ~   The results depend on what is found in your file system, of course.    matches are sorted alphabetically.
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|): Whole lines;CTRL-X CTRL-L
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|): Macro definitions (also in included files);CTRL-X CTRL-D
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|): Current and included files;CTRL-X CTRL-I
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|): Words from a dictionary;CTRL-X CTRL-K
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|): Words from a thesaurus;CTRL-X CTRL-T
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|): Tags;CTRL-X CTRL-]
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|): Vim command line;CTRL-X CTRL-V
    @ COMPLETION I INSERTMODE (s119) (ctrl+n/p + |ins-completion|  +|ft-c-omni): Completing in source code :DDD;ctrl+x ctrl+o  =s120
    @ PLACERA IN DET SOM SKREVS IN SENAST I I-MODE;Ctrl+a
    @ PLACERA IN DET SOM SKREVS IN SENAST I I-MODE + gå ur insertmode****;Ctrl+@
    @ MATA IN TECKNET OVANFÖR/NEDANFÖR (PÅ RADEN OVANFÖR/NEDANFÖR) MARKÖREN :D;ctrl+y // ctrl+e
    @ MATA IN INNEHÅLLET FRÅN REGISTER X;CTRL+R {x}
    @ MATA IN DIREKT (=TOLKA INTE T EX BACKSPACE UTAN MATA IN SOM <BS>);CTRL+R CTRL+R
    @ TA BORT INDENTERING INNE I INSERTMODE;ctrl+d
    @ INDENTERA INNE I INSERTMODE;ctrl+t
    backspace
    ctrl+h :)
    samma som tab
    ctrl+i
    enter
    ctrl+m; ctrl+j
    pausa ins-mode
    ctrl+o
    @ MATA IN ENTER M FL TECKEN 'VERBATIM';ctrl+v
    zzzz2
    FÖRKORTNINGAR
    s122
    :abbreviate
    :iabbrev
    :cabbrev
    :unabbreviate
    :abclear (iabclear, cabclear)
    :noreabbrev
    (t ex)
    :iabbrev ad advertisement
    Now, when you type "ad", the whole word "advertisement" will be inserted into the text. This is triggered by typing a character that can't be part of a word, for example a space:
    I saw the ad<Space>
    o
    As a programmer, I use two rather unusual abbreviations: >
    :iabbrev #b /****************************************
    :iabbrev #e <Space>****************************************/
    The ":abbreviate" command lists the abbreviations:
    +++S 123
    entering special characters
    s124
    digraphs :))) [t ex Copyright-tecknet]
    s124
    pausa insertmode för ett kommando
    |usr_25.txt| Editing formatted text
    breaking lines
    :set textwidth=30
    reformatting
    s127
    gq
    *25.2* Aligning text
    To center a range of lines, use the following command: >
    :{range}center [width]
    s127
    Similarly, the ":right" command right-justifies the text: >
    :1,5right 37
    gives this result:
    left alignment
    Finally there is this command: >
    :{range}left [margin]
    Unlike ":center" and ":right", however, the argument to ":left" is not the length of the line. Instead it is the left margin. If it is omitted, the text will be put against the left side of the screen (using a zero margin would do the same). If it is 5, the text will be indented 5 spaces. For example, use these commands: >
    :1left 5
    :2,5left
    This results in the following:
    I taught for a while. One ~ time, I was stopped by the ~ Fort Worth police, because my ~ homework was too hard. True ~ story. ~
    justifying text
    Vim has no built-in way of justifying text. However, there is a neat macro package that does the job. To use this package, execute the following command: >
    :runtime macros/justify.vim
    An alternative is to filter the text through an external program.
    :%!fmt
    scroll :) (s130)
    If you don't have a scrollbar or don't want to use it, use these commands to scroll the text. The cursor will stay in the same place, but it's moved back into the visible text if necessary.
    zh
    right
    4zh
    four characters right
    zH
    half a window width right
    ze
    right to put the cursor at the end
    zl
    left
    4zl
    four characters left
    zL
    half a window width left
    zs
    left to put the cursor at the start
    :D
    g0
    to first visible character in this line
    g^
    to first non-blank visible character in this line
    gm
    to middle of this line
    g$
    to last visible character in this line
    :set linebreak
    (s131 - se till att ord inte bryts mitt i) :]
    :)
    gk
    gj
    :map <Up> gk
    :map <Down> gj
    turning the paragraph into one line :)
    :g/./,/^$/join
    That looks complicated.
    Let's break it up in pieces:
    :g/./
    A ":global" command that finds all lines that contain at least one character.
    ,/^$/
    A range, starting from the current line (the non-empty line) until an empty line.
    join
    The ":join" command joins the range of lines together into one line.
    EDITING TABLES s132 :) SE MER
    |usr_26.txt| Repeating
    addera/subtrahera nummer
    ctrl+a/ctrl+x
    Making a change in many files - s136
    :DDD
    :args *.c
    lägg alla filer som slutar på .c i mappen i argslistan
    This finds all C files and edits the first one. Now you can perform a substitution command on all these files: >
    :argdo %s/\<x_cnt\>/x_counter/ge | update
    The ":argdo" command takes an argument that is another command. That command will be executed on all files in the argument list
    kör kommando(n) på alla fönster
    :windo
    kör kommandon på alla buffrar
    :bufdo (obs! kolla först buf-listan med ls)
    Using Vim from a shell script s136 :DDD
    SE MER SE MER
    använda vim från ett shellscript
    %s/--person--/Jones/g write tempfile quit
    for file in * .txt; do vim -e -s $file < change.vim lpr -r tempfile done
    if you use the standard input to read text from, you can use the -S argument to read a script
    producer | vim -S change.vim -
    redigera std.out från kommandot ls direkt med vim
    ls | vim -
    s137: vim -s file.txt ...
    Error setting the text for the following input: = -s has a different meaning when it is used without -e. here itt means to source the "script" as Normalmodecommands. when used with -e it means to be silent, and doesnt use the next argument as a filename.
    another way is to record the commands while you perform them manually. this is how you do that:
    vim -w script file.txt ...
    Error setting the text for the following input: =all typed keys will be written to "script". if you make a small mistake you can just continue and remember to edit the script later..
    the -w argument appends to an existing script. that is good when you want to record the script bit by bit.
    if you want to start from scratch and start all over, use the -W argument. it overwrites any existing file
    NORMAL MODE SCRIPTS
    If you really want to use Normal mode commands in a script, you can use it like this: >
    vim -s script file.txt ...
    Note:
    "-s" has a different meaning when it is used without "-e". Here it means to source the "script" as Normal mode commands. When used with "-e" it means to be silent, and doesn't use the next argument as a file name.
    +++SE MER :DDD
    Spela in script i farten/on the fly :DD s137
    To create the script you can edit the script file and type the commands. You need to imagine what the result would be, which can be a bit difficult.
    Another way is to record the commands while you perform them manually. This is how you do that: >
    vim -w script file.txt ...
    All typed keys will be written to "script". If you make a small mistake you can just continue and remember to edit the script later.
    The "-w" argument appends to an existing script. That is good when you want to record the script bit by bit. If you want to start from scratch and start all over, use the "-W" argument. It overwrites any existing file.
    |usr_27.txt| Search commands and patterns (s139-
    ignore case
    case in one pattern
    offsets
    t ex 
    @ SEARCH FOR PATTERN "DEFAULT" +MOVE TO BEGINNING OF SECOND LINE PAST PATTERN***;/default/2
    character offsets :) (s141)
    e=end; b=beginning
    @ PATTERNSEARCH + CHARACTEROFFSET: Slutet på ordet 'const';/const/e
    @ PATTERNSEARCH + CHARACTEROFFSET: Blanksteg efter ordet 'const';const/e+1
    @ PATTERNSEARCH + CHARACTEROFFSET: Näst sista bokstaves i ordet 'const';const/e-1
    @ PATTERNSEARCH + CHARACTEROFFSET: Tredje bokstaven i ordet 'const';const/b+2
    @ PATTERNSEARCH + CHARACTEROFFSET: Sök efter samma mönster igen + END (som inte söktes förra gången);//e
    /that/e
    To repeat with the same offset: >
    /
    "n" does the same thing.
    To repeat while removing a previously used offset: >
    //
    Också förstås för ?-sökningar (gällande båda röda ovan) :)
    ?const?e-2
    matching multiple (* mm) :D
    ange exakt hur många multiple
    matcha så lite som möjligt
    alternativ
    \|
    \& (s143) :D
    character ranges
    [a-bfx-y]
    o
    +SE MER s144
    \e
    <Esc>
    \t
    <Tab>
    \r
    <CR>
    \b
    <BS>
    [tak "] :)
    fördefinierade
    @@@@
    \d
    digit
    [0-9]
    \D
    non-digit
    [^0-9]
    \x
    hex digit
    [0-9a-fA-F]
    \X
    non-hex digit
    [^0-9a-fA-F]
    \s
    white space
    [          ]  (tabs och blanks)
    \S
    non-white characters
    [^        ]  (not tabs och blanks)
    \l
    lowercase alpha
    [a-z]
    \L
    non-lowercase alpha
    [^a-z]
    \u
    uppercase alpha
    [A-Z]
    \U
    non-uppercase alpha
    [^A-Z]
    character classes
    \i
    identifier characters
    isident'
    \I
    like \i, excluding digits
    \k
    keyword characters
    iskeyword'
    \K
    like \k, excluding digits
    \p
    printable characters
    isprint'
    \P
    like \p, excluding digits
    \f
    file name characters
    isfname'
    \F
    like \f, excluding digits
    matching a line break :)
    t ex
    whitespace eller linebreak :)
    \_s
    any character or a linebreak
    \_.
    o
    + \n och \r :DD
    EXEMPEL REGEX s146
    |usr_28.txt| Folding
    SE MER s147
    o
    @@@@
    @_fold_001;zfap
    @_fold_002;zo
    @_fold_003;zc
    @_fold_004;zr
    @_fold_005;zm
    @_fold_006;zR
    @_fold_007;zM
    @_fold_009;zn
    @_fold_010;zN
    @_fold_020;zi
    @_fold_030;:set foldcolumn=4
    @_fold_040;zO
    @_fold_050;zC
    @_fold_060;zd
    @_fold_070;zD
    (+fler options)
    o
    o
    folding by indent **** (s149)
    folding with markers
    folding by syntax (s151)
    folding by expression
    folding unchanged lines (vimdiff)
    |usr_29.txt| Moving through programs <#ID_922606698>
    ctags och skapa tags :DDD - SE MER s154
    To split the current window and jump to the tag under the cursor use this command:  :)
    CTRL-W ]
    the preview window :)) - SE MER s157
    t ex
    If the name of a function appears in the text, you can get its definition in the preview window with: >
    CTRL-W }
    Show tag under cursor in preview window
    Stäng preview-fönstret
    Ctrl+w z
    fr s26 :) ;; moving through programs :) (manual s158) <#ID_1575994988>
    [ Ctrl+d
    [ Ctrl+i
    hoppa till första raden i nuvurande och inkluderade filer som innehåller ordet under markören; starta sökning i början av nuvarande filen
    [#
    hoppa till början av #if --- #endif
    ]#
    [{
    hoppa till { på samma nivå :] = TESTA
    ]}
    hoppa till } på samma nivå :] = TESTA
    [[
    hoppa till yttersta {
    flytta till början av nuvarande sektion
    ][
    hoppa till yttersta }
    i C/Java = yttre { } är klassen och nästa nivå av { } är metoden :D
    [m
    hoppa till def av metod (= { inne i klass)
    ]m
    []
    gå till slutet av förra funktionen :)
    ]]
    gå till början av nästa funktion :)
    [(
    hoppa till ( på samma nivå :] = TESTA
    ])
    hoppa till ) på samma nivå :] = TESTA
    {/ ,, [/
    gå till början av kommentar
    ]/
    gå till slutet av kommentar :} (testa)
    [I (=stort i)
    You are editing a C program and wonder if a variable is declared as "int" or "unsigned". A quick way to find this is with the "[I" command.
    zzzz s161
    [+tab
    [i
    ]I (=stort i)
    ]i
    [D
    [d
    ]D
    ]d
    finding local identifiers
    gD
    gd
    locating included files + path :DDD !! s160 =SE MER :)
    |usr_30.txt| Editing programs
    compiling
    +errorcheck :)
    använda extern kompilator :)
    o
    äldre errorlists
    switching compilers
    output redirection
    indentering mm i C :)
    formatera kommentarer - s170 :DD
    definiera hur en kommentar ser ut
    |usr_31.txt| Exploiting the GUI
    s176 - redigera epostmeddelanden i vim :) - se mer ev
    |usr_32.txt| The undo tree
    s177
    +timetravel och earlier :)
    Tuning Vim
    |usr_40.txt| Make new commands
    key mapping - s180
    defining command-line--commands - s183
    autocommands - s186
    events :)
    patterns
    (mm)
    o
    o
    o
    |usr_41.txt| Write a Vim script (s190-224)
    |usr_42.txt| Add new menus
    |usr_43.txt| Using filetypes
    |usr_44.txt| Your own syntax highlighted
    |usr_45.txt| Select your language
    o
    Making Vim Run + Reference manual :)
    |usr_90.txt| Installing Vim
    Reference manual
    |reference_toc|
    Error setting the text for the following input: = More detailed information for all commands :).
    The user manual is available as a single, ready to print HTML and PDF file here:
    vimdoc.sf.net <http://vimdoc.sf.net>
    SENASTE = placera in <#ID_926325771>
    PLACERA IN
    placera in tab (??) :]
    Ctrl+d
    Ctrl+t
    INSERT MODE
    samma som backspace
    Ctrl+h
    samma som tab
    Ctrl+i
    samma som enter
    Ctrl+j, Ctrl+m
    samma som Esc :DD !!!!!!
    Ctrl+AltGr+8
    kör ett kommando i ex-mode
    Ctrl+o
    sudda alla inmatade tecken på nuv. raden :] (TESTA)
    Ctrl+u
    mata in tecken enligt sin 3-siffriga kod
    Ctrl+v +3-siffrigt tal
    Ctrl-w =????
    höj/sänk tal med 1
    INDENTERING
    @ I Insertmode: ta bort all indentering på nuvarande raden;0 Ctrl+d
    @ Ta bort all indentering på nuvarande raden + återställ på nästa rad;^ Ctrl+d
    (@@)  vim completing mm :); <http://www.cs.oberlin.edu/~kuperman/help/vim/completion.html>
    @  getting dictionaries :); <http://vim.runpaint.org/typing/auto-completing-text/#getting-dictionaries>
    @ språkkod för svenska i vim :D ; <http://ubuntu-se.org/phpBB3/viewtopic.php?f=67&t=32844>
    @ dictionaries för andra språk i vim :); <ftp://ftp.vim.org/pub/vim/runtime/spell/>
    human-language-codes vim <https://www.google.com/search?client=ubuntu&channel=fs&q=language+codes+vim&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=zou&tbo=d&channel=fs&sclient=psy-ab&q=human+language+codes+vim&oq=human+language+codes+vim&gs_l=serp.3...35825.36815.0.37089.6.6.0.0.0.1.130.570.4j2.6.0.les%3B..0.0...1c.1.8Gwbg5LXOQE&pbx=1&fp=1&bpcl=39468505&biw=1366&bih=634&bav=on.2,or.r_gc.r_pw.r_cp.r_qf.&cad=b&sei=5_3EUKWeBKTl4QSg0IGYAg>
    Ctrl+x Ctrl+p
    Ctrl+x Ctrl+n
    o
    Ctrl+x Ctrl+u
    @ VIM COMMANDLINE: GISSA VAD DET INNAN MARKÖREN (SOM SKA SLUTFÖRAS) ÄR, OCH MATA IN TRÄFFAR;Ctrl+x Ctrl+v   +tryck ctrl+n/p för förra/nästa träff
    @ SPELLINGCOMPLETION**;  Ctrl+x (Ctrl?+) s  ??     svensk stavning <http://ubuntu-se.org/phpBB3/viewtopic.php?f=67&t=32844>
    (@@@) thesaurus i vim; <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+thesaurus+file&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=fHa&tbo=d&channel=fs&sclient=psy-ab&q=vim+thesaurus&oq=vim+thesaurus&gs_l=serp.3..0l3j0i8i30.18174.18742.0.19024.5.5.0.0.0.0.119.461.4j1.5.0.les%3B..0.0...1c.1.h2VTMF7o51U&pbx=1&fp=1&bpcl=39468505&biw=1366&bih=634&bav=on.2,or.r_gc.r_pw.r_cp.r_qf.&cad=b&sei=L_7EUPCrGcKC4ATYk4GoDg>
    @ set up a lightweight vim thesaurus ; <http://www.nickcoleman.org/blog/index.cgi?post=vim-thesaurus!201202170802!general%2Cblogging%2Cinternet%2Cprogramming%2Csoftware%2Cunix>    synonymer.se :) <http://www.synonymer.se/>
    @ tags;Ctrl+x Ctrl+]   ???
    o
    @ stoppa ovanläge när inne i (?);Ctrl+e
    REGISTERS
    mata in innehållet ur angivet register :D
    Ctrl+r [0-9a-z"%#*:=]
    @ mata in innehållet ur angivet register (bokstavligt);Ctrl+r Ctrl+r
    mata in innehållet ur angivet register (bokstavligt + autoindentera INTE);Ctrl+r Ctrl+o
    mata in innehållet ur angivet register (bokstavligt + fixera indentering);Ctrl+r Ctrl+p
    mata in radbrytn.tecken m fl uttryckligen
    Ctrl+v :D
    tvinga systemet att spara bufferten även om inte strömstopp o likn
    :pre
    3 sätten att specificera radadresser :)
    - med uttryckliga radnummer
    - med symboler som anger relativt till nuvarande position (t ex $, .+1 osv)
    - som sökmönster som adress som anger rader som ska påverkas
    kommandoradshistorik
    visa history för /-sökningar
    o
    öppna kommandoradsfönster med :-kommandohistorik + tom kommandorad längst ner
    q:
    Error setting the text for the following input: =redigera som vanlig text + tryck sen enter :DD.
    öppna kommandoradsfönster med /-sökhistorik + tom kommandorad längst ner
    q/
    öppna kommandoradsfönster med ?-sökhistorik + tom kommandorad längst ner
    q?
    ändra kommando från kommandohistoriken inne i kommandofönstret
    [[titta över regex]]
    ---
    kör skalprogram och läs in resultatet i filen
    :r !skalkommando :D
    slå på liten kolumn till vänster som visar folds
    vyer
    spara fil med folds mm = view
    öppna sparad vy
    se lista på filer du redigerat senaste gångerna inne i vim
    kolla listan på filer redigerat senaste gångerna + gå ut och redigera m hj av siffra ***
    s100 i vim user manual :D
    dela fönster för att också kunna redigera fil 3 från oldfileslistan :)
    skapa en 'session' = spara fönster och filer från ett redigeringstillfälle
    återställ session
    1. från inne i vim
    2. från kommandoraden
    namn på registret text sparades i förra gången suddades med d (delete)
    visa innehållet i delete- och bokstavsbuffrarna
    klistra in namnet på filen i filens text
    ---------------------------------------
    indentera i kommandoläge
    ta bort indentering i kommandoläge
    repetera förra kommandolägeskommandot
    ge full sökväg m hj av %
    x4
    o
    gå tillbaks till hur fil såg ut för 20 min sedan
    gå tillbaks till hur fil såg ut för 1 timme sedan
    SE MER: kör kommando i flera flikar
    skapa fold från markören 5 rader ner
    öka storlek på split m Ctrl-kommando
    sök fram/nästan fram till nästa bokstaven s
    gör 10 rader neråt redo för kommandorads-kommando
    o
    följ hyperlänk i hjälpfil ****
    gå tillbaks efter följt länk i hjälpfil
    gå framåt igen efter gått tillbaks från följt länk
    gå till nästa/föregående undanvikning ***
    gj/gk ????? :]
    o
    blandat
    sudda t o m sista raden = dG :D
    I
    A
    ändra case på tecken = tilde :)
    konvertera en text till html :)
    Convert the current file to HTML with this command: >
    :TOhtml
    In case that doesn't work: >
    :source $VIMRUNTIME/syntax/2html.vim
    :so /usr/share/vim/vim72/syntax/2html.vim
    :TOhtml 
    You will see it crunching away, this can take quite a while for a large file. Some time later another window shows the HTML code. Now write this somewhere (doesn't matter where, you throw it away later): >
    :write main.c.html
    Open this file in your favorite browser and print it from there. If all goes well, the output should look exactly as it does in Vim. See |2html.vim| for details. Don't forget to delete the HTML file when you are done with it.
    öppna fil i readonly-läge
    A.
    vim -R fil
    view fil
    (lägg till ! för att tvinga write :)
    B.
    vim -M fil
    (:se modifiable och :se write för att kunna ändra filen :)
    o
    lägg ihop två rader
    J
    lägg ihop två rader utan att ändra mellanslag :)
    gJ
    o
    o
    höst2013:
    :set guifont={Andale\ Mono\ 11}
    xlsfonts ==visa tillgängliga fonts i gvim
    ???
    :echo &path
    några intressanta plugins:
    sessionman
    SuperTab
    VimOutliner + otl2html + otl2docbook
    vims inbyggda sort
    i
    u
    n
    :sort /mönster/
    skifta mellan de olika visuallägena
    lägga till t ex ':set number' i sin vimrc + kommentar ovanför
    sätta a2ps för att hantera utskrifter - s36 i Bram Beer-boken
    sätta så osynliga tecken (som Linebreak) syns - :se list
    output redirection to a file - s57 i Bram Beer-boken
    Enkel map för att spara sessions - s59 i Bram Beer-boken
    g- för undogrenar
    boilerplatecode och templates - s68 i Bram Beer-boken
    ctrl+k för accenttecken, t ex långt japanskt o
    o
    gf öppnar fil i samma fönster som standard. öppna i ny tab med ctrl+w+gf. remap för att göra till default = :nnoremap gf <C-W>gf
    om namnet på din fil följs av ett radnummer, t ex foo.txt:10 så kan du hoppa till den givna raden med gF  (=???)
    snipMate - s88 i Bram Beer-boken
    Navigating sourcecode - s95 i Bram Beer-boken = TESTA!
    :b f på s99 i Bram Beer-boken
    (=??) :)
    Sätta synliga markörer och bokmärken - s113 i Bram Beer-boken
    Skapa menyer och verktygsknappar - s121 i Bram Beer-boken
    ** och *.txt för att söka 'neråt- efter filer (när jobbar med vimgrep mm)
    = sXX i Bram Beer-boken (??)
    :help pattern för mer om regular expressions
    :set keywordprg=pydoc (typ) ist. för 'man' för att kunna jobba med py och 'K'
    - s57 i Bram Beer-boken
    - s57 i Bram Beer-boken










    ----------------------------------------------------------------------------------------------------

    zzzz
    PRACTICAL VIM******::
    / - sök från kommandoraden
    Error setting the text for the following input: = - utvärdera ett vimskript i kommandoradsläge.
    välja inne i en xml-etikett: it :D*******
    Error setting the text for the following input: =till Inkscapekodredigering förmodl..
    Se till att vim startas utan specialinställningar:
    $ vim -u NONE -N
    +fil med:
    set nocompatible
    filetype plugin on
    +$ vim -u code/essential.vim
    :version (kolla vilka features som är inladdade (huge))
    -----------------------------------------------------------
    SUPERKOMMANDO 1:
    .-kommandot(=mikromakro)::
    >G (punkt ökar indrag igen) :D
    +när går in i insert = alla tryckn. sparas +kan sen spelas upp med .
    A:Esc j. :)
    RECEPT s33 ******************
    ++Tips 4: make motion and change repeatable.
    @:
    & (=kör :substitute igen)
    SUPERKOMMANDO 2:
    * + n +. :DD
    THE DOT-FORMULA:: s11
    en flytt + ett utförande/ändring
    ------ Normalmode
    Skriv en el två meningar t ex (en tanke/ansats typ), kika + u om inte nöjd
    +Esc-o-tricket ist.för Return
    Vimgolf och daw
    Höj “0px” till “-180px.” i bit css-kod = 180<C-a> (oavsett var på raden)************
    C-x och oktalt
    (set nrformats=octal mm (blank: allt tolkas decimalt)
    u går förstås också att använda med count :)
    ----
    Combine and conquer::
    daw
    gUaw ******
    dap
    gUap
    Dubblering av operator gör = på hel rad:
    dd, gUU
    s50
    >
    <
    =
    !
    commentary.vim
    textobj-entire
    gg=G
    s51
    Egna operatorpending uttryck :) ??
    " custom mappings that initiate or target Operator-Pending mode."
    <C-h>
    <C-w>
    <C-u>
    Effect
    Delete back one character (backspace)
    Delete back one word
    Delete back to start of line
    <C-[>
    Switch to Normal mode
    <C-o>
    Switch to Insert Normal mode
    C-r + 0 =klistra in just utklippt :)
    The <C-r><C-p>{register} command is smarter. It inserts text literally and fixes
    any unintended indentation (see :h i_CTRL-R_CTRL-P
    The Expressionregister:
    A
    6 chairs, each costing $35, totals $
    <C-r>=6*35<CR>
    6 chairs, each costing $35, totals $210
    If you want to find out the numeric code for any character in your document,
    just place the cursor on it and trigger the ga command. This outputs a mes-
    sage at the bottom of the screen, revealing the character code in decimal and
    hexadecimal notations (see :h ga ).
    <C-k>{char1}{char2}
    Insert character represented by {char1}{char2} digraph
    The character pairs that make up a digraph are chosen to be descriptive,
    making them easier to remember or even guess. For example, the double-
    angle quotation marks « and » are represented by the digraphs << and >>;
    the vulgar (or common) fractions 1⁄2, 1⁄4, and 3⁄4 are represented by the digraphs
    12, 14, and 34, respectively. The default set of digraphs that ship with Vim
    follows certain conventions, which are summarized under :h digraphs-default .
    We can view a list of the available digraphs by running :digraphs, but the output
    of this command is difficult to digest. A more usable list can be found by
    looking up :h digraph-table .
    Virtual replace-mode: s60
    Samma för ett tecken: r och gr
    s63 = Selectmode ***
    gv
    o
    O
    Python och indentering
    When we use the dot command to repeat a Visual mode command, it acts on
    the same amount of text as was marked by the most recent visual selection.
    We can use Ex commands to read and write files (:edit and :write), to create
    tabs (:tabnew) or split windows (:split), or to interact with the argument list
    (:prev/:next) or the buffer list (:bprev/:bnext). In fact, Vim has an Ex command
    for just about everything (see :h ex-cmd-index for the full list).
    In this chapter, we’ll focus mainly on the handful of Ex commands we can
    use to edit text. Table 9, Ex Commands That Operate on the Text in a Buffer,
    on page 52, shows a selection of some of the most useful ones.
    Most of these commands can accept a range. We’ll find out what this means
    in Tip 28, on page 54. The :copy command is great for quickly duplicating a
    line, as we’ll see in Duplicate Lines with the ‘:t’ Command, on page 59. The
    :normal command provides a convenient way to make the same change on a
    range of lines, as we’ll see in Tip 30, on page 61.
    We’ll learn more about :delete, :yank, and :put commands in Chapter 10,
    Copy
    and Paste, on page 141. The :substitute and :global commands are very powerful,
    so they each get a chapter of their own. See Chapter 14, Substitution, on page
    215, and Chapter 15, Global Commands, on page 237.
    gå till rad 1
    :1
    :p
    :3p
    :2,5p
    :2,5d
    :%p
    . These marks persist even when we leave Visual mode. If
    you try running :'<,'>p straight from Normal mode, it will always act on the
    lines that most recently formed a Visual mode selection.
    :/mö/,/mä/p
    :/mö/+1,/mä/-1p
    The general form for an offset goes like this:
    :{address}+n
    If n is omitted, it defaults to 1. The {address} could be a line number, a mark,
    or a pattern.
    Discussion
    The syntax for defining a range is very flexible. We can mix and match line
    numbers, marks, and patterns, and we can apply an offset to any of them.
    This table summarizes a few of the symbols that can be used to create
    addresses and ranges for Ex commands:
    :t och :m
    mer=s83
    (s81)
    Visual + m$
    @:
    @@ If we want to run a Normal mode command on a series of consecutive lines, we can do so using the :normal command; When used in combination with the dot command or a macro, we can perform repetitive tasks with very little effort.  jVG +   :'<,'>normal. ********     . For example, we could have       solved the problem above with this single command:   :%normal A;   
    Single line command to command could be used to comment out an entire JavaScript file;:%normal i//
    :normal @q **************
    @@ KÖR FÖRRA :-KOMMANDOT IGEN, FAST PÅ DEN HÄR RADEN****;:normal @: (??=bör funka va?) :)
    Tab och Ctrl+d *****
    In many scenarios, Vim’s tab-completion does the right thing. If we type a
    command that expects a filepath as an argument (such as :edit or :write), then
    <Tab> will complete directories and filenames relative to the current working
    directory. With the :tag command we can autocomplete tag names. The :set
    and :help commands know about every configuration option in Vim.
    We can even define the tab-completion behavior when creating our own custom
    Ex commands. To see what’s possible, check out :h :command-complete .
    Even in Command-Line mode, Vim always knows where the cursor is positioned
    and which split window is active. To save time, we can insert the current word
    (or WORD) from the active document onto our command prompt.
    At Vim’s command line, the <C-r><C-w> mapping copies the word under the
    cursor and inserts it at the command-line prompt. We can use this to save
    ourselves a bit of typing.
    ****************:DD
    We’ll carry out the remaining changes using a :substitute command. Since our
    cursor is on the word “counter,” we don’t need to type it out again. We can
    just use the <C-r><C-w> mapping to populate the replacement field:
    ➾
    :%s//<C-r><C-w>/g
    That command doesn’t look very succinct when written down, but two
    keystrokes to insert a word ain’t bad. We didn’t have to type the search pattern
    either, thanks to the * command. Refer to Tip 90, on page 220, to see why we
    can leave the search field blank like that.
    For another application, try opening your vimrc file, place your cursor on a
    setting, and then type :help <C-r><C-w> to look up the documentation for that
    setting.
    By default, Vim records the last twenty commands. With memory becoming
    ever cheaper in today’s computers, we can probably afford to up this limit by
    changing the ‘history’ option. Try adding this line to your vimrc:
    set history=200
    We can get the best of both by creating the following custom mappings:
    ex_mode/history-scrollers.vim
    cnoremap <C-p> <Up>
    cnoremap <C-n> <Down>
    q: ************
    :write | !ruby %
    Each of these commands is already in our history, so we shouldn’t have to
    type the entire command line from scratch. But how can we merge two records
    from our history into one? Press q: and meet the command-line window (see
    :h cmdwin ).
    -
    stäng med :q (el ctrl+w-c, ZQ)
    Command
    q/
    q:
    ctrl-f
    Action
    Open the command-line window with history of searches
    Open the command-line window with history of Ex commands
    Switch from Command-Line mode to the command-line window***************
    We can easily invoke external programs without leaving Vim. Best of all, we
    can send the contents of a buffer as standard input to a command or use the
    standard output from an external command to populate our buffer.
    The commands discussed in this tip work best when used from Vim inside a
    terminal. If you’re using GVim (or MacVim), then things may not work quite
    as smoothly. That shouldn’t come as a great surprise. It’s much easier for
    Vim to delegate work to the shell if Vim itself is already running inside a shell.
    GVim does some things better, but this is one area where terminal Vim has
    the edge.
    On Vim’s command line, the % symbol is shorthand for the current file name
    (see :h cmdline-special ). We can exploit this to run external commands that do
    something with the current file. For example, if we’re working on a Ruby file,
    we could execute it by running this:
    ➾
    :!ruby %
    The :!{cmd} syntax is great for firing one-off commands, but what if we want
    to run several commands in the shell? In that case, we can use Vim’s :shell
    command to start an interactive shell session (see :h :shell ):
    ➾
    :shell
    ➾
    $ pwd
    ❮
    /Users/drew/books/PracticalVim/code/ex_mode
    ➾
    $ ls
    ❮
    duplicate.todo
    loop.js
    emails.csv
    practical-vim.html
    foobar.js
    shopping-list.todo
    history-scrollers.vim
    ➾
    $ exit
    Suppose that we’re running Vim inside a bash shell and we want to execute a series
    of shell commands. Pressing Ctrl - z suspends the process that’s running Vim and
    returns control to bash. The Vim process sits idle in the background, allowing us to
    interact with our bash session as normal. We can inspect the list of jobs by running
    this command:
    ➾
    $ jobs
    ❮
    [1]+ Stopped
    vim
    In bash, we can use the fg command to resume a suspended job, bringing it back
    into the foreground. That brings Vim back to life exactly as we left it. The Ctrl - z and
    fg commands are quicker and easier to use than Vim’s equivalent :shell and exit com-
    mands. For more information, run man bash and read the section on job control.
    The :read !{cmd} command lets us direct standard output into a buffer. As you
    might expect, the :write !{cmd} does the inverse: it uses the contents of the buffer as standard input for the specified {cmd} (see :h :write_c ).
    The effect of the :write !sh command is that each line of the current buffer is
    executed in the shell. Refer to :h rename-files for a nice example of this com-
    mand in use.
    ex_mode/emails.csv
    first name,last name,email
    john,smith,john@example.com <mailto:john@example.com>
    drew,neil,drew@vimcasts.org <mailto:drew@vimcasts.org>
    jane,doe,jane@example.com <mailto:jane@example.com>
    We’ll sort the records by the second field: last name. We can use the -t',' option
    to tell the sort command that fields are separated with commas, and we can
    use the -k2 flag to indicate that the second field is to be used for the sort.
    The first line of the file contains header information. We want to leave it at
    the top of the file, so we’ll exclude it from the sort operation by using a range
    of :2,$. This command line does what we want:
    ➾
    :2,$!sort -t',' -k2
    Vim provides a convenient shortcut for setting the range of a :[range]!{filter}
    command such as this. The !{motion} operator command drops us into Com-
    mand-Line mode and prepopulates the [range] with the lines covered by the
    specified {motion} (see :h ! ). For example, if we place our cursor on line 2 and
    then invoke !G , Vim opens a prompt with the :.,$! range set up for us.
    :[range]!{filter}
    Filter the specified [range] through external program {filter}
    5!! =liknande som ovan (tror den skickar aktuell rad +4 till kommandoraden för filtrering) :)
    Vim gives special treatment to some commands. For example, both make and
    grep have wrapper commands. Not only are they easy to execute from inside
    Vim, but their output is parsed and used to populate the quickfix list.
    Bind om.Ctrl+^ (=byt mellan % och #)
    Consider remaps av bn mfl
    :argdo och bufdo
    s101 TimPopes unimpaired.vim
    Error setting the text for the following input: =ger flera bra mappings för bn mfl.
    . If we wanted to delete buffers numbered 5
    through 10 inclusive, we could do so by running :5,10bd . But if we wanted to
    keep buffer number 8, then we’d instead have to run :bd 5 6 7 9 10.
    splitwindows
    tabpages
    the argumentlist
    In Tip 36, on page 77, we saw that the :ls command provides a listing of buffers.
    Now let’s examine the argument list:
    ➾
    :args
    ❮
    [a.txt] b.txt c.txt. d.txt e.txt
    The argument list represents the list of files that was passed as an argument
    when we ran the vim command. In our case, we provided a single argument,
    *.txt, but our shell expanded the * wildcard, matching the five files that we see
    in our argument list. The [] characters indicate which of the files in the
    argument list is active.
    . We can change the contents
    of the argument list at any time, which means that the :args listing doesn’t
    necessarily reflect the values that were passed to the vim command when we
    launched the editor. Don’t take the name literally!
    Populate the Argument List - s103
    Populate the Argument List
    When the :args Ex command is run without arguments, it prints the contents
    of the argument list. We can also set the contents of the argument list using
    this form (:h :args_f ):
    :args {arglist}
    The {arglist} can include filenames, wildcards, or even the output from a shell
    command.
    T ex:
    :args index.html app.js
    Specify Files by Glob
    Wildcards are placeholders that can stand in for characters in the name of a
    file or directory. The * symbol will match zero or more characters, but only
    in the scope of the specified directory (:h wildcard ). The ** wildcard also
    matches zero or more characters, but it can recurse downward into directories
    below the specified directory (:h starstar-wildcard ).
    Glob
    :args *.*
    :args **/*.js
    :args **/*.*
    Files Matching the Expansion
    index.html
    app.js
    app.js
    lib/framework.js
    app/controllers/Mailer.js
    ...etc
    app.js
    index.js
    lib/framework.js
    lib/theme.css
    app/controllers/Mailer.js
    ...etc
    :args **/*.js **/*.css
    As I wrote this book, I sometimes wanted to populate the argument list with
    the chapters in the same order that they appear in the table of contents. For
    this purpose, I maintained a plain-text file that contains one filename per
    line. Here’s an excerpt from it:
    files/.chapters
    the_vim_way.pml
    normal_mode.pml
    insert_mode.pml
    visual_mode.pml
    I can populate the argument list from this file by running this:
    ➾
    :args `cat .chapters`
    Vim executes the text inside the backtick characters in the shell, using the
    output from the cat command as the argument for the :args command.
    The argument list is simpler to manage than the buffer list, making it the
    ideal place to group our buffers into a collection. With the :args {arglist} com-
    mand, we can clear the argument list and then repopulate it from scratch
    with a single command. We can traverse the files in the argument list using
    :next and :prev commands. Or we can use :argdo to execute the same command
    on each buffer in the set.
    The way I see it, the buffer list is like my desktop: it’s always messy. The
    argument list is like a separate workspace that I always keep tidy, just in
    case I need space to stretch out. We’ll see a few examples of how the argument
    list can be used in other tips, such as Tip 69, on page 169, and Tip 96, on page
    233
    Hidden buffers mm: (:cnext??)
    :quit
    :write
    :edit!
    :qall!
    :wall
    :first
    :next
    If we enable the ‘hidden’ setting (see :h 'hidden' ), then we can use the :next,
    :bnext, :cnext (and so on) commands without a trailing bang. If the active buffer
    is modified, Vim will automatically hide it when we navigate away from it.
    The ‘hidden’ setting makes it possible to use :argdo and :bufdo to change a collec-
    tion of buffers with a single command.
    After running :argdo {cmd}, we’ll want to save the changes that were made to
    each item in the argument list. We could do it one at a time by running :first
    and then :wn, which would give us the opportunity to eyeball each file. Or if
    we’re confident that everything is in order, we could run :argdo write (or :wall) to
    save all buffers.
    We can use the :edit command to load another buffer into the active window.
    If we run <C-w>s followed by :edit {filename}, we can divide our workspace and
    then open another buffer in one split window while keeping the existing buffer
    visible in the other split. Alternatively, we could use the command :split {file-
    name}, which combines those two steps into one. This table summarizes the
    ways of dividing our workspace into split windows:
    Command
    <C-w>s
    <C-w>v
    :sp[lit] {file}
    :vsp[lit] {file}
    Effect
    Split the current window horizontally, reusing the current buffer
    in the new window
    Split the current window vertically, reusing the current buffer
    in the new window
    Split the current window horizontally, loading {file} into the new
    window
    Split the current window vertically, loading {file} into the new
    window
    Ex Command
    Normal Command
    Effect
    :cl[ose]
    <C-w>c
    Close the active window
    :on[ly]
    <C-w>o
    Keep only the active window, closing all others
    s110 - :h window-resize . This table summarizes a handful of the most useful
    commands: (men lättast med musen)
    Vim includes commands for rearranging windows, but rather than describing
    them here, I’d like to point you toward a screencast on Vimcasts.org that
    demonstrates the possibilities.1 Y
    1
    <http://vimcasts.org/e/7>
    Tabs = s111********
    The :lcd {path} command lets us set the working directory locally for the current
    window. If we create a new tab page and then use the :lcd command to switch
    to another directory, we can then comfortably scope each tab page to a differ-
    ent project. Note that :lcd applies locally to the current window, not to the
    current tab page. If we have a tab page containing two or more split windows,
    we could set the local working directory for all of them by running :windo lcd
    2
    {path}. Check out episode 9 of Vimcasts for more information.
    ***************
    <http://vimcasts.org/e/9>
    Opening and Closing Tabs
    We can open a new tab page with the :tabedit {filename} command. If we omit
    the {filename} argument, then Vim creates a new tab page containing an
    empty buffer.
    Alternatively, if the current tab page contains more than one window, we can
    use the <C-w>T command, which moves the current window into a new tab
    page (see :h CTRL-W_T ).
    If the active tab page contains only a single window, the :close command will
    close the window and the tab page with it. Or we can use the :tabclose com-
    mand, which closes the current tab page no matter how many windows it contains. Finally, if we want to close all tab pages except for the current one,
    we can use the :tabonly command.
    Command
    :tabe[dit] {filename}
    <C-w>T
    :tabc[lose]
    :tabo[nly]
    Effect
    Open {filename} in a new tab
    Move the current window into its own tab
    Close the current tab page and all of its windows
    Keep the active tab page, closing all others
    Ex Command
    Normal Command
    Effect
    :tabn[ext] {N}
    {N}gt
    Switch to tab page number {N}
    :tabn[ext]
    gt
    Switch to the next tab page
    :tabp[revious]
    gT
    Switch to the previous tab page
    Rearranging Tabs
    We can use the :tabmove [N] Ex command to rearrange tab pages. When [N] is
    0, the current tab page is moved to the beginning, and if we omit [N], the
    current tab page is moved to the end. If your terminal supports the mouse
    or if you’re using GVim, reordering tab pages by drag and drop is also possible.
    zzzz s114
    2
    Practical Vim 2*******::
    :e kan använda relativa sökvägar
    :edit %:h <Tab>
    The %:h expansion is so useful that you might want to consider creating a
    mapping for it. Check out Easy Expansion of the Active File Directory, on page
    95, for a suggestion.
    Easy Expansion of the Active File Directory
    Try sourcing this line in your vimrc file:
    cnoremap <expr> %%
    getcmdtype() == ':' ? expand('%:h').'/' : '%%'
    Now when we type %% on Vim’s : command-line prompt, it automatically expands to
    the path of the active buffer, just as though we had typed %:h <Tab> . Besides working
    nicely with :edit, this can come in handy with other Ex commands such as :write, :saveas,
    and :read.
    For more ideas on how to use this mapping, see the Vimcasts episode on the :edit
    a
    command.a.
    <http://vimcasts.org/episodes/the-edit-command/>
    The ‘path’ option allows us to specify a set of directories inside of which Vim
    will search when the :find command is invoked (see :h 'path' ). In our case, we
    want to make it easier to look up files in the app/controllers and app/views directo-
    ries. We can add these to our path simply by running this:
    ➾
    :set path+=app/**
    The ** wildcard matches all subdirectories beneath the app/ directory. We
    discussed wildcards in Populate the Argument List, on page 81, but the
    treatment of * and ** is slightly different in the context of the ‘path’ setting (see
    :h file-searching ). The wildcards are handled by Vim rather than by the shell.
    Smart Path Management with rails.vim
    Tim Pope’s rails.vim plugin does some clever things to make navigating around a
    Rails project easier.a The plugin automatically configures the ‘path’ setting to include
    all the directories found in a conventional Rails project. This means that we can use
    the :find command without having to worry about setting up the ‘path’.
    But rails.vim doesn’t stop there. It also provides convenience commands, such as
    :Rcontroller, :Rmodel, :Rview, and others. Each of these acts as a specialized version of the
    :find command, scoping its search to the corresponding directory.
    a.
    <https://github.com/tpope/vim-rails>
    netrw
    vim .
    C-R, -(=till mapp ovanför)
    +alla vanliga motionsc
    :e. explorer för cwd
    :E explorer för aktiva bufferns mapp
    **********
    Även :Sexplore and :Vexplore
    if we decide that we want to switch back to the
    buffer we were already editing, we can do so using the <C-^> command.
    The netrw plugin doesn’t just let us explore the file system. We can create
    new files (:h netrw-% ) or directories (:h netrw-d ), rename existing ones
    (:h netrw-rename ), or delete them (:h netrw-del ). For a demonstration, watch
    episode 15 of Vimcasts.1
    <http://vimcasts.org/e/15>
    We haven’t even touched on the killer feature that gives the plugin its name:
    netrw makes it possible to read and write files across a network. The plugin
    can use many protocols, including scp, ftp, curl, and wget, depending on what’s
    available on your system. To find out more, look up :h netrw-ref .
    :edit madeup/dir/doesnotexist.yet
    :!mkdir -p %:h
    :write
    The -p flag tells mkdir to create intermediate directories. See Open a File Relative
    to the Active File Directory, on page 95,
    ev remap av Go
    :w !sudo tee % > /dev/null
    -------
    Vim has a vast number of motions. We can’t cover them all in this chapter,
    so I recommend that you look up the :h motion.txt
    noremap <Up> <Nop>
    m fl g0 och g$
    nnoremap k gk
    nnoremap gk k
    nnoremap j gj
    nnoremap gj j
    w
    b
    e
    ge
    W , B , E , and gE
    Don’t Throw Away the Reverse Character Search Command
    Vim assigns a function to almost every key on the keyboard. If we want to create our
    own custom mappings, which keys should we bind them to? Vim provides the <Leader>
    key as a namespace for our own user-defined commands. Here is how we can create
    our own custom mappings using <Leader> :
    noremap <Leader>n nzz
    noremap <Leader>N Nzz
    The default leader key is \ , so we could trigger these custom mappings by pressing
    \n and \N . If you want to know what these mappings do, look up :h zz .
    On some keyboards, the \ command is inconvenient to reach, so Vim makes it easy
    to set the leader key to something else (see :h mapleader ). A common choice is to set
    the comma key as leader. If you take this route, I strongly recommend mapping the
    reverse character search command to another key. Here’s an example:
    let mapleader=","
    noremap \ ,
    The ; and , commands complement each other. If you take one of them away, then
    the whole family of character search commands becomes much less useful.
    dt.
    f;-pair och /n-pair
    Here, we use the /ge <CR> search motion to tell the d{motion} command what
    to delete. The search command is an exclusive motion. That means that even
    though our cursor ends up on the “g” at the start of the word “gets,” that
    character is excluded from the delete operation (see :h exclusive ).
    ab (, aB krull, och at tags ************
    d, c och y
    textobjects: i/aw,s,p
    Keystrokes
    Buffer Contents
    ``
    Position before the last jump within current file
    `.
    Location of last change
    `^
    Location of last insertion
    `[
    Start of last change or yank
    `]
    End of last change or yank
    `<
    Start of last visual selection
    `>
    End of last visual selection
    ******
    Vim provides a motion that lets us move between opening and closing pairs of
    parentheses. By enabling the matchit.vim plugin, we can extend this behavior
    to work on pairs of XML tags as well as on keywords in some programming
    languages.
    ******
    Error setting the text for the following input: =se s147-148.
    Ändra matchande måsvingar till klamrar-tricket med %
    +++
    Note that in this case, the <C-o> command would work just as well as the ``
    motion (see Tip 55, on page 131). The surround.vim plugin provides commands
    that would make this task even easier. Find out more in Surround.vim, on
    page 129.
    Error setting the text for the following input: =se s148*****.
    Jumps::
    Ctrl+o, Ctrl+i
    :jumps
    <C-]> - Jump to definition of keyword under the cursor (m fl)
    Vim can maintain multiple jump lists at the same time. In fact, each separate
    window has its own jump list. If we’re using split windows or multiple tab
    pages, then the <C-o> and <C-i> commands will always be scoped to the jump
    list of the active window.
    uCtrl+r (=tillb. till senaste ändring)
    changelist och :changes :)
    Using the g; and g, commands, we can traverse backward
    and forward through the change list.
    To jump back to the most recent modification in the document, we press g; .
    That places the cursor back on the line and column where it ended up after
    the previous edit. The result is the same as if we had pressed u<C-r> , except
    that we don’t make any transitory changes to the document.
    The `. mark always references the position of the last change (:h `. ),
    while the `^ mark tracks the position of the cursor the last time that Insert
    mode was stopped
    If we leave Insert mode and then scroll around the document,
    we can quickly carry on where we left off by pressing gi (:h gi ).
    Vim treats filenames in our document as a kind of hyperlink. When configured
    properly, we can use the gf command to go to the filename under the cursor.
    , I recommend using the -u NONE -N flags to ensure
    that Vim starts up without loading any no plugins:
    :set suffixesadd+=.rb (i detta fallet)
    +Ctrl+o och Ctrl+i ************
    Specify the Directories to Look Inside
    In this example, each of the files referenced with the require statement was
    located relative to the working directory. But what if we referenced function-
    ality that was provided by a third-party library, such as a rubygem?
    That’s where the ‘path’ option comes in (:h 'path' ). We can configure this to
    reference a comma-separated list of directories.
    We can inspect the value of the path by running this command:
    ➾
    :set path?
    ❮
    path=.,/usr/include,,
    For example, it would be useful if the ‘path’ included the directories for all
    rubygems used in a Ruby project. Then we could use the gf command to
    open up the modules referenced by any require statements. For an automated
    solution, check out Tim Pope’s bundler.vim plugin,1 which uses the project
    Gemfile to populate the ‘path’ setting.
    The ‘suffixesadd’ and ‘path’ options can be set locally for each buffer, so they can
    be configured in different ways for different file types. Vim is distributed with
    file-type plugins for many other languages besides Ruby, so in practice you
    won’t often have to set these options yourself. Even so, it’s worth understand-
    ing how the gf command works. It makes each filepath in our document
    behave like a hyperlink, which makes it easier to navigate through a codebase.
    1
    2
    <https://github.com/tpope/vim-bundler>
    <https://github.com/vim-ruby/vim-ruby>
    While the jump list and change list are like breadcrumb trails that allow us
    to retrace our steps, the gf and <C-]> commands provide wormholes that
    transport us from one part of our codebase to another.
    mark + `{letter}**
    . By default, global marks are
    persisted between editing sessions (although this behavior can be configured;
    see :h 'viminfo' ). Now you can always open up your vimrc file with two
    keystrokes
    Global marks can be especially useful when we need to browse through a set
    of files and then quickly snap back to where we started.*****
    *********
    :vimgrep /fooBar/ **
    By default, :vimgrep jumps directly to the first match that it finds, which could
    mean switching to another file. At this point, we can use the <C-o> command
    to get back to where we were prior to running :vimgrep.
    Try to get into a habit of setting a global mark before using any commands
    that interact with the quickfix list, such as :grep, :vimgrep, and :make. The same
    goes for the commands that interact with the buffer and argument lists, such
    as :args {arglist} and :argdo (see Tip 37, on page 80).
    Delete, yank and put::
    Not clobbering unnamed register = "_d *****
    . We could cut the current line into register
    c by running :delete c, and then we could paste it below the current line with
    the :put c command. These may seem verbose in comparison with the Normal
    mode commands, but they’re useful in combination with other Ex commands
    and in Vim scripts. For example, Tip 99, on page 240, shows how :yank can be
    used with the :global command.
    The Unnamed Register ("")
    The Yank Register ("0)
    When we use the y{motion} command, the specified text is copied not only
    into the unnamed register but also into the yank register, which is addressed
    by the 0 symbol (see :h quote0 ).
    ***************
    :reg (registers) ****
    "* och middle-mouse :)
    Vim can be compiled with or without support for X11 clipboard integration.
    To find out whether your version of Vim has the feature enabled, run the
    :version command and look for xterm_clipboard. If it’s prefixed with a minus sign,
    then your version of Vim does not support this feature. A plus sign means
    that the feature is available.
    The Expression Register ("=)
    Vim’s registers can be thought of simply as containers that hold a block of
    text. The expression register, referenced by the = symbol (:h quote= ), is an
    exception. When we fetch the contents of the expression register, Vim drops
    into Command-Line mode, showing an = prompt. We can enter a Vim script
    expression and then press <CR> to execute it. If the expression returns a string
    (or a value that can be easily coerced into a string), then Vim uses it.
    For examples of the expression register in action, check out Tip 16, on page
    31, Tip 95, on page 230, Tip 94, on page 229, and Tip 70, on page 174.
    ***************** SE MER !
    In addition, Vim provides a handful of
    registers whose values are set implicitly. These are known collectively as the
    read-only registers (:h quote. ). The following table summarizes them:
    Register
    "%
    "#
    ".
    ":
    "/
    Contents
    Name of the current file
    Name of the alternate file
    Last inserted text
    Last Ex command
    Last search pattern
    Technically, the "/ register is not read-only—it can be set explicitly using the
    :let command (see :h quote/ )—but it’s included in this table for convenience.
    Clobber visual selection with conts of the unnamed register
    ++??
    ****
    Keystrokes
    Buffer Contents
    {start}
    I like chips and fish.
    fc
    I like chips and fish.
    de
    I like
    and fish.
    mm
    I like
    and fish.
    ww
    I like
    and fish.
    ve
    I like
    and fish.
    p
    I like
    and chips.
    `m
    I like
    and chips.
    P
    I like fish and chips.
    In this case, it would be quicker to delete “chips and fish” and then type out
    “fish and chips” instead, using the c3w command for example. But this same
    technique can also be used to swap the order of longer phrases.
    When pasting from a line-wise register, the p and P commands put the text
    below or above the current line. This is more intuitive than the character-wise
    behavior.
    It’s worth noting that Vim also provides gp and gP commands. These also put
    the text before or after the current line, but they leave the cursor positioned
    at the end of the pasted text instead of at the beginning. The gP command is
    especially useful when duplicating a range of lines, as demonstrated here:
    +html-table-exemplet s170**
    Paste from systemclipboard i standard-vim
    When the ‘paste’ option is enabled,
    Vim turns off all Insert mode mappings and abbreviations and resets a host
    of options, including ‘autoindent’ (look up :h 'paste' for the full list). That allows
    us to safely paste from the system clipboard with no surprises.
    When we’re finished using the system paste command, we should disable the
    ‘paste’ option again. That means switching back to Normal mode and then
    running the Ex command :set paste!. Don’t you think it would be handy if there
    were a way of toggling this option without leaving Insert mode?
    The way that Vim behaves when ‘paste’ is enabled means that the usual
    methods for creating custom mappings won’t work in Insert mode. Instead,
    we can assign a key to the ‘pastetoggle’ option (:h 'pastetoggle' ):
    ➾
    :set pastetoggle=<f5>
    Macros::
    Spela in en punktformel som ett one off-makro *** s180
    Kör makro på flera heterogena rader (som kan bryta makrot) med
    :'<,'>normal @a ********* = köra i kedja som kan sen innan ELLER (då) parallellt :
    If we type qa , then Vim will record our keystrokes, saving them into register
    a by overwriting the existing contents of that register. If we type qA , then Vim
    will record our keystrokes, appending them to the existing contents of register
    a. We can amend our mistake: s186
    s187
    Source these lines of configuration to reproduce the examples in this tip:
    macros/rc.vim
    set nocompatible
    filetype plugin indent on
    set hidden
    if has("autocmd")
    autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
    endif
    Mer om :args (mest repetition) :D s187
    Köra makro över flera filer - s187+ ****
    To prevent this, we’ll revert all of the changes we just made to the first buffer
    in the argument list by running :edit! (see :h :edit! ):
    ➾
    :edit!
    Now we can go ahead and execute the macro in all of the buffers in the
    argument list:
    ➾
    :argdo normal @a
    +att istället lägga till :next som sista steg och skippa :e
    :argdo write och :wall (och :wnext)
    @@  KÖR KOMMANDOT I @a PÅ ALLA FILER I ARGLISTAN;:argdo normal @a (=kör parallellt över filer)
    We can do that
    using the expression register. In Tip 16, on page 31, we saw that the expres-
    sion register can be used to do simple sums and to insert the result into the
    document. We can insert the value stored in variable i just by running
    <C-r>=i<CR> in Insert mode.
    :put a
    . For example, we
    could use the substitute() function (which is not the same as the :substitute com-
    mand! See :h substitute() ) to perform the same edit as before:
    ➾
    :let @a=substitute(@a, '\~', 'vU', 'g')
    :substitute, which allows us to
    find occurrences of one pattern and replace them
    with something else, and :global , which lets us run
    any Ex command on each line that matches a par-
    ticular pattern.
    Patterns:: s198
    very magic, very nomagic
    Note that these items can be used anywhere in a pattern. If you realize that you need a case sensitive search after you typed out the full pattern, just tack \C on at the end, and it will affect everything that went before it. *****
    smartcase
    lösning på grundinställningen magic (som kräver många backslashtecken)
    /\v#([0-9a-fA-F]{}|[0-9a-fA-F]{})
    (=very magic ger perl/python/ruby-lik syntax)
    /\v#(\x{}|\x{}) ********
    Use the \V Literal Switch for Verbatim Searches.
    The special characters used for defining regular expressions are handy when searching for patterns, but they can get in the way if we want to search for text verbatim. Using the verynomagic literal switch, we can cancel out most of the special meanings attached to characters such as ., *, and ?.
    /\Va.k.a.<CR>
    As a general rule, if you want to search for a regular expression, use the \v pattern switch, and if you want to search for verbatim text, use the \V literal switch.
    Here’s a regular expression that matches duplicate words:
    ➾
    /\v<(\w+)\_s+\1>
    Now try searching for this pattern on the springtime excerpt, and you should
    see “the the” light up as a search match. Now try joining the two lines
    together ( vipJ will do it), and you should find that it still matches. Best of all,
    this pattern doesn’t just match “the the,” it works for any pair of duplicate
    words.
    There aren’t many scenarios where submatches are useful in a search pattern.
    One more example springs to mind: matching opening and closing pairs of
    XML or HTML tags. But as we’ll see in Tip 93, on page 228, we can also use
    submatches in the replacement {string} of the :substitute command.
    Combining these, we could approximate the < item as \W\zs\w, and the > item
    as \w\ze\W.
    Stake the Boundaries of a Match - s207
    Sometimes we might want to specify a broad pattern and then focus on a subset of the match. Vim’s \zs and \ze items allow us to do just that.
    Here’s another example, this time using both \zs and \ze to tweak the start
    and end of the match:
    Keystrokes
    {start}
    /\v"[^"]+" <CR>
    /\v"\zs[^"]+\ze"<CR>
    Buffer Contents
    Match "quoted words"---not quote marks.
    Match "quoted words"---not quote marks.
    Match "quoted words"---not quote marks.
    We can tell Vim not to bother assigning it to the \1 register by prepending a % in front
    of the parentheses, like this:
    What difference does this make? Well, it’s a smidge faster, not that you’re likely to
    notice. But it can be useful if you find yourself using several sets of parentheses.
    Suppose we wanted to replace all occurrences of FIRSTNAME LASTNAME with LASTNAME,
    FIRSTNAME for both forms of my name. We could do so like this:
    ➾
    /\v(%(And|D)rew) (Neil)
    ➾
    :%s//\2, \1/g
    The search pattern assigns either “Andrew” or “Drew” to capture register \1 and assigns
    “Neil” to register \2. If we hadn’t used %() for the second set of parentheses, then it
    would have captured a fragment of text unnecessarily, cluttering up our replacement
    field.
    Instead of using \zs and \ze, we could rewrite the /\v"\zs[^"]+\ze" <CR> pattern from Tip
    77, on page 192, using Vim’s positive lookaround items, like so:
    ➾
    /\v"@<=[^"]+"@=
    Advanced: s209
    Suppose that we want to search for all instances of the URL http://vim-doc.net/search?q=/\\. Rather than typing it out in full, we’ll just yank it into a register so that we can paste it into our search field. We want to match this text exactly as is, so we’ll use the \V literal switch.
    In our example text, we’re searching for a URL that includes two consecutive
    backslashes. We have to include two backslashes in the search field for each
    of them. Searching forward, we end up with this:
    ➾
    /\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\
    At last! Our search query matches the entire URL:
    Escaping characters by hand is laborious, error-prone work. Fortunately,
    Vim script includes a library function that can do the hard work for us:
    escape({string}, {chars}) (see :h escape() ).
    s211
    In Vim script, the . operator performs string concatena-
    tion, *************
    212, Gvim och :promptfind
    s213
    Search
    Having studied Vim’s regular expression engines in the previous chapter, let’s
    see how we can put them to use with the search command. We’ll start with
    the basics: how to execute a search, highlight matches, and jump between
    them. Then we’ll learn a couple of tricks that exploit Vim’s incremental search
    feature, which not only gives us instant feedback but can also save us typing
    by autocompleting our match. We’ll also learn how to count the number of
    matches that occur in a document.
    Composing a regular expression—and getting it right—often takes a few
    attempts, so developing a workflow that allows us to iterate on a pattern is
    important. We’ll learn about two methods for doing this: calling up our search
    history and working in the command-line window.
    Have you ever wished for a simple way of searching for text that’s already
    present in your document? We’ll finish by devising a simple customization
    that overrides the * command to search for the current visual selection.
    /+Enter =samma mönster för sökning igen=även efter '?' :D **********
    In Tip 84, on page 206, we’ll meet a more complex example where we change
    the offset each time we repeat a search. (//e tex)
    hlsearch' causes all matches
    to be highlighted throughout the active document as well as in any other open
    split windows.
    we could run :set nohlsearch to disable the feature entirely (:se
    nohls and :se hls! also work).
    Create a Shortcut to Mute Highlighting
    Typing :noh <CR> to mute search highlighting is laborious. We can speed things up by
    creating a mapping such as this:
    nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>
    Normally, <C-l> clears and redraws the screen (see :h CTRL-L ). This mapping builds
    on top of the usual behavior by muting search highlighting.
    S216********SE MER
    Vim’s search command is much more useful when the incremental search feature
    is enabled. Here are a couple of ways that this option can improve your work-
    flow.
    Esc eller CR
    Of course, we could simply type out the “carrot” in full. But here’s a handy
    shortcut: <C-r><C-w> . This autocompletes the search field using the remainder
    of the current preview match. If we used this command after entering “carr”
    into the search field, it would append “ot,” causing the match to encompass
    the entire word “carrot.”
    Note that the <C-r><C-w> autocompletion is slightly brittle in this context. If
    you prefix your search with the \v item, then <C-r><C-w> will complete the entire
    word under the cursor (creating /\vcarrcarrot <CR> , for example) instead of the
    remainder of the word. As long as you are searching for words and not
    patterns, the autocomplete feature of incremental search can be a nice little
    time-saver.
    There’s no way of making the search command report the number of matches
    in the current document. But here’s a command that does:
    ➾
    :%s///gn
    ❮
    117 matches on 65 lines
    *********
    ea
    /lang/e -exemplet ******
    In the real world, it won’t always be obvious when a search offset will come
    in handy. Suppose that we started off by executing the search command
    without the offset. Then, after pressing n a couple of times, we realize that
    we’d prefer to place the cursor at the end of the match. That’s no problem:
    we could simply run //e <CR> . When we leave the search field blank like this,
    Vim reuses the pattern from the previous search. So this repeats the last
    search but with an offset.
    To begin with, we write a regular expression to match either “Xml” or “Xhtml.”
    That’s easy enough: /\vX(ht)?ml\C <CR> does the job.
    The \C item enforces case
    sensitivity, so this should work regardless of whether ‘ignorecase’ and/or
    ‘smartcase’ are enabled. A
    (+RESTEN PÅ S222**********************)
    [ A Text Object for
    Search Matches, on page 209, discusses a more optimal solution, which requires
    a plugin.]
    BLUE, S223 (ny plugin för ovan)
    Create Complex Patterns by Iterating upon Search History ***********
    This is our final
    pattern:
    ➾
    /\v'(([^']|'\w)+)'
    We could either run /<Up> and edit the search field, or we could run q/ and
    make the change in the command-line window. Use whichever you feel is
    more appropriate. The search highlighting won’t look any different from the
    last time, but for each match, the text inside quotes will be assigned to the
    \1 capture register. That means we can run the following substitute command:
    ➾
    :%s//“\1”/g
    What we’ve done here is effectively identical to this:
    ➾
    :%s/\v'(([^']|'\w)+)'/“\1”/g
    Would you trust yourself to type that out correctly in one go?
    Don’t worry about getting a search pattern right the first time. Vim keeps our
    most recent search pattern two keystrokes away, so it’s easy to refine a pat-
    tern. Start with a broad match; then take as many steps as you need to focus
    on your target.
    Being able to edit the command line directly is great for simple edits. If we
    have the ‘incsearch’ setting enabled, then we get the added bonus of live feedback
    as we edit the command line. We lose this perk as soon as we call up the
    command-line window. But with the full power of Vim’s modal editing at our
    fingertips, this is a fair trade-off.
    In Normal mode, the * command lets us search for the word under the cursor.
    Using a small amount of Vim script, we can redefine the * command in Visual
    mode so that, instead of searching for the current word, it searches for the
    current selection.
    s226
    It always felt to me
    that triggering the * command from Visual mode should search for the current
    selection, not the current word. With a small amount of Vim script, we can
    add this feature to Vim.
    :vmap X y/<C-R>"<CR>
    (+hela visual star-search-plugin)
    (((zzzz=s229)))
    3
    Practical Vim 3:: *************
    The substitute command has many parts to it. The rules for the [range] are
    just the same as for every other Ex command, which we covered in-depth in
    Tip 28, on page 54.
    If we run the substitute command using a pattern that has no matches in
    the current file, Vim will report an error saying “E486: Pattern not found.”
    We can silence these errors by including the e flag, as we’ll see in Tip 96, on
    page 233.
    The & flag simply tells Vim to reuse the same flags from the previous substitute
    command. Tip 92, on page 224, shows a scenario where it comes in handy.
    \r
    \t
    \\
    \1
    \2
    \0
    &
    ~
    \={Vim script}
    Represents
    Insert a carriage return
    Insert a tab character
    Insert a single backslash
    Insert the first submatch
    Insert the second submatch (and so on, up to \9)
    Insert the entire matched pattern
    Insert the entire matched pattern
    Use {string} from the previous invocation of :substitute
    Evaluate {Vim script} expression; use result as replacement
    {string}
    The \={Vim script} token is very powerful. It allows us to execute code and use
    the result as our replacement {string} ************
    Substitutemetoden eller punktmetoden - Välj vad som känns bäst :)
    ➾
    :%s/\v'(([^']|'\w)+)'/“\1”/g
    It’s equivalent to these two separate commands:
    ➾
    /\v'(([^']|'\w)+)'
    ➾
    :%s//“\1”/g
    So what? One way or another, we’ll still have to type out the full pattern,
    right? That’s not the point. The substitute command involves two steps:
    composing a pattern and devising a suitable replacement string. This tech-
    nique allows us to decouple those two tasks.
    ****************
    Besides, who says we have to type out the pattern? In Tip 86, on page 212, we
    used a smidgen of Vim script to add a Visual mode equivalent of the * com-
    mand. This mapping allows us to select any text in our document and then
    hit the * key to search for the selection. We could then run the substitute
    command with an empty search field to replace our selection (and any similar
    matches) with something else. Talk about being lazy!
    I’m not saying that you should never fill out the search field of the substitute
    command. Here, for example, we have a substitute command that joins every
    line of a file by replacing newlines with commas:
    ➾
    :%s/\n/,
    It’s such a simple command that you won’t gain anything by splitting it in
    two. In fact, doing so would probably add work.
    If you think that you’ll want to recall a substitute command in its complete
    form from history, you can always fill out the search field explicitly. Pressing
    <C-r>/ at the command line pastes the contents of the last search register in
    place. Typing out the following would create a complete entry in our command
    history:
    ➾
    :%s/<C-r>//“\1”/g
    If the text in register 0 contains any characters that have special meaning
    within the replacement field (such as & or ~, for example), we would have to
    edit the string by hand to escape those characters. Also, if register 0 contained
    a multiline excerpt of text, it might not fit on the command line.
    To avoid these problems, we could simply pass a reference to the register
    containing the text we want to use in the substitution field.
    Pass by Reference
    Suppose that we’ve yanked a multiline selection of text, and it’s stored in
    register 0. Now we want to use that text as the replacement field of the sub-
    stitute command. We could do so by running this:
    ➾
    :%s//\=@0/g <mailto:=@0>
    In the replacement field, the \= item tells Vim to evaluate a Vim script
    expression. In Vim script, we can reference the contents of a register as
    @{register}. @0 returns the contents of the yank register, while @" returns the
    contents of the default register. So the expression :%s//\=@0/g tells Vim to <mailto:=@0>
    substitute the last pattern with the contents of the yank register.
    ➾
    :%s/Pragmatic Vim/Practical Vim/g
    Compare it with this sequence of commands:
    ➾
    :let @/='Pragmatic Vim'
    ➾
    :let @a='Practical Vim'
    ➾
    :%s//\=@a/g <mailto:=@a>
    :let @/='Pragmatic Vim' is a programmatic way of setting the search pattern. It
    has the same effect as executing the search /Pragmatic Vim <CR> (except that
    running :let @/='Pragmatic Vim' does not create a record in the search history).
    We could exploit this. We could search for the text we want to act upon and
    yank its replacement into register a. Then we could replay the :%s//\=@a/g <mailto:=@a>
    command, and it would use the values of @/ and @a that we had just prepared.
    Next we could search for something else and yank another replacement string
    into register a, and when we replayed the :%s//\=@a/g command, it would do <mailto:=@a>
    something else entirely.
    Try it out. You might love it or you might hate it. But either way, it’s a pretty
    neat trick!
    Suppose that we’ve just executed this command, which acts upon the current
    line:
    ➾
    :s/target/replacement/g
    We realize our mistake at once: we should have prepended %. No harm done.
    We can repeat the command across the entire file just by pressing g& (see
    :h g& ), which is equivalent to running the following:
    ➾
    :%s//~/&
    The :&& command requires some explanation, since the first and second &
    symbols have different meanings. The first one forms the :& Ex command,
    which repeats the last :substitute command (see :h :& ), while the second one
    indicates that the flags from the previous :s command should be reused.
    Discussion
    We can always specify a new range and replay the substitution using the :&&
    command. It doesn’t matter what range was used the last time. :&& by itself
    acts on the current line, :'<,'>&& acts on the visual selection, and :%&& acts
    on the entire file. As we saw already, the g& command is a handy shortcut
    for :%&&.
    Fixing the & Command
    The & command is a synonym for :s, which repeats the last substitution. Unfortunately,
    if any flags were used, the & command disregards them, meaning that the outcome
    could be quite different from the previous substitution.
    Making & trigger the :&& command is more useful. It preserves flags and therefore
    produces more consistent results. These mappings fix the & command in Normal
    mode and create a Visual mode equivalent:
    nnoremap & :&&<CR>
    xnoremap & :&&<CR>
    Now suppose that we want to swap the order of the fields so that the email
    comes first, then the first name, and finally the last name. We could use this
    substitute command to do it:
    ➾
    ➾
    /\v^([^,]*),([^,]*),([^,]*)$
    :%s//\3,\2,\1
    Perform Arithmetic on the Replacement
    The replacement field needn’t be a simple string. We can evaluate a Vim script
    expression and then use the result as the replacement string. Thus with a single
    command, we can promote every HTML header tag in a document.
    We’ll harness the substitute command to do it. Here’s the general idea: we
    write a pattern that matches the numeral portion of HTML header tags. Then
    we write a substitute command that uses a Vim script expression to subtract
    one from the number that was captured. When we run the substitute com-
    mand globally across the entire file, all HTML header tags will be changed
    with that single command.
    We only want to match the ones that
    immediately follow <h or </h. This pattern should do the trick:
    ➾
    /\v\<\/?h\zs\d
    s246 - abolish.vim mm *******
    250++ Qargs :)
    We can invert the behavior of the :global command either by running :global! or
    :vglobal (mnemonic: invert). Each of these tells Vim to execute [cmd] on each
    line that doesn’t match the specified pattern.
    Combining the :global and :delete commands allows us to cut down the size of a
    file rapidly. We can either keep or discard all lines that match a {pattern}.
    :g/TODO
    ➾
    :g/TODO/yank A
    ➾
    :reg a
    We could even combine the :global command with either :bufdo or :argdo to collect
    all TODO items from a set of files. I’ll leave that as an exercise for you, but
    look to Tip 96, on page 233, for a hint at the workflow.
    aOne of my favorite plugins from Tim Pope is called Abolish.
    Search across multiple files mm:
    ➾
    :argdo %s//Practical/ge
    ➾
    /Pragmatic\ze Vim
    ➾
    :vimgrep /<C-r>// **/*.txt
    Pressing <C-r>/ inserts the last search pattern.
    Each match returned by vimgrep is recorded in the quickfix list (see Chapter 17, Compile Code and Navigate Errors with the Quickfix List, on page 259). We can browse the results by running :copen, which opens the quickfix window. But instead of stepping through the results, one at a time, we want to run the substitute command on every file that appears in the quickfix list.
    It would be convenient if Vim included a :quickfixdo command, but there is no such thing. So instead we’ll use this small snippet of Vim script: s249
    Note that the last three commands could be combined into one,
    like this:
    ➾
    :Qargs | argdo %s//Practical/g | update
    The [cmd] could be any Ex command except for another :global command. In
    practice, Ex commands that interact with the text in the document prove
    most useful, such as those in Table 9, Ex Commands That Operate on the Text
    in a Buffer, on page 52. If we don’t specify a [cmd], then Vim will use :print by
    default.
    We can invert the behavior of the :global command either by running :global! or
    :vglobal (mnemonic: invert).
    Combining the :global and :delete commands allows us to cut down the size of a
    file rapidly. We can either keep or discard all lines that match a {pattern}.
    So if we can devise a pattern that matches HTML tags, we could use it with
    the :global command to reject any lines that match the pattern.
    These commands would do the trick:
    ➾
    /\v\<\/?\w+>
    ➾
    :g//d
    :v/href/d
    :g/TODO
    We’ll use the a register. First we’ll need to clear it by running qaq .
    ➾
    :g/TODO/yank A
    ➾
    :reg a
    but in Vim it actually shows a ^J symbol
    for newlines.)
    We could even combine the :global command with either :bufdo or :argdo to collect
    all TODO items from a set of files. I’ll leave that as an exercise for you, but
    look to Tip 96, on page 233, for a hint at the workflow.
    Here’s an alternative solution:
    ➾
    :g/TODO/t$
    Sort Properties for Every Block of Rules
    We can sort the properties for every block of rules in the file with a single
    :global command. Say we run this command on our style sheet:
    ➾
    :g/{/ .+1,/}/-1 sort
    The [range] for our [cmd] can be set dynamically using the match from :g/{pattern}
    as a reference point. Normally the . address stands for the line that the cursor
    is positioned on. But in the context of a :global command, it stands for each
    line in turn that matches the specified {pattern}.
    We can break our command into two separate Ex commands. Let’s work our
    way backward from the end. This is a valid Ex command:
    ➾
    :.+1,/}/-1 sort
    :.+1,/}/-1 sort
    That places our cursor at the top of a {} block, right where we need it. Now
    let’s put our :global and [cmd] Ex commands back together:
    ➾
    :g/{/ .+1,/}/-1 sort
    Note that the :> command echoes a message each time it is invoked, whereas
    :sort doesn’t. We can mute these messages by prefixing our [cmd] with :silent
    (see :h :sil ):
    ➾
    :g/{/sil .+1,/}/-1 >
    s261
    CHAPTER 16
    Index and Navigate
    Source Code with ctags
    Vim’s ctags support allows us to navigate around a codebase by quickly
    jumping to definitions of functions and classes.
    As a secondary benefit, we can also use the output from ctags to
    generate a word list for autocompletion, a
    ➾
    $ sudo apt-get install exuberant-ctags
    Tell Vim Where to Find the Tags File
    The ‘tags’ option specifies where Vim should look to find a tags file (:h 'tags' ).
    When ./ is used in the ‘tags’ option, Vim replaces it with the path of the cur-
    rently active file. We can inspect the defaults:
    ➾
    :set tags?
    ❮
    tags=./tags,tags
    With these settings, Vim looks for a tags file in the directory of the current file
    and in the working directory. U
    We can invoke ctags directly from Vim by running the following:
    ➾
    :!ctags -R
    :nnoremap <f5> :!ctags -R<CR>
    That lets us rebuild the index just by pressing the <F5> key, but we still have
    to remember periodically to generate the tags file. Now let’s consider a couple
    of options for automating this process.
    Automatically Execute ctags Each Time a File is Saved
    Vim’s autocommand feature allows us to invoke a command on each occur-
    rence of an event, such as a buffer being created, opened, or written to file.
    +++Git-integrering mm
    Re-indexing our codebase on each commit strikes a good balance. Sure, the
    tags file might fall out of step with our working copy, but the errors are toler-
    able.
    S269 - Navigating code mm*******
    Compile Code and Navigate Errors
    with the Quickfix List
    Vim’s quickfix list is a core feature that allows us to integrate external tools
    into our workflow. At its simplest, it maintains a sequence of annotated
    addresses comprising the filename, line number, column number (optional),
    and a message. Traditionally, these addresses would be a list of error messages
    generated by a compiler, but they could just as well be warnings from a syntax
    checker, linter, or any other tool that emits such output.
    We’ll start off by looking at an example workflow: running make in an external
    shell and navigating to error messages by hand. Then we’ll introduce the :make
    command, seeing how it can streamline our workflow by parsing error mes-
    sages from the compiler and making them navigable in the form of the
    quickfix list.
    Compile the Project from Inside Vim
    s271
    :make, och förberedelser inför mm :]
    ➾
    :args $VIMRUNTIME/compiler/*.vim
    One down side to using external programs is that their regex syntax may be
    incompatible with the one we use for most Vim searches. We’ll see that the
    :vimgrep command allows us to use Vim’s native search engine to find patterns
    in multiple files. This convenience comes at a cost: vimgrep isn’t nearly as fast
    as dedicated programs.
    284 = VIMGREP **********
    S289 *******
    S290 ************
    Filenamecompletion + :cd - *******
    s296 - OMNICOMPLETION
    s298 Spellcheck
    s306 (set settings)*****
    s307 ++++
    zzzz=s307
    o
    TIPS, TRICKS OCH BÄSTAKOMMANDON! :D <#ID_1195520506>
    några nya länkar:
    vimtips (essential vim) <http://www.pixelbeat.org/vim.tips.html>
    o
    gå direkt till nån av nio sessionerna innan nuvarande = '1-'9 :D
    BÄSTABÄSTA :]
    grundmärken :)
    ] - slut av senaste ändring
    " - markörposition när senast ändrade filen
    . - pos. där senaste ändring gjordes
    )
    }
    block
    t - (tagblocks = < > )
    b - ( )
    B - { }
    a"
    a'
    a`
    a<
    a]
    1: /four  2:cw five  3:n  4:.  :DDDD
    mata in unicodetecken/specialtecken :DD
    Testa: mata in Enter som tecken (med t ex Ctrl+v (???)) för att kunna lägga flerradstext i ett register %]
    mata in unicode-tecken
    mata in Del m fl tecken via siffror - ctrl+v 127
    mata in hexadecimala tecknet x7f - ctrl+v x7f
    mata in oktala tecken - ctrl+v o123
    Error setting the text for the following input: =Ctrl+v u +unicode-tal :).
    u1234
    Error setting the text for the following input: =16-bit.
    U12345678
    Error setting the text for the following input: =32-bit.
    o
    Digraphs (t ex copywrighttecknet) - ctrl+k Co
    se vilka digraphs som är tillgängliga - :digraphs
    +s125
    öppna fil under markören i ny tab :DDDDDD !!! --- Ctrl-w gf
    Ändra färgschema :D ***
    o
    förena rader (i exemplet, blanka rader)
    :g/./,/^$/join
    gå direkt till senaste sessionen :D == '0 (klar2014)
    o
    klistra in senast kopierade (med y t.ex.) med Ctrl+r när i insertmode (klar2014)
    Ctrl+r, 0
    placera in det som skrevs in senast i i-mode :DDD (klar2014)
    Ctrl+a
    Ctrl+@
    ++i insertmode = Ctrl+r, i
    skicka x antal rader till kommandoraden för redigering (klar2014)
    5:
    :.,.+4
    o
    tags i vim <http://vim.wikia.com/wiki/Browsing_programs_with_tags>
    o
    Ctrl-]
    For example, the command ':stag func1' will open the func1 definition in a new window.
    You can position the cursor over a tag name and then press Ctrl-W ]. This will open the tag location in a new window.
    o
    :tselect func1' will list all the locations where func1 is defined. You can then enter the number of a tag match to jump to that location.
    You can position the cursor over the tag name and press g] to get a list of matching tags.
    You can visually select a text and press g] to get a list of matching tags.
    You can use the 'stselect' ex command. This will open the selected tag from the tag list in a new window.
    You can position the cursor over the tag name and press Ctrl-W g] to do a :stselect.
    o
    gå tillbaks:
    :pop
    Ctrl+t
    o
    How do I jump again to a previously jumped tag location?
    You can use the 'tag' ex command to jump to a previously jumped tag location, which is stored in the tag stack.
    Help: tag
    How do I list the contents of the tag stack?
    Vim remembers the location from which you jumped to a tag in the tag stack. You can list the current tag stack using the 'tags' ex command.
    TILL TAG OM BARA EN MATCH, ANNARS VISA LISTA
    BROWSE THROUGH LIST OF MULTIPLE TAGMATCHES
    o
    ANVÄNDA PREVIEWFÖNSTRET OCH VISA TAG
    o
    You can position the cursor on a tag name and press Ctrl-W } to open the tag in the preview window.
    o
    o
    You can position the cursor on the tag and press Ctrl-W g} to do a :ptjump on the tag.
    BROWSE THROUGH LIST OF TAGS =I PREVIEWFÖNSTRET !! (:ptselect, :ptjump osv)
    o
    $ vim -t
    Error setting the text for the following input: = öppna vim för redigering utifrån en tag-match i en fil :).
    LIST ALL THE TAGS MATCHING A SEARCHPATTERN
    DRS VIMHÄFTE 2 (folds till autocommand (och precis innan 'add new menus')
    TAGS - s25-26
    A tag is a location where an identifier is defined. An example is a functiondefinition in a C- or C++-program
    Generate c-tags for all c-files in the current directory: ctags *.c
    CONFIGURE CTAGS FOR PYTHON AND VIM <Configuring%20ctags%20for%20Python%20and%20Vim>
    o
    o
    o
    o
    o
    mm
    PREVIEWWINDOW - s157 i usermanual
    HOPPA I PROGRAM - s26-27
    KODFELMEDDELANDEN - s27-28
    INDENTERING - s(28)-29 (+softtabstops och annat)
    formatering
    browse (30-31)
    UNDO OCH UNDOTREE - s31
    MAPS - s31-33
    EGENDEFINIERADE KOMMANDON :) - s33-34
    AUTOCOMMAND - s34-35
    ADD NEW MENUS - s225 i usermanual
    färgkod KLAR 2014
    c/mönster
    ändra framåt till mönster
    c?mönster
    ändra bakåt till mönster
    cn
    ändra framåt till nästa mönster
    cG
    ändra till slutet










    kolumner och virtualmode: s133
    Gives you very general help. Scroll down to see a list of all helpfiles, including those added locally (i.e. not distributed with Vim). >;:help user-toc.txt
    set printoptions=paper:A4,syntax:y,wrap:y,, The printoptions line is a comma separated list of values that affect how Vim formats the document before it sends it to the printer. A list of options is at :help popt. The paper option sets the paper size. It accepts values such as A3, letter, and legal. The syntax option determines whether the document is printed with syntax highlighting. By default it has the value a which means that Vim only uses highlighting for colour printers. A value of y forces highlighting. Lines are wrapped when wrap:y, which is the default. If wrap has the value n, long lines are truncated. Other useful options are header:0 to stop a header from being printed, number:y to number lines, duplex:off to print on only one side of the page.
    Editing formatted text - s126








    ZZZZ
    öppna fil i ny flik m gf
    Error setting the text for the following input: = ctrl+w gf :D.
    öppna fil i nytt fönster
    ctrl+w f
    o
    When you know the file name, but it's not to be found in the file, you can type it: >
    :find inits.h
    Vim will then use the 'path' option to try and locate the file. This is the same as the ":edit" command, except for the use of 'path'.
    o
    A nice way to directly start Vim to edit a file somewhere in the 'path': >
    vim "+find stdio.h"
    This finds the file "stdio.h" in your value of 'path'. necessary to have one argument |-+c|.
    buffer-list
    AHA! :DD
    active
    hidden
    inactive
    hidden buffers
    inactive buffers
    listing buffers
    :buffers
    :ls
    :files
    redigera buffer 2
    :buffer 2
    redigera buffer som innehåller ordet 'help'
    :buffer help
    öppna buffer 3 i nytt fönster
    :sbuffer 3
    ta bort buffer 3 från buffer-listan
    :bdelete 3
    o
    :bnext
    o
    :bprevious
    o
    :bfirst
    o
    :blast
    o
    Even after removing the buffer with ":bdelete" Vim still remembers it.
    It's actually made "unlisted", it no longer appears in the list from
    ":buffers". The ":buffers!" command will list unlisted buffers (yes,
    Vim can do the impossible). To really make Vim forget about a buffer,
    use ":bwipe". Also see the 'buflisted' option.
    tecken för bufferlist :DD ***
    u
    Buffer is unlisted |unlisted-buffer|.
    %
    Current buffer.
    #
    Alternate buffer.
    a
    Buffer is loaded and displayed.
    h
    Buffer is loaded but hidden.
    =
    Buffer is read-only.
    -
    Buffer is not modifiable, the 'modifiable' option is off.
    +
    Buffer has been modified.
    |usr_23.txt| Editing other files
    o
    :set fileformat?
    The three names that Vim uses are:
    unix
    dos
    mac
    <LF>
    <CR><LF>
    <CR>
    +s112
    o
    Vim assumes that on Unix you probably won't edit a Mac file, and doesn't check
    for this type of file. To check for this format anyway, add "mac" to
    fileformats': >
    :set fileformats+=mac
    +se mer s113
    öppna filer på internet :D
    Someone sends you an e-mail message, which refers to a file by its URL.
    example:
    For
    You can find the information here: ~
    ftp://ftp.vim.org/pub/vim/README ~ <ftp://ftp.vim.org/pub/vim/README>
    You could start a program to download the file, save it on your local disk and
    then start Vim to edit it.
    There is a much simpler way. Move the cursor to any character of the URL.
    Then use this command: >
    gf
    With a bit of luck, Vim will figure out which program to use for downloading
    the file, download it and edit the copy. To open the file in a new window use
    CTRL-W f.
    o
    Accessing files over the internet works with the netrw plugin. Currently URLs with these formats are recognized:
    ftp://
    uses ftp
    rcp://
    uses rcp
    scp://
    uses scp
    http://
    uses wget (reading only)
    encryption
    s114
    binary files
    s115
    |usr_24.txt| Inserting quickly
    COMPLETION
    sök före/efter
    ctrl+p
    SÖK TIDIGARE/SENARE ORD :)
    *slutför ord redan i fil
    *slutför var eller funkt.namn i skript du jobbar med
    Ctrl+p
    Ctrl+n
    sökställen =var letar ctrl+n/p
    1.current file
    2.files in other windows
    3.other loaded files (hidden buffers)
    4.files which are not loaded (inactive buffers)
    5.tagfiles
    6.all files #included by the current file
    ctrl+n
    o
    The Vim editor goes through a lot of effort to find words to complete. By default, it searches the following places:
    1
    Current file
    2
    Files in other windows
    3
    Other loaded files (hidden buffers)
    4
    Files which are not loaded (inactive buffers)
    5
    Tag files
    6
    All files #included by the current file
    OPTIONS
    You can customize the search order with the 'complete' option.
    även 'ignorecase' och 'infercase'
    COMPLETING SPECIFIC ITEMS
    If you know what you are looking for, you can use these commands to complete with a certain type of item:
    CTRL-X CTRL-F
    file names
    COMPLETING FILE NAMES
    Let's take CTRL-X CTRL-F as an example. This will find file names. It scans the current directory for files and displays each one that matches the word in front of the cursor.
    Suppose, for example, that you have the following files in the current directory:
    main.c
    sub_count.c
    sub_done.c
    sub_exit.c
    Now enter Insert mode and start typing:
    The exit code is in the file sub ~
    At this point, you enter the command CTRL-X CTRL-F.
    Vim now completes the current word "sub" by looking at the files in the current dir ectory.
    The first match is sub_count.c.
    This is not the one you want, so you match the next file by typing CTRL-N. This match is sub_done.c. Typing CTRL-N again takes you to sub_exit.c.
    The results:
    The exit code is in the file sub_exit.c ~
    the file is found in /usr/ ~
    If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all files in the file system. For example, type "/u" and CTRL-X CTRL-F. This will match "/usr" (this is on Unix):
    If you now press CTRL-N you go back to "/u". Instead, to accept the "/usr/"
    and go one directory level deeper, use CTRL-X CTRL-F again:
    the file is found in /usr/X11R6/ ~
    The results depend on what is found in your file system, of course.
    matches are sorted alphabetically.
    The
    SE MER s119
    CTRL-X CTRL-L
    whole lines
    CTRL-X CTRL-D
    macro definitions (also in included files)
    CTRL-X CTRL-I
    current and included files
    CTRL-X CTRL-K
    words from a dictionary
    CTRL-X CTRL-T
    words from a thesaurus
    CTRL-X CTRL-]
    tags
    CTRL-X CTRL-V
    Vim command line
    After each of them CTRL-N can be used to find the next match, CTRL-P to find the previous match. :DDD
    More information for each of these commands here: |ins-completion|.
    o
    completing in source code :DDD
    ctrl+x ctrl+o
    s120
    +explained |ft-c-omni|
    placera in det som skrevs in senast i i-mode :DDD
    Ctrl+a
    Ctrl+@
    Mata in tecknet ovanför/nedanför (på raden ovanför/nedanför) markören :D
    ctrl+y
    ctrl+e
    MATA IN INNEHÅLLET FRÅN REGISTER X
    CTRL+R {x}
    CTRL+R CTRL+R
    mata in direkt (=tolka inte t ex backspace utan mata in som <BS>)
    INSERTMODE-KOMMANDON :D
    [+SE OCKSÅ COMPLETION :D ]
    o
    ctrl+d
    ta bort indentering inne i insertmode
    ctrl+t
    indentera inne i insertmode
    o
    backspace
    ctrl+h :)
    samma som tab
    ctrl+i
    enter
    ctrl+m; ctrl+j
    pausa ins-mode
    ctrl+o
    mata in enter m fl tecken 'verbatim' :]
    ctrl+v
    zzzz2
    FÖRKORTNINGAR
    s122
    :abbreviate
    :iabbrev
    :cabbrev
    :unabbreviate
    :abclear (iabclear, cabclear)
    :noreabbrev
    (t ex)
    :iabbrev ad advertisement
    Now, when you type "ad", the whole word "advertisement" will be inserted into the text. This is triggered by typing a character that can't be part of a word, for example a space:
    I saw the ad<Space>
    o
    As a programmer, I use two rather unusual abbreviations: >
    :iabbrev #b /****************************************
    :iabbrev #e <Space>****************************************/
    The ":abbreviate" command lists the abbreviations:
    +++S 123
    entering special characters
    s124
    digraphs :))) [t ex Copyright-tecknet]
    s124
    pausa insertmode för ett kommando
    |usr_25.txt| Editing formatted text
    breaking lines
    :set textwidth=30
    reformatting
    s127
    gq
    *25.2* Aligning text
    To center a range of lines, use the following command: >
    :{range}center [width]
    s127
    Similarly, the ":right" command right-justifies the text: >
    :1,5right 37
    gives this result:
    left alignment
    Finally there is this command: >
    :{range}left [margin]
    Unlike ":center" and ":right", however, the argument to ":left" is not the length of the line. Instead it is the left margin. If it is omitted, the text will be put against the left side of the screen (using a zero margin would do the same). If it is 5, the text will be indented 5 spaces. For example, use these commands: >
    :1left 5
    :2,5left
    This results in the following:
    I taught for a while. One ~ time, I was stopped by the ~ Fort Worth police, because my ~ homework was too hard. True ~ story. ~
    justifying text
    Vim has no built-in way of justifying text. However, there is a neat macro package that does the job. To use this package, execute the following command: >
    :runtime macros/justify.vim
    An alternative is to filter the text through an external program.
    :%!fmt
    scroll :) (s130)
    If you don't have a scrollbar or don't want to use it, use these commands to scroll the text. The cursor will stay in the same place, but it's moved back into the visible text if necessary.
    zh
    right
    4zh
    four characters right
    zH
    half a window width right
    ze
    right to put the cursor at the end
    zl
    left
    4zl
    four characters left
    zL
    half a window width left
    zs
    left to put the cursor at the start
    :D
    g0
    to first visible character in this line
    g^
    to first non-blank visible character in this line
    gm
    to middle of this line
    g$
    to last visible character in this line
    :set linebreak
    (s131 - se till att ord inte bryts mitt i) :]
    :)
    gk
    gj
    :map <Up> gk
    :map <Down> gj
    turning the paragraph into one line :)
    :g/./,/^$/join
    That looks complicated.
    Let's break it up in pieces:
    :g/./
    A ":global" command that finds all lines that contain at least one character.
    ,/^$/
    A range, starting from the current line (the non-empty line) until an empty line.
    join
    The ":join" command joins the range of lines together into one line.
    EDITING TABLES s132 :) SE MER
    |usr_26.txt| Repeating
    markera förra markeringen igen
    gv :DDDD
    addera/subtrahera nummer
    ctrl+a/ctrl+x
    Making a change in many files - s136
    :DDD
    :args *.c
    lägg alla filer som slutar på .c i mappen i argslistan
    This finds all C files and edits the first one. Now you can perform a substitution command on all these files: >
    :argdo %s/\<x_cnt\>/x_counter/ge | update
    The ":argdo" command takes an argument that is another command. That command will be executed on all files in the argument list
    kör kommando(n) på alla fönster
    :windo
    kör kommandon på alla buffrar
    :bufdo (obs! kolla först buf-listan med ls)
    Using Vim from a shell script s136 :DDD
    SE MER SE MER
    använda vim från ett shellscript
    %s/--person--/Jones/g write tempfile quit
    for file in * .txt; do vim -e -s $file < change.vim lpr -r tempfile done
    if you use the standard input to read text from, you can use the -S argument to read a script
    producer | vim -S change.vim -
    redigera std.out från kommandot ls direkt med vim
    ls | vim -
    s137: vim -s file.txt ...
    Error setting the text for the following input: = -s has a different meaning when it is used without -e. here itt means to source the "script" as Normalmodecommands. when used with -e it means to be silent, and doesnt use the next argument as a filename.
    another way is to record the commands while you perform them manually. this is how you do that:
    vim -w script file.txt ...
    Error setting the text for the following input: =all typed keys will be written to "script". if you make a small mistake you can just continue and remember to edit the script later..
    the -w argument appends to an existing script. that is good when you want to record the script bit by bit.
    if you want to start from scratch and start all over, use the -W argument. it overwrites any existing file
    NORMAL MODE SCRIPTS
    If you really want to use Normal mode commands in a script, you can use it like this: >
    vim -s script file.txt ...
    Note:
    "-s" has a different meaning when it is used without "-e". Here it means to source the "script" as Normal mode commands. When used with "-e" it means to be silent, and doesn't use the next argument as a file name.
    +++SE MER :DDD
    Spela in script i farten/on the fly :DD s137
    To create the script you can edit the script file and type the commands. You need to imagine what the result would be, which can be a bit difficult.
    Another way is to record the commands while you perform them manually. This is how you do that: >
    vim -w script file.txt ...
    All typed keys will be written to "script". If you make a small mistake you can just continue and remember to edit the script later.
    The "-w" argument appends to an existing script. That is good when you want to record the script bit by bit. If you want to start from scratch and start all over, use the "-W" argument. It overwrites any existing file.
    |usr_27.txt| Search commands and patterns (s139-
    ignore case
    case in one pattern
    offsets
    t ex 
    /default/2
    This command searches for the pattern "default" and then moves to the beginning of the second line past the pattern.
    character offsets :) (s141)
    e=end; b=beginning
    /const/e
    /const/e+1
    /const/e-1
    /const/b+2
    repeating searches :DD
    To repeat searching for the previously used search pattern, but with a different offset, leave out the pattern: >
    /that
    //e
    Is equal to: >
    /that/e
    To repeat with the same offset: >
    /
    "n" does the same thing.
    To repeat while removing a previously used offset: >
    //
    Också förstås för ?-sökningar (gällande båda röda ovan) :)
    ?const?e-2
    matching multiple (* mm) :D
    ange exakt hur många multiple
    matcha så lite som möjligt
    alternativ
    \|
    \& (s143) :D
    character ranges
    [a-bfx-y]
    o
    +SE MER s144
    \e
    <Esc>
    \t
    <Tab>
    \r
    <CR>
    \b
    <BS>
    [tak "] :)
    fördefinierade
    \d
    digit
    [0-9]
    \D
    non-digit
    [^0-9]
    \x
    hex digit
    [0-9a-fA-F]
    \X
    non-hex digit
    [^0-9a-fA-F]
    \s
    white space
    [          ]  (tabs och blanks)
    \S
    non-white characters
    [^        ]  (not tabs och blanks)
    \l
    lowercase alpha
    [a-z]
    \L
    non-lowercase alpha
    [^a-z]
    \u
    uppercase alpha
    [A-Z]
    \U
    non-uppercase alpha
    [^A-Z]
    character classes
    \i
    identifier characters
    isident'
    \I
    like \i, excluding digits
    \k
    keyword characters
    iskeyword'
    \K
    like \k, excluding digits
    \p
    printable characters
    isprint'
    \P
    like \p, excluding digits
    \f
    file name characters
    isfname'
    \F
    like \f, excluding digits
    matching a line break :)
    t ex
    whitespace eller linebreak :)
    \_s
    any character or a linebreak
    \_.
    o
    + \n och \r :DD
    EXEMPEL REGEX s146
    |usr_28.txt| Folding
    SE MER s147
    o
    zfap
    zo
    zc
    zr
    zm
    zR
    zM
    o
    zn
    zN
    zi
    :set foldcolumn=4
    zO
    zC
    zd
    zD
    o
    (+fler options)
    o
    o
    folding by indent **** (s149)
    folding with markers
    folding by syntax (s151)
    folding by expression
    folding unchanged lines (vimdiff)
    |usr_29.txt| Moving through programs <#ID_922606698>
    ctags och skapa tags :DDD - SE MER s154
    To split the current window and jump to the tag under the cursor use this command:  :)
    CTRL-W ]
    the preview window :)) - SE MER s157
    t ex
    If the name of a function appears in the text, you can get its definition in the preview window with: >
    CTRL-W }
    Show tag under cursor in preview window
    Stäng preview-fönstret
    Ctrl+w z
    fr s26 :) ;; moving through programs :) (manual s158) <#ID_1575994988>
    [ Ctrl+d
    [ Ctrl+i
    hoppa till första raden i nuvurande och inkluderade filer som innehåller ordet under markören; starta sökning i början av nuvarande filen
    [#
    hoppa till början av #if --- #endif
    ]#
    [{
    hoppa till { på samma nivå :] = TESTA
    ]}
    hoppa till } på samma nivå :] = TESTA
    [[
    hoppa till yttersta {
    flytta till början av nuvarande sektion
    ][
    hoppa till yttersta }
    i C/Java = yttre { } är klassen och nästa nivå av { } är metoden :D
    [m
    hoppa till def av metod (= { inne i klass)
    ]m
    []
    gå till slutet av förra funktionen :)
    ]]
    gå till början av nästa funktion :)
    [(
    hoppa till ( på samma nivå :] = TESTA
    ])
    hoppa till ) på samma nivå :] = TESTA
    {/ ,, [/
    gå till början av kommentar
    ]/
    gå till slutet av kommentar :} (testa)
    [I (=stort i)
    You are editing a C program and wonder if a variable is declared as "int" or "unsigned". A quick way to find this is with the "[I" command.
    zzzz s161
    [+tab
    [i
    ]I (=stort i)
    ]i
    [D
    [d
    ]D
    ]d
    finding local identifiers
    gD
    gd
    locating included files + path :DDD !! s160 =SE MER :)
    |usr_30.txt| Editing programs
    compiling
    +errorcheck :)
    använda extern kompilator :)
    o
    äldre errorlists
    switching compilers
    output redirection
    indentering mm i C :)
    formatera kommentarer - s170 :DD
    definiera hur en kommentar ser ut
    |usr_31.txt| Exploiting the GUI
    s176 - redigera epostmeddelanden i vim :) - se mer ev
    |usr_32.txt| The undo tree
    s177
    +timetravel och earlier :)
    Tuning Vim
    |usr_40.txt| Make new commands
    key mapping - s180
    defining command-line--commands - s183
    autocommands - s186
    events :)
    patterns
    (mm)
    o
    o
    o
    |usr_41.txt| Write a Vim script (s190-224)
    http://vimdoc.sourceforge.net/htmldoc/usr_41.html
    |usr_42.txt| Add new menus
    |usr_43.txt| Using filetypes
    |usr_44.txt| Your own syntax highlighted
    |usr_45.txt| Select your language
    o
    Making Vim Run + Reference manual :)
    |usr_90.txt| Installing Vim
    Reference manual
    |reference_toc|
    Error setting the text for the following input: = More detailed information for all commands :).
    The user manual is available as a single, ready to print HTML and PDF file here:
    vimdoc.sf.net <http://vimdoc.sf.net>
    LÄNKAR OCH HOPP
    Följ länk :) = Ctrl+]
    Gå tillbaks = Ctrl+o/t :}
    zzzz zzzz zzzz zzzz
    The following commands open the file name under the cursor:
    gf         open in the same window ("goto file")
    +se ev också gF i Vimrecipes
    öppna fil under markören i nytt fönster --- Ctrl-w f
    öppna fil under markören i ny tab :DDDDDD !!! --- Ctrl-w gf
    +se och ev sammanställ med hopp och marks längre ner :]
    öppna mansida för ordet under markören :)
    K
    GRUNDREDIGERARKOMMANDON :)
    o
    spara och stäng fönster = ZZ :DDD
    stäng fönster utan att spara = ZQ :DDD
    i
    a
    mata in 3 utropstecken-tricket :)
    3a!<Esc> :)
    x
    dl
    putta fram ett tecken förbi nästa (teh till the) = xp :)
    d
    dd = sudda en hel rad :)
    7dw = sudda ordet och 6 till höger
    c
    s
    cl
    X
    samma som backspace :DDD
    dh
    D
    d$
    dd
    C
    c$
    S
    cc
    r
    o
    cH
    ändra till toppen
    cL
    ändra till botten
    c+
    [lägg till]
    c5|
    ändra till kol. 5
    dH
    d2)
    2y)
    c{
    ändra till föregående stycke
    xxxx <#ID_677267623>
    o
    PRACTICAL VIM (tecknade pennfiguren :) <../gdrive/PRACTICAL_VIM.pdf>
    1 <#ID_1398700069>
    yyyy
    Practical Vim******::
    / - sök från kommandoraden
    Error setting the text for the following input: = - utvärdera ett vimskript i kommandoradsläge.
    välja inne i en xml-etikett: it :D*******
    Error setting the text for the following input: =till Inkscapekodredigering förmodl..
    Se till att vim startas utan specialinställningar:
    $ vim -u NONE -N
    +fil med:
    set nocompatible
    filetype plugin on
    +$ vim -u code/essential.vim
    :version (kolla vilka features som är inladdade (huge))
    -----------------------------------------------------------
    SUPERKOMMANDO 1:
    .-kommandot(=mikromakro)::
    >G (punkt ökar indrag igen) :D
    +när går in i insert = alla tryckn. sparas +kan sen spelas upp med .
    A:Esc j. :)
    RECEPT s33 ******************
    ++Tips 4: make motion and change repeatable.
    @:
    & (=kör :substitute igen)
    SUPERKOMMANDO 2:
    * + n +. :DD
    THE DOT-FORMULA:: s11
    en flytt + ett utförande/ändring
    ------ Normalmode
    Skriv en el två meningar t ex (en tanke/ansats typ), kika + u om inte nöjd
    +Esc-o-tricket ist.för Return
    Vimgolf och daw
    Höj “0px” till “-180px.” i bit css-kod = 180<C-a> (oavsett var på raden)************
    C-x och oktalt
    (set nrformats=octal mm (blank: allt tolkas decimalt)
    u går förstås också att använda med count :)
    ----
    Combine and conquer::
    daw
    gUaw ******
    dap
    gUap
    Dubblering av operator gör = på hel rad:
    dd, gUU
    s50
    >
    <
    =
    !
    commentary.vim
    textobj-entire
    gg=G
    s51
    Egna operatorpending uttryck :) ??
    " custom mappings that initiate or target Operator-Pending mode."
    <C-h>
    <C-w>
    <C-u>
    Effect
    Delete back one character (backspace)
    Delete back one word
    Delete back to start of line
    <C-[>
    Switch to Normal mode
    <C-o>
    Switch to Insert Normal mode
    C-r + 0 =klistra in just utklippt :)
    The <C-r><C-p>{register} command is smarter. It inserts text literally and fixes
    any unintended indentation (see :h i_CTRL-R_CTRL-P
    The Expressionregister:
    A
    6 chairs, each costing $35, totals $
    <C-r>=6*35<CR>
    6 chairs, each costing $35, totals $210
    If you want to find out the numeric code for any character in your document,
    just place the cursor on it and trigger the ga command. This outputs a mes-
    sage at the bottom of the screen, revealing the character code in decimal and
    hexadecimal notations (see :h ga ).
    <C-k>{char1}{char2}
    Insert character represented by {char1}{char2} digraph
    The character pairs that make up a digraph are chosen to be descriptive,
    making them easier to remember or even guess. For example, the double-
    angle quotation marks « and » are represented by the digraphs << and >>;
    the vulgar (or common) fractions 1⁄2, 1⁄4, and 3⁄4 are represented by the digraphs
    12, 14, and 34, respectively. The default set of digraphs that ship with Vim
    follows certain conventions, which are summarized under :h digraphs-default .
    We can view a list of the available digraphs by running :digraphs, but the output
    of this command is difficult to digest. A more usable list can be found by
    looking up :h digraph-table .
    Virtual replace-mode: s60
    Samma för ett tecken: r och gr
    s63 = Selectmode ***
    gv
    o
    O
    Python och indentering
    When we use the dot command to repeat a Visual mode command, it acts on
    the same amount of text as was marked by the most recent visual selection.
    We can use Ex commands to read and write files (:edit and :write), to create
    tabs (:tabnew) or split windows (:split), or to interact with the argument list
    (:prev/:next) or the buffer list (:bprev/:bnext). In fact, Vim has an Ex command
    for just about everything (see :h ex-cmd-index for the full list).
    In this chapter, we’ll focus mainly on the handful of Ex commands we can
    use to edit text. Table 9, Ex Commands That Operate on the Text in a Buffer,
    on page 52, shows a selection of some of the most useful ones.
    Most of these commands can accept a range. We’ll find out what this means
    in Tip 28, on page 54. The :copy command is great for quickly duplicating a
    line, as we’ll see in Duplicate Lines with the ‘:t’ Command, on page 59. The
    :normal command provides a convenient way to make the same change on a
    range of lines, as we’ll see in Tip 30, on page 61.
    We’ll learn more about :delete, :yank, and :put commands in Chapter 10,
    Copy
    and Paste, on page 141. The :substitute and :global commands are very powerful,
    so they each get a chapter of their own. See Chapter 14, Substitution, on page
    215, and Chapter 15, Global Commands, on page 237.
    gå till rad 1
    :1
    :p
    :3p
    :2,5p
    :2,5d
    :%p
    . These marks persist even when we leave Visual mode. If
    you try running :'<,'>p straight from Normal mode, it will always act on the
    lines that most recently formed a Visual mode selection.
    :/mö/,/mä/p
    :/mö/+1,/mä/-1p
    The general form for an offset goes like this:
    :{address}+n
    If n is omitted, it defaults to 1. The {address} could be a line number, a mark,
    or a pattern.
    Discussion
    The syntax for defining a range is very flexible. We can mix and match line
    numbers, marks, and patterns, and we can apply an offset to any of them.
    This table summarizes a few of the symbols that can be used to create
    addresses and ranges for Ex commands:
    :t och :m
    mer=s83
    (s81)
    Visual + m$
    @:
    If we want to run a Normal mode command on a series of consecutive lines,
    we can do so using the :normal command. When used in combination with the
    dot command or a macro, we can perform repetitive tasks with very little effort.
    jVG +
    :'<,'>normal. ********
    . For example, we could have
    solved the problem above with this single command:
    ➾
    :%normal A;
    The % symbol is used as a range representing the entire file. So :%normal A;
    instructs Vim to append a semicolon at the end of every line of the file. Making
    this change involves switching into Insert mode, but Vim automatically reverts
    to Normal mode afterward
    This single
    command could be used to comment out an entire JavaScript file:
    ➾
    :%normal i//
    :normal @q **************
    :normal @: (??=bör funka va?) :)
    Tab och Ctrl+d *****
    In many scenarios, Vim’s tab-completion does the right thing. If we type a
    command that expects a filepath as an argument (such as :edit or :write), then
    <Tab> will complete directories and filenames relative to the current working
    directory. With the :tag command we can autocomplete tag names. The :set
    and :help commands know about every configuration option in Vim.
    We can even define the tab-completion behavior when creating our own custom
    Ex commands. To see what’s possible, check out :h :command-complete .
    Even in Command-Line mode, Vim always knows where the cursor is positioned
    and which split window is active. To save time, we can insert the current word
    (or WORD) from the active document onto our command prompt.
    At Vim’s command line, the <C-r><C-w> mapping copies the word under the
    cursor and inserts it at the command-line prompt. We can use this to save
    ourselves a bit of typing.
    ****************:DD
    We’ll carry out the remaining changes using a :substitute command. Since our
    cursor is on the word “counter,” we don’t need to type it out again. We can
    just use the <C-r><C-w> mapping to populate the replacement field:
    ➾
    :%s//<C-r><C-w>/g
    That command doesn’t look very succinct when written down, but two
    keystrokes to insert a word ain’t bad. We didn’t have to type the search pattern
    either, thanks to the * command. Refer to Tip 90, on page 220, to see why we
    can leave the search field blank like that.
    For another application, try opening your vimrc file, place your cursor on a
    setting, and then type :help <C-r><C-w> to look up the documentation for that
    setting.
    By default, Vim records the last twenty commands. With memory becoming
    ever cheaper in today’s computers, we can probably afford to up this limit by
    changing the ‘history’ option. Try adding this line to your vimrc:
    set history=200
    We can get the best of both by creating the following custom mappings:
    ex_mode/history-scrollers.vim
    cnoremap <C-p> <Up>
    cnoremap <C-n> <Down>
    q: ************
    :write | !ruby %
    Each of these commands is already in our history, so we shouldn’t have to
    type the entire command line from scratch. But how can we merge two records
    from our history into one? Press q: and meet the command-line window (see
    :h cmdwin ).
    -
    stäng med :q (el ctrl+w-c, ZQ)
    Command
    q/
    q:
    ctrl-f
    Action
    Open the command-line window with history of searches
    Open the command-line window with history of Ex commands
    Switch from Command-Line mode to the command-line window***************
    We can easily invoke external programs without leaving Vim. Best of all, we
    can send the contents of a buffer as standard input to a command or use the
    standard output from an external command to populate our buffer.
    The commands discussed in this tip work best when used from Vim inside a
    terminal. If you’re using GVim (or MacVim), then things may not work quite
    as smoothly. That shouldn’t come as a great surprise. It’s much easier for
    Vim to delegate work to the shell if Vim itself is already running inside a shell.
    GVim does some things better, but this is one area where terminal Vim has
    the edge.
    On Vim’s command line, the % symbol is shorthand for the current file name
    (see :h cmdline-special ). We can exploit this to run external commands that do
    something with the current file. For example, if we’re working on a Ruby file,
    we could execute it by running this:
    ➾
    :!ruby %
    The :!{cmd} syntax is great for firing one-off commands, but what if we want
    to run several commands in the shell? In that case, we can use Vim’s :shell
    command to start an interactive shell session (see :h :shell ):
    ➾
    :shell
    ➾
    $ pwd
    ❮
    /Users/drew/books/PracticalVim/code/ex_mode
    ➾
    $ ls
    ❮
    duplicate.todo
    loop.js
    emails.csv
    practical-vim.html
    foobar.js
    shopping-list.todo
    history-scrollers.vim
    ➾
    $ exit
    Suppose that we’re running Vim inside a bash shell and we want to execute a series
    of shell commands. Pressing Ctrl - z suspends the process that’s running Vim and
    returns control to bash. The Vim process sits idle in the background, allowing us to
    interact with our bash session as normal. We can inspect the list of jobs by running
    this command:
    ➾
    $ jobs
    ❮
    [1]+ Stopped
    vim
    In bash, we can use the fg command to resume a suspended job, bringing it back
    into the foreground. That brings Vim back to life exactly as we left it. The Ctrl - z and
    fg commands are quicker and easier to use than Vim’s equivalent :shell and exit com-
    mands. For more information, run man bash and read the section on job control.
    The :read !{cmd} command lets us direct standard output into a buffer. As you
    might expect, the :write !{cmd} does the inverse: it uses the contents of the buffer as standard input for the specified {cmd} (see :h :write_c ).
    The effect of the :write !sh command is that each line of the current buffer is
    executed in the shell. Refer to :h rename-files for a nice example of this com-
    mand in use.
    ex_mode/emails.csv
    first name,last name,email
    john,smith,john@example.com <mailto:john@example.com>
    drew,neil,drew@vimcasts.org <mailto:drew@vimcasts.org>
    jane,doe,jane@example.com <mailto:jane@example.com>
    We’ll sort the records by the second field: last name. We can use the -t',' option
    to tell the sort command that fields are separated with commas, and we can
    use the -k2 flag to indicate that the second field is to be used for the sort.
    The first line of the file contains header information. We want to leave it at
    the top of the file, so we’ll exclude it from the sort operation by using a range
    of :2,$. This command line does what we want:
    ➾
    :2,$!sort -t',' -k2
    Vim provides a convenient shortcut for setting the range of a :[range]!{filter}
    command such as this. The !{motion} operator command drops us into Com-
    mand-Line mode and prepopulates the [range] with the lines covered by the
    specified {motion} (see :h ! ). For example, if we place our cursor on line 2 and
    then invoke !G , Vim opens a prompt with the :.,$! range set up for us.
    :[range]!{filter}
    Filter the specified [range] through external program {filter}
    5!! =liknande som ovan (tror den skickar aktuell rad +4 till kommandoraden för filtrering) :)
    Vim gives special treatment to some commands. For example, both make and
    grep have wrapper commands. Not only are they easy to execute from inside
    Vim, but their output is parsed and used to populate the quickfix list.
    Bind om.Ctrl+^ (=byt mellan % och #)
    Consider remaps av bn mfl
    :argdo och bufdo
    s101 TimPopes unimpaired.vim
    Error setting the text for the following input: =ger flera bra mappings för bn mfl.
    . If we wanted to delete buffers numbered 5
    through 10 inclusive, we could do so by running :5,10bd . But if we wanted to
    keep buffer number 8, then we’d instead have to run :bd 5 6 7 9 10.
    splitwindows
    tabpages
    the argumentlist
    In Tip 36, on page 77, we saw that the :ls command provides a listing of buffers.
    Now let’s examine the argument list:
    ➾
    :args
    ❮
    [a.txt] b.txt c.txt. d.txt e.txt
    The argument list represents the list of files that was passed as an argument
    when we ran the vim command. In our case, we provided a single argument,
    *.txt, but our shell expanded the * wildcard, matching the five files that we see
    in our argument list. The [] characters indicate which of the files in the
    argument list is active.
    . We can change the contents
    of the argument list at any time, which means that the :args listing doesn’t
    necessarily reflect the values that were passed to the vim command when we
    launched the editor. Don’t take the name literally!
    Populate the Argument List - s103
    Populate the Argument List
    When the :args Ex command is run without arguments, it prints the contents
    of the argument list. We can also set the contents of the argument list using
    this form (:h :args_f ):
    :args {arglist}
    The {arglist} can include filenames, wildcards, or even the output from a shell
    command.
    T ex:
    :args index.html app.js
    Specify Files by Glob
    Wildcards are placeholders that can stand in for characters in the name of a
    file or directory. The * symbol will match zero or more characters, but only
    in the scope of the specified directory (:h wildcard ). The ** wildcard also
    matches zero or more characters, but it can recurse downward into directories
    below the specified directory (:h starstar-wildcard ).
    Glob
    :args *.*
    :args **/*.js
    :args **/*.*
    Files Matching the Expansion
    index.html
    app.js
    app.js
    lib/framework.js
    app/controllers/Mailer.js
    ...etc
    app.js
    index.js
    lib/framework.js
    lib/theme.css
    app/controllers/Mailer.js
    ...etc
    :args **/*.js **/*.css
    As I wrote this book, I sometimes wanted to populate the argument list with
    the chapters in the same order that they appear in the table of contents. For
    this purpose, I maintained a plain-text file that contains one filename per
    line. Here’s an excerpt from it:
    files/.chapters
    the_vim_way.pml
    normal_mode.pml
    insert_mode.pml
    visual_mode.pml
    I can populate the argument list from this file by running this:
    ➾
    :args `cat .chapters`
    Vim executes the text inside the backtick characters in the shell, using the
    output from the cat command as the argument for the :args command.
    The argument list is simpler to manage than the buffer list, making it the
    ideal place to group our buffers into a collection. With the :args {arglist} com-
    mand, we can clear the argument list and then repopulate it from scratch
    with a single command. We can traverse the files in the argument list using
    :next and :prev commands. Or we can use :argdo to execute the same command
    on each buffer in the set.
    The way I see it, the buffer list is like my desktop: it’s always messy. The
    argument list is like a separate workspace that I always keep tidy, just in
    case I need space to stretch out. We’ll see a few examples of how the argument
    list can be used in other tips, such as Tip 69, on page 169, and Tip 96, on page
    233
    Hidden buffers mm: (:cnext??)
    :quit
    :write
    :edit!
    :qall!
    :wall
    :first
    :next
    If we enable the ‘hidden’ setting (see :h 'hidden' ), then we can use the :next,
    :bnext, :cnext (and so on) commands without a trailing bang. If the active buffer
    is modified, Vim will automatically hide it when we navigate away from it.
    The ‘hidden’ setting makes it possible to use :argdo and :bufdo to change a collec-
    tion of buffers with a single command.
    After running :argdo {cmd}, we’ll want to save the changes that were made to
    each item in the argument list. We could do it one at a time by running :first
    and then :wn, which would give us the opportunity to eyeball each file. Or if
    we’re confident that everything is in order, we could run :argdo write (or :wall) to
    save all buffers.
    We can use the :edit command to load another buffer into the active window.
    If we run <C-w>s followed by :edit {filename}, we can divide our workspace and
    then open another buffer in one split window while keeping the existing buffer
    visible in the other split. Alternatively, we could use the command :split {file-
    name}, which combines those two steps into one. This table summarizes the
    ways of dividing our workspace into split windows:
    Command
    <C-w>s
    <C-w>v
    :sp[lit] {file}
    :vsp[lit] {file}
    Effect
    Split the current window horizontally, reusing the current buffer
    in the new window
    Split the current window vertically, reusing the current buffer
    in the new window
    Split the current window horizontally, loading {file} into the new
    window
    Split the current window vertically, loading {file} into the new
    window
    Ex Command
    Normal Command
    Effect
    :cl[ose]
    <C-w>c
    Close the active window
    :on[ly]
    <C-w>o
    Keep only the active window, closing all others
    s110 - :h window-resize . This table summarizes a handful of the most useful
    commands: (men lättast med musen)
    Vim includes commands for rearranging windows, but rather than describing
    them here, I’d like to point you toward a screencast on Vimcasts.org that
    demonstrates the possibilities.1 Y
    1
    <http://vimcasts.org/e/7>
    Tabs = s111********
    The :lcd {path} command lets us set the working directory locally for the current
    window. If we create a new tab page and then use the :lcd command to switch
    to another directory, we can then comfortably scope each tab page to a differ-
    ent project. Note that :lcd applies locally to the current window, not to the
    current tab page. If we have a tab page containing two or more split windows,
    we could set the local working directory for all of them by running :windo lcd
    2
    {path}. Check out episode 9 of Vimcasts for more information.
    ***************
    <http://vimcasts.org/e/9>
    Opening and Closing Tabs
    We can open a new tab page with the :tabedit {filename} command. If we omit
    the {filename} argument, then Vim creates a new tab page containing an
    empty buffer.
    Alternatively, if the current tab page contains more than one window, we can
    use the <C-w>T command, which moves the current window into a new tab
    page (see :h CTRL-W_T ).
    If the active tab page contains only a single window, the :close command will
    close the window and the tab page with it. Or we can use the :tabclose com-
    mand, which closes the current tab page no matter how many windows it contains. Finally, if we want to close all tab pages except for the current one,
    we can use the :tabonly command.
    Command
    :tabe[dit] {filename}
    <C-w>T
    :tabc[lose]
    :tabo[nly]
    Effect
    Open {filename} in a new tab
    Move the current window into its own tab
    Close the current tab page and all of its windows
    Keep the active tab page, closing all others
    Ex Command
    Normal Command
    Effect
    :tabn[ext] {N}
    {N}gt
    Switch to tab page number {N}
    :tabn[ext]
    gt
    Switch to the next tab page
    :tabp[revious]
    gT
    Switch to the previous tab page
    Rearranging Tabs
    We can use the :tabmove [N] Ex command to rearrange tab pages. When [N] is
    0, the current tab page is moved to the beginning, and if we omit [N], the
    current tab page is moved to the end. If your terminal supports the mouse
    or if you’re using GVim, reordering tab pages by drag and drop is also possible.
    zzzz s114
    2
    Practical Vim 2*******::
    :e kan använda relativa sökvägar
    :edit %:h <Tab>
    The %:h expansion is so useful that you might want to consider creating a
    mapping for it. Check out Easy Expansion of the Active File Directory, on page
    95, for a suggestion.
    Easy Expansion of the Active File Directory
    Try sourcing this line in your vimrc file:
    cnoremap <expr> %%
    getcmdtype() == ':' ? expand('%:h').'/' : '%%'
    Now when we type %% on Vim’s : command-line prompt, it automatically expands to
    the path of the active buffer, just as though we had typed %:h <Tab> . Besides working
    nicely with :edit, this can come in handy with other Ex commands such as :write, :saveas,
    and :read.
    For more ideas on how to use this mapping, see the Vimcasts episode on the :edit
    a
    command.a.
    <http://vimcasts.org/episodes/the-edit-command/>
    The ‘path’ option allows us to specify a set of directories inside of which Vim
    will search when the :find command is invoked (see :h 'path' ). In our case, we
    want to make it easier to look up files in the app/controllers and app/views directo-
    ries. We can add these to our path simply by running this:
    ➾
    :set path+=app/**
    The ** wildcard matches all subdirectories beneath the app/ directory. We
    discussed wildcards in Populate the Argument List, on page 81, but the
    treatment of * and ** is slightly different in the context of the ‘path’ setting (see
    :h file-searching ). The wildcards are handled by Vim rather than by the shell.
    Smart Path Management with rails.vim
    Tim Pope’s rails.vim plugin does some clever things to make navigating around a
    Rails project easier.a The plugin automatically configures the ‘path’ setting to include
    all the directories found in a conventional Rails project. This means that we can use
    the :find command without having to worry about setting up the ‘path’.
    But rails.vim doesn’t stop there. It also provides convenience commands, such as
    :Rcontroller, :Rmodel, :Rview, and others. Each of these acts as a specialized version of the
    :find command, scoping its search to the corresponding directory.
    a.
    <https://github.com/tpope/vim-rails>
    netrw
    vim .
    C-R, -(=till mapp ovanför)
    +alla vanliga motionsc
    :e. explorer för cwd
    :E explorer för aktiva bufferns mapp
    **********
    Även :Sexplore and :Vexplore
    if we decide that we want to switch back to the
    buffer we were already editing, we can do so using the <C-^> command.
    The netrw plugin doesn’t just let us explore the file system. We can create
    new files (:h netrw-% ) or directories (:h netrw-d ), rename existing ones
    (:h netrw-rename ), or delete them (:h netrw-del ). For a demonstration, watch
    episode 15 of Vimcasts.1
    <http://vimcasts.org/e/15>
    We haven’t even touched on the killer feature that gives the plugin its name:
    netrw makes it possible to read and write files across a network. The plugin
    can use many protocols, including scp, ftp, curl, and wget, depending on what’s
    available on your system. To find out more, look up :h netrw-ref .
    :edit madeup/dir/doesnotexist.yet
    :!mkdir -p %:h
    :write
    The -p flag tells mkdir to create intermediate directories. See Open a File Relative
    to the Active File Directory, on page 95,
    ev remap av Go
    :w !sudo tee % > /dev/null
    -------
    Vim has a vast number of motions. We can’t cover them all in this chapter,
    so I recommend that you look up the :h motion.txt
    noremap <Up> <Nop>
    m fl g0 och g$
    nnoremap k gk
    nnoremap gk k
    nnoremap j gj
    nnoremap gj j
    w
    b
    e
    ge
    W , B , E , and gE
    Don’t Throw Away the Reverse Character Search Command
    Vim assigns a function to almost every key on the keyboard. If we want to create our
    own custom mappings, which keys should we bind them to? Vim provides the <Leader>
    key as a namespace for our own user-defined commands. Here is how we can create
    our own custom mappings using <Leader> :
    noremap <Leader>n nzz
    noremap <Leader>N Nzz
    The default leader key is \ , so we could trigger these custom mappings by pressing
    \n and \N . If you want to know what these mappings do, look up :h zz .
    On some keyboards, the \ command is inconvenient to reach, so Vim makes it easy
    to set the leader key to something else (see :h mapleader ). A common choice is to set
    the comma key as leader. If you take this route, I strongly recommend mapping the
    reverse character search command to another key. Here’s an example:
    let mapleader=","
    noremap \ ,
    The ; and , commands complement each other. If you take one of them away, then
    the whole family of character search commands becomes much less useful.
    dt.
    f;-pair och /n-pair
    Here, we use the /ge <CR> search motion to tell the d{motion} command what
    to delete. The search command is an exclusive motion. That means that even
    though our cursor ends up on the “g” at the start of the word “gets,” that
    character is excluded from the delete operation (see :h exclusive ).
    ab (, aB krull, och at tags ************
    d, c och y
    textobjects: i/aw,s,p
    Keystrokes
    Buffer Contents
    ``
    Position before the last jump within current file
    `.
    Location of last change
    `^
    Location of last insertion
    `[
    Start of last change or yank
    `]
    End of last change or yank
    `<
    Start of last visual selection
    `>
    End of last visual selection
    ******
    Vim provides a motion that lets us move between opening and closing pairs of
    parentheses. By enabling the matchit.vim plugin, we can extend this behavior
    to work on pairs of XML tags as well as on keywords in some programming
    languages.
    ******
    Error setting the text for the following input: =se s147-148.
    Ändra matchande måsvingar till klamrar-tricket med %
    +++
    Note that in this case, the <C-o> command would work just as well as the ``
    motion (see Tip 55, on page 131). The surround.vim plugin provides commands
    that would make this task even easier. Find out more in Surround.vim, on
    page 129.
    Error setting the text for the following input: =se s148*****.
    Jumps::
    Ctrl+o, Ctrl+i
    :jumps
    <C-]> - Jump to definition of keyword under the cursor (m fl)
    Vim can maintain multiple jump lists at the same time. In fact, each separate
    window has its own jump list. If we’re using split windows or multiple tab
    pages, then the <C-o> and <C-i> commands will always be scoped to the jump
    list of the active window.
    uCtrl+r (=tillb. till senaste ändring)
    changelist och :changes :)
    Using the g; and g, commands, we can traverse backward
    and forward through the change list.
    To jump back to the most recent modification in the document, we press g; .
    That places the cursor back on the line and column where it ended up after
    the previous edit. The result is the same as if we had pressed u<C-r> , except
    that we don’t make any transitory changes to the document.
    The `. mark always references the position of the last change (:h `. ),
    while the `^ mark tracks the position of the cursor the last time that Insert
    mode was stopped
    If we leave Insert mode and then scroll around the document,
    we can quickly carry on where we left off by pressing gi (:h gi ).
    Vim treats filenames in our document as a kind of hyperlink. When configured
    properly, we can use the gf command to go to the filename under the cursor.
    , I recommend using the -u NONE -N flags to ensure
    that Vim starts up without loading any no plugins:
    :set suffixesadd+=.rb (i detta fallet)
    +Ctrl+o och Ctrl+i ************
    Specify the Directories to Look Inside
    In this example, each of the files referenced with the require statement was
    located relative to the working directory. But what if we referenced function-
    ality that was provided by a third-party library, such as a rubygem?
    That’s where the ‘path’ option comes in (:h 'path' ). We can configure this to
    reference a comma-separated list of directories.
    We can inspect the value of the path by running this command:
    ➾
    :set path?
    ❮
    path=.,/usr/include,,
    For example, it would be useful if the ‘path’ included the directories for all
    rubygems used in a Ruby project. Then we could use the gf command to
    open up the modules referenced by any require statements. For an automated
    solution, check out Tim Pope’s bundler.vim plugin,1 which uses the project
    Gemfile to populate the ‘path’ setting.
    The ‘suffixesadd’ and ‘path’ options can be set locally for each buffer, so they can
    be configured in different ways for different file types. Vim is distributed with
    file-type plugins for many other languages besides Ruby, so in practice you
    won’t often have to set these options yourself. Even so, it’s worth understand-
    ing how the gf command works. It makes each filepath in our document
    behave like a hyperlink, which makes it easier to navigate through a codebase.
    1
    2
    <https://github.com/tpope/vim-bundler>
    <https://github.com/vim-ruby/vim-ruby>
    While the jump list and change list are like breadcrumb trails that allow us
    to retrace our steps, the gf and <C-]> commands provide wormholes that
    transport us from one part of our codebase to another.
    mark + `{letter}**
    . By default, global marks are
    persisted between editing sessions (although this behavior can be configured;
    see :h 'viminfo' ). Now you can always open up your vimrc file with two
    keystrokes
    Global marks can be especially useful when we need to browse through a set
    of files and then quickly snap back to where we started.*****
    *********
    :vimgrep /fooBar/ **
    By default, :vimgrep jumps directly to the first match that it finds, which could
    mean switching to another file. At this point, we can use the <C-o> command
    to get back to where we were prior to running :vimgrep.
    Try to get into a habit of setting a global mark before using any commands
    that interact with the quickfix list, such as :grep, :vimgrep, and :make. The same
    goes for the commands that interact with the buffer and argument lists, such
    as :args {arglist} and :argdo (see Tip 37, on page 80).
    Delete, yank and put::
    Not clobbering unnamed register = "_d *****
    . We could cut the current line into register
    c by running :delete c, and then we could paste it below the current line with
    the :put c command. These may seem verbose in comparison with the Normal
    mode commands, but they’re useful in combination with other Ex commands
    and in Vim scripts. For example, Tip 99, on page 240, shows how :yank can be
    used with the :global command.
    The Unnamed Register ("")
    The Yank Register ("0)
    When we use the y{motion} command, the specified text is copied not only
    into the unnamed register but also into the yank register, which is addressed
    by the 0 symbol (see :h quote0 ).
    ***************
    :reg (registers) ****
    "* och middle-mouse :)
    Vim can be compiled with or without support for X11 clipboard integration.
    To find out whether your version of Vim has the feature enabled, run the
    :version command and look for xterm_clipboard. If it’s prefixed with a minus sign,
    then your version of Vim does not support this feature. A plus sign means
    that the feature is available.
    The Expression Register ("=)
    Vim’s registers can be thought of simply as containers that hold a block of
    text. The expression register, referenced by the = symbol (:h quote= ), is an
    exception. When we fetch the contents of the expression register, Vim drops
    into Command-Line mode, showing an = prompt. We can enter a Vim script
    expression and then press <CR> to execute it. If the expression returns a string
    (or a value that can be easily coerced into a string), then Vim uses it.
    For examples of the expression register in action, check out Tip 16, on page
    31, Tip 95, on page 230, Tip 94, on page 229, and Tip 70, on page 174.
    ***************** SE MER !
    In addition, Vim provides a handful of
    registers whose values are set implicitly. These are known collectively as the
    read-only registers (:h quote. ). The following table summarizes them:
    Register
    "%
    "#
    ".
    ":
    "/
    Contents
    Name of the current file
    Name of the alternate file
    Last inserted text
    Last Ex command
    Last search pattern
    Technically, the "/ register is not read-only—it can be set explicitly using the
    :let command (see :h quote/ )—but it’s included in this table for convenience.
    Clobber visual selection with conts of the unnamed register
    ++??
    ****
    Keystrokes
    Buffer Contents
    {start}
    I like chips and fish.
    fc
    I like chips and fish.
    de
    I like
    and fish.
    mm
    I like
    and fish.
    ww
    I like
    and fish.
    ve
    I like
    and fish.
    p
    I like
    and chips.
    `m
    I like
    and chips.
    P
    I like fish and chips.
    In this case, it would be quicker to delete “chips and fish” and then type out
    “fish and chips” instead, using the c3w command for example. But this same
    technique can also be used to swap the order of longer phrases.
    When pasting from a line-wise register, the p and P commands put the text
    below or above the current line. This is more intuitive than the character-wise
    behavior.
    It’s worth noting that Vim also provides gp and gP commands. These also put
    the text before or after the current line, but they leave the cursor positioned
    at the end of the pasted text instead of at the beginning. The gP command is
    especially useful when duplicating a range of lines, as demonstrated here:
    +html-table-exemplet s170**
    Paste from systemclipboard i standard-vim
    When the ‘paste’ option is enabled,
    Vim turns off all Insert mode mappings and abbreviations and resets a host
    of options, including ‘autoindent’ (look up :h 'paste' for the full list). That allows
    us to safely paste from the system clipboard with no surprises.
    When we’re finished using the system paste command, we should disable the
    ‘paste’ option again. That means switching back to Normal mode and then
    running the Ex command :set paste!. Don’t you think it would be handy if there
    were a way of toggling this option without leaving Insert mode?
    The way that Vim behaves when ‘paste’ is enabled means that the usual
    methods for creating custom mappings won’t work in Insert mode. Instead,
    we can assign a key to the ‘pastetoggle’ option (:h 'pastetoggle' ):
    ➾
    :set pastetoggle=<f5>
    Macros::
    Spela in en punktformel som ett one off-makro *** s180
    Kör makro på flera heterogena rader (som kan bryta makrot) med
    :'<,'>normal @a ********* = köra i kedja som kan sen innan ELLER (då) parallellt :
    If we type qa , then Vim will record our keystrokes, saving them into register
    a by overwriting the existing contents of that register. If we type qA , then Vim
    will record our keystrokes, appending them to the existing contents of register
    a. We can amend our mistake: s186
    s187
    Source these lines of configuration to reproduce the examples in this tip:
    macros/rc.vim
    set nocompatible
    filetype plugin indent on
    set hidden
    if has("autocmd")
    autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
    endif
    Mer om :args (mest repetition) :D s187
    Köra makro över flera filer - s187+ ****
    To prevent this, we’ll revert all of the changes we just made to the first buffer
    in the argument list by running :edit! (see :h :edit! ):
    ➾
    :edit!
    Now we can go ahead and execute the macro in all of the buffers in the
    argument list:
    ➾
    :argdo normal @a
    +att istället lägga till :next som sista steg och skippa :e
    :argdo write och :wall (och :wnext)
    + :argdo normal @a (=kör parallellt över filer)
    We can do that
    using the expression register. In Tip 16, on page 31, we saw that the expres-
    sion register can be used to do simple sums and to insert the result into the
    document. We can insert the value stored in variable i just by running
    <C-r>=i<CR> in Insert mode.
    :put a
    . For example, we
    could use the substitute() function (which is not the same as the :substitute com-
    mand! See :h substitute() ) to perform the same edit as before:
    ➾
    :let @a=substitute(@a, '\~', 'vU', 'g')
    :substitute, which allows us to
    find occurrences of one pattern and replace them
    with something else, and :global , which lets us run
    any Ex command on each line that matches a par-
    ticular pattern.
    Patterns:: s198
    very magic, very nomagic
    Note that these items can be used anywhere in a pattern. If you realize that you need a case sensitive search after you typed out the full pattern, just tack \C on at the end, and it will affect everything that went before it. *****
    smartcase
    lösning på grundinställningen magic (som kräver många backslashtecken)
    /\v#([0-9a-fA-F]{}|[0-9a-fA-F]{})
    (=very magic ger perl/python/ruby-lik syntax)
    /\v#(\x{}|\x{}) ********
    Use the \V Literal Switch for Verbatim Searches.
    The special characters used for defining regular expressions are handy when searching for patterns, but they can get in the way if we want to search for text verbatim. Using the verynomagic literal switch, we can cancel out most of the special meanings attached to characters such as ., *, and ?.
    /\Va.k.a.<CR>
    As a general rule, if you want to search for a regular expression, use the \v pattern switch, and if you want to search for verbatim text, use the \V literal switch.
    Here’s a regular expression that matches duplicate words:
    ➾
    /\v<(\w+)\_s+\1>
    Now try searching for this pattern on the springtime excerpt, and you should
    see “the the” light up as a search match. Now try joining the two lines
    together ( vipJ will do it), and you should find that it still matches. Best of all,
    this pattern doesn’t just match “the the,” it works for any pair of duplicate
    words.
    There aren’t many scenarios where submatches are useful in a search pattern.
    One more example springs to mind: matching opening and closing pairs of
    XML or HTML tags. But as we’ll see in Tip 93, on page 228, we can also use
    submatches in the replacement {string} of the :substitute command.
    Combining these, we could approximate the < item as \W\zs\w, and the > item
    as \w\ze\W.
    Stake the Boundaries of a Match - s207
    Sometimes we might want to specify a broad pattern and then focus on a subset of the match. Vim’s \zs and \ze items allow us to do just that.
    Here’s another example, this time using both \zs and \ze to tweak the start
    and end of the match:
    Keystrokes
    {start}
    /\v"[^"]+" <CR>
    /\v"\zs[^"]+\ze"<CR>
    Buffer Contents
    Match "quoted words"---not quote marks.
    Match "quoted words"---not quote marks.
    Match "quoted words"---not quote marks.
    We can tell Vim not to bother assigning it to the \1 register by prepending a % in front
    of the parentheses, like this:
    What difference does this make? Well, it’s a smidge faster, not that you’re likely to
    notice. But it can be useful if you find yourself using several sets of parentheses.
    Suppose we wanted to replace all occurrences of FIRSTNAME LASTNAME with LASTNAME,
    FIRSTNAME for both forms of my name. We could do so like this:
    ➾
    /\v(%(And|D)rew) (Neil)
    ➾
    :%s//\2, \1/g
    The search pattern assigns either “Andrew” or “Drew” to capture register \1 and assigns
    “Neil” to register \2. If we hadn’t used %() for the second set of parentheses, then it
    would have captured a fragment of text unnecessarily, cluttering up our replacement
    field.
    Instead of using \zs and \ze, we could rewrite the /\v"\zs[^"]+\ze" <CR> pattern from Tip
    77, on page 192, using Vim’s positive lookaround items, like so:
    ➾
    /\v"@<=[^"]+"@=
    Advanced: s209
    Suppose that we want to search for all instances of the URL http://vim-doc.net/search?q=/\\. Rather than typing it out in full, we’ll just yank it into a register so that we can paste it into our search field. We want to match this text exactly as is, so we’ll use the \V literal switch.
    In our example text, we’re searching for a URL that includes two consecutive
    backslashes. We have to include two backslashes in the search field for each
    of them. Searching forward, we end up with this:
    ➾
    /\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\
    At last! Our search query matches the entire URL:
    Escaping characters by hand is laborious, error-prone work. Fortunately,
    Vim script includes a library function that can do the hard work for us:
    escape({string}, {chars}) (see :h escape() ).
    s211
    In Vim script, the . operator performs string concatena-
    tion, *************
    212, Gvim och :promptfind
    s213
    Search
    Having studied Vim’s regular expression engines in the previous chapter, let’s
    see how we can put them to use with the search command. We’ll start with
    the basics: how to execute a search, highlight matches, and jump between
    them. Then we’ll learn a couple of tricks that exploit Vim’s incremental search
    feature, which not only gives us instant feedback but can also save us typing
    by autocompleting our match. We’ll also learn how to count the number of
    matches that occur in a document.
    Composing a regular expression—and getting it right—often takes a few
    attempts, so developing a workflow that allows us to iterate on a pattern is
    important. We’ll learn about two methods for doing this: calling up our search
    history and working in the command-line window.
    Have you ever wished for a simple way of searching for text that’s already
    present in your document? We’ll finish by devising a simple customization
    that overrides the * command to search for the current visual selection.
    /+Enter =samma mönster för sökning igen=även efter '?' :D **********
    In Tip 84, on page 206, we’ll meet a more complex example where we change
    the offset each time we repeat a search. (//e tex)
    hlsearch' causes all matches
    to be highlighted throughout the active document as well as in any other open
    split windows.
    we could run :set nohlsearch to disable the feature entirely (:se
    nohls and :se hls! also work).
    Create a Shortcut to Mute Highlighting
    Typing :noh <CR> to mute search highlighting is laborious. We can speed things up by
    creating a mapping such as this:
    nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>
    Normally, <C-l> clears and redraws the screen (see :h CTRL-L ). This mapping builds
    on top of the usual behavior by muting search highlighting.
    S216********SE MER
    Vim’s search command is much more useful when the incremental search feature
    is enabled. Here are a couple of ways that this option can improve your work-
    flow.
    Esc eller CR
    Of course, we could simply type out the “carrot” in full. But here’s a handy
    shortcut: <C-r><C-w> . This autocompletes the search field using the remainder
    of the current preview match. If we used this command after entering “carr”
    into the search field, it would append “ot,” causing the match to encompass
    the entire word “carrot.”
    Note that the <C-r><C-w> autocompletion is slightly brittle in this context. If
    you prefix your search with the \v item, then <C-r><C-w> will complete the entire
    word under the cursor (creating /\vcarrcarrot <CR> , for example) instead of the
    remainder of the word. As long as you are searching for words and not
    patterns, the autocomplete feature of incremental search can be a nice little
    time-saver.
    There’s no way of making the search command report the number of matches
    in the current document. But here’s a command that does:
    ➾
    :%s///gn
    ❮
    117 matches on 65 lines
    *********
    ea
    /lang/e -exemplet ******
    In the real world, it won’t always be obvious when a search offset will come
    in handy. Suppose that we started off by executing the search command
    without the offset. Then, after pressing n a couple of times, we realize that
    we’d prefer to place the cursor at the end of the match. That’s no problem:
    we could simply run //e <CR> . When we leave the search field blank like this,
    Vim reuses the pattern from the previous search. So this repeats the last
    search but with an offset.
    To begin with, we write a regular expression to match either “Xml” or “Xhtml.”
    That’s easy enough: /\vX(ht)?ml\C <CR> does the job.
    The \C item enforces case
    sensitivity, so this should work regardless of whether ‘ignorecase’ and/or
    ‘smartcase’ are enabled. A
    (+RESTEN PÅ S222**********************)
    [ A Text Object for
    Search Matches, on page 209, discusses a more optimal solution, which requires
    a plugin.]
    BLUE, S223 (ny plugin för ovan)
    Create Complex Patterns by Iterating upon Search History ***********
    This is our final
    pattern:
    ➾
    /\v'(([^']|'\w)+)'
    We could either run /<Up> and edit the search field, or we could run q/ and
    make the change in the command-line window. Use whichever you feel is
    more appropriate. The search highlighting won’t look any different from the
    last time, but for each match, the text inside quotes will be assigned to the
    \1 capture register. That means we can run the following substitute command:
    ➾
    :%s//“\1”/g
    What we’ve done here is effectively identical to this:
    ➾
    :%s/\v'(([^']|'\w)+)'/“\1”/g
    Would you trust yourself to type that out correctly in one go?
    Don’t worry about getting a search pattern right the first time. Vim keeps our
    most recent search pattern two keystrokes away, so it’s easy to refine a pat-
    tern. Start with a broad match; then take as many steps as you need to focus
    on your target.
    Being able to edit the command line directly is great for simple edits. If we
    have the ‘incsearch’ setting enabled, then we get the added bonus of live feedback
    as we edit the command line. We lose this perk as soon as we call up the
    command-line window. But with the full power of Vim’s modal editing at our
    fingertips, this is a fair trade-off.
    In Normal mode, the * command lets us search for the word under the cursor.
    Using a small amount of Vim script, we can redefine the * command in Visual
    mode so that, instead of searching for the current word, it searches for the
    current selection.
    s226
    It always felt to me
    that triggering the * command from Visual mode should search for the current
    selection, not the current word. With a small amount of Vim script, we can
    add this feature to Vim.
    :vmap X y/<C-R>"<CR>
    (+hela visual star-search-plugin)
    (((zzzz=s229)))
    3
    Practical Vim 3:: *************
    The substitute command has many parts to it. The rules for the [range] are
    just the same as for every other Ex command, which we covered in-depth in
    Tip 28, on page 54.
    If we run the substitute command using a pattern that has no matches in
    the current file, Vim will report an error saying “E486: Pattern not found.”
    We can silence these errors by including the e flag, as we’ll see in Tip 96, on
    page 233.
    The & flag simply tells Vim to reuse the same flags from the previous substitute
    command. Tip 92, on page 224, shows a scenario where it comes in handy.
    \r
    \t
    \\
    \1
    \2
    \0
    &
    ~
    \={Vim script}
    Represents
    Insert a carriage return
    Insert a tab character
    Insert a single backslash
    Insert the first submatch
    Insert the second submatch (and so on, up to \9)
    Insert the entire matched pattern
    Insert the entire matched pattern
    Use {string} from the previous invocation of :substitute
    Evaluate {Vim script} expression; use result as replacement
    {string}
    The \={Vim script} token is very powerful. It allows us to execute code and use
    the result as our replacement {string} ************
    Substitutemetoden eller punktmetoden - Välj vad som känns bäst :)
    ➾
    :%s/\v'(([^']|'\w)+)'/“\1”/g
    It’s equivalent to these two separate commands:
    ➾
    /\v'(([^']|'\w)+)'
    ➾
    :%s//“\1”/g
    So what? One way or another, we’ll still have to type out the full pattern,
    right? That’s not the point. The substitute command involves two steps:
    composing a pattern and devising a suitable replacement string. This tech-
    nique allows us to decouple those two tasks.
    ****************
    Besides, who says we have to type out the pattern? In Tip 86, on page 212, we
    used a smidgen of Vim script to add a Visual mode equivalent of the * com-
    mand. This mapping allows us to select any text in our document and then
    hit the * key to search for the selection. We could then run the substitute
    command with an empty search field to replace our selection (and any similar
    matches) with something else. Talk about being lazy!
    I’m not saying that you should never fill out the search field of the substitute
    command. Here, for example, we have a substitute command that joins every
    line of a file by replacing newlines with commas:
    ➾
    :%s/\n/,
    It’s such a simple command that you won’t gain anything by splitting it in
    two. In fact, doing so would probably add work.
    If you think that you’ll want to recall a substitute command in its complete
    form from history, you can always fill out the search field explicitly. Pressing
    <C-r>/ at the command line pastes the contents of the last search register in
    place. Typing out the following would create a complete entry in our command
    history:
    ➾
    :%s/<C-r>//“\1”/g
    If the text in register 0 contains any characters that have special meaning
    within the replacement field (such as & or ~, for example), we would have to
    edit the string by hand to escape those characters. Also, if register 0 contained
    a multiline excerpt of text, it might not fit on the command line.
    To avoid these problems, we could simply pass a reference to the register
    containing the text we want to use in the substitution field.
    Pass by Reference
    Suppose that we’ve yanked a multiline selection of text, and it’s stored in
    register 0. Now we want to use that text as the replacement field of the sub-
    stitute command. We could do so by running this:
    ➾
    :%s//\=@0/g <mailto:=@0>
    In the replacement field, the \= item tells Vim to evaluate a Vim script
    expression. In Vim script, we can reference the contents of a register as
    @{register}. @0 returns the contents of the yank register, while @" returns the
    contents of the default register. So the expression :%s//\=@0/g tells Vim to <mailto:=@0>
    substitute the last pattern with the contents of the yank register.
    ➾
    :%s/Pragmatic Vim/Practical Vim/g
    Compare it with this sequence of commands:
    ➾
    :let @/='Pragmatic Vim'
    ➾
    :let @a='Practical Vim'
    ➾
    :%s//\=@a/g <mailto:=@a>
    :let @/='Pragmatic Vim' is a programmatic way of setting the search pattern. It
    has the same effect as executing the search /Pragmatic Vim <CR> (except that
    running :let @/='Pragmatic Vim' does not create a record in the search history).
    We could exploit this. We could search for the text we want to act upon and
    yank its replacement into register a. Then we could replay the :%s//\=@a/g <mailto:=@a>
    command, and it would use the values of @/ and @a that we had just prepared.
    Next we could search for something else and yank another replacement string
    into register a, and when we replayed the :%s//\=@a/g command, it would do <mailto:=@a>
    something else entirely.
    Try it out. You might love it or you might hate it. But either way, it’s a pretty
    neat trick!
    Suppose that we’ve just executed this command, which acts upon the current
    line:
    ➾
    :s/target/replacement/g
    We realize our mistake at once: we should have prepended %. No harm done.
    We can repeat the command across the entire file just by pressing g& (see
    :h g& ), which is equivalent to running the following:
    ➾
    :%s//~/&
    The :&& command requires some explanation, since the first and second &
    symbols have different meanings. The first one forms the :& Ex command,
    which repeats the last :substitute command (see :h :& ), while the second one
    indicates that the flags from the previous :s command should be reused.
    Discussion
    We can always specify a new range and replay the substitution using the :&&
    command. It doesn’t matter what range was used the last time. :&& by itself
    acts on the current line, :'<,'>&& acts on the visual selection, and :%&& acts
    on the entire file. As we saw already, the g& command is a handy shortcut
    for :%&&.
    Fixing the & Command
    The & command is a synonym for :s, which repeats the last substitution. Unfortunately,
    if any flags were used, the & command disregards them, meaning that the outcome
    could be quite different from the previous substitution.
    Making & trigger the :&& command is more useful. It preserves flags and therefore
    produces more consistent results. These mappings fix the & command in Normal
    mode and create a Visual mode equivalent:
    nnoremap & :&&<CR>
    xnoremap & :&&<CR>
    Now suppose that we want to swap the order of the fields so that the email
    comes first, then the first name, and finally the last name. We could use this
    substitute command to do it:
    ➾
    ➾
    /\v^([^,]*),([^,]*),([^,]*)$
    :%s//\3,\2,\1
    Perform Arithmetic on the Replacement
    The replacement field needn’t be a simple string. We can evaluate a Vim script
    expression and then use the result as the replacement string. Thus with a single
    command, we can promote every HTML header tag in a document.
    We’ll harness the substitute command to do it. Here’s the general idea: we
    write a pattern that matches the numeral portion of HTML header tags. Then
    we write a substitute command that uses a Vim script expression to subtract
    one from the number that was captured. When we run the substitute com-
    mand globally across the entire file, all HTML header tags will be changed
    with that single command.
    We only want to match the ones that
    immediately follow <h or </h. This pattern should do the trick:
    ➾
    /\v\<\/?h\zs\d
    s246 - abolish.vim mm *******
    250++ Qargs :)
    We can invert the behavior of the :global command either by running :global! or
    :vglobal (mnemonic: invert). Each of these tells Vim to execute [cmd] on each
    line that doesn’t match the specified pattern.
    Combining the :global and :delete commands allows us to cut down the size of a
    file rapidly. We can either keep or discard all lines that match a {pattern}.
    :g/TODO
    ➾
    :g/TODO/yank A
    ➾
    :reg a
    We could even combine the :global command with either :bufdo or :argdo to collect
    all TODO items from a set of files. I’ll leave that as an exercise for you, but
    look to Tip 96, on page 233, for a hint at the workflow.
    aOne of my favorite plugins from Tim Pope is called Abolish.
    Search across multiple files mm:
    ➾
    :argdo %s//Practical/ge
    ➾
    /Pragmatic\ze Vim
    ➾
    :vimgrep /<C-r>// **/*.txt
    Pressing <C-r>/ inserts the last search pattern.
    Each match returned by vimgrep is recorded in the quickfix list (see Chapter 17, Compile Code and Navigate Errors with the Quickfix List, on page 259). We can browse the results by running :copen, which opens the quickfix window. But instead of stepping through the results, one at a time, we want to run the substitute command on every file that appears in the quickfix list.
    It would be convenient if Vim included a :quickfixdo command, but there is no such thing. So instead we’ll use this small snippet of Vim script: s249
    Note that the last three commands could be combined into one,
    like this:
    ➾
    :Qargs | argdo %s//Practical/g | update
    The [cmd] could be any Ex command except for another :global command. In
    practice, Ex commands that interact with the text in the document prove
    most useful, such as those in Table 9, Ex Commands That Operate on the Text
    in a Buffer, on page 52. If we don’t specify a [cmd], then Vim will use :print by
    default.
    We can invert the behavior of the :global command either by running :global! or
    :vglobal (mnemonic: invert).
    Combining the :global and :delete commands allows us to cut down the size of a
    file rapidly. We can either keep or discard all lines that match a {pattern}.
    So if we can devise a pattern that matches HTML tags, we could use it with
    the :global command to reject any lines that match the pattern.
    These commands would do the trick:
    ➾
    /\v\<\/?\w+>
    ➾
    :g//d
    :v/href/d
    :g/TODO
    We’ll use the a register. First we’ll need to clear it by running qaq .
    ➾
    :g/TODO/yank A
    ➾
    :reg a
    but in Vim it actually shows a ^J symbol
    for newlines.)
    We could even combine the :global command with either :bufdo or :argdo to collect
    all TODO items from a set of files. I’ll leave that as an exercise for you, but
    look to Tip 96, on page 233, for a hint at the workflow.
    Here’s an alternative solution:
    ➾
    :g/TODO/t$
    Sort Properties for Every Block of Rules
    We can sort the properties for every block of rules in the file with a single
    :global command. Say we run this command on our style sheet:
    ➾
    :g/{/ .+1,/}/-1 sort
    The [range] for our [cmd] can be set dynamically using the match from :g/{pattern}
    as a reference point. Normally the . address stands for the line that the cursor
    is positioned on. But in the context of a :global command, it stands for each
    line in turn that matches the specified {pattern}.
    We can break our command into two separate Ex commands. Let’s work our
    way backward from the end. This is a valid Ex command:
    ➾
    :.+1,/}/-1 sort
    :.+1,/}/-1 sort
    That places our cursor at the top of a {} block, right where we need it. Now
    let’s put our :global and [cmd] Ex commands back together:
    ➾
    :g/{/ .+1,/}/-1 sort
    Note that the :> command echoes a message each time it is invoked, whereas
    :sort doesn’t. We can mute these messages by prefixing our [cmd] with :silent
    (see :h :sil ):
    ➾
    :g/{/sil .+1,/}/-1 >
    s261
    CHAPTER 16
    Index and Navigate
    Source Code with ctags
    Vim’s ctags support allows us to navigate around a codebase by quickly
    jumping to definitions of functions and classes.
    As a secondary benefit, we can also use the output from ctags to
    generate a word list for autocompletion, a
    ➾
    $ sudo apt-get install exuberant-ctags
    Tell Vim Where to Find the Tags File
    The ‘tags’ option specifies where Vim should look to find a tags file (:h 'tags' ).
    When ./ is used in the ‘tags’ option, Vim replaces it with the path of the cur-
    rently active file. We can inspect the defaults:
    ➾
    :set tags?
    ❮
    tags=./tags,tags
    With these settings, Vim looks for a tags file in the directory of the current file
    and in the working directory. U
    We can invoke ctags directly from Vim by running the following:
    ➾
    :!ctags -R
    :nnoremap <f5> :!ctags -R<CR>
    That lets us rebuild the index just by pressing the <F5> key, but we still have
    to remember periodically to generate the tags file. Now let’s consider a couple
    of options for automating this process.
    Automatically Execute ctags Each Time a File is Saved
    Vim’s autocommand feature allows us to invoke a command on each occur-
    rence of an event, such as a buffer being created, opened, or written to file.
    +++Git-integrering mm
    Re-indexing our codebase on each commit strikes a good balance. Sure, the
    tags file might fall out of step with our working copy, but the errors are toler-
    able.
    S269 - Navigating code mm*******
    Compile Code and Navigate Errors
    with the Quickfix List
    Vim’s quickfix list is a core feature that allows us to integrate external tools
    into our workflow. At its simplest, it maintains a sequence of annotated
    addresses comprising the filename, line number, column number (optional),
    and a message. Traditionally, these addresses would be a list of error messages
    generated by a compiler, but they could just as well be warnings from a syntax
    checker, linter, or any other tool that emits such output.
    We’ll start off by looking at an example workflow: running make in an external
    shell and navigating to error messages by hand. Then we’ll introduce the :make
    command, seeing how it can streamline our workflow by parsing error mes-
    sages from the compiler and making them navigable in the form of the
    quickfix list.
    Compile the Project from Inside Vim
    s271
    :make, och förberedelser inför mm :]
    ➾
    :args $VIMRUNTIME/compiler/*.vim
    One down side to using external programs is that their regex syntax may be
    incompatible with the one we use for most Vim searches. We’ll see that the
    :vimgrep command allows us to use Vim’s native search engine to find patterns
    in multiple files. This convenience comes at a cost: vimgrep isn’t nearly as fast
    as dedicated programs.
    284 = VIMGREP **********
    S289 *******
    S290 ************
    Filenamecompletion + :cd - *******
    s296 - OMNICOMPLETION
    s298 Spellcheck
    s306 (set settings)*****
    s307 ++++
    zzzz=s307
    o
    TIPS, TRICKS OCH BÄSTAKOMMANDON! :D <#ID_1195520506>
    några nya länkar:
    vimtips (essential vim) <http://www.pixelbeat.org/vim.tips.html>
    o
    gå direkt till nån av nio sessionerna innan nuvarande = '1-'9 :D
    BÄSTABÄSTA :]
    grundmärken :)
    ] - slut av senaste ändring
    " - markörposition när senast ändrade filen
    . - pos. där senaste ändring gjordes
    )
    }
    block
    t - (tagblocks = < > )
    b - ( )
    B - { }
    a"
    a'
    a`
    a<
    a]
    1: /four  2:cw five  3:n  4:.  :DDDD
    mata in unicodetecken/specialtecken :DD
    Testa: mata in Enter som tecken (med t ex Ctrl+v (???)) för att kunna lägga flerradstext i ett register %]
    mata in unicode-tecken
    mata in Del m fl tecken via siffror - ctrl+v 127
    mata in hexadecimala tecknet x7f - ctrl+v x7f
    mata in oktala tecken - ctrl+v o123
    Error setting the text for the following input: =Ctrl+v u +unicode-tal :).
    u1234
    Error setting the text for the following input: =16-bit.
    U12345678
    Error setting the text for the following input: =32-bit.
    o
    Digraphs (t ex copywrighttecknet) - ctrl+k Co
    se vilka digraphs som är tillgängliga - :digraphs
    +s125
    öppna fil under markören i ny tab :DDDDDD !!! --- Ctrl-w gf
    Ändra färgschema :D ***
    o
    förena rader (i exemplet, blanka rader)
    :g/./,/^$/join
    gå direkt till senaste sessionen :D == '0 (klar2014)
    o
    klistra in senast kopierade (med y t.ex.) med Ctrl+r när i insertmode (klar2014)
    Ctrl+r, 0
    placera in det som skrevs in senast i i-mode :DDD (klar2014)
    Ctrl+a
    Ctrl+@
    ++i insertmode = Ctrl+r, i
    skicka x antal rader till kommandoraden för redigering (klar2014)
    5:
    :.,.+4
    o
    tags i vim <http://vim.wikia.com/wiki/Browsing_programs_with_tags>
    o
    Ctrl-]
    For example, the command ':stag func1' will open the func1 definition in a new window.
    You can position the cursor over a tag name and then press Ctrl-W ]. This will open the tag location in a new window.
    o
    :tselect func1' will list all the locations where func1 is defined. You can then enter the number of a tag match to jump to that location.
    You can position the cursor over the tag name and press g] to get a list of matching tags.
    You can visually select a text and press g] to get a list of matching tags.
    You can use the 'stselect' ex command. This will open the selected tag from the tag list in a new window.
    You can position the cursor over the tag name and press Ctrl-W g] to do a :stselect.
    o
    gå tillbaks:
    :pop
    Ctrl+t
    o
    How do I jump again to a previously jumped tag location?
    You can use the 'tag' ex command to jump to a previously jumped tag location, which is stored in the tag stack.
    Help: tag
    How do I list the contents of the tag stack?
    Vim remembers the location from which you jumped to a tag in the tag stack. You can list the current tag stack using the 'tags' ex command.
    TILL TAG OM BARA EN MATCH, ANNARS VISA LISTA
    BROWSE THROUGH LIST OF MULTIPLE TAGMATCHES
    o
    ANVÄNDA PREVIEWFÖNSTRET OCH VISA TAG
    o
    You can position the cursor on a tag name and press Ctrl-W } to open the tag in the preview window.
    o
    o
    You can position the cursor on the tag and press Ctrl-W g} to do a :ptjump on the tag.
    BROWSE THROUGH LIST OF TAGS =I PREVIEWFÖNSTRET !! (:ptselect, :ptjump osv)
    o
    $ vim -t
    Error setting the text for the following input: = öppna vim för redigering utifrån en tag-match i en fil :).
    LIST ALL THE TAGS MATCHING A SEARCHPATTERN
    DRS VIMHÄFTE 2 (folds till autocommand (och precis innan 'add new menus')
    TAGS - s25-26
    A tag is a location where an identifier is defined. An example is a functiondefinition in a C- or C++-program
    Generate c-tags for all c-files in the current directory: ctags *.c
    CONFIGURE CTAGS FOR PYTHON AND VIM <Configuring%20ctags%20for%20Python%20and%20Vim>
    o
    o
    o
    o
    o
    mm
    PREVIEWWINDOW - s157 i usermanual
    HOPPA I PROGRAM - s26-27
    KODFELMEDDELANDEN - s27-28
    INDENTERING - s(28)-29 (+softtabstops och annat)
    formatering
    browse (30-31)
    UNDO OCH UNDOTREE - s31
    MAPS - s31-33
    EGENDEFINIERADE KOMMANDON :) - s33-34
    AUTOCOMMAND - s34-35
    ADD NEW MENUS - s225 i usermanual
    färgkod KLAR 2014
    c/mönster
    ändra framåt till mönster
    c?mönster
    ändra bakåt till mönster
    cn
    ändra framåt till nästa mönster
    cG
    ändra till slutet
    d13G
    sudda framåt till (och med?) rad 13
    o
    öppna ny rad under nuvarande = o
    öppna ny rad över nuvarande = O :D
    :e
    redigera annan fil
    :e annan_fil
    byt till filen x.txt +gå till rad 100
    :e +100 x.txt
    byt till filen x.txt +gå till mönstret 'mönster'
    :e +/mönster x.txt
    :e /zzz y.txt
    återgå till sparade versionen av nuvarande fil
    :e!  :)
    öppna alternativa filen
    :e #
    :e(!) $MYVIMRC
    o
    :w
    :q
    :x
    uppdatera filen och gå ut ur vi (samma som wq)
    :20
    gå till rad 20 :)
    :d3
    ta bort 3 rader från den där markören stod
    :r fil_x.txt
    se nedan :]
    o
    vim nyfil3.txt :]
    skapa ny fil direkt i skalet :]
    vim \+30 fil.txt :]
    gå till rad 30 i en fil
    vim \+ fil.txt :]
    gå till sista raden i en fil
    o
    vim \+/ord fil.txt :]
    gå till rad med ordet 'ord' i en fil
    vim +/^References file.txt
    o
    p
    P
    Error setting the text for the following input: = klistra in innan :).
    o
    r
    replace
    ersätt || med &&
    2r& [markör på första | ] :)
    o
    |
    gå till kolumn 3 på nuvarande rad
    3|
    kolumner och virtualmode: s133
    undo/redo = u / Ctrl+r :DD
    revert line :D = U
    undo last U = ett U till
    o
    slå ihop markerade rader :DDDD = J
    slå ihop 3 rader
    3J
    UNDO/REDO
    u
    Error setting the text for the following input: =undo :).
    U (=stort u) :)
    ångra alla ändringar på nuvarande raden :D
    Ctrl+r
    Error setting the text for the following input: =redo :).
    byt namn på filen, men spara inte än
    :file nyttnamn.txt
    FLYTTA RUNT :)
    flytta mellan ord
    o
    gå till början på nästa ord
    w
    Error setting the text for the following input: =fortsätter på början av nästa rad om når slutet av nuvarande :).
    gå till början av förra ordet
    b
    Error setting the text for the following input: =fortsätter på början av förra raden om når början av nuvarande :).
    o
    gå till slutet av nuvarande ordet
    e
    gå till ins-läge vid slutet av ord :)
    ea
    gå till slutet av förra ordet :)
    ge
    o
    gE
    räknar in skiljetecken i ord :DDDD
    W
    B
    E
    gE
    gå till början/slutet på rad
    o
    0
    $ (1$ är samma sak :)
    gå till slutet på nästa rad :DDDD
    2$
    ^
    o
    gå till första tecknet på nästa rad
    Enter // +
    gå till första tecknet på förra raden
    -
    gå till nästa tecken ÄVEN om på nästa rad :)
    blanksteg
    gå till mitten på rad
    gm
    gå ner/upp VISUELL rad (inte LOGISK rad, som standard)
    gj/gk
    sök till/till och med ett tecken :DD
    F T t f  :)
    ,  ;
    :DD
    repetera sökkommando (ftFT) i samma riktning
    ;
    repetera sökkommando (ftFT) i andra riktningen
    ,
    exempel
    ändra fram till (men inte med) punkt
    ct.
    o
    flytta mellan matchande parenteser :DD
    %
    tillåtna parenteser:
    (
    [
    {
    <  (??) :}
    flytta till nästa parentes från vanlig text
    %
    gå till rad n :)
    gå till rad 15
    15G
    gå till första raden
    gg
    gå till sista raden
    G
    gå till halva filen (50 %) :D
    50%
    o
    o
    H
    gå till 3 rader under översta raden på skärmen
    3H  :DD
    o
    M
    o
    L
    gå till 3 rader över nedersta raden på skärmen
    3L  :DD
    visa var du är i filen :)
    o
    :se ruler :))
    o
    Ctrl-g [=infon ges redan om linjalen är påslagen] :DD
    o
    :se nu
    FLYTTA UPP/NER-KOMMANDON D :D
    rad upp = Ctrl+y
    halvskärm upp = Ctrl+u
    helskärm upp = Ctrl+b
    rad ner = Ctrl+e
    halvskärm ner = Ctrl+d
    helskärm ner = Ctrl+f
    flytta ner/upp 5 rader :D
    5 ctrl+d/u
    :DD
    o
    zt
    o
    zz
    200zz / 200zRetur
    flytta rad 200 till toppen av skärmen
    o
    zb
    o
    grundläggande flyttkommanden i ex
    o
    :d
    sudda alla rader i en fil :)
    :%d
    :m
    flytta rad 226 t om slutrad till två rader innan nuvarande
    :226,$m.-2
    :t / :co
    kopiera alla rader i filen och placera in på slutet av filen
    :%t$
    o
    :160,224m23
    flytta 150 t om 224 till efter rad 23
    :23,29co100
    o
    :p
    visa rad 100 och 5 rader framåt
    :100;+5p
    visa första rad där 'mönster' förekommer + 10 rader framåt :D
    :/mönster/;+10p
    OBS!
    vim (d)
    raderar fram till angivet ord på rad
    ex (:d)
    raderar hela raden
    :ya
    som p men anv. med radadresser och namngivna buffrar :)
    :pu
    som p men anv. med radadresser och namngivna buffrar :)
    o
    :160,224ya a
    o
    :pu a
    VISA RADNUMMER, visa filinfo MM
    visa radnummer i filen temporärt :]
    :#
    visa radnummer för rad 1-10 temporärt :]
    :1,10#
    visa radnummer för markerade rader temporärt :)
    - markerade med visual mode
    - markerade med sökmönster
    - markerade med marks ('t mm) :)
    visa radnummer för nuvarande raden
    Ctrl+g
    :.=
    skriv ut totalt antal rader (förutom g Ctrl+g)
    skriv ut totalt antal rader
    visa radnummer för första linjen där 'mönster' förekommer
    :/mönster/=
    KOLLA MER PÅ DETTA KOMMANDOT
    visa filnamn mm info
    :file
    info om fil
    -
    fil kan inte modifieras (t ex hjälpfilerna)
    +
    filen innehåller ändringar
    =
    filen är read-only enbart
    =+
    filen är read-only men innehåller ändå ändringar
    pppp
    OPERATORER OCH RÖRELSER(motions) :) (se ev mer + öva i usr_04)
    w
    e
    skillnad mellan e och w = w bevarar ett blanksteg :)
    b
    $
    o
    gå till slutet av nästa rad
    2$
    5$
    0
    t ex d4w :)
    r
    även t ex 5rx = xxxxx
    ersätt tecken med radbryt = r<Enter>
    repetera senaste ändring = .
    SE MER EV
    obs! fungerar inte för
    u
    Ctrl+r
    :-kommandon :)
    gå till tidigare ändringar i text (förra/nästa) :D
    g, / g;
    u
    Ctrl+r
    TEXTOBJEKT/BLOCK-IDENTIFIERARE :DDDDD
    aw ==> t ex daw = sudda ett ord :D
    aw
    iw
    aW
    iW
    as
    kopiera mening man står i till minne f, var man än står i meningen :)) = "fyas
    sudda mening + blanksteg efter
    das
    is
    ap
    ip
    a], a[  (=???)  = [ ] + text inne i :)
    i], i[  = text inne i [ ] :D
    o
    3 sorternas block :)
    (
    <
    {
    ab
    a), a(
    ib
    i), i(  (=??)
    at
    a>, a< (=???)
    block från <a> till <a/>
    it
    i>, i< (=???)
    aB
    a}, a{
    block från { till } :] = TESTA
    iB
    text inne i { }-block :D OCH [ ]-block tydligen :] =testa
    a"
    Error setting the text for the following input: = citerad text :D [+se nedan].
    a'
    a`
    (i")
    (i')
    (i`)
    RÄKNA ORD/RÄKNA TECKEN mm :)
    visa info om filen (rad, antal tecken mm)
    gCtrl+g
    HELP (:h) :)
    öppna hjälpen
    :h, <F1>
    kolla upp kommandot o för visualmode
    v_o; v_O  :)
    o
    o
    To get help on the "x" command, for example, enter the following: >
    :help x
    To find out how to delete text, use this command: >
    :help deleting
    To get a complete index of all Vim commands, use the following command: >
    :help index
    When you need to get help for a control character command (for example, CTRL-A), you need to spell it with the prefix "CTRL-". >
    :help CTRL-A
    For example, the following command displays help for the normal-mode CTRL-H command: >
    :help CTRL-H
    insert-mode version of a command, use "i_". following command: > If you want the help for the For CTRL-H this gives you the
    :help i_CTRL-H
    o
    When you start the Vim editor, you can use several command-line arguments. These all begin with a dash (-). To find what the -t argument does, for example, use the command: >
    :help -t
    The Vim editor has a number of options that enable you to configure and customize the editor. If you want help for an option, you need to enclose it in single quotation marks. To find out what the 'number' option does, for example, use the following command: >
    :help 'number'
    The table with all mode prefixes can be found here: |help-context|.
    Special keys are enclosed in angle brackets. To find help on the up-arrow key in Insert mode, for instance, use this command: >
    :help i_<Up>
    If you see an error message that you don't understand, for example: E37: No write since last change (use ! to override) ~ You can use the error ID at the start to find help about it: >
    :help E37
    Summary:
    :help
    Gives you very general help. Scroll down to see a list of all helpfiles, including those added locally (i.e. not distributed with Vim). >
    :help user-toc.txt
    Table of contents of the User Manual. >
    Ex-command "subject", for instance the following: >
    :help :subject
    Help on getting help. >
    :help :help
    normal-mode command "abc". >
    :help abc
    The same in Insert mode. >
    :help i_abc
    :help v_abc
    :)
    Control key <C-B> in Normal mode. >
    :help CTRL-B
    The same in Insert mode. >
    :help i_CTRL-B
    The same in Visual mode. >
    :help v_CTRL-B
    The same in Command-line mode. >
    :help c_abc
    :help c_CTRL-B
    Option 'subject'. >
    :help 'subject'
    Function "subject". >
    :help subject()
    Command-line option "-subject". >
    :help -subject
    Compile-time feature "+subject". >
    :help +subject
    Autocommand event "EventName". >
    :help EventName
    The top of the helpfile "digraph.txt".
    :help digraphs.txt
    Similarly for any other helpfile. >
    Find a help tag starting with "pattern". Repeat <Tab> for others. >
    :help pattern<Tab>
    See all possible help tag matches "pattern" at once. >
    :help pattern<Ctrl-D>
    :)
    HELPGREP
    Search the whole text of all help files for pattern "pattern".
    :helpgrep pattern
    Jumps to the first match. Jump to other matches with: > next match >
    :cn
    previous match >
    :cprev
    :cN
    first or last match >
    :cfirst
    :clast
    QUICKFIX-FÖNSTRET
    open/close the quickfix window; press <Enter> to jump to the item under the cursor
    :copen
    :cclose
    1. Using QuickFix commands
    *quickfix* *Quickfix* *E42*
    Vim has a special mode to speedup the edit-compile-edit cycle.  This is inspired by the quickfix option of the Manx's Aztec C compiler on the Amiga. The idea is to save the error messages from the compiler in a file and use Vim to jump to the errors one by one.  You can examine each problem and fix it, without having to remember all the error messages. In Vim the quickfix commands are used more generally to find a list of positions in files.  For example, |:vimgrep| finds pattern matches.  You can use the positions in a script with the |getqflist()| function.  Thus you can do a lot more than the edit/compile/fix cycle!
    If you are using Manx's Aztec C compiler on the Amiga look here for how to use it with Vim: |quickfix-manx|.  If you are using another compiler you should save the error messages in a file and start Vim with "vim -q filename".  An easy way to do this is with the |:make| command (see below).  The 'errorformat' option should be set to match the error messages from your compiler (see |errorformat| below).
    LOCATION-LIST :)
    SE MER!! <http://vimdoc.sourceforge.net/htmldoc/quickfix.html>
    *location-list* *E776*
    A location list is similar to a quickfix list and contains a list of positions in files.  A location list is associated with a window and each window can have a separate location list.  A location list can be associated with only one window.  The location list is independent of the quickfix list. When a window with a location list is split, the new window gets a copy of the location list.  When there are no references to a location list, the location list is destroyed.
    The following quickfix commands can be used.  The location list commands are similar to the quickfix commands, replacing the 'c' prefix in the quickfix command with 'l'.
    JUMPS
    visa lista på senaste jumps :) == :jumps
    gå tillbaks till där senaste hoppet gjordes :D
    o
    Ctrl+t (pop tags)
    Ctrl+o :)
    följ en länk(=jump to tag) :DD
    Ctrl+]
    MARKS :)
    o
    gå till rad 20
    G20 :)
    hoppa tillbaks till raden där du hoppade från :)
    '
    hoppa tillbaks till exakta positionen där du hoppade från :DDD
    Error setting the text for the following input: =två backticks :DD.
    hoppa tillbaks till positionen man hoppade från
    ' el 2 backticks IGEN :DD
    definition av ett hopp: alla kommandon som flyttar markören längre än inom en rad :DDD
    undantag:
    fFtT
    w och e
    j och k
    gå tillbaks till äldre/nyare hopp
    Ctrl+o / Ctrl+i
    visa lista på jumps
    :jumps
    o
    visa lista på alla marks
    :marks
    hoppa till märke a
    backtick a :)
    hoppa till märke a:s rad
    a
    :DDDD
    till start/slutrad av nuvarande mening == '(  //  ')  :)
    (till) start/slutpos av nuvarande mening :D == `(  //  `)
    till start/slutrad av nuvarande stycke == '{  //  '}  :)
    (till) start/slutpos av nuvarande stycke :D == `{  //  `}
    position där senaste ändring gjordes :D == '. `.
    markör-position när senast redigerade filen :) == `" :DDDD
    gå till nästa märke :D ****** == ]`
    rad där senaste ändring gjordes :DD == '.
    position där senaste ändring gjordes :DD == `.
    till pos. markören var senast när ins.mode stoppades (används av gi tex) == `^  :)
    till rad markören var senast när ins.mode stoppades (används av gi tex) == '^  :)
    till första/sista tecknet av senast ändrad(?)/kopierad(=yanked) text = `[ // `] :DDDD
    samma för rader = '[ // '] :))
    hoppa till markörbokstav (t ex a) MEN ändra inte i jump-list :DDD = g`a
    Error setting the text for the following input: =lista på specialmärken:.
    o
    markörposition innan hopp gjordes
    "
    markörposition när sist ändrade filen
    [
    start av senaste ändring
    ]
    slut av senaste ändring
    MARKS
    globalt märke (t ex 'f') = mF :DDDDD
    sudda märken = :delm
    sudda ett visst märke (t ex a) = :delm a
    ta bort alla markeringar i texten
    :delm!
    komma direkt tillbaks till där du var när senast redigerade i vim ****
    0  :DDDDDD
    REPETITIONSPUNKT :D
    Error setting the text for the following input: =funkar inte för u, Ctrl+r och :-kommandon :].
    REGISTERS :D
    visa vad som finns i registers :D == :reg(isters)
    OLIKA SORTERNA REGISTER :) <vim-registers_super.txt>
    ALLMÄNT OM REGISTERS :DDDD !!!!
    klistra in från urklipp (inte bokstavregister)
    1. från kommandoläge
    "+p
    2. från insertläge
    Ctrl+r, +
    "a/"A - "z/"Z -- 26 registren med namn :]
    o
    lägg till sökning efter ordet 'mönster' sist register c
    qC/mönster<Enter>q
    kopiera och lägg till sist i register a
    "Ay
    o
    "-  -- lilla delete-registret
    Error setting the text for the following input: =det senast suddade, om mindre än en rad :D.
    "0 - "9 -- 10 numrerade registren :]
    Error setting the text for the following input: =senast suddade (och 1-9 bakåt), om mer än en rad.
    förra suddade (mer än en rad)
    "1
    "_ -- black hole register :)
    sudda ut ett ord till blackhole-registret
    "_dw
    SKILLNAD MELLAN " OCH 0-registren :D
    I was pleased when I discovered the 0 register. If you yank text without assigning it to a particular register, then it will be assigned to the 0 register, as well as being saved in the default " register. The difference between the 0 and " registers is that 0 is only populated with yanked text, whereas the the default register is also populated with text deleted using d/D/x/X/c/C/s/S commands.
    I find this useful when I want to copy some text, delete something and replace it with the copied text. The following steps illustrate an example:
    Yank the text you want to copy with y[motion] - this text is saved in " and 0 registers
    Delete the text you want to replace with d[motion] - this text is saved in " register
    Paste the yanked text with "0p
    On the final step, if you were to paste from the default register (with p), it would use the text that you had just deleted (probably not what you intended).
    o
    ":
    Error setting the text for the following input: =senaste exkommandot.
    2. från insertläge
    Ctrl+r, :
    kör senaste registerkommandot igen
    @:
    ".
    Error setting the text for the following input: =senast inmatat :D.
    2. från insertläge
    Ctrl+r, .
    o
    o
    "% -- namn på nuvarande filen :)
    2. från insertläge
    Ctrl+r, %
    klistra in fils namn i texten
    "%p
    ge full sökväg till fil med %
    %:p (t ex :e %:p)
    /full/sök/väg/fil.txt
    %:p
    /full/sök/väg/fil.txt
    /full/sök/väg/fil.txt
    %:.
    (om står i mappen sök) väg/fil.txt
    /full/sök/väg/fil.txt
    %:e
    (.)txt
    /full/sök/väg/fil.txt
    %:h
    /full/sök/väg/
    /full/sök/väg/fil.txt
    %:t
    fil.txt
    "# -- namn på alt-filen :)
    2. från insertläge
    Ctrl+r, #
    "=
    Vim expression register :) <http://stackoverflow.com/questions/7027741/what-is-the-purpose-of-the-expression-register>
    SE MER
    "" -- the unnamed register
    o
    "* -- selection :)
    Error setting the text for the following input: =används enklast med Shift+Insert :D.
    2. från insertläge
    Ctrl+r, *
    "+ -- clipboard
    2. från insertläge
    Ctrl+r, +
    "~
    "/ -- senaste sökmönster-registret :]
    Error setting the text for the following input: =för både /- och ?-sökningar :).
    2. från insertläge
    Ctrl+r, /
    :let @/ = "the"
    inskrivet på kommandorad-registret ::]
    SÖKNING MED / och ?
    o
    tecknen att se upp med vid sökning = /  :)
    .
    *
    [
    ]
    ^
    %
    /
    \
    ?
    ~
    $
    hitta ordet ord i texten
    /ord
    hitta första '#include' efter pekaren
    /#include
    hitta första '#include' innan pekaren
    ?#include
    hitta nästa/förra
    n/N
    :)
    gå tillbaks ett steg i /-sökhistoriken
    / + pil upp :)
    o
    hitta nästa förra ordet 'x' med snabbtryck :DDD
    # // *
    hitta nästa förra ordet som ordet 'x' ingår i; = med snabbtryck :DDD
    g# // g*
    sök tredje ordet framåt med knapptryck :)
    3*
    början/slutet på ord
    hitta ordet the (=inte i nåt annat ord) :D
    /\<the\>
    början/slutet på rad
    byt ut screen mot line på rad 12
    :12s/screen/line/
    TIPS! n går att göra om igen efter ett litet tag = går att använda för intressant redigering :D
    sudda från markören bakåt till och med ordet 'move' :D
    d?move
    sök textsträng med ic/noic för just den sökningen
    ignore case
    \c (gement c)
    match case
    \C
    sök efter mönstret 'mönster' med ignorecase på :)
    /\cmönster
    smartcase <http://linuxcommando.blogspot.se/2008/06/smart-case-insensitive-incremental.html>
    (tillsammans med ic =sök ic om bara gemener matas in, annars matchcase :DDD )
    ev också tillsammans med incsearch
    också tillsammans med ignorecase (t ex :set ignorecase smartcase)
    använda regex i / /-sökning :D
    /\(ab\)*
    /ab\+
    /folders\=
    /ab\{,5}
    o
    \{,4}
    \{,}
    \{,1}
    \{,}
    \{,}
    \{}
    /ab\{-1,3}
    \{-}
    /a.\{-}b
    /foo\|bar
    /one\|two\|three
    /\(foo\|bar\)
    this matches "foo", "foobar", "foofoo", "barfoobar" etc
    /end\(if\|foo\|bar\)
    A related item is "\&". this requires that both alternatives match in the same place. the resulting match uses the last alternative.
    example: /forever\&.....
    this matches "for" in "forever". it will not match "fortuin", for example
    /[1236aoeus]
    /[0-9a-f]
    /"[^"]*"
    o
    /\a
    klass=alpha (bokstäver)
    se fler vid regular expressions
    o
    o
    o
    o
    o
    ******
    \zs, \ze
    sök med ignorecase
    /\csökord
    /sökord/i
    ?
    EFTER KRASCH
    öppna en fil du redigerade vid datorkrasch
    vim -r help.txt
    tips: +=spara först återhämta filen under annat namn för att kunna jämföra m orig.filen
    :w help.txt.recov :e # :diffsp(lit) help.txt
    om redigerade fil utan namn vid krasch
    vim -r ""
    lista alla swapfiler som finns i en viss mapp
    vim -r i en mapp :)
    CLIPBOARD OCH MARKERAD_TEXT
    "+
    "* / Shift+Insert
    SKRIVA UT**
    :ha(rdcopy)
    There are several options that change the way Vim prints:
    printdevice'
    printheader'
    printfont'
    printoptions'
    skriv ut bara vissa rader :)
    v100j:hardcopy
    REDIGERA MER ÄN EN FIL (på samma gång :))
    hm ??
    :pre
    :wpre
    :last
    :first
    :2n
    :2pre
    redigera en fil
    :e fil.txt
    ((om får felmeddelande, t ex E37 = :h E37)) :))
    :]
    redigera ny fil utan att stänga eller spara nuvarande filen :DD
    :hide edit foo.txt
    ev kortform=
    :hid e foo.txt
    öppna fil när inne i vim men ligg kvar i filen du redigerar just nu
    :hide edit foo.txt
    ev kortform=
    :hid e foo.txt
    redigera nästa fil i bufferlistan
    :n
    gå två filer framåt i bufferlistan
    :2n
    :)
    gå till förra filen i b-listan
    :prev
    redigera nästa fil i bufferlistan även om nuvarande har ändringar
    :n!
    spara och gå till nästa fil
    :wn
    se lista på filer som redigeras
    :ar((gs))
    :ls
    spara och gå till förra filen i listan
    :wp
    gå till sista/första filen i b-listan
    :la
    :fir
    obs!
    There is no ":wlast" or ":wfirst" command though!
    sätta autowrite :)
    :set autowrite
    ange annan lista på filer att redigera :DDD
    EDITING ANOTHER LIST OF FILES
    You can redefine the list of files without the need to exit Vim and start it again. Use this command to edit three other files: >
    :args five.c six.c seven.h
    Or use a wildcard, like it's used in the shell: >
    :args *.txt
    Vim will take you to the first file in the list. Again, if the current file has changes, you can either write the file first, or use ":args!" (with ! added) to abandon the changes.
    markerar filen i argslistan som redigeras just nu
    [ ]
    2 bra kommandon när hoppar mellan filer :D
    ((obs! funkar förmodl. inte när lämnat filen = stängt + senare öppnar igen ??? ))
    Error setting the text for the following input: =kolla.
    position där senaste ändring gjordes :D == '. `.
    markör-position när senast redigerade filen :) == `" :DDDD
    GLOBALA MÄRKEN
    sätt globala märket F (=SUVERÄNT när hoppar mellan flera filer man redigerar samtidigt :D !!! )
    mF
    It's often useful to think of a simple connection between the mark letter and where it is placed. For example, use the H mark in a header file, M in a Makefile and C in a C code file. :)
    To see where a specific mark is, give an argument to the ":marks" command: >
    :marks M
    You can also give several arguments: >
    :marks McP
    Don't forget that you can use CTRL-O and CTRL-I to jump to older and newer positions without placing marks there. !!
    BACKUPFILES :DDD
    sätt så backupfiler skapas :)
    :set backup
    ändra ändelse för backupfiler :]
    :set backupext=.bak
    The name of the backup file is the original file with a ~ added to the end. If your file is named data.txt, for example, the backup file name is data.txt~. If you do not like the fact that the backup files end with ~, you can change the extension: >
    Another option that matters here is 'backupdir'. It specifies where the backup file is written. The default, to write the backup in the same directory as the original file, will mostly be the right thing. :)
    behålla första originalfilen genom hela processen = ange patch-läge :D
    (testa ev :)
    KEEPING THE ORIGINAL FILE
    If you are editing source files, you might want to keep the file before you make any changes. But the backup file will be overwritten each time you write the file. Thus it only contains the previous version, not the first one.
    To make Vim keep the original file, set the 'patchmode' option. This specifies the extension used for the first backup of a changed file. Usually you would do this: >
    :set patchmode=.orig
    When you now edit the file data.txt for the first time, make changes and write the file, Vim will keep a copy of the unchanged file under the name "data.txt.orig".
    If you make further changes to the file, Vim will notice that "data.txt.orig" already exists and leave it alone. Further backup files will then be called "data.txt~" (or whatever you specified with 'backupext'). If you leave 'patchmode' empty (that is the default), the original file will not be kept.
    ANVÄNDA REGISTERS :D
    kopiera nuvarande mening till register f
    "fyas
    o
    o
    SPLIT (=DELA FÖNSTER :D )
    - kommandon som vertical ska funka för alla kommandon som delar fönster :D -
    tips på användningsområden :]
    *visa flera filer nedanför varandra :)
    *VISA TVÅ DELAR AV SAMMA FIL SAMTIDIGT :DDD
    *se skillnad mellan två filer genom att sätt de bredvid varandra (+även vimdiff)
    dela fönster
    :split :)
    :sp fil2.txt
    hoppa till andra split-fönstret :)
    ctrl+w, w
    stäng ett splitfönster :)
    ZZ, :close, :quit
    stänga alla splitfönster UTOM nuvarande
    :only :D
    öppna 'fil2' i splitfönster ovanför nuvarande
    :split fil2
    öppna ny tom fil som splitfönster :D
    :new
    öppna 3 rader högt splitfönster
    :3split alpha.c
    öka storlek på splitfönstret
    dra med musen
    ctrl+w + // ctrl+w -
    öka storlek på fönster till 4 rader
    4 Ctrl-w +
    Both of these commands take a count and increase or decrease the window size by that many lines. Thus "4 CTRL-W +" make the window four lines higher.
    To set the window height to a specified number of lines: > {height}CTRL-W _
    To make a window as high as it can be, use the CTRL-W _ command without a count.
    --------- VERTICAL SPLIT ---------
    dela fönster vertikalt
    :vsplit
    dela fönster vertikalt med 'fil2'
    :vsplit fil2
    o
    2 splitvarianterna för komm. som redigerar en fil
    1. Ex-mode: s (t ex :tag hoppar till tag och :stag delar och hoppar till)
    2. Normal mode: Ctrl-w (t ex Ctrl+w Ctrl-(tak)
    öppna ny tom fil i vertikal split
    :vnew
    :vertical new
    FLYTTA MELLAN SPLITFÖNSTER :DDDD
    CTRL-W h
    move to the window
    on the left
    CTRL-W j
    move to the window
    below
    CTRL-W k
    move to the window
    above
    CTRL-W l (litet L)
    move to the window
    on the right
    CTRL-W t
    move to the TOP window
    CTRL-W b
    move to the BOTTOM window
    CTRL-W x
    byt fönstret mot fönster n (def. nästa :)
    CTRL-W p
    gå till föregående använt fönster :D
    FLYTTA SPLITFÖNSTER :)))
    CTRL--W K
    move window to the top
    CTRL-W H
    move window to the far left
    CTRL-W J
    move window to the bottom
    CTRL-W L
    move window to the far right
    RESTEN FÖNSTERKOMMANDONA :]
    CTRL-W +
    öka storlek på splitfönstret
    CTRL-W -
    minska storlek på splitfönstret
    CTRL-W <
    minska fönsterbredd n kolumner
    CTRL-W >
    minska fönsterbredd n kolumner
    CTRL-W =
    sätt samma bredd och höjd på alla fönster :)
    CTRL-W P
    gå till föregående fönster
    o
    CTRL-W R
    rotera fönster uppåt n gånger
    CTRL-W r
    rotera fönster neråt n gånger
    CTRL-W s
    dela fönster i två delar, nya n rader högt :D
    CTRL-W v
    dela fönster vertikalt, nytt fönster n kolumner brett :)
    CTRL-W |
    sätt fönstervidd till n kolumner
    CTRL-W T
    flytta nuvarande fönster till ny tab
    CTRL-W w
    gå till (n) nästa fönster
    CTRL-W W
    gå till n föregående fönster
    CTRL-W ]
    dela fönster och hoppa till länk under markören
    CTRL-W _
    fönster till höjd n; default highest possible :]
    CTRL-W q, CTRL-W c
    stäng nuvarande fönster
    CTRL-W o
    stäng alla fönster utom nuvarande (=samma som :only) :)
    CTRL-W d
    split window and jump to definition under cursor
    CTRL-W i
    split window and jump to declaration of identifier under cursor
    CTRL-W f
    dela fönster och redigera filnamn under markören
    CTRL-W F
    dela fönster och redigera filnamn under markören + gå till rad n
    CTRL-W g f
    redigera filnamn under markören i ny tabpage :)
    CTRL-W g F
    redigera filnamn under markören i ny tabpage + gå till rad n efter filnamnet :D
    CTRL-W n
    öppna nytt fönster n rader högt
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    CTRL-W 
    stänga alla splitfönster och vim
    :qall :)
    :qa
    stäng alla fönster även om ändringar gjorts
    :qa!
    öppna splitfönster för alla öppna filer när inne i vim
    :all
    öppna splitfönster för öppna filer, men max 3 :D
    :3al
    öppna vertikala splitfönster för alla öppna filer när inne i vim
    :vertical all
    spara alla ____
    :wall
    spara och stäng alla ___
    :wqall
    :xall
    o
    :qall!
    --------- ÖPPNA FLERA FILER I SPLITFÖNSTER (FRÅN KOMMANDORADEN) ---------
    öppna flera filer i splitfönster (från kommandoraden)
    vim -o one.txt two.txt three.txt
    öppna flera filer i vertikalt splitfönster (från kommandoraden)
    vim -O one.txt two.txt three.txt
    --------- VIMDIFF --------- [vimdiffnotation s60]
    öppna två filer i vimdiff :DDD
    vimdiff main.c~ main.c
    snabbsyntax bash: vimdiff main.c{~,}
    notering:
    ändrad text
    highlighting
    text som saknas i ena filen
    ------------------
    fold
    + +-----
    öppna vimdiff från INNE I vim :)
    A. :) (=grund)
    Another way to start in diff mode can be done from inside Vim. Edit the "main.c" file, then make a split and show the differences: >
    :edit main.c
    :vertical diffsplit main.c~
    B. (? :] )
    If you have a patch or diff file, you can use the third way to start diff mode. First edit the file to which the patch applies. Then tell Vim the name of the patch file: >
    :edit main.c
    :vertical diffpatch main.c.diff
    WARNING: The patch file must contain only one patch, for the file you are editing. Otherwise you will get a lot of error messages, and some files might be patched unexpectedly.
    The patching will only be done to the copy of the file in Vim. The file on your harddisk will remain unmodified (until you decide to write the file).
    alternativ variant(??)
    :vert diffsplit fil
    :diffthis
    :vert diffpatch fil
    Error setting the text for the following input: =se mer s60 och :help :D.
    lägg till vertical i diffopt (=??)
    options:
    :set noscrollbind
    :)
    hoppa till nästa//förra ändring/skillnad i vimdiff :D
    ]c
    [c
    gå till tredje ändring framåt
    3]c
    o
    :diffupdate :)
    You can move text from one window to the other. This either removes differences or adds new ones. Vim doesn't keep the highlighting updated in all situations. To update it use this command: >
    hämta rad från andra filen till saknad rad under markören
    dp :D
    hämta rad under markören till saknad rad i andra filen
    do :D
    ""Many commands that edit another file have a variant that splits the window. ""
    t ex :stag SE MER EV
    options
    splitbelow'
    splitright'
    :DDDD
    When splitting a window you can prepend a modifier command to tell where the window is to appear:
    :leftabove {cmd}
    left or above the current window
    :aboveleft {cmd}
    samma
    :rightbelow {cmd}
    right or below the current window
    :belowright {cmd}
    samma
    :topleft {cmd}
    at the top or left of the Vim window
    :botright {cmd}
    at the bottom or right of the Vim window
    t ex :)
    TABS/TABSPLIT :)
    osäkra
    :tab help gt (=??) [kommentar: "tab funkar för alla kommandon som öppnar nytt fönster)
    visa lista på alla öppna tabs
    :tabs
    öppna fil2 i tab :DD
    :tabsplit fil2
    gå till nästa flik (tab)
    gt :)
    skapa flik (tab) på SAMMA fil som kommandot körs ifrån :DDD
    :tab split
    You can put ":tab" before any Ex command that opens a window. The window will be opened in a new tab page. Another example: >
    :tab help gt
    Error setting the text for the following input: =Will show the help text for "gt" in a new tab page. :DDD.
    :tab sp(lit)
    :tabedit alt-fil.txt
    double click with the mouse in the top line
    A new tab page will be created.
    stäng alla flikar utom nuvarande
    tabonly :DDD
    öppna fil1, fil2 och fil3 i varsin flik (från kommandoraden) :)
    vim -p fil{,2,3}
    stäng nuvarande tab
    :tabclose
    gå till nästa tab
    :tabnext
    gå till förra tab
    :tabprevious
    gå 5 tabs framåt
    5gt ; :tabnext 5
    utför kommando cmd i alla öppna flikar
    :tabdo cmd
    kör kommando på flera öppna tabs i ett fönster (t ex ersätt x med y)
    :windo w(rite) :DDD
    :windo s/x/y/g
    NETRW/VIM EXPLORER (filbläddraren :D )
    s106 :)
    öppna filbläddraren (i nuvarande mappen)
    :e .
    o
    dela fönster och öppna explorer i splitfönstret
    :Sex
    samma med vertical split
    :Vex
    samma med tab
    :Tex
    öppna vim explorer
    :e .  //  :Exp
    hjälp
    <F1>
    öppna mapp/fil
    <CR>
    gå uppåt(bakåt) i trädet
    -
    visa/gömma filer/mappar [norm. hiding o show]
    a
    o
    o
    sätt bokmärke (b) i mapp
    mb
    gå till mapp med bokmärke
    gb
    gör mappen du är i till aktiv mapp i vim
    c
    o
    skapa ny mapp (delete)
    d
    sudda filer eller mappar
    D, <Del>
    flippa mellan tunn, lång, bred el trädlistning
    i
    refresh listing
    C-l (=L)
    browse with horizontal split ?? :)
    o
    o
    visa/göm gömda filer (.fil)
    gh
    copy marked files to marked-file target directory
    mc
    kör diff på markerade filer (max 3)
    md
    placera markerade filer i args-listan och redigera
    me  :)
    move marked files to marked-file target directory
    mm
    skriv ut markerade filer
    mp
    mark files satisfying a shell-style regex (glob)
    mr
    current browsing-dir becomes markfile target
    mt  :)
    avmarkera alla markerade filer
    mu
    apply arbitrary shell command to marked files
    mx
    obtain file specified under cursor
    O
    o
    lista mappar markerade med bokmärken
    qb
    visa info om fil
    qf
    omvänd sorteringsordning
    r
    rename files
    R
    välj sorteringssätt: namn, fil el filstorlek
    s
    öppna fil/mapp under markören i ny flik
    t
    change to recently visited directory (back)
    u
    change to subsequently visited directory (forw)
    U
    enter the file/directory under the cursor in a new browser window - vsplit is used
    v
    view file with associated program
    x
    open a new file in netrw's current directory
    %
    setting the editing-window
    C
    speca hide-lista :)
    C-h
    o
    preview ??
    p
    edit in preview-window ??
    P
    kör ctags på markerade filer  :) <http://www.google.com/search?client=ubuntu&channel=fs&q=ctags&ie=utf-8&oe=utf-8>
    mT
    compress/decompress marked files
    mz
    speca suffixprioritet för namnsortering
    S
    NETRW/VIM-EXPLORER
    MAKING BIG CHANGES***
    MATA IN FLERA EX AV ETT TECKEN :)
    50i*Esc
    5I-Esc  (stort i)
    25a*-Esc
    25A*-Esc
    RECORD/SPELA IN KOMMANDOSEKVENS
    spela in kommandosekvens i register a
    qa
    gör kommandosekvensen
    avsluta med q
    kör kommandosekvens i register a
    @a
    kör senaste körda kommandosekvens
    @@
    kör kommandosekvens i register a 3 gånger
    3@a
    redigera felinspelat kommando i register x
    klistra in raden från register
    redigera
    delete tillbaks till register x
    Suppose you have recorded a command to change a word to register c. It works properly, but you would like to add a search for the next word to change. This can be done with: >
    qC/word<Enter>q
    You start with "qC", which records to the c register and appends. Thus writing to an uppercase register name means to append to the register with the same letter, but lowercase.
    This works both with recording and with yank and delete commands. For example, you want to collect a sequence of lines into the a register. Yank the first line with: >
    "aY
    Now move to the second line, and type: >
    "AY
    ändra ett namn i alla filer i en argslista :D ******
    vim *.cpp qq :%s/\<getResp\>/getAnswer/g :wnext q @q 999@q
    VISUAL BLOCK MODE
    mata in samma text i början av flera rader
    markera raderna med ctrl+v
    tryck I (stort i)
    mata in text
    tryck Esc
    mata in samma text i slutet av flera rader :D
    markera raderna med ctrl+v
    tryck A
    mata in text
    tryck Esc
    The Visual block "c" command deletes the block and then throws you into Insert mode to enable you to type in a string. The string will be inserted in each line in the block. :) ***
    The "C" command deletes text from the left edge of the block to the end of line. It then puts you in Insert mode so that you can type in a string, which is added to the end of each line.
    Other commands that change the characters in the block: :D
    ~
    swap case
    (a -> A and A -> a)
    byt case för 5 tecken
    5~
    U
    make uppercase
    (a -> A and A -> A)
    u
    make lowercase
    (a -> a and A -> a)
    fylla ett helt block med ett visst tecken
    r + tecknet :)
    CLEVER TRICKS
    byt ut ett ord/en sträng i flera filer
    Let's assume you have a directory with C++ files, all ending in ".cpp".
    There is a function called "GetResp" that you want to rename to "GetAnswer".
    vim *.cpp
    Start Vim, defining the argument list to contain all the C++ files. You are now in the first file.
    qq
    Start recording into the q register
    :%s/\<GetResp\>/GetAnswer/g
    Do the replacements in the first file.
    :wnext
    Write this file and move to the next one.
    q
    Stop recording.
    @q
    Execute the q register. This will replay the substitution and ":wnext". You can verify that this doesn't produce an error message.
    999@q
    Execute the q register on the remaining files.
    Obs! :)
    There is one catch: If one of the .cpp files does not contain the word "GetResp", you will get an error and replacing will stop. To avoid this, add the "e" flag to the substitute command: >
    :%s/\<GetResp\>/GetAnswer/ge
    The "e" flag tells ":substitute" that not finding a match is not an error.
    kasta om ord i en lista m hj av substitute :)
    You have a list of names in this form:
    Doe, John ~
    Smith, Peter ~
    You want to change that to:
    John Doe ~
    Peter Smith ~
    This can be done with just one command: >
    :%s/\([^,]*\), \(.*\)/\2 \1/
    sortera en lista (som slutar vid en blank rad :DDD (s88)
    To sort this list, filter the text through the external sort command: >
    /^OBJS
    j
    :.,/^$/-1!sort
    This goes to the first line, where "OBJS" is the first thing in the line.
    Then it goes one line down and filters the lines until the next empty line.
    kasta om rader (=vänd bak och fram på en fil)
    :g/^/m 0
    ????
    :'t+1,.g/^/m 't
    se mer ev ? (s88)
    räkna ord
    g ctrl+g
    For other ways to count words, lines and other items, see |count-items|.  SE MER :D
    Öppna en manpage för ett ord :) [se mer senare]
    *12.6* Find a man page
    *find-manpage*
    While editing a shell script or C program, you are using a command or function
    that you want to find the man page for (this is on Unix). Let's first use a
    simple way: Move the cursor to the word you want to find help on and press >
    K
    Vim will run the external "man" program on the word. If the man page is
    found, it is displayed. This uses the normal pager to scroll through the text
    (mostly the "more" program). When you get to the end pressing <Enter> will
    get you back into Vim.
    A disadvantage is that you can't see the man page and the text you are working
    on at the same time. There is a trick to make the man page appear in a Vim
    window. First, load the man filetype plugin: >
    :runtime! ftplugin/man.vim
    Put this command in your vimrc file if you intend to do this often.
    can use the ":Man" command to open a window on a man page: >
    Now you
    :Man csh
    You can scroll around and the text is highlighted. This allows you to find
    the help you were looking for. Use CTRL-W w to jump to the window with the
    text you were working on.
    To find a man page in a specific section, put the section number first.
    For example, to look in section 3 for "echo": >
    :Man 3 echo
    To jump to another man page, which is in the text with the typical form
    "word(1)", press CTRL-] on it. Further ":Man" commands will use the same
    window.
    To display a man page for the word under the cursor, use this: >
    \K
    (If you redefined the <Leader>, use it instead of the backslash).
    For example, you want to know the return value of "strstr()" while editing
    this line:
    if ( strstr (input, "aap") == ) ~
    Move the cursor to somewhere on "strstr" and type "\K".
    A window will open
    to display the man page for strstr().
    To remove whitespace at the end of every line, execute the following command: >
    :%s/\s\+$//
    If you are a UNIX user, you can use a combination of Vim and the grep command to EDIT ALL THE FILES THAT CONTAIN A GIVEN WORD :D. This is extremely useful if you are working on a program and want to view or edit all the files that contain a specific variable. 
    vim `grep -l frame_counter *.c`
    VIMGREP (Hitta ord inne i filer i buffertlistan i vim :DDD )
    o
    yyyy
    Error setting the text for the following input: =sortera :D.
    o
    :grep error_string *.c
    This causes Vim to search for the string "error_string" in all the specified files (*.c). The editor will now open the first file where a match is found and position the cursor on the first matching line.
    :cnext
    To go to the next matching line (no matter in what file it is), use the ":cnext" command.
    :cprev
    To go to the previous match, use the ":cprev" command.
    :clist
    Use ":clist" to see all the matches and where they are.
    o
    Vim has a built-in command that you can use to search a set of files for a
    given string. If you want to find all occurrences of "error_string" in all C
    program files, for example, enter the following command: >
    o
    :vimgrep /vindruvor/ inköpslista
    :vimgrep /vindruvor/ *.txt
    Error setting the text for the following input: =sök i flera filer (eller mappar).
    :cn  /  :cN
    :cl
    :cc 5
    gy till post nr 5 i lista över responses från senaste vimgrepsökning
    The ":grep" command uses the external commands grep (on Unix) or findstr (on Windows). You can change this by setting the option 'grepprg'.
    stänga vim och komma tillbaks (kap 21 i user manual)
    o
    ctrl+z
    {andra kommandon i skalet mm}
    fg
    o
    :shell
    :!xterm&
    VIMINFO (=spara märken, innehåll i registers mm med en fil :DD
    s99 :) [se mer detaljerna]
    o
    Error setting the text for the following input: =sätt upp lapp på väggen + sätt :DD.
    The "!" is also used in other places where a program is run. Let's take a look at an overview:
    :!{program}
    execute {program}
    :r !{program}
    execute {program} and read its output
    :w !{program}
    execute {program} and send text to its input
    :[range]!{program}
    filter text through {program}
    sessions
    gå direkt till senaste filen som redigerades :D == '0
    gå direkt till nån av nio filer som red.ades innan nuvarande = '1-'9 :D
    se var du hamnar m hj av :marks :)
    visa numrerad lista på senaste redigerade filerna
    :oldfiles
    redigera 2 från :oldfiles-listan
    :e #<2
    dela fönster med fil 2 från oldfileslistan
    :split #<2
    #<2 olikn kan användas med alla kommandon som tar ett filnamn som argument :D
    t ex :split #<2
    enlare sätt att redigera fil 2 i oldfiles-listan :D
    :browse oldfiles
    q
    2<Enter>
    utbyta register-innehåll mm mellan två instanser av vim :DDDD !!
    You can use the ":wviminfo" and ":rviminfo" commands to save and restore the information while still running Vim. This is useful for exchanging register contents between two instances of Vim, for example. In the first Vim do: >
    :wviminfo! ~/tmp/viminfo
    And in the second Vim do: >
    :rviminfo! ~/tmp/viminfo
    SE MER EV s101 :)
    SESSIONS :)
    session = en sittning (=alla fönster som var öppna, filer i buffertlistan mm) :D
    skapa en session
    :mksession session.vim
    öppna en sparad session
    :so(urce) session.vim
    vim -S session.vim
    (S funkar för att sourcea alla vimskript) :]
    options för session :)
    blank
    keep empty windows
    buffers
    all buffers, not only the ones in a window
    curdir
    the current directory
    folds
    folds, also manually created ones
    help
    the help window
    options
    all options and mappings
    winsize
    window sizes
    Change this to your liking. To also restore the size of the Vim window, for example, use: >
    :set sessionoptions+=resize
    SESSIONS AND VIMINFO :DD
    Sessions store many things, but not the position of marks, contents of registers and the command line history. You need to use the viminfo feature for these things.
    In most situations you will want to use sessions separately from viminfo.
    This can be used to switch to another session, but keep the command line history. And yank text into registers in one session, and paste it back in another session.
    You might prefer to keep the info with the session. You will have to do this yourself then. Example: >
    :mksession! ~/.vim/secret.vim
    :wviminfo! ~/.vim/secret.viminfo
    And to restore this again: >
    :source ~/.vim/secret.vim
    :rviminfo! ~/.vim/secret.viminfo
    o
    Exempel på användning :D
    :wall
    :mksession! ~/.vim/secret.vim
    :source ~/.vim/boring.vim
    If you open help windows, split and close various window, and generally mess up the window layout, you can go back to the last saved session: >
    :source ~/.vim/boring.vim
    For example, this is a nice layout to use (s102):
    This has a help window at the top, so that you can read this text. The narrow vertical window on the left contains a file explorer. This is a Vim plugin that lists the contents of a directory. You can select files to edit there.
    More about this in the next chapter.
    Create this from a just started Vim with: >
    :help
    CTRL-W w
    :vertical split ~/
    You can resize the windows a bit to your liking. Then save the session with: >
    :mksession ~/.vim/mine.vim
    Now you can start Vim with this layout: >
    vim -S ~/.vim/mine.vim
    VIEWS :] (s103)
    grund
    view med namn
    (s149)
    :mkview
    This will store the settings and other things that influence the view on the file. You can change what is stored with the 'viewoptions' option.
    :loadview
    When you come back to the same file later, you can load the view again: >
    You can store up to ten views on one file. For example, to save the current setup as the third view and load the second view: >
    :mkview 3
    :loadview 2
    MODELINES (=sätta options för en speciell fil) :DD (s104) SE MER
    (som första el sista 5 rader i en fil) /* vim:set shiftwidth=4: */
    skifta mellan unix och windows (s103) se mer ev
    WRITE :D
    o
    spara ut nuvarande rad till filen 'nyfil.txt'
    :.w /tmp/nyfil.txt
    :.write otherfile
    spara ut rad 5 till sista raden och lägg till i filen nyfil
    :5,$w >> /tmp/nyfil.txt
    :.,$
    lägg till hela nuvarande fils innehåll till sist i filen 'loggfil' :DD
    :w >> logfile
    skriv över utfil med nuvarande rad från nufil
    :.w! utfil
    o
    spara som :)
    :sav filkopia.txt
    ändra namn på filen man redigerar UTAN att spara (!)
    :f(ile) nytt filnamn
    Vim will mark the file as "not edited". This means that Vim knows this is not the file you started editing. When you try to write the file, you might get this message:
    E13: File exists (use ! to override) ~
    This protects you from accidentally overwriting another file.
    skriv ut vad filen heter
    :f
    annat sätt att skriva :w filnamn.kopia
    :w %.kopia :)
    REDIGERA KOMMANDOHISTORIK :DDDDDDD
    o
    SUBSTITUERING [:s///]
    The general form of this command is as follows: >
    :[range]substitute/from/to/[flags]
    from' är i själva verket ett mönster/regex :DDD (t ex \<from)
    g/mönster1/s//mönster2/
    flaggor/växlar för substituering
    g
    global (=ersätt på alla ställen i raden)
    p
    print
    :s/this/that/p
    e
    Error setting the text for the following input: =att inte hitta ordet för utbytet är inte error (=stoppar inte inspelade kommandosekvenser när inget hittas :). <#ID_576869931>
    c
    confirm
    y
    yes
    n
    no
    a
    all
    q
    quit
    l (litet L)
    last
    ctrl+e
    rulla ner bilden en rad
    ctrl+y
    rulla upp bilden en rad
    n
    byt ut saker som innehåller snedstreck :)
    :s+one/two+one or two+
    :s:one/two:one or two:
    osv
    gör utbyte bara inom range :)
    :1,5s/this/that/g
    :.+3,$-5
    tre rader efter markörsraden till fem rader ovanför filens sista rad
    gör utbyte i range mellan märke t och märke b :DD
    :'t,'b
    visiual range-märkning
    :'<,'>
    från slutet av markering till slutet av filen :]
    :'>,$
    gör utbyte bara på en viss rad
    :54s/President/Fool/
    byt ut i nuvarande raden t o m sista raden
    :.,$s/yes/no/
    mönster som adress-range: byt ut grey mot gray i nuvarande kapitlet
    :?^Chapter?,/^Chapter/s=grey=gray=g
    rad-offsets :DDD
    o
    Then you can specify an offset.
    To search for a pattern and then use the line above it: >
    /Chapter/-1
    o
    You can use any number instead of the 1.
    To address the second line below the match: >
    /Chapter/+2
    ange 5 rader fr o m nuvarande :DDD
    When you know how many lines you want to change, you can type the number and then ":". For example, when you type "5:", you will get: >
    :.,.+4
    byt ful mot snygg på alla ställen i nuvarande kapitlet
    :?^Chapter?,/^Chapter/s=ful=snygg=g
    Ta bort helt tomma rader
    :%s/\s\+$//g
    ??? hela matchade mönstret (\1 är ju matchade parenteser nr 1) ???
    \0
    o
    skifta plats på två ord
    använd fångande parenteser + byt plats på innehållet med \2 och \1
    ändra 'That or this' till 'This or that'
    :s/\(That\) or \(this\)/\u\2 or \l\1/ [näst sista= litet L!]
    ändra alla tecken fram till \e / \E till versal
    \U
    ändra alla tecken fram till \e / \E till gemen
    \L
    o
    &
    hela det matchade
    :%s/Kalle/& Stropp/
    ~
    senaste ersättningen
    :s/honoms/hans/ :s/hanses/~/
    :)
    :D
    Gör om exakt senaste s-substitueringen :DD
    & ***
    o
    :s
    o
    ???????????????
    räkna ord i hela filen
    använd /n sist (?) :)
    öppna man-sida från ord i text inne i vim
    ta bort helt tomma rader i filen
    byt ut ord med :s och visa bytena som gjorts
    /p :)
    GLOBAL (= :g)
    :[range]global/{pattern}/{command}
    command = :-kommandon
    vanliga normallägeskommandon måste anges med :normal :)
    funkar för alla regexmönster :)
    Suppose you want to change "foobar" to "barfoo", but only in C++ style comments. These comments start with "//". Use this command: >
    :g+//+s/foobar/barfoo/g
    o
    :g
    kör på alla rader där mönster förekommer
    o
    :g!
    kör på alla rader där mönster INTE förekommer
    :v
    kör på alla rader där mönster INTE förekommer
    hitta och visa alla rader i fil som innehåller mönster
    :g/mönster/p
    hitta och visa alla rader i fil som inte innehåller mönster + visa radnummer för dessa rader
    :g!/mönster/nu
    hitta och visa alla rader mellan 60 och 124 som innehåller 'mönster'
    :60,124g/mönster/p
    :1,3d | s/deres/deras/
    sudda rad 1 till 3, byt sedan ut deres mot deras (på rad 1)
    vänd bak och fram på fil :D
    :g/^/m0
    o
    READ :D
    läs in innehållet i filen patch.txt till sist i nuvarande filen
    :$r patch.txt
    läs in resultatet från kommandot ls i filen (=hamnar raden under markören) :)
    :r !ls
    not från anteckningarna: kommandot till höger ska också kunna ha växlar :D
    läs in resultatet från kommandot 'date -u' till överst i filen
    :0r !date -u  :)
    placera in fil a efter raden med 'mönster'
    :/mönster/r mapp/a
    läs in innehållet från alternativa filen i nuvarande filen :]
    :e #
    FILTRERA TEXT MED BASHKOMMANDON :DDDDD
    REGLER::
    x.Textblock måste vara mer än en rad
    x. Hela raderna påverkas :)
    Filtrera textblock genom kommando :DDDD
    ![blockadress][kommando]
    !{motion/rows}{program}
    t ex: !)kommando  :)
    textblocksoperatorer: :)
    gg
    G
    { }
    ( )
    [[  ]]  (?)
    +
    -
    skicka från nuvarande rad till rad 20 för filtrering av kommando
    :.,.+20!kommando
    filtrera t o m rad 5 med sort
    !5Gsort<Enter>
    Error setting the text for the following input: =filtrera från nuvarande rad till rad 5 med sort och sätt in på orginalplats :).
    Filtrera hela filen
    :!%sort
    Filtrera hela filen (numerisk sort)
    :!%sort -n
    filtrera texten i filen med cat och sätt in radnummer:
    :%!cat -n %
    sortera baklänges
    :sort!
    filtrera från nuvarande rad till raden innan tom rad genom sort
    :.,/^$/-1!sort
    filtrera från nuvarande rad till rad 20 med sort och sätt in på orginalplats
    20!!sort
    :)
    !20!sort
    :.,.+20!sort
    filtrera nästa 10 rader med sort och sätt in på orginalplats
    !10+sort
    :)
    10!+sort
    filtrera nuvarande rad genom filter
    !!kommando :)
    (=samma som :.!kommando :)
    byt ut nuvarande rad mot resultatet för kommandot date
    !!date
    räkna antalet ord i nuvarande fil m hj av wc
    :w !wc  :DD
    gg, !Gwc
    Error setting the text for the following input: =INTE! (räknar men ersätter hela filen med resultatet.
    skicka all text från nuvarande filen till specat kommando
    :w !kommando
    Repetera föregående filtreringskommando
    ! objekt !
    ??????? :]
    o
    :96,99!sort
    skicka nästa mening genom kommando x
    !)kommando
    kör nuvarande rad genom kommando x
    !!kommando
    kör nuvarande rad+4 genom kommando x
    5!!kommando
    kör nuvarande rad+3 genom sort
    4!!sort
    !4!sort
    kör kommando på nästa 10 rader
    !10+kommando
    10+!kommando
    -----
    skicka nuvarande rad+4 rader framåt till kommando t ex för redigering (förbered för redigering) :)
    5: (=ger :.,.+4)
    :)
    . förbered nästa mening för redigering
    !)
    . ändra allt i fil från gemener till versaler
    tr '[a-z]' 
    Options för extern kommando-filtrering
    s79 i vim user manual
    skillnaden mellan !!date och :r !date :DDD
    vim softtabstops :) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim--converting_tabs_to_spaces.html>
    Error setting the text for the following input: =kolla med abbe och krister om vilka inställningar de använder (för python mm) :D.
    dra in block en shiftwidth
    >
    ta bort en shiftwidth för block
    <
    :se autoindent
    :se smartindent
    :se expandtab
    :se tabstop=4
    :retab
    :.retab
    :retab 8 (??)
    :se shiftwidth=4
    :se softtabstop=4
    backspace kommer att hantera 4 spaces som en tab :)
    (+det kanske finns färdiga extra filer och paket att installera för python och vim?? (testkörning mm=? :)
    TABS OCH INDENTERA/DRA IN BLOCK
    dra in fyra rader en indent :DD
    4>>
    dra in block en shiftwidth
    >
    ta bort en shiftwidth för block
    <
    mata in/ta bort tab [insertmode]
    ctrl+t/ctrl+d
    :se autoindent
    :se smartindent
    CONVERTING TABS TO SPACES och SOFTTABSTOPS :DDD (25.3 s129)
    :se expandtab
    :se tabstop=4
    :retab
    :.retab
    lägg om tabstop till 
    :set tabstop=3
    :retab 8
    (s129)
    :se shiftwidth=4
    :se softtabstop=4
    backspace kommer att handera 4 spaces som en tab :)
    vim colorschemes <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+color+schemes&ie=utf-8&oe=utf-8>
    THE GUI
    status på filen :)
    -
    cannot be modified (e.g., a help file)
    +
    contains changes
    =
    is read-only
    =+
    is read-only, contains changes anyway
    If nothing is shown you have an ordinary, unchanged file.
    -- s65
    clipboard - s66
    options
    :set selectmode+=mouse
    s67
    BLANDADE EX-KOMMANDON :)
    skicka x antal rader till kommandoraden för redigering
    :.,.+4
    5:
    SKRIV UT
    :ha(rdcopy)
    You can specify that a different printer is used with :set pdev=printer. For example, :set pdev=usblp1
    skriva ut/ange printrange (=????) :)))
    mer om printing :) <http://vim.runpaint.org/basics/printing/>
    If you have a PDF printer installed1, you can use this technique to print a file to PDF. For example, assuming your PDF printer is called pdf:
    set pdev=pdf
    set printoptions=paper:A4,syntax:y,wrap:y
    The printoptions line is a comma separated list of values that affect how Vim formats the document before it sends it to the printer. A list of options is at :help popt. The paper option sets the paper size. It accepts values such as A3, letter, and legal. The syntax option determines whether the document is printed with syntax highlighting. By default it has the value a which means that Vim only uses highlighting for colour printers. A value of y forces highlighting. Lines are wrapped when wrap:y, which is the default. If wrap has the value n, long lines are truncated. Other useful options are header:0 to stop a header from being printed, number:y to number lines, duplex:off to print on only one side of the page.
    FLYTTA, KOPIERA MM :)
    ??? flytta raderna 13-14 till överst i filen ???
    ???
    SPELA IN KOMMANDOSEKVENSER :)
    spela in kommando-sekvens till a-registret
    qa
    kör inspelade kommandot i a-registret
    @a
    kör senast körda inspelade kommandosekvensen igen
    @@
    utför inspelade kommandosekvensen a 3 gånger
    3@a
    avsluta inspelning av kommandosekvensen
    kör senast körda q-kommandot igen
    lägg till sökning efter 'mönster' med / sist i kommandoregistret c
    anv C (se mer)
    kopiera och lägg till rad sist i register a
    anv C (se mer)
    VISUAL MODE
    v
    V
    Ctrl+v
    o
    gå till hörn diagonalt mittemot :D
    O
    gå till hörn HORISONTELLT mittemot
    VIMRC
    syntax för kommando, t ex :set incsearch i .vimrc-filen :]
    set incsearch
    s36+ [kolla options]
    set nocompatible
    set backspace=indent,eol,start
    set autoindent
    sätt backup (+extra)
    if has("vms")
    set nobackup
    else
    set backup
    endif
    set history=50
    set ruler
    set showcmd
    set incsearch
    mappings
    map Q gq  :)
    This defines the "Q" command to do formatting with the "gq" operator. This is how it worked before Vim 5.0.
    vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>
    This mapping yanks the visually selected text and searches for it in C files.
    This switches on syntax highlighting, but only if colors are available
    if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
    endif
    filetype plugin indent on
    This switches on three very clever mechanisms:
    Filetype detection.
    Using filetype plugin files
    Using indent files
    autocmd FileType text setlocal textwidth=78
    This makes Vim break text to avoid lines getting longer than 78 characters. But only for files that have been detected to be plain text.
    sök i :h på line-continuation
    sed -ie 's/.*/the_heart_asks_pleasure_first/' .dfs2rc
    MAPPINGS
    listade vid .vimrc :)
    :map <F5> i{<Esc>ea}<Esc>
    mapping för att omge ett ord med måsvingar
    :map Q gq
    o
    :map \p i(<Esc>ea)<Esc>
    :map \c i{<Esc>ea}<Esc>
    lista alla angivna mappings
    :map
    :)
    :vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/*.c *.h"<CR> (s37 i user manual) :)
    Namn på vanliga tangenter i mappings :DDD
    o
    specialnamn för F-tangenter mm <http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_2%29>
    specialnamn för F-tangenter mm <http://vimdoc.sourceforge.net/htmldoc/map.html#mapping>
    f5
    <F5>
    escape
    <Esc>
    enter
    backspace
    <BS>
    bra tangentkombinationer för nya mappings
    F2-12
    \p
    _x
    ,x
    (-x)?
    SYNTAX HIGHLIGHTING = se mer ev s44
    slå på syntax highlighting
    :syntax enable
    PLUGINS
    listade vid .vimrc :)
    var lägga plugins
    lägg i pluginmappen :)
    två sorternas plugins
    global plugin: Used for all kinds of files
    filetype plugin: Only used for a specific type of file
    plugin directory
    Unix
    ~/.vim/plugin/
    :)
    Instead of putting plugins directly into the plugin/ directory, you may better organize them by putting them into subdirectories under plugin/. As an example, consider using "~/.vim/plugin/perl/*.vim" for all your Perl plugins.
    The Vim distribution comes with a set of plugins for different filetypes that you can start using with this command: >
    :filetype plugin on
    The scripts in $VIMRUNTIME/macros are global ones, the filetype plugins are in $VIMRUNTIME/ftplugin.
    *lägga till nya help-filer för en plugin :) (s41 manualen)
    Copy the help file to the "doc" directory. >
    :!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc
    Now comes the trick, which allows you to jump to the subjects in the new help file: Generate the local tags file with the |:helptags| command. >
    :helptags ~/.vim/doc(=sökväg till dokumentationen)
    Now you can use the > :help g% command to find help for "g%" in the help file you just added.
    You can see an entry for the local help file when you do: >
    :help local-additions
    ((se ev även write-local-help))
    FORMATERA TEXT (=t ex alla rader lika långa mm)
    sätt textbredd till 72 tecken
    :se textwidth=72
    formatera om nuvarande stycke så det rättar sig efter formatering (t ex 72 teckens radbredd)
    gq ap
    formatera om hela filen så det rättar sig efter formatering
    gggqG
    formatera nuvarande rad och gå till nästa
    gqj
    gU/gu
    ord till stora bokstäver
    gUw
    ord till små bokstäver
    guw
    byt case på tecken
    g tilde
    Dubblera ovanstående för att påverka hel rad :DDDD !!!!!
    g tilde
    g~
    gUgU(gUU)
    gugu(guu)
    g tilde x2(g tilde tilde)
    g~~
    byta case på visual-markerad text (till upper)
    U
    :set wrapmargin=4 (=bryt rad med hård radbrytning när är 4 tecken från terminalkanten)
    ÅTERHÄMTA EFTER EN KRASCH
    öppna fil help.txt som redigerades när syst. kraschade
    vim -r help.txt :)
    (därefter)
    To be on the safe side, write this file under another name: >
    :write help.txt.recovered
    Compare the file with the original file to check if you ended up with what you expected. Vimdiff is very useful for this |08.7|. For example: >
    :write help.txt.recovered
    :edit #
    :diffsp help.txt
    options
    updatetime'
    updatecount'
    If you were editing without a file name, give an empty string as argument: >
    vim -r ""
    Vim can store the swap file in several places. Normally it is in the same directory as the original file. To find it, change to the directory of the file, and use: >
    vim -r
    mm SE MER EV EV SENARE
    o
    o
    o
    o
    Editing formatted text - s126
    REDIGERA KOMMANDORADEN
    gå ur kommandoraden
    Esc/Ctrl+c
    gå ett ord åt vänster/höger
    ctrl+vänster/höger :]
    komm.radskommando: gå till början av :-kommandorad
    Ctrl+b
    komm.radskommando: gå till slutet av :-kommandorad
    Ctrl+e
    komm.radskommando: sudda ord
    Ctrl+w
    komm.radskommando: ta bort allt inskrivet fram till slutet på :-kommandoraden :) [=TESTA]
    Ctrl+u :)
    komm.radskommando: sudda allt hittills inskrivet på :-kommandoraden
    ??
    i :-kommandorad: slutför ord så långt det går för gå igenom alternativ ett efter ett
    Tab (ev x2)
    gå tillbaks till förra ordet (motsatt tab)
    ctrl+p
    i :-kommandorad: lista alla alternativ för påbörjat ord (samma som 2T i skal när flera alternativ finns)
    Ctrl+d
    samma som tab i detta sammanhang :)
    Ctrl+L
    gå till senaste :-kommandot som börjar m 'se'
    :se + pil upp :]
    ta reda på nuvarande värden på options m hj av tab :DDDD
    Gives: >
    :set iskeyword
    Now type "=" and press <Tab>: >
    :set iskeyword=@,48-57,_,192-255
    What happens here is that Vim inserts the old value of the option. Now you can edit it.
    What is completed with <Tab> is what Vim expects in that place. Just try it out to see how it works. In some situations you will not get what you want. That's either because Vim doesn't know what you want, or because completion was not implemented for that situation. In that case you will get a <Tab> inserted (displayed as ^I).
    o
    lista slutföringsträffar för ett ord :D (som 2x tab i skalet)
    ctrl+d :)
    slutför ord till längsta möjliga icke tvetydiga sträng :)
    ctrl+L
    More about all of this here: |cmdline-completion|
    visa history för :-kommandona
    :history
    visa history för /-sök
    :history /
    visa history för
    öppna fönster och redigera kommandoradshistoriken :DDDD
    *20.5* Command line window
    Typing the text in the command line works different from typing text in Insert mode. It doesn't allow many commands to change the text. For most commands that's OK, but sometimes you have to type a complicated command. That's where the command line window is useful.
    Open the command line window with this command: >
    q:
    Vim now opens a (small) window at the bottom.
    It contains the command line history, and an empty line at the end:
    FOLDS
    :se foldmethod=indent(/syntax)
    gå till föregående/nästa undanvikning :DDDDD
    zk/zj
    fold – grund: skapa fold i vim
    zf
    fold – grund: öppna/stäng alla folds direkt :)
    zi
    om foldmethod satt till indent: vik undan indenterat block
    zM
    o
    o
    o
    o
    o
    When in insertmode, the fold at the cursorline is never closed. That allows you to see what you type!
    o
    The folding is local to the window. This allows you to open two windows on the same buffer, one with folds and one without folds. Or one with all folds closed and one with all folds open.
    VYER
    SENAST REDIGERADE FILER :)
    MATA IN :)
    mata in samma text i början av fyra rader m hj av Ctrl+V :)
    C-v; I (stort i); mata in; Esc
    SÖKMÖNSTER/REGEX/REGULAR EXPRESSIONS :DD (se också /-sök ovan)
    Error setting the text for the following input: =Lägg till sist från eminenta Vim-tips-filen advanced + Regexavsnittet från user-manual.
    o
    KRYPTERING - manualen s114
    REDIGERA BINÄRFILER - manualen s115
    Redigera komprimerade filer - manualen s116
    SENASTE = placera in <#ID_926325771>
    PLACERA IN
    placera in tab (??) :]
    Ctrl+d
    Ctrl+t
    INSERT MODE
    samma som backspace
    Ctrl+h
    samma som tab
    Ctrl+i
    samma som enter
    Ctrl+j, Ctrl+m
    samma som Esc :DD !!!!!!
    Ctrl+AltGr+8
    kör ett kommando i ex-mode
    Ctrl+o
    sudda alla inmatade tecken på nuv. raden :] (TESTA)
    Ctrl+u
    mata in tecken enligt sin 3-siffriga kod
    Ctrl+v +3-siffrigt tal
    Ctrl-w =????
    höj/sänk tal med 1
    INDENTERING
    ta bort all indentering på nuvarande raden :)
    0 Ctrl+d
    ta bort all indentering på nuvarande raden + återställ på nästa raden :)
    ^ Ctrl+d
    CTRL-X-SUBMODE :]
    vim completing mm :) <http://www.cs.oberlin.edu/~kuperman/help/vim/completion.html>
    Ctrl+x Ctrl+L
    hel rad
    Ctrl+x Ctrl+d
    makrodefinition (även i included files)
    Ctrl+x Ctrl+i
    keyword in current and included files (??)
    Ctrl+x Ctrl+k
    getting dictionaries :) <http://vim.runpaint.org/typing/auto-completing-text/#getting-dictionaries>
    språkkod för svenska i vim :D <http://ubuntu-se.org/phpBB3/viewtopic.php?f=67&t=32844>
    dictionaries för andra språk i vim :) <ftp://ftp.vim.org/pub/vim/runtime/spell/>
    human-language-codes vim <https://www.google.com/search?client=ubuntu&channel=fs&q=language+codes+vim&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=zou&tbo=d&channel=fs&sclient=psy-ab&q=human+language+codes+vim&oq=human+language+codes+vim&gs_l=serp.3...35825.36815.0.37089.6.6.0.0.0.1.130.570.4j2.6.0.les%3B..0.0...1c.1.8Gwbg5LXOQE&pbx=1&fp=1&bpcl=39468505&biw=1366&bih=634&bav=on.2,or.r_gc.r_pw.r_cp.r_qf.&cad=b&sei=5_3EUKWeBKTl4QSg0IGYAg>
    Ctrl+x Ctrl+o
    omnicompletion
    Error setting the text for the following input: =samma som c-x c-v nedan, men mer specifikt för programmeringsspråk.
    för att kunna köra omnicompletion: filetypeplugin (indent) på, och kör ctags
    Ctrl+x Ctrl+p
    Ctrl+x Ctrl+n
    o
    Ctrl+x Ctrl+u
    Ctrl+x Ctrl+v
    Error setting the text for the following input: =vim commandline: gissa vad det innan markören (som ska slutföras) är, och mata in träffar.
    +tryck ctrl+n/p för förra/nästa träff
    Ctrl+x Ctrl+f - s119-120
    filenames (of files that resides anywhere on the linuxsystem)
    Error setting the text for the following input: =när du ger sökväg refererad till inne i dokument.
    Ctrl+x Ctrl+y
    Ctrl+x Ctrl+e
    Ctrl+x (Ctrl?+) s
    spelling
    svensk stavning <http://ubuntu-se.org/phpBB3/viewtopic.php?f=67&t=32844>
    Ctrl+x Ctrl+t
    ord från synonymordbok
    thesaurus i vim <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+thesaurus+file&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=fHa&tbo=d&channel=fs&sclient=psy-ab&q=vim+thesaurus&oq=vim+thesaurus&gs_l=serp.3..0l3j0i8i30.18174.18742.0.19024.5.5.0.0.0.0.119.461.4j1.5.0.les%3B..0.0...1c.1.h2VTMF7o51U&pbx=1&fp=1&bpcl=39468505&biw=1366&bih=634&bav=on.2,or.r_gc.r_pw.r_cp.r_qf.&cad=b&sei=L_7EUPCrGcKC4ATYk4GoDg>
    set up a lightweight vim thesaurus <http://www.nickcoleman.org/blog/index.cgi?post=vim-thesaurus!201202170802!general%2Cblogging%2Cinternet%2Cprogramming%2Csoftware%2Cunix>
    synonymer.se :) <http://www.synonymer.se/>
    Ctrl+x Ctrl+]
    tags
    o
    Ctrl+e
    stoppa ovanläge när inne i (?)
    REGISTERS
    mata in innehållet ur angivet register :D
    Ctrl+r [0-9a-z"%#*:=]
    mata in innehållet ur angivet register (bokstavligt)
    Ctrl+r Ctrl+r
    mata in innehållet ur angivet register (bokstavligt + autoindentera INTE)
    Ctrl+r Ctrl+o
    mata in innehållet ur angivet register (bokstavligt + fixera indentering)
    Ctrl+r Ctrl+p
    mata in radbrytn.tecken m fl uttryckligen
    Ctrl+v :D
    tvinga systemet att spara bufferten även om inte strömstopp o likn
    :pre
    3 sätten att specificera radadresser :)
    - med uttryckliga radnummer
    - med symboler som anger relativt till nuvarande position (t ex $, .+1 osv)
    - som sökmönster som adress som anger rader som ska påverkas
    kommandoradshistorik
    visa history för /-sökningar
    o
    öppna kommandoradsfönster med :-kommandohistorik + tom kommandorad längst ner
    q:
    Error setting the text for the following input: =redigera som vanlig text + tryck sen enter :DD.
    öppna kommandoradsfönster med /-sökhistorik + tom kommandorad längst ner
    q/
    öppna kommandoradsfönster med ?-sökhistorik + tom kommandorad längst ner
    q?
    ändra kommando från kommandohistoriken inne i kommandofönstret
    [[titta över regex]]
    ---
    kör skalprogram och läs in resultatet i filen
    :r !skalkommando :D
    slå på liten kolumn till vänster som visar folds
    vyer
    spara fil med folds mm = view
    öppna sparad vy
    se lista på filer du redigerat senaste gångerna inne i vim
    kolla listan på filer redigerat senaste gångerna + gå ut och redigera m hj av siffra ***
    s100 i vim user manual :D
    dela fönster för att också kunna redigera fil 3 från oldfileslistan :)
    skapa en 'session' = spara fönster och filer från ett redigeringstillfälle
    återställ session
    1. från inne i vim
    2. från kommandoraden
    namn på registret text sparades i förra gången suddades med d (delete)
    visa innehållet i delete- och bokstavsbuffrarna
    klistra in namnet på filen i filens text
    ---------------------------------------
    indentera i kommandoläge
    ta bort indentering i kommandoläge
    repetera förra kommandolägeskommandot
    ge full sökväg m hj av %
    x4
    o
    gå tillbaks till hur fil såg ut för 20 min sedan
    gå tillbaks till hur fil såg ut för 1 timme sedan
    SE MER: kör kommando i flera flikar
    skapa fold från markören 5 rader ner
    öka storlek på split m Ctrl-kommando
    sök fram/nästan fram till nästa bokstaven s
    gör 10 rader neråt redo för kommandorads-kommando
    o
    följ hyperlänk i hjälpfil ****
    gå tillbaks efter följt länk i hjälpfil
    gå framåt igen efter gått tillbaks från följt länk
    gå till nästa/föregående undanvikning ***
    gj/gk ????? :]
    o
    blandat
    sudda t o m sista raden = dG :D
    I
    A
    ändra case på tecken = tilde :)
    konvertera en text till html :)
    Convert the current file to HTML with this command: >
    :TOhtml
    In case that doesn't work: >
    :source $VIMRUNTIME/syntax/2html.vim
    :so /usr/share/vim/vim72/syntax/2html.vim
    :TOhtml 
    You will see it crunching away, this can take quite a while for a large file. Some time later another window shows the HTML code. Now write this somewhere (doesn't matter where, you throw it away later): >
    :write main.c.html
    Open this file in your favorite browser and print it from there. If all goes well, the output should look exactly as it does in Vim. See |2html.vim| for details. Don't forget to delete the HTML file when you are done with it.
    öppna fil i readonly-läge
    A.
    vim -R fil
    view fil
    (lägg till ! för att tvinga write :)
    B.
    vim -M fil
    (:se modifiable och :se write för att kunna ändra filen :)
    o
    lägg ihop två rader
    J
    lägg ihop två rader utan att ändra mellanslag :)
    gJ
    o
    o
    höst2013:
    :set guifont={Andale\ Mono\ 11}
    xlsfonts ==visa tillgängliga fonts i gvim
    ???
    :echo &path
    några intressanta plugins:
    sessionman
    SuperTab
    VimOutliner + otl2html + otl2docbook
    vims inbyggda sort
    i
    u
    n
    :sort /mönster/
    skifta mellan de olika visuallägena
    lägga till t ex ':set number' i sin vimrc + kommentar ovanför
    sätta a2ps för att hantera utskrifter - s36 i Bram Beer-boken
    sätta så osynliga tecken (som Linebreak) syns - :se list
    output redirection to a file - s57 i Bram Beer-boken
    Enkel map för att spara sessions - s59 i Bram Beer-boken
    g- för undogrenar
    boilerplatecode och templates - s68 i Bram Beer-boken
    ctrl+k för accenttecken, t ex långt japanskt o
    o
    gf öppnar fil i samma fönster som standard. öppna i ny tab med ctrl+w+gf. remap för att göra till default = :nnoremap gf <C-W>gf
    om namnet på din fil följs av ett radnummer, t ex foo.txt:10 så kan du hoppa till den givna raden med gF  (=???)
    snipMate - s88 i Bram Beer-boken
    Navigating sourcecode - s95 i Bram Beer-boken = TESTA!
    :b f på s99 i Bram Beer-boken
    (=??) :)
    Sätta synliga markörer och bokmärken - s113 i Bram Beer-boken
    Skapa menyer och verktygsknappar - s121 i Bram Beer-boken
    ** och *.txt för att söka 'neråt- efter filer (när jobbar med vimgrep mm)
    = sXX i Bram Beer-boken (??)
    :help pattern för mer om regular expressions
    :set keywordprg=pydoc (typ) ist. för 'man' för att kunna jobba med py och 'K'
    - s57 i Bram Beer-boken
    - s57 i Bram Beer-boken
    mer från user manual:
    vimscript <http://vimdoc.sourceforge.net/htmldoc/usr_41.html>
    Help FAQ Both
    Vim documentation: usr_41
    main help file
    *usr_41.txt*        For Vim version 7.3.  Last change: 2011 Feb 15
    VIM USER MANUAL - by Bram Moolenaar
    Write a Vim script
    The Vim script language is used for the startup vimrc file, syntax files, and
    many other things.  This chapter explains the items that can be used in a Vim
    script.  There are a lot of them, thus this is a long chapter.
    |41.1|        Introduction
    |41.2|        Variables
    |41.3|        Expressions
    |41.4|        Conditionals
    |41.5|        Executing an expression
    |41.6|        Using functions
    |41.7|        Defining a function
    |41.8|        Lists and Dictionaries
    |41.9|        Exceptions
    |41.10|        Various remarks
    |41.11|        Writing a plugin
    |41.12|        Writing a filetype plugin
    |41.13|        Writing a compiler plugin
    |41.14|        Writing a plugin that loads quickly
    |41.15|        Writing library scripts
    |41.16|        Distributing Vim scripts
    Next chapter: |usr_42.txt|  Add new menus
    Previous chapter: |usr_40.txt|  Make new commands
    Table of contents: |usr_toc.txt|
    ==============================================================================
    *41.1*        Introduction                                *vim-script-intro* *script*
    Your first experience with Vim scripts is the vimrc file.  Vim reads it when
    it starts up and executes the commands.  You can set options to values you
    prefer.  And you can use any colon command in it (commands that start with a
    ":"; these are sometimes referred to as Ex commands or command-line commands).
    Syntax files are also Vim scripts.  As are files that set options for a
    specific file type.  A complicated macro can be defined by a separate Vim
    script file.  You can think of other uses yourself.
    Let's start with a simple example:
    :let i = 1
    :while i < 5
    :  echo "count is" i
    :  let i += 1
    :endwhile
    Note:
    The ":" characters are not really needed here.  You only need to use
    them when you type a command.  In a Vim script file they can be left
    out.  We will use them here anyway to make clear these are colon
    commands and make them stand out from Normal mode commands.
    Note:
    You can try out the examples by yanking the lines from the text here
    and executing them with :@"
    The output of the example code is:
    count is 1
    count is 2
    count is 3
    count is 4
    In the first line the ":let" command assigns a value to a variable.  The
    generic form is:
    :let {variable} = {expression}
    In this case the variable name is "i" and the expression is a simple value,
    the number one.
    The ":while" command starts a loop.  The generic form is:
    :while {condition}
    :  {statements}
    :endwhile
    The statements until the matching ":endwhile" are executed for as long as the
    condition is true.  The condition used here is the expression "i < 5".  This
    is true when the variable i is smaller than five.
    Note:
    If you happen to write a while loop that keeps on running, you can
    interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).
    The ":echo" command prints its arguments.  In this case the string "count is"
    and the value of the variable i.  Since i is one, this will print:
    count is 1
    Then there is the ":let i += 1" command.  This does the same thing as
    ":let i = i + 1".  This adds one to the variable i and assigns the new value
    to the same variable.
    The example was given to explain the commands, but would you really want to
    make such a loop it can be written much more compact:
    :for i in range(1, 4)
    :  echo "count is" i
    :endfor
    We won't explain how |:for| and |range()| work until later.  Follow the links
    if you are impatient.
    THREE KINDS OF NUMBERS
    Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts
    with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number starts
    with a zero.  "017" is decimal 15.  Careful: don't put a zero before a decimal
    number, it will be interpreted as an octal number!
    The ":echo" command always prints decimal numbers.  Example:
    :echo 0x7f 036
    127 30
    A number is made negative with a minus sign.  This also works for hexadecimal
    and octal numbers.   A minus sign is also used for subtraction.  Compare this
    with the previous example:
    :echo 0x7f -036
    97
    White space in an expression is ignored.  However, it's recommended to use it
    for separating items, to make the expression easier to read.  For example, to
    avoid the confusion with a negative number above, put a space between the
    minus sign and the following number:
    :echo 0x7f - 036
    ==============================================================================
    *41.2*        Variables
    A variable name consists of ASCII letters, digits and the underscore.  It
    cannot start with a digit.  Valid variable names are:
    counter
    _aap3
    very_long_variable_name_with_underscores
    FuncLength
    LENGTH
    Invalid names are "foo+bar" and "6var".
    These variables are global.  To see a list of currently defined variables
    use this command:
    :let
    You can use global variables everywhere.  This also means that when the
    variable "count" is used in one script file, it might also be used in another
    file.  This leads to confusion at least, and real problems at worst.  To avoid
    this, you can use a variable local to a script file by prepending "s:".  For
    example, one script contains this code:
    :let s:count = 1
    :while s:count < 5
    :  source other.vim
    :  let s:count += 1
    :endwhile
    Since "s:count" is local to this script, you can be sure that sourcing the
    "other.vim" script will not change this variable.  If "other.vim" also uses an
    "s:count" variable, it will be a different copy, local to that script.  More
    about script-local variables here: |script-variable|.
    There are more kinds of variables, see |internal-variables|.  The most often
    used ones are:
    b:name                variable local to a buffer
    w:name                variable local to a window
    g:name                global variable (also in a function)
    v:name                variable predefined by Vim
    DELETING VARIABLES
    Variables take up memory and show up in the output of the ":let" command.  To
    delete a variable use the ":unlet" command.  Example:
    :unlet s:count
    This deletes the script-local variable "s:count" to free up the memory it
    uses.  If you are not sure if the variable exists, and don't want an error
    message when it doesn't, append !:
    :unlet! s:count
    When a script finishes, the local variables used there will not be
    automatically freed.  The next time the script executes, it can still use the
    old value.  Example:
    :if !exists("s:call_count")
    :  let s:call_count = 0
    :endif
    :let s:call_count = s:call_count + 1
    :echo "called" s:call_count "times"
    The "exists()" function checks if a variable has already been defined.  Its
    argument is the name of the variable you want to check.  Not the variable
    itself!  If you would do this:
    :if !exists(s:call_count)
    Then the value of s:call_count will be used as the name of the variable that
    exists() checks.  That's not what you want.
    The exclamation mark ! negates a value.  When the value was true, it
    becomes false.  When it was false, it becomes true.  You can read it as "not".
    Thus "if !exists()" can be read as "if not exists()".
    What Vim calls true is anything that is not zero.  Zero is false.
    Note:
    Vim automatically converts a string to a number when it is looking for
    a number.  When using a string that doesn't start with a digit the
    resulting number is zero.  Thus look out for this:
    :if "true"
    The "true" will be interpreted as a zero, thus as false!
    STRING VARIABLES AND CONSTANTS
    So far only numbers were used for the variable value.  Strings can be used as
    well.  Numbers and strings are the basic types of variables that Vim supports.
    The type is dynamic, it is set each time when assigning a value to the
    variable with ":let".  More about types in |41.8|.
    To assign a string value to a variable, you need to use a string constant.
    There are two types of these.  First the string in double quotes:
    :let name = "peter"
    :echo name
    peter
    If you want to include a double quote inside the string, put a backslash in
    front of it:
    :let name = "\"peter\""
    :echo name
    "peter"
    To avoid the need for a backslash, you can use a string in single quotes:
    :let name = '"peter"'
    :echo name
    "peter"
    Inside a single-quote string all the characters are as they are.  Only the
    single quote itself is special: you need to use two to get one.  A backslash
    is taken literally, thus you can't use it to change the meaning of the
    character after it.
    In double-quote strings it is possible to use special characters.  Here are
    a few useful ones:
    \t                <Tab>
    \n                <NL>, line break
    \r                <CR>, <Enter>
    \e                <Esc>
    \b                <BS>, backspace
    \"                "
    \\                \, backslash
    \<Esc>                <Esc>
    \<C-W>                CTRL-W
    The last two are just examples.  The  "\<name>" form can be used to include
    the special key "name".
    See |expr-quote| for the full list of special items in a string.
    ==============================================================================
    *41.3*        Expressions
    Vim has a rich, yet simple way to handle expressions.  You can read the
    definition here: |expression-syntax|.  Here we will show the most common
    items.
    The numbers, strings and variables mentioned above are expressions by
    themselves.  Thus everywhere an expression is expected, you can use a number,
    string or variable.  Other basic items in an expression are:
    $NAME                environment variable
    &name                option
    @r                register
    Examples:
    :echo "The value of 'tabstop' is" &ts
    :echo "Your home directory is" $HOME
    :if @a > 5
    The &name form can be used to save an option value, set it to a new value,
    do something and restore the old value.  Example:
    :let save_ic = &ic
    :set noic
    :/The Start/,$delete
    :let &ic = save_ic
    This makes sure the "The Start" pattern is used with the 'ignorecase' option
    off.  Still, it keeps the value that the user had set.  (Another way to do
    this would be to add "\C" to the pattern, see |/\C|.)
    MATHEMATICS
    It becomes more interesting if we combine these basic items.  Let's start with
    mathematics on numbers:
    a + b                add
    a - b                subtract
    a * b                multiply
    a / b                divide
    a % b                modulo
    The usual precedence is used.  Example:
    :echo 10 + 5 * 2
    20
    Grouping is done with parentheses.  No surprises here.  Example:
    :echo (10 + 5) * 2
    30
    Strings can be concatenated with ".".  Example:
    :echo "foo" . "bar"
    foobar
    When the ":echo" command gets multiple arguments, it separates them with a
    space.  In the example the argument is a single expression, thus no space is
    inserted.
    Borrowed from the C language is the conditional expression:
    a ? b : c
    If "a" evaluates to true "b" is used, otherwise "c" is used.  Example:
    :let i = 4
    :echo i > 5 ? "i is big" : "i is small"
    i is small
    The three parts of the constructs are always evaluated first, thus you could
    see it work as:
    (a) ? (b) : (c)
    ==============================================================================
    *41.4*        Conditionals
    The ":if" commands executes the following statements, until the matching
    ":endif", only when a condition is met.  The generic form is:
    :if {condition}
    {statements}
    :endif
    Only when the expression {condition} evaluates to true (non-zero) will the
    {statements} be executed.  These must still be valid commands.  If they
    contain garbage, Vim won't be able to find the ":endif".
    You can also use ":else".  The generic form for this is:
    :if {condition}
    {statements}
    :else
    {statements}
    :endif
    The second {statements} is only executed if the first one isn't.
    Finally, there is ":elseif":
    :if {condition}
    {statements}
    :elseif {condition}
    {statements}
    :endif
    extra ":endif".
    A useful example for your vimrc file is checking the 'term' option and
    This works just like using ":else" and then "if", but without the need for an
    doing something depending upon its value:
    :if &term == "xterm"
    :  " Do stuff for xterm
    :elseif &term == "vt100"
    :  " Do stuff for a vt100 terminal
    :else
    :  " Do something for other terminals
    :endif
    LOGIC OPERATIONS
    We already used some of them in the examples.  These are the most often used
    ones:
    a == b                equal to
    a != b                not equal to
    a >  b                greater than
    a >= b                greater than or equal to
    a <  b                less than
    a <= b                less than or equal to
    The result is one if the condition is met and zero otherwise.  An example:
    :if v:version >= 700
    :  echo "congratulations"
    :else
    :  echo "you are using an old version, upgrade!"
    :endif
    Here "v:version" is a variable defined by Vim, which has the value of the Vim
    version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is
    very useful to write a script that works with multiple versions of Vim.
    |v:version|
    The logic operators work both for numbers and strings.  When comparing two
    strings, the mathematical difference is used.  This compares byte values,
    which may not be right for some languages.
    When comparing a string with a number, the string is first converted to a
    number.  This is a bit tricky, because when a string doesn't look like a
    number, the number zero is used.  Example:
    :if 0 == "one"
    :  echo "yes"
    :endif
    This will echo "yes", because "one" doesn't look like a number, thus it is
    converted to the number zero.
    For strings there are two more items:
    a =~ b                matches with
    a !~ b                does not match with
    The left item "a" is used as a string.  The right item "b" is used as a
    pattern, like what's used for searching.  Example:
    :if str =~ " "
    :  echo "str contains a space"
    :endif
    :if str !~ '\.$'
    :  echo "str does not end in a full stop"
    :endif
    Notice the use of a single-quote string for the pattern.  This is useful,
    because backslashes would need to be doubled in a double-quote string and
    patterns tend to contain many backslashes.
    The 'ignorecase' option is used when comparing strings.  When you don't want
    that, append "#" to match case and "?" to ignore case.  Thus "==?" compares
    two strings to be equal while ignoring case.  And "!~#" checks if a pattern
    doesn't match, also checking the case of letters.  For the full table see
    |expr-==|.
    MORE LOOPING
    The ":while" command was already mentioned.  Two more statements can be used
    in between the ":while" and the ":endwhile":
    :continue                Jump back to the start of the while loop; the
    loop continues.
    :break                        Jump forward to the ":endwhile"; the loop is
    discontinued.
    Example:
    :while counter < 40
    :  call do_something()
    :  if skip_flag
    :    continue
    :  endif
    :  if finished_flag
    :    break
    :  endif
    :  sleep 50m
    :endwhile
    The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty
    milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.
    Even more looping can be done with the ":for" command, see below in |41.8|.
    ==============================================================================
    *41.5*        Executing an expression
    So far the commands in the script were executed by Vim directly.  The
    ":execute" command allows executing the result of an expression.  This is a
    very powerful way to build commands and execute them.
    An example is to jump to a tag, which is contained in a variable:
    :execute "tag " . tag_name
    The "." is used to concatenate the string "tag " with the value of variable
    "tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that
    will be executed is:
    :tag get_cmd
    The ":execute" command can only execute colon commands.  The ":normal" command
    executes Normal mode commands.  However, its argument is not an expression but
    the literal command characters.  Example:
    :normal gg=G
    This jumps to the first line and formats all lines with the "=" operator.
    To make ":normal" work with an expression, combine ":execute" with it.
    Example:
    :execute "normal " . normal_commands
    The variable "normal_commands" must contain the Normal mode commands.
    Make sure that the argument for ":normal" is a complete command.  Otherwise
    Vim will run into the end of the argument and abort the command.  For example,
    if you start Insert mode, you must leave Insert mode as well.  This works:
    :execute "normal Inew text \<Esc>"
    This inserts "new text " in the current line.  Notice the use of the special
    key "\<Esc>".  This avoids having to enter a real <Esc> character in your
    script.
    If you don't want to execute a string but evaluate it to get its expression
    value, you can use the eval() function:
    :let optname = "path"
    :let optval = eval('&' . optname)
    A "&" character is prepended to "path", thus the argument to eval() is
    "&path".  The result will then be the value of the 'path' option.
    The same thing can be done with:
    :exe 'let optval = &' . optname
    ==============================================================================
    *41.6*        Using functions
    Vim defines many functions and provides a large amount of functionality that
    way.  A few examples will be given in this section.  You can find the whole
    list here: |functions|.
    A function is called with the ":call" command.  The parameters are passed in
    between parentheses separated by commas.  Example:
    :call search("Date: ", "W")
    This calls the search() function, with arguments "Date: " and "W".  The
    search() function uses its first argument as a search pattern and the second
    one as flags.  The "W" flag means the search doesn't wrap around the end of
    the file.
    A function can be called in an expression.  Example:
    :let line = getline(".")
    :let repl = substitute(line, '\a', "*", "g")
    :call setline(".", repl)
    The getline() function obtains a line from the current buffer.  Its argument
    is a specification of the line number.  In this case "." is used, which means
    the line where the cursor is.
    The substitute() function does something similar to the ":substitute"
    command.  The first argument is the string on which to perform the
    substitution.  The second argument is the pattern, the third the replacement
    string.  Finally, the last arguments are the flags.
    The setline() function sets the line, specified by the first argument, to a
    new string, the second argument.  In this example the line under the cursor is
    replaced with the result of the substitute().  Thus the effect of the three
    statements is equal to:
    :substitute/\a/*/g
    Using the functions becomes more interesting when you do more work before and
    after the substitute() call.






    FUNCTIONS                                                *function-list*
    There are many functions.  We will mention them here, grouped by what they are
    used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on
    the function name to jump to detailed help on it.
    String manipulation:                                        *string-functions*
    nr2char()                get a character by its ASCII value
    char2nr()                get ASCII value of a character
    str2nr()                convert a string to a Number
    str2float()                convert a string to a Float
    printf()                format a string according to % items
    escape()                escape characters in a string with a '\'
    shellescape()                escape a string for use with a shell command
    fnameescape()                escape a file name for use with a Vim command
    tr()                        translate characters from one set to another
    strtrans()                translate a string to make it printable
    tolower()                turn a string to lowercase
    toupper()                turn a string to uppercase
    match()                        position where a pattern matches in a string
    matchend()                position where a pattern match ends in a string
    matchstr()                match of a pattern in a string
    matchlist()                like matchstr() and also return submatches
    stridx()                first index of a short string in a long string
    strridx()                last index of a short string in a long string
    strlen()                length of a string
    substitute()                substitute a pattern match with a string
    submatch()                get a specific match in a ":substitute"
    strpart()                get part of a string
    expand()                expand special keywords
    iconv()                        convert text from one encoding to another
    byteidx()                byte index of a character in a string
    repeat()                repeat a string multiple times
    eval()                        evaluate a string expression
    List manipulation:                                        *list-functions*
    get()                        get an item without error for wrong index
    len()                        number of items in a List
    empty()                        check if List is empty
    insert()                insert an item somewhere in a List
    add()                        append an item to a List
    extend()                append a List to a List
    remove()                remove one or more items from a List
    copy()                        make a shallow copy of a List
    deepcopy()                make a full copy of a List
    filter()                remove selected items from a List
    map()                        change each List item
    sort()                        sort a List
    reverse()                reverse the order of a List
    split()                        split a String into a List
    join()                        join List items into a String
    range()                        return a List with a sequence of numbers
    string()                String representation of a List
    call()                        call a function with List as arguments
    index()                        index of a value in a List
    max()                        maximum value in a List
    min()                        minimum value in a List
    count()                        count number of times a value appears in a List
    repeat()                repeat a List multiple times
    Dictionary manipulation:                                *dict-functions*
    get()                        get an entry without an error for a wrong key
    len()                        number of entries in a Dictionary
    has_key()                check whether a key appears in a Dictionary
    empty()                        check if Dictionary is empty
    remove()                remove an entry from a Dictionary
    extend()                add entries from one Dictionary to another
    filter()                remove selected entries from a Dictionary
    map()                        change each Dictionary entry
    keys()                        get List of Dictionary keys
    values()                get List of Dictionary values
    items()                        get List of Dictionary key-value pairs
    copy()                        make a shallow copy of a Dictionary
    deepcopy()                make a full copy of a Dictionary
    string()                String representation of a Dictionary
    max()                        maximum value in a Dictionary
    min()                        minimum value in a Dictionary
    count()                        count number of times a value appears
    Floating point computation:                                *float-functions*
    float2nr()                convert Float to Number
    abs()                        absolute value (also works for Number)
    round()                        round off
    ceil()                        round up
    floor()                        round down
    trunc()                        remove value after decimal point
    log10()                        logarithm to base 10
    pow()                        value of x to the exponent y
    sqrt()                        square root
    sin()                        sine
    cos()                        cosine
    tan()                        tangent
    asin()                        arc sine
    acos()                        arc cosine
    atan()                        arc tangent
    atan2()                        arc tangent
    sinh()                        hyperbolic sine
    cosh()                        hyperbolic cosine
    tanh()                        hyperbolic tangent
    Variables:                                                *var-functions*
    type()                        type of a variable
    islocked()                check if a variable is locked
    function()                get a Funcref for a function name
    getbufvar()                get a variable value from a specific buffer
    setbufvar()                set a variable in a specific buffer
    getwinvar()                get a variable from specific window
    gettabvar()                get a variable from specific tab page
    gettabwinvar()                get a variable from specific window & tab page
    setwinvar()                set a variable in a specific window
    settabvar()                set a variable in a specific tab page
    settabwinvar()                set a variable in a specific window & tab page
    garbagecollect()        possibly free memory
    Cursor and mark position:                *cursor-functions* *mark-functions*
    col()                        column number of the cursor or a mark
    virtcol()                screen column of the cursor or a mark
    line()                        line number of the cursor or mark
    wincol()                window column number of the cursor
    winline()                window line number of the cursor
    cursor()                position the cursor at a line/column
    getpos()                get position of cursor, mark, etc.
    setpos()                set position of cursor, mark, etc.
    byte2line()                get line number at a specific byte count
    line2byte()                byte count at a specific line
    diff_filler()                get the number of filler lines above a line
    Working with text in the current buffer:                *text-functions*
    getline()                get a line or list of lines from the buffer
    setline()                replace a line in the buffer
    append()                append line or list of lines in the buffer
    indent()                indent of a specific line
    cindent()                indent according to C indenting
    lispindent()                indent according to Lisp indenting
    nextnonblank()                find next non-blank line
    prevnonblank()                find previous non-blank line
    search()                find a match for a pattern
    searchpos()                find a match for a pattern
    searchpair()                find the other end of a start/skip/end
    searchpairpos()                find the other end of a start/skip/end
    searchdecl()                search for the declaration of a name
    *system-functions* *file-functions*
    System functions and manipulation of files:
    glob()                        expand wildcards
    globpath()                expand wildcards in a number of directories
    findfile()                find a file in a list of directories
    finddir()                find a directory in a list of directories
    resolve()                find out where a shortcut points to
    fnamemodify()                modify a file name
    pathshorten()                shorten directory names in a path
    simplify()                simplify a path without changing its meaning
    executable()                check if an executable program exists
    filereadable()                check if a file can be read
    filewritable()                check if a file can be written to
    getfperm()                get the permissions of a file
    getftype()                get the kind of a file
    isdirectory()                check if a directory exists
    getfsize()                get the size of a file
    getcwd()                get the current working directory
    haslocaldir()                check if current window used |:lcd|
    tempname()                get the name of a temporary file
    mkdir()                        create a new directory
    delete()                delete a file
    rename()                rename a file
    system()                get the result of a shell command
    hostname()                name of the system
    readfile()                read a file into a List of lines
    writefile()                write a List of lines into a file
    Date and Time:                                *date-functions* *time-functions*
    getftime()                get last modification time of a file
    localtime()                get current time in seconds
    strftime()                convert time to a string
    reltime()                get the current or elapsed time accurately
    reltimestr()                convert reltime() result to a string
    *buffer-functions* *window-functions* *arg-functions*
    Buffers, windows and the argument list:
    argc()                        number of entries in the argument list
    argidx()                current position in the argument list
    argv()                        get one entry from the argument list
    bufexists()                check if a buffer exists
    buflisted()                check if a buffer exists and is listed
    bufloaded()                check if a buffer exists and is loaded
    bufname()                get the name of a specific buffer
    bufnr()                        get the buffer number of a specific buffer
    tabpagebuflist()        return List of buffers in a tab page
    tabpagenr()                get the number of a tab page
    tabpagewinnr()                like winnr() for a specified tab page
    winnr()                        get the window number for the current window
    bufwinnr()                get the window number of a specific buffer
    winbufnr()                get the buffer number of a specific window
    getbufline()                get a list of lines from the specified buffer
    Command line:                                        *command-line-functions*
    getcmdline()                get the current command line
    getcmdpos()                get position of the cursor in the command line
    setcmdpos()                set position of the cursor in the command line
    getcmdtype()                return the current command-line type
    Quickfix and location lists:                        *quickfix-functions*
    getqflist()                list of quickfix errors
    setqflist()                modify a quickfix list
    getloclist()                list of location list items
    setloclist()                modify a location list
    Insert mode completion:                                *completion-functions*
    complete()                set found matches
    complete_add()                add to found matches
    complete_check()        check if completion should be aborted
    pumvisible()                check if the popup menu is displayed
    Folding:                                        *folding-functions*
    foldclosed()                check for a closed fold at a specific line
    foldclosedend()                like foldclosed() but return the last line
    foldlevel()                check for the fold level at a specific line
    foldtext()                generate the line displayed for a closed fold
    foldtextresult()        get the text displayed for a closed fold
    Syntax and highlighting:          *syntax-functions* *highlighting-functions*
    clearmatches()                clear all matches defined by |matchadd()| and
    the |:match| commands
    getmatches()                get all matches defined by |matchadd()| and
    the |:match| commands
    hlexists()                check if a highlight group exists
    hlID()                        get ID of a highlight group
    synID()                        get syntax ID at a specific position
    synIDattr()                get a specific attribute of a syntax ID
    synIDtrans()                get translated syntax ID
    synstack()                get list of syntax IDs at a specific position
    synconcealed()                get info about concealing
    diff_hlID()                get highlight ID for diff mode at a position
    matchadd()                define a pattern to highlight (a "match")
    matcharg()                get info about |:match| arguments
    matchdelete()                delete a match defined by |matchadd()| or a
    |:match| command
    setmatches()                restore a list of matches saved by
    |getmatches()|
    History:                                        *history-functions*
    histadd()                add an item to a history
    histdel()                delete an item from a history
    histget()                get an item from a history
    histnr()                get highest index of a history list
    Spelling:                                        *spell-functions*
    spellbadword()                locate badly spelled word at or after cursor
    spellsuggest()                return suggested spelling corrections
    soundfold()                return the sound-a-like equivalent of a word
    Interactive:                                        *interactive-functions*
    browse()                put up a file requester
    browsedir()                put up a directory requester
    confirm()                let the user make a choice
    getchar()                get a character from the user
    getcharmod()                get modifiers for the last typed character
    feedkeys()                put characters in the typeahead queue
    input()                        get a line from the user
    inputlist()                let the user pick an entry from a list
    inputsecret()                get a line from the user without showing it
    inputdialog()                get a line from the user in a dialog
    inputsave()                save and clear typeahead
    inputrestore()                restore typeahead
    GUI:                                                *gui-functions*
    getfontname()                get name of current font being used
    getwinposx()                X position of the GUI Vim window
    getwinposy()                Y position of the GUI Vim window
    Vim server:                                        *server-functions*
    serverlist()                return the list of server names
    remote_send()                send command characters to a Vim server
    remote_expr()                evaluate an expression in a Vim server
    server2client()                send a reply to a client of a Vim server
    remote_peek()                check if there is a reply from a Vim server
    remote_read()                read a reply from a Vim server
    foreground()                move the Vim window to the foreground
    remote_foreground()        move the Vim server window to the foreground
    Window size and position:                        *window-size-functions*
    winheight()                get height of a specific window
    winwidth()                get width of a specific window
    winrestcmd()                return command to restore window sizes
    winsaveview()                get view of current window
    winrestview()                restore saved view of current window
    Various:                                        *various-functions*
    mode()                        get current editing mode
    visualmode()                last visual mode used
    hasmapto()                check if a mapping exists
    mapcheck()                check if a matching mapping exists
    maparg()                get rhs of a mapping
    exists()                check if a variable, function, etc. exists
    has()                        check if a feature is supported in Vim
    changenr()                return number of most recent change
    cscope_connection()        check if a cscope connection exists
    did_filetype()                check if a FileType autocommand was used
    eventhandler()                check if invoked by an event handler
    getpid()                get process ID of Vim
    libcall()                call a function in an external library
    libcallnr()                idem, returning a number
    getreg()                get contents of a register
    getregtype()                get type of a register
    setreg()                set contents and type of a register
    taglist()                get list of matching tags
    tagfiles()                get a list of tags files
    mzeval()                evaluate |MzScheme| expression





    ==============================================================================
    *41.7*        Defining a function
    Vim enables you to define your own functions.  The basic function declaration
    begins as follows:
    :function {name}({var1}, {var2}, ...)
    :  {body}
    :endfunction
    Note:
    Function names must begin with a capital letter.
    Let's define a short function to return the smaller of two numbers.  It starts
    with this line:
    :function Min(num1, num2)
    This tells Vim that the function is named "Min" and it takes two arguments:
    "num1" and "num2".
    The first thing you need to do is to check to see which number is smaller:
    :  if a:num1 < a:num2
    The special prefix "a:" tells Vim that the variable is a function argument.
    Let's assign the variable "smaller" the value of the smallest number:
    :  if a:num1 < a:num2
    :    let smaller = a:num1
    :  else
    :    let smaller = a:num2
    :  endif
    The variable "smaller" is a local variable.  Variables used inside a function
    are local unless prefixed by something like "g:", "a:", or "s:".
    Note:
    To access a global variable from inside a function you must prepend
    "g:" to it.  Thus "g:today" inside a function is used for the global
    variable "today", and "today" is another variable, local to the
    function.
    You now use the ":return" statement to return the smallest number to the user.
    Finally, you end the function:
    :  return smaller
    :endfunction
    The complete function definition is as follows:
    :function Min(num1, num2)
    :  if a:num1 < a:num2
    :    let smaller = a:num1
    :  else
    :    let smaller = a:num2
    :  endif
    :  return smaller
    :endfunction
    For people who like short functions, this does the same thing:
    :function Min(num1, num2)
    :  if a:num1 < a:num2
    :    return a:num1
    :  endif
    :  return a:num2
    :endfunction
    A user defined function is called in exactly the same way as a built-in
    function.  Only the name is different.  The Min function can be used like
    this:
    :echo Min(5, 8)
    Only now will the function be executed and the lines be interpreted by Vim.
    If there are mistakes, like using an undefined variable or function, you will
    now get an error message.  When defining the function these errors are not
    detected.
    When a function reaches ":endfunction" or ":return" is used without an
    argument, the function returns zero.
    To redefine a function that already exists, use the ! for the ":function"
    command:
    :function!  Min(num1, num2, num3)
    USING A RANGE
    The ":call" command can be given a line range.  This can have one of two
    meanings.  When a function has been defined with the "range" keyword, it will
    take care of the line range itself.
    The function will be passed the variables "a:firstline" and "a:lastline".
    These will have the line numbers from the range the function was called with.
    Example:
    :function Count_words() range
    :  let lnum = a:firstline
    :  let n = 0
    :  while lnum <= a:lastline
    :    let n = n + len(split(getline(lnum)))
    :    let lnum = lnum + 1
    :  endwhile
    :  echo "found " . n . " words"
    :endfunction
    You can call this function with:
    :10,30call Count_words()
    It will be executed once and echo the number of words.
    The other way to use a line range is by defining a function without the
    "range" keyword.  The function will be called once for every line in the
    range, with the cursor in that line.  Example:
    :function  Number()
    :  echo "line " . line(".") . " contains: " . getline(".")
    :endfunction
    If you call this function with:
    :10,15call Number()
    The function will be called six times.
    VARIABLE NUMBER OF ARGUMENTS
    Vim enables you to define functions that have a variable number of arguments.
    The following command, for instance, defines a function that must have 1
    argument (start) and can have up to 20 additional arguments:
    :function Show(start, ...)
    The variable "a:1" contains the first optional argument, "a:2" the second, and
    so on.  The variable "a:0" contains the number of extra arguments.
    For example:
    :function Show(start, ...)
    :  echohl Title
    :  echo "start is " . a:start
    :  echohl None
    :  let index = 1
    :  while index <= a:0
    :    echo "  Arg " . index . " is " . a:{index}
    :    let index = index + 1
    :  endwhile
    :  echo ""
    :endfunction
    This uses the ":echohl" command to specify the highlighting used for the
    following ":echo" command.  ":echohl None" stops it again.  The ":echon"
    command works like ":echo", but doesn't output a line break.
    You can also use the a:000 variable, it is a List of all the "..." arguments.
    See |a:000|.
    LISTING FUNCTIONS
    The ":function" command lists the names and arguments of all user-defined
    functions:
    :function
    function Show(start, ...)
    function GetVimIndent()
    function SetSyn(name)
    To see what a function does, use its name as an argument for ":function":
    :function SetSyn
    1     if &syntax == ''
    2       let &syntax = a:name
    3     endif
    endfunction
    The line number is useful for when you get an error message or when debugging.
    DEBUGGING
    See |debug-scripts| about debugging mode.
    You can also set the 'verbose' option to 12 or higher to see all function
    calls.  Set it to 15 or higher to see every executed line.
    DELETING A FUNCTION
    To delete the Show() function:
    :delfunction Show
    You get an error when the function doesn't exist.
    FUNCTION REFERENCES
    Sometimes it can be useful to have a variable point to one function or
    another.  You can do it with the function() function.  It turns the name of a
    function into a reference:
    :let result = 0                " or 1
    :function! Right()
    :  return 'Right!'
    :endfunc
    :function! Wrong()
    :  return 'Wrong!'
    :endfunc
    :
    :if result == 1
    :  let Afunc = function('Right')
    :else
    :  let Afunc = function('Wrong')
    :endif
    :echo call(Afunc, [])
    Wrong!
    Note that the name of a variable that holds a function reference must start
    with a capital.  Otherwise it could be confused with the name of a builtin
    function.
    The way to invoke a function that a variable refers to is with the call()
    function.  Its first argument is the function reference, the second argument
    is a List with arguments.
    Function references are most useful in combination with a Dictionary, as is
    explained in the next section.
    ==============================================================================
    *41.8*        Lists and Dictionaries
    So far we have used the basic types String and Number.  Vim also supports two
    composite types: List and Dictionary.
    A List is an ordered sequence of things.  The things can be any kind of value,
    thus you can make a List of numbers, a List of Lists and even a List of mixed
    items.  To create a List with three strings:
    :let alist = ['aap', 'mies', 'noot']
    The List items are enclosed in square brackets and separated by commas.  To
    create an empty List:
    :let alist = []
    You can add items to a List with the add() function:
    :let alist = []
    :call add(alist, 'foo')
    :call add(alist, 'bar')
    :echo alist
    ['foo', 'bar']
    List concatenation is done with +:
    :echo alist + ['foo', 'bar']
    ['foo', 'bar', 'foo', 'bar']
    Or, if you want to extend a List directly:
    :let alist = ['one']
    :call extend(alist, ['two', 'three'])
    :echo alist
    ['one', 'two', 'three']
    Notice that using add() will have a different effect:
    :let alist = ['one']
    :call add(alist, ['two', 'three'])
    :echo alist
    ['one', ['two', 'three']]
    The second argument of add() is added as a single item.
    FOR LOOP
    One of the nice things you can do with a List is iterate over it:
    :let alist = ['one', 'two', 'three']
    :for n in alist
    :  echo n
    :endfor
    one
    two
    three
    This will loop over each element in List "alist", assigning the value to
    variable "n".  The generic form of a for loop is:
    :for {varname} in {listexpression}
    :  {commands}
    :endfor
    To loop a certain number of times you need a List of a specific length.  The
    range() function creates one for you:
    :for a in range(3)
    :  echo a
    :endfor
    0
    1
    2
    Notice that the first item of the List that range() produces is zero, thus the
    last item is one less than the length of the list.
    You can also specify the maximum value, the stride and even go backwards:
    :for a in range(8, 4, -2)
    :  echo a
    :endfor
    8
    6
    4
    A more useful example, looping over lines in the buffer:
    :for line in getline(1, 20)
    :  if line =~ "Date: "
    :    echo matchstr(line, 'Date: \zs.*')
    :  endif
    :endfor
    This looks into lines 1 to 20 (inclusive) and echoes any date found in there.
    DICTIONARIES
    A Dictionary stores key-value pairs.  You can quickly lookup a value if you
    know the key.  A Dictionary is created with curly braces:
    :let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
    Now you can lookup words by putting the key in square brackets:
    :echo uk2nl['two']
    twee
    The generic form for defining a Dictionary is:
    {<key> : <value>, ...}
    An empty Dictionary is one without any keys:
    {}
    The possibilities with Dictionaries are numerous.  There are various functions
    for them as well.  For example, you can obtain a list of the keys and loop
    over them:
    :for key in keys(uk2nl)
    :  echo key
    :endfor
    three
    one
    two
    You will notice the keys are not ordered.  You can sort the list to get a
    specific order:
    :for key in sort(keys(uk2nl))
    :  echo key
    :endfor
    one
    three
    two
    But you can never get back the order in which items are defined.  For that you
    need to use a List, it stores items in an ordered sequence.
    DICTIONARY FUNCTIONS
    The items in a Dictionary can normally be obtained with an index in square
    brackets:
    :echo uk2nl['one']
    een
    A method that does the same, but without so many punctuation characters:
    :echo uk2nl.one
    een
    This only works for a key that is made of ASCII letters, digits and the
    underscore.  You can also assign a new value this way:
    :let uk2nl.four = 'vier'
    :echo uk2nl
    {'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'}
    And now for something special: you can directly define a function and store a
    reference to it in the dictionary:
    :function uk2nl.translate(line) dict
    :  return join(map(split(a:line), 'get(self, v:val, "???")'))
    :endfunction
    Let's first try it out:
    :echo uk2nl.translate('three two five one')
    drie twee ??? een
    The first special thing you notice is the "dict" at the end of the ":function"
    line.  This marks the function as being used from a Dictionary.  The "self"
    local variable will then refer to that Dictionary.
    Now let's break up the complicated return command:
    split(a:line)
    The split() function takes a string, chops it into whitespace separated words
    and returns a list with these words.  Thus in the example it returns:
    :echo split('three two five one')
    ['three', 'two', 'five', 'one']
    This list is the first argument to the map() function.  This will go through
    the list, evaluating its second argument with "v:val" set to the value of each
    item.  This is a shortcut to using a for loop.  This command:
    :let alist = map(split(a:line), 'get(self, v:val, "???")')
    Is equivalent to:
    :let alist = split(a:line)
    :for idx in range(len(alist))
    :  let alist[idx] = get(self, alist[idx], "???")
    :endfor
    The get() function checks if a key is present in a Dictionary.  If it is, then
    the value is retrieved.  If it isn't, then the default value is returned, in
    the example it's '???'.  This is a convenient way to handle situations where a
    key may not be present and you don't want an error message.
    The join() function does the opposite of split(): it joins together a list of
    words, putting a space in between.
    This combination of split(), map() and join() is a nice way to filter a line
    of words in a very compact way.
    OBJECT ORIENTED PROGRAMMING
    Now that you can put both values and functions in a Dictionary, you can
    actually use a Dictionary like an object.
    Above we used a Dictionary for translating Dutch to English.  We might want
    to do the same for other languages.  Let's first make an object (aka
    Dictionary) that has the translate function, but no words to translate:
    :let transdict = {}
    :function transdict.translate(line) dict
    :  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
    :endfunction
    It's slightly different from the function above, using 'self.words' to lookup
    word translations.  But we don't have a self.words.  Thus you could call this
    an abstract class.
    Now we can instantiate a Dutch translation object:
    :let uk2nl = copy(transdict)
    :let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
    :echo uk2nl.translate('three one')
    drie een
    And a German translator:
    :let uk2de = copy(transdict)
    :let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
    :echo uk2de.translate('three one')
    drei ein
    You see that the copy() function is used to make a copy of the "transdict"
    Dictionary and then the copy is changed to add the words.  The original
    remains the same, of course.
    Now you can go one step further, and use your preferred translator:
    :if $LANG =~ "de"
    :  let trans = uk2de
    :else
    :  let trans = uk2nl
    :endif
    :echo trans.translate('one two three')
    een twee drie
    Here "trans" refers to one of the two objects (Dictionaries).  No copy is
    made.  More about List and Dictionary identity can be found at |list-identity|
    and |dict-identity|.
    Now you might use a language that isn't supported.  You can overrule the
    translate() function to do nothing:
    :let uk2uk = copy(transdict)
    :function! uk2uk.translate(line)
    :  return a:line
    :endfunction
    :echo uk2uk.translate('three one wladiwostok')
    three one wladiwostok
    Notice that a ! was used to overwrite the existing function reference.  Now
    use "uk2uk" when no recognized language is found:
    :if $LANG =~ "de"
    :  let trans = uk2de
    :elseif $LANG =~ "nl"
    :  let trans = uk2nl
    :else
    :  let trans = uk2uk
    :endif
    :echo trans.translate('one two three')
    one two three
    For further reading see |Lists| and |Dictionaries|.
    ==============================================================================
    *41.9*        Exceptions
    Let's start with an example:
    :try
    :   read ~/templates/pascal.tmpl
    :catch /E484:/
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry
    The ":read" command will fail if the file does not exist.  Instead of
    generating an error message, this code catches the error and gives the user a
    nice message.
    For the commands in between ":try" and ":endtry" errors are turned into
    exceptions.  An exception is a string.  In the case of an error the string
    contains the error message.  And every error message has a number.  In this
    case, the error we catch contains "E484:".  This number is guaranteed to stay
    the same (the text may change, e.g., it may be translated).
    When the ":read" command causes another error, the pattern "E484:" will not
    match in it.  Thus this exception will not be caught and result in the usual
    error message.
    You might be tempted to do this:
    :try
    :   read ~/templates/pascal.tmpl
    :catch
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry
    This means all errors are caught.  But then you will not see errors that are
    useful, such as "E21: Cannot make changes, 'modifiable' is off".
    Another useful mechanism is the ":finally" command:
    :let tmp = tempname()
    :try
    :   exe ".,$write " . tmp
    :   exe "!filter " . tmp
    :   .,$delete
    :   exe "$read " . tmp
    :finally
    :   call delete(tmp)
    :endtry
    This filters the lines from the cursor until the end of the file through the
    "filter" command, which takes a file name argument.  No matter if the
    filtering works, something goes wrong in between ":try" and ":finally" or the
    user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
    always executed.  This makes sure you don't leave the temporary file behind.
    More information about exception handling can be found in the reference
    manual: |exception-handling|.
    ==============================================================================
    *41.10*        Various remarks
    Here is a summary of items that apply to Vim scripts.  They are also mentioned
    elsewhere, but form a nice checklist.
    The end-of-line character depends on the system.  For Unix a single <NL>
    character is used.  For MS-DOS, Windows, OS/2 and the like, <CR><LF> is used.
    This is important when using mappings that end in a <CR>.  See |:source_crnl|.
    WHITE SPACE
    Blank lines are allowed and ignored.
    Leading whitespace characters (blanks and TABs) are always ignored.  The
    whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in
    the example below) are reduced to one blank character and plays the role of a
    separator, the whitespaces after the last (visible) character may or may not
    be ignored depending on the situation, see below.
    For a ":set" command involving the "=" (equal) sign, such as in:
    :set cpoptions    =aABceFst
    the whitespace immediately before the "=" sign is ignored.  But there can be
    no whitespace after the "=" sign!
    To include a whitespace character in the value of an option, it must be
    escaped by a "\" (backslash)  as in the following example:
    :set tags=my\ nice\ file
    The same example written as:
    :set tags=my nice file
    will issue an error, because it is interpreted as:
    :set tags=my
    :set nice
    :set file
    COMMENTS
    The character " (the double quote mark) starts a comment.  Everything after
    and including this character until the end-of-line is considered a comment and
    is ignored, except for commands that don't consider comments, as shown in
    examples below.  A comment can start on any character position on the line.
    There is a little "catch" with comments for some commands.  Examples:
    :abbrev dev development                " shorthand
    :map <F3> o#include                " insert include
    :execute cmd                        " do it
    :!ls *.c                        " list C files
    The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
    mapping of <F3> will actually be the whole line after the 'o# ....' including
    the '"' insert include'.  The "execute" command will give an error.  The "!"
    command will send everything after it to the shell, causing an error for an
    unmatched '"'' character.
    There can be no comment after ":map", ":abbreviate", ":execute" and "!"
    commands (there are a few more commands with this restriction).  For the
    ":map", ":abbreviate" and ":execute" commands there is a trick:
    :abbrev dev development|" shorthand
    :map <F3> o#include|" insert include
    :execute cmd                        |" do it
    With the '|' character the command is separated from the next one.  And that
    next command is only a comment.  For the last command you need to do two
    things: |:execute| and use '|':
    :exe '!ls *.c'                        |" list C files
    Notice that there is no white space before the '|' in the abbreviation and
    mapping.  For these commands, any character until the end-of-line or '|' is
    included.  As a consequence of this behavior, you don't always see that
    trailing whitespace is included:
    :map <F4> o#include
    To spot these problems, you can set the 'list' option when editing vimrc
    files.
    For Unix there is one special way to comment a line, that allows making a Vim
    script executable:
    #!/usr/bin/env vim -S
    echo "this is a Vim script"
    quit
    The "#" command by itself lists a line with the line number.  Adding an
    exclamation mark changes it into doing nothing, so that you can add the shell
    command to execute the rest of the file. |:#!| |-S|
    PITFALLS
    Even bigger problem arises in the following example:
    :map ,ab o#include
    :unmap ,ab
    Here the unmap command will not work, because it tries to unmap ",ab ".  This
    does not exist as a mapped sequence.  An error will be issued, which is very
    hard to identify, because the ending whitespace character in ":unmap ,ab " is
    not visible.
    And this is the same as what happens when one uses a comment after an 'unmap'
    command:
    :unmap ,ab     " comment
    Here the comment part will be ignored.  However, Vim will try to unmap
    ,ab     '', which does not exist.  Rewrite it as:
    :unmap ,ab|    " comment
    RESTORING THE VIEW
    Sometimes you want to make a change and go back to where cursor was.
    Restoring the relative position would also be nice, so that the same line
    appears at the top of the window.
    This example yanks the current line, puts it above the first line in the
    file and then restores the view:
    map ,p ma"aYHmbgg"aP`bzt`a
    What this does:
    ma"aYHmbgg"aP`bzt`a
    ma                        set mark a at cursor position
    "aY                        yank current line into register a
    Hmb                go to top line in window and set mark b there
    gg                go to first line in file
    "aP                put the yanked line above it
    `b                go back to top line in display
    zt        position the text in the window as before
    `a        go back to saved cursor position
    PACKAGING
    others, use this scheme:
    To avoid your function names to interfere with functions that you get from
    - Prepend a unique string before each function name.  I often use an
    abbreviation.  For example, "OW_" is used for the option window functions.
    - Put the definition of your functions together in a file.  Set a global
    variable to indicate that the functions have been loaded.  When sourcing the
    file again, first unload the functions.
    Example:
    " This is the XXX package
    if exists("XXX_loaded")
    delfun XXX_one
    delfun XXX_two
    endif
    function XXX_one(a)
    ... body of function ...
    endfun
    function XXX_two(b)
    ... body of function ...
    endfun
    let XXX_loaded = 1
    ==============================================================================
    *41.11*        Writing a plugin                                *write-plugin*
    You can write a Vim script in such a way that many people can use it.  This is
    called a plugin.  Vim users can drop your script in their plugin directory and
    use its features right away |add-plugin|.
    There are actually two types of plugins:
    global plugins: For all types of files.
    filetype plugins: Only for files of a specific type.
    In this section the first type is explained.  Most items are also relevant for
    writing filetype plugins.  The specifics for filetype plugins are in the next
    section |write-filetype-plugin|.
    NAME
    First of all you must choose a name for your plugin.  The features provided
    by the plugin should be clear from its name.  And it should be unlikely that
    someone else writes a plugin with the same name but which does something
    different.  And please limit the name to 8 characters, to avoid problems on
    old Windows systems.
    A script that corrects typing mistakes could be called "typecorr.vim".  We
    will use it here as an example.
    For the plugin to work for everybody, it should follow a few guidelines.  This
    will be explained step-by-step.  The complete example plugin is at the end.
    BODY
    Let's start with the body of the plugin, the lines that do the actual work:
    14        iabbrev teh the
    15        iabbrev otehr other
    16        iabbrev wnat want
    17        iabbrev synchronisation
    18                \ synchronization
    19        let s:count = 4
    The actual list should be much longer, of course.
    The line numbers have only been added to explain a few things, don't put them
    in your plugin file!
    HEADER
    You will probably add new corrections to the plugin and soon have several
    versions laying around.  And when distributing this file, people will want to
    know who wrote this wonderful plugin and where they can send remarks.
    Therefore, put a header at the top of your plugin:
    1        " Vim global plugin for correcting typing mistakes
    2        " Last Change:        2000 Oct 15
    3        " Maintainer:        Bram Moolenaar <Bram@vim.org> <mailto:Bram@vim.org>
    About copyright and licensing: Since plugins are very useful and it's hardly
    worth restricting their distribution, please consider making your plugin
    either public domain or use the Vim |license|.  A short note about this near
    the top of the plugin should be sufficient.  Example:
    4        " License:        This file is placed in the public domain.
    LINE CONTINUATION, AVOIDING SIDE EFFECTS                *use-cpo-save*
    In line 18 above, the line-continuation mechanism is used |line-continuation|.
    Users with 'compatible' set will run into trouble here, they will get an error
    message.  We can't just reset 'compatible', because that has a lot of side
    effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
    value and restore it later.  That will allow the use of line-continuation and
    make the script work for most people.  It is done like this:
    11        let s:save_cpo = &cpo
    12        set cpo&vim
    ..
    42        let &cpo = s:save_cpo
    We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
    the end of the plugin this value is restored.
    Notice that a script-local variable is used |s:var|.  A global variable could
    already be in use for something else.  Always use script-local variables for
    things that are only used in the script.
    NOT LOADING
    It's possible that a user doesn't always want to load this plugin.  Or the
    system administrator has dropped it in the system-wide plugin directory, but a
    user has his own plugin he wants to use.  Then the user must have a chance to
    disable loading this specific plugin.  This will make it possible:
    6        if exists("g:loaded_typecorr")
    7          finish
    8        endif
    9        let g:loaded_typecorr = 1
    This also avoids that when the script is loaded twice it would cause error
    messages for redefining functions and cause trouble for autocommands that are
    added twice.
    The name is recommended to start with "loaded_" and then the file name of the
    plugin, literally.  The "g:" is prepended just to avoid mistakes when using
    the variable in a function (without "g:" it would be a variable local to the
    function).
    Using "finish" stops Vim from reading the rest of the file, it's much quicker
    than using if-endif around the whole file.
    MAPPING
    Now let's make the plugin more interesting: We will add a mapping that adds a
    correction for the word under the cursor.  We could just pick a key sequence
    for this mapping, but the user might already use it for something else.  To
    allow the user to define which keys a mapping in a plugin uses, the <Leader>
    item can be used:
    22          map <unique> <Leader>a  <Plug>TypecorrAdd
    The "<Plug>TypecorrAdd" thing will do the work, more about that further on.
    The user can set the "mapleader" variable to the key sequence that he wants
    this mapping to start with.  Thus if the user has done:
    let mapleader = "_"
    the mapping will define "_a".  If the user didn't do this, the default value
    will be used, which is a backslash.  Then a map for "\a" will be defined.
    Note that <unique> is used, this will cause an error message if the mapping
    already happened to exist. |:map-<unique>|
    But what if the user wants to define his own key sequence?  We can allow that
    with this mechanism:
    21        if !hasmapto('<Plug>TypecorrAdd')
    22          map <unique> <Leader>a  <Plug>TypecorrAdd
    23        endif
    This checks if a mapping to "<Plug>TypecorrAdd" already exists, and only
    defines the mapping from "<Leader>a" if it doesn't.  The user then has a
    chance of putting this in his vimrc file:
    map ,c  <Plug>TypecorrAdd
    Then the mapped key sequence will be ",c" instead of "_a" or "\a".
    PIECES
    If a script gets longer, you often want to break up the work in pieces.  You
    can use functions or mappings for this.  But you don't want these functions
    and mappings to interfere with the ones from other scripts.  For example, you
    could define a function Add(), but another script could try to define the same
    function.  To avoid this, we define the function local to the script by
    prepending it with "s:".
    We will define a function that adds a new typing correction:
    30        function s:Add(from, correct)
    31          let to = input("type the correction for " . a:from . ": ")
    32          exe ":iabbrev " . a:from . " " . to
    ..
    36        endfunction
    Now we can call the function s:Add() from within this script.  If another
    script also defines s:Add(), it will be local to that script and can only
    be called from the script it was defined in.  There can also be a global Add()
    function (without the "s:"), which is again another function.
    <SID> can be used with mappings.  It generates a script ID, which identifies
    the current script.  In our typing correction plugin we use it like this:
    24        noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
    ..
    28        noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
    Thus when a user types "\a", this sequence is invoked:
    \a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()
    If another script would also map <SID>Add, it would get another script ID and
    thus define another mapping.
    Note that instead of s:Add() we use <SID>Add() here.  That is because the
    mapping is typed by the user, thus outside of the script.  The <SID> is
    translated to the script ID, so that Vim knows in which script to look for
    the Add() function.
    This is a bit complicated, but it's required for the plugin to work together
    with other plugins.  The basic rule is that you use <SID>Add() in mappings and
    s:Add() in other places (the script itself, autocommands, user commands).
    We can also add a menu entry to do the same as the mapping:
    26        noremenu <script> Plugin.Add\ Correction      <SID>Add
    The "Plugin" menu is recommended for adding menu items for plugins.  In this
    case only one item is used.  When adding more items, creating a submenu is
    recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
    CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.
    Note that in line 28 ":noremap" is used to avoid that any other mappings cause
    trouble.  Someone may have remapped ":call", for example.  In line 24 we also
    use ":noremap", but we do want "<SID>Add" to be remapped.  This is why
    "<script>" is used here.  This only allows mappings which are local to the
    script. |:map-<script>|  The same is done in line 26 for ":noremenu".
    |:menu-<script>|
    <SID> AND <Plug>                                        *using-<Plug>*
    Both <SID> and <Plug> are used to avoid that mappings of typed keys interfere
    with mappings that are only to be used from other mappings.  Note the
    difference between using <SID> and <Plug>:
    <Plug>        is visible outside of the script.  It is used for mappings which the
    user might want to map a key sequence to.  <Plug> is a special code
    that a typed key will never produce.
    To make it very unlikely that other plugins use the same sequence of
    characters, use this structure: <Plug> scriptname mapname
    In our example the scriptname is "Typecorr" and the mapname is "Add".
    This results in "<Plug>TypecorrAdd".  Only the first character of
    scriptname and mapname is uppercase, so that we can see where mapname
    starts.
    <SID>        is the script ID, a unique identifier for a script.
    Internally Vim translates <SID> to "<SNR>123_", where "123" can be any
    number.  Thus a function "<SID>Add()" will have a name "<SNR>11_Add()"
    in one script, and "<SNR>22_Add()" in another.  You can see this if
    you use the ":function" command to get a list of functions.  The
    translation of <SID> in mappings is exactly the same, that's how you
    can call a script-local function from a mapping.
    USER COMMAND
    Now let's add a user command to add a correction:
    38        if !exists(":Correct")
    39          command -nargs=1  Correct  :call s:Add(<q-args>, 0)
    40        endif
    The user command is defined only if no command with the same name already
    exists.  Otherwise we would get an error here.  Overriding the existing user
    command with ":command!" is not a good idea, this would probably make the user
    wonder why the command he defined himself doesn't work.  |:command|
    SCRIPT VARIABLES
    When a variable starts with "s:" it is a script variable.  It can only be used
    inside a script.  Outside the script it's not visible.  This avoids trouble
    with using the same variable name in different scripts.  The variables will be
    kept as long as Vim is running.  And the same variables are used when sourcing
    the same script again. |s:var|
    The fun is that these variables can also be used in functions, autocommands
    and user commands that are defined in the script.  In our example we can add
    a few lines to count the number of corrections:
    19        let s:count = 4
    ..
    30        function s:Add(from, correct)
    ..
    34          let s:count = s:count + 1
    35          echo s:count . " corrections now"
    36        endfunction
    First s:count is initialized to 4 in the script itself.  When later the
    s:Add() function is called, it increments s:count.  It doesn't matter from
    where the function was called, since it has been defined in the script, it
    will use the local variables from this script.
    THE RESULT
    Here is the resulting complete example:
    1        " Vim global plugin for correcting typing mistakes
    2        " Last Change:        2000 Oct 15
    3        " Maintainer:        Bram Moolenaar <Bram@vim.org> <mailto:Bram@vim.org>
    4        " License:        This file is placed in the public domain.
    5
    6        if exists("g:loaded_typecorr")
    7          finish
    8        endif
    9        let g:loaded_typecorr = 1
    10
    11        let s:save_cpo = &cpo
    12        set cpo&vim
    13
    14        iabbrev teh the
    15        iabbrev otehr other
    16        iabbrev wnat want
    17        iabbrev synchronisation
    18                \ synchronization
    19        let s:count = 4
    20
    21        if !hasmapto('<Plug>TypecorrAdd')
    22          map <unique> <Leader>a  <Plug>TypecorrAdd
    23        endif
    24        noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
    25
    26        noremenu <script> Plugin.Add\ Correction      <SID>Add
    27
    28        noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
    29
    30        function s:Add(from, correct)
    31          let to = input("type the correction for " . a:from . ": ")
    32          exe ":iabbrev " . a:from . " " . to
    33          if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
    34          let s:count = s:count + 1
    35          echo s:count . " corrections now"
    36        endfunction
    37
    38        if !exists(":Correct")
    39          command -nargs=1  Correct  :call s:Add(<q-args>, 0)
    40        endif
    41
    42        let &cpo = s:save_cpo
    Line 33 wasn't explained yet.  It applies the new correction to the word under
    the cursor.  The |:normal| command is used to use the new abbreviation.  Note
    that mappings and abbreviations are expanded here, even though the function
    was called from a mapping defined with ":noremap".
    Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
    then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
    Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
    writing the file:
    :set fileformat=unix
    DOCUMENTATION                                                *write-local-help*
    It's a good idea to also write some documentation for your plugin.  Especially
    when its behavior can be changed by the user.  See |add-local-help| for how
    they are installed.
    Here is a simple example for a plugin help file, called "typecorr.txt":
    1        *typecorr.txt*        Plugin for correcting typing mistakes
    2
    3        If you make typing mistakes, this plugin will have them corrected
    4        automatically.
    5
    6        There are currently only a few corrections.  Add your own if you like.
    7
    8        Mappings:
    9        <Leader>a   or   <Plug>TypecorrAdd
    10                Add a correction for the word under the cursor.
    11
    12        Commands:
    13        :Correct {word}
    14                Add a correction for {word}.
    15
    16                                                        *typecorr-settings*
    17        This plugin doesn't have any settings.
    The first line is actually the only one for which the format matters.  It will
    be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
    help.txt |local-additions|.  The first "*" must be in the first column of the
    first line.  After adding your help file do ":help" and check that the entries
    line up nicely.
    You can add more tags inside ** in your help file.  But be careful not to use
    existing help tags.  You would probably use the name of your plugin in most of
    them, like "typecorr-settings" in the example.
    Using references to other parts of the help in || is recommended.  This makes
    it easy for the user to find associated help.
    FILETYPE DETECTION                                        *plugin-filetype*
    If your filetype is not already detected by Vim, you should create a filetype
    detection snippet in a separate file.  It is usually in the form of an
    autocommand that sets the filetype when the file name matches a pattern.
    Example:
    au BufNewFile,BufRead *.foo                        set filetype=foofoo
    Write this single-line file as "ftdetect/foofoo.vim" in the first directory
    that appears in 'runtimepath'.  For Unix that would be
    "~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the
    filetype for the script name.
    You can make more complicated checks if you like, for example to inspect the
    contents of the file to recognize the language.  Also see |new-filetype|.
    SUMMARY                                                        *plugin-special*
    Summary of special things to use in a plugin:
    s:name                        Variables local to the script.
    <SID>                        Script-ID, used for mappings and functions local to
    the script.
    hasmapto()                Function to test if the user already defined a mapping
    for functionality the script offers.
    <Leader>                Value of "mapleader", which the user defines as the
    keys that plugin mappings start with.
    :map <unique>                Give a warning if a mapping already exists.
    :noremap <script>        Use only mappings local to the script, not global
    mappings.
    exists(":Cmd")                Check if a user command already exists.
    ==============================================================================
    *41.12*        Writing a filetype plugin        *write-filetype-plugin* *ftplugin*
    A filetype plugin is like a global plugin, except that it sets options and
    defines mappings for the current buffer only.  See |add-filetype-plugin| for
    how this type of plugin is used.
    First read the section on global plugins above |41.11|.  All that is said there
    also applies to filetype plugins.  There are a few extras, which are explained
    here.  The essential thing is that a filetype plugin should only have an
    effect on the current buffer.
    DISABLING
    If you are writing a filetype plugin to be used by many people, they need a
    chance to disable loading it.  Put this at the top of the plugin:
    " Only do this when not done yet for this buffer
    if exists("b:did_ftplugin")
    finish
    endif
    let b:did_ftplugin = 1
    This also needs to be used to avoid that the same plugin is executed twice for
    the same buffer (happens when using an ":edit" command without arguments).
    Now users can disable loading the default plugin completely by making a
    filetype plugin with only this line:
    let b:did_ftplugin = 1
    This does require that the filetype plugin directory comes before $VIMRUNTIME
    in 'runtimepath'!
    If you do want to use the default plugin, but overrule one of the settings,
    you can write the different setting in a script:
    setlocal textwidth=70
    Now write this in the "after" directory, so that it gets sourced after the
    distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be
    "~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set
    "b:did_ftplugin", but it is ignored here.
    OPTIONS
    To make sure the filetype plugin only affects the current buffer use the
    :setlocal
    command to set options.  And only set options which are local to a buffer (see
    the help for the option to check that).  When using |:setlocal| for global
    options or options local to a window, the value will change for many buffers,
    and that is not what a filetype plugin should do.
    When an option has a value that is a list of flags or items, consider using
    "+=" and "-=" to keep the existing value.  Be aware that the user may have
    changed an option value already.  First resetting to the default value and
    then changing it is often a good idea.  Example:
    :setlocal formatoptions& formatoptions+=ro
    MAPPINGS
    To make sure mappings will only work in the current buffer use the
    :map <buffer>
    command.  This needs to be combined with the two-step mapping explained above.
    An example of how to define functionality in a filetype plugin:
    if !hasmapto('<Plug>JavaImport')
    map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
    endif
    noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>
    |hasmapto()| is used to check if the user has already defined a map to
    <Plug>JavaImport.  If not, then the filetype plugin defines the default
    mapping.  This starts with |<LocalLeader>|, which allows the user to select
    the key(s) he wants filetype plugin mappings to start with.  The default is a
    backslash.
    "<unique>" is used to give an error message if the mapping already exists or
    overlaps with an existing mapping.
    |:noremap| is used to avoid that any other mappings that the user has defined
    interferes.  You might want to use ":noremap <script>" to allow remapping
    mappings defined in this script that start with <SID>.
    The user must have a chance to disable the mappings in a filetype plugin,
    without disabling everything.  Here is an example of how this is done for a
    plugin for the mail filetype:
    " Add mappings, unless the user didn't want this.
    if !exists("no_plugin_maps") && !exists("no_mail_maps")
    " Quote text by inserting "> "
    if !hasmapto('<Plug>MailQuote')
    vmap <buffer> <LocalLeader>q <Plug>MailQuote
    nmap <buffer> <LocalLeader>q <Plug>MailQuote
    endif
    vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
    nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
    endif
    Two global variables are used:
    no_plugin_maps                disables mappings for all filetype plugins
    no_mail_maps                disables mappings for a specific filetype
    USER COMMANDS
    To add a user command for a specific file type, so that it can only be used in
    one buffer, use the "-buffer" argument to |:command|.  Example:
    :command -buffer  Make  make %:r.s
    VARIABLES
    A filetype plugin will be sourced for each buffer of the type it's for.  Local
    script variables |s:var| will be shared between all invocations.  Use local
    buffer variables |b:var| if you want a variable specifically for one buffer.
    FUNCTIONS
    When defining a function, this only needs to be done once.  But the filetype
    plugin will be sourced every time a file with this filetype will be opened.
    This construct makes sure the function is only defined once:
    :if !exists("*s:Func")
    :  function s:Func(arg)
    :    ...
    :  endfunction
    :endif
    UNDO                                                        *undo_ftplugin*
    When the user does ":setfiletype xyz" the effect of the previous filetype
    should be undone.  Set the b:undo_ftplugin variable to the commands that will
    undo the settings in your filetype plugin.  Example:
    let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
    \ . "| unlet b:match_ignorecase b:match_words b:match_skip"
    Using ":setlocal" with "<" after the option name resets the option to its
    global value.  That is mostly the best way to reset the option value.
    This does require removing the "C" flag from 'cpoptions' to allow line
    continuation, as mentioned above |use-cpo-save|.
    FILE NAME
    The filetype must be included in the file name |ftplugin-name|.  Use one of
    these three forms:
    .../ftplugin/stuff.vim
    .../ftplugin/stuff_foo.vim
    .../ftplugin/stuff/bar.vim
    "stuff" is the filetype, "foo" and "bar" are arbitrary names.
    SUMMARY                                                        *ftplugin-special*
    Summary of special things to use in a filetype plugin:
    <LocalLeader>                Value of "maplocalleader", which the user defines as
    the keys that filetype plugin mappings start with.
    :map <buffer>                Define a mapping local to the buffer.
    :noremap <script>        Only remap mappings defined in this script that start
    with <SID>.
    :setlocal                Set an option for the current buffer only.
    :command -buffer        Define a user command local to the buffer.
    exists("*s:Func")        Check if a function was already defined.
    Also see |plugin-special|, the special things used for all plugins.
    ==============================================================================
    *41.13*        Writing a compiler plugin                *write-compiler-plugin*
    A compiler plugin sets options for use with a specific compiler.  The user can
    load it with the |:compiler| command.  The main use is to set the
    errorformat' and 'makeprg' options.
    Easiest is to have a look at examples.  This command will edit all the default
    compiler plugins:
    :next $VIMRUNTIME/compiler/*.vim
    Use |:next| to go to the next plugin file.
    There are two special items about these files.  First is a mechanism to allow
    a user to overrule or add to the default file.  The default files start with:
    :if exists("current_compiler")
    :  finish
    :endif
    :let current_compiler = "mine"
    When you write a compiler file and put it in your personal runtime directory
    (e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
    make the default file skip the settings.
    *:CompilerSet*
    The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
    ":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
    older Vim versions don't, thus your plugin should define it then.  This is an
    example:
    if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
    endif
    CompilerSet errorformat&                " use the default 'errorformat'
    CompilerSet makeprg=nmake
    When you write a compiler plugin for the Vim distribution or for a system-wide
    runtime directory, use the mechanism mentioned above.  When
    "current_compiler" was already set by a user plugin nothing will be done.
    When you write a compiler plugin to overrule settings from a default plugin,
    don't check "current_compiler".  This plugin is supposed to be loaded
    last, thus it should be in a directory at the end of 'runtimepath'.  For Unix
    that could be ~/.vim/after/compiler.
    ==============================================================================
    *41.14*        Writing a plugin that loads quickly        *write-plugin-quickload*
    A plugin may grow and become quite long.  The startup delay may become
    noticeable, while you hardly ever use the plugin.  Then it's time for a
    quickload plugin.
    The basic idea is that the plugin is loaded twice.  The first time user
    commands and mappings are defined that offer the functionality.  The second
    time the functions that implement the functionality are defined.
    It may sound surprising that quickload means loading a script twice.  What we
    mean is that it loads quickly the first time, postponing the bulk of the
    script to the second time, which only happens when you actually use it.  When
    you always use the functionality it actually gets slower!
    Note that since Vim 7 there is an alternative: use the |autoload|
    functionality |41.15|.
    The following example shows how it's done:
    " Vim global plugin for demonstrating quick loading
    " Last Change:        2005 Feb 25
    " Maintainer:        Bram Moolenaar <Bram@vim.org> <mailto:Bram@vim.org>
    " License:        This file is placed in the public domain.
    if !exists("s:did_load")
    command -nargs=* BNRead  call BufNetRead(<f-args>)
    map <F19> :call BufNetWrite('something')<CR>
    let s:did_load = 1
    exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
    finish
    endif
    function BufNetRead(...)
    echo 'BufNetRead(' . string(a:000) . ')'
    " read functionality here
    endfunction
    function BufNetWrite(...)
    echo 'BufNetWrite(' . string(a:000) . ')'
    " write functionality here
    endfunction
    When the script is first loaded "s:did_load" is not set.  The commands between
    the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
    the rest of the script is not executed.
    The second time the script is loaded "s:did_load" exists and the commands
    after the "endif" are executed.  This defines the (possible long)
    BufNetRead() and BufNetWrite() functions.
    If you drop this script in your plugin directory Vim will execute it on
    startup.  This is the sequence of events that happens:
    1. The "BNRead" command is defined and the <F19> key is mapped when the script
    is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
    ":finish" command causes the script to terminate early.
    2. The user types the BNRead command or presses the <F19> key.  The
    BufNetRead() or BufNetWrite() function will be called.
    3. Vim can't find the function and triggers the |FuncUndefined| autocommand
    event.  Since the pattern "BufNet*" matches the invoked function, the
    command "source fname" will be executed.  "fname" will be equal to the name
    of the script, no matter where it is located, because it comes from
    expanding "<sfile>" (see |expand()|).
    4. The script is sourced again, the "s:did_load" variable exists and the
    functions are defined.
    Notice that the functions that are loaded afterwards match the pattern in the
    |FuncUndefined| autocommand.  You must make sure that no other plugin defines
    functions that match this pattern.
    ==============================================================================
    *41.15*        Writing library scripts                        *write-library-script*
    Some functionality will be required in several places.  When this becomes more
    than a few lines you will want to put it in one script and use it from many
    scripts.  We will call that one script a library script.
    Manually loading a library script is possible, so long as you avoid loading it
    when it's already done.  You can do this with the |exists()| function.
    Example:
    if !exists('*MyLibFunction')
    runtime library/mylibscript.vim
    endif
    call MyLibFunction(arg)
    Here you need to know that MyLibFunction() is defined in a script
    "library/mylibscript.vim" in one of the directories in 'runtimepath'.
    To make this a bit simpler Vim offers the autoload mechanism.  Then the
    example looks like this:
    call mylib#myfunction(arg)
    That's a lot simpler, isn't it?  Vim will recognize the function name and when
    it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
    That script must define the "mylib#myfunction()" function.
    You can put many other functions in the mylib.vim script, you are free to
    organize your functions in library scripts.  But you must use function names
    where the part before the '#' matches the script name.  Otherwise Vim would
    not know what script to load.
    If you get really enthusiastic and write lots of library scripts, you may
    want to use subdirectories.  Example:
    call netlib#ftp#read('somefile')
    For Unix the library script used for this could be:
    ~/.vim/autoload/netlib/ftp.vim
    Where the function is defined like this:
    function netlib#ftp#read(fname)
    "  Read the file fname through ftp
    endfunction
    Notice that the name the function is defined with is exactly the same as the
    name used for calling the function.  And the part before the last '#'
    exactly matches the subdirectory and script name.
    You can use the same mechanism for variables:
    let weekdays = dutch#weekdays
    This will load the script "autoload/dutch.vim", which should contain something
    like:
    let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
    \ 'donderdag', 'vrijdag', 'zaterdag']
    Further reading: |autoload|.
    ==============================================================================
    *41.16*        Distributing Vim scripts                        *distribute-script*
    Vim users will look for scripts on the Vim website:        http://www.vim.org. <http://www.vim.org.>
    If you made something that is useful for others, share it!
    Vim scripts can be used on any system.  There might not be a tar or gzip
    command.  If you want to pack files together and/or compress them the "zip"
    utility is recommended.
    For utmost portability use Vim itself to pack scripts together.  This can be
    done with the Vimball utility.  See |vimball|.
    It's good if you add a line to allow automatic updating.  See |glvs-plugins|.
    ==============================================================================
    Next chapter: |usr_42.txt|  Add new menus
    Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
    top - main help file
    Help FAQ Both
    adding new menus <http://vimdoc.sourceforge.net/htmldoc/usr_42.html>
    }}}
   Plocka (först = bra lista) {{{
 plocka från mm:  gå igenom usermanual igen
 plockbitar från filerna i gvimgroup 2 (till höger)
 plockbitar från olika sammanställningarna = odsdokument
 plocka från tidigare ankifiler
 plocka från tidigare mnemosynefilerna****


   PLUGINS = s38
   :options
   Change options directly in the options window

  Öppna ny fil, utan att spara (el stänga) gamla ; :hide edit foo.txt
   :n, :wn :last :first : pre? :2n
  :ls/:ar
                C-^
   C-o / C-i

   :echo &path
   :buffers :buffers! :bdelete 3  :bwipe
   :bfirst  :bnext  :buffer 3 ***  :buffer help  :sbuffer 4

   s119
   Complete filename     c-x c-f ****
   Complete whole lines     c-x c-L *****
      macrodefs (också i included)  c-x c-d
   c-x c-y//e ????
   C words from a dictionary    c-x c-k
     Thesaurus       c-t
           c-i         c-v*********
   c-r c-r ********
   i: c-y//c-e
    c-x c-o/p

   zk//zj
   /ord/e+2  b

   :find  = samma som :e men använder path       :find inits.h
   vim "+find stdio.h"
   :/mö/=  :  #   nu
    :%normal i//

   :%t$

   g&
   !objekt!
   g.
   vo_cheatsheet.txt
   c-a c-@

   ia xdcs  yp   / ?
   f F t T  ; ,     <blank> <CR> + -  2$
   @"("") @/ @: @+ @* @.
   q Q

   ***** `` `" `.(start of last change) `[ `] `{ `( `^(=last yank)    `<=???
 ]` [`
   C-n C-p
   q:

   :'<,'>normal .  "=kör senaste, t.ex. A + '&' till slutet på rad, på alla markerade rader *****2015

   xydcs
   HELP OCH HELPGREP
   {  (  ab at aB   aw as ap  *****
   Enter  2$  -
   %  + 'matchpairs'
   `a  ]`  `[ `]  `"  `.  `^

   :scriptnames


   kolla om vi-compatible--växeln är satt;:set compatible?  [vimrc] [compatible-default]
   kolla vilka scripts som lästs in till din session;:scriptnames [vimrc]
   vimtutor för gvim;gvimtutor ,,  vimtutor -g
  öppna user-manual;:h man
  öppna reference-manual;:h ref(erence)

   vim usermanual::
   }}}
  också plocka in {{{
    öppna 3 filer från kommandoraden  ;  vim fil1 fil2 fil3
    visa lista öppna buffrar  ;  :ar(gs)

    Ctrl+^
    {x}%
    "13yy
    o
    PLUGINS MM:
    xmledit (=för att redigera xml) <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+plugin+check+xml&ie=utf-8&oe=utf-8>
    xmlwf (=kolla och rätta till wellformedness för xml) <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+plugin+check+xml+well+formed&ie=utf-8&oe=utf-8>
    googlesök: tools for editing xml in vim
    o
    plugin för att redigera xml  ;  xmledit
    plugin för att kolla att xml är välformad(syntax)  ;  xmlwf
    vim outliner
    ladda ner zippad fil
    ./install.sh
    sammanfattning av vanliga kommandon finns under :h vo_cheatsheet.txt
    SE MER + TESTA
    o
    <http://www.linux.com/learn/tutorials/424395:weekend-project-learn-vimoutliner-on-linux>
    <https://www.google.com/search?client=ubuntu&channel=fs&q=vimoutliner+tutorial&ie=utf-8&oe=utf-8>
    o
    options för fönster = s57 i user-manual
    vim user manual complete :D (258 sidor) xx/258 <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_user_manual.pdf>
    options för fönster = s57 i user-manual
    föreläsning: "More instantly better vim" <http://www.youtube.com/watch?v=aHm36-na4-4>
    surround.vim (makron för html- och xml-matchning mm) <http://www.vim.org/scripts/script.php?script_id=1697>
    vimplugins: matchit <www.vim.org/scripts/script.php?script_id=39>
    vimplugins: xmledit <www.vim.org/scripts/script.php?script_id=301>
    vim-latex
    Vimcasts.org :D <http://vimcasts.org/>
    o
    vimscripting: :D
    vimdoc.sourceforge.net/htmldoc/usr_41.html
    till LISTA_Ex-kommandon, Vim-funktioner mm :DDD <#ID_1833914625>
    ex-funktioner i vim <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--komm-rad_ex-komm_functions.odt>
    plocka_från_till_sista_vimsammanställningen.txt :DDD <./plockfil_sista_vimsammanställn/>
    Vim recipes mm <https://www.google.com/search?client=ubuntu&channel=fs&q=vim+recipes+pdf&ie=utf-8&oe=utf-8>
    o
    o
    LISTA_Exkommandon <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_exkommandon.mm>
    LISTA_Vimfunktioner <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_vimfunktioner.mm>
    LISTA_Autocommands <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_autocommands.mm>
    LISTA_Options <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_options.mm>
    LISTA_Skalväxlar <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_skalväxlar.mm>
    LISTA_kompileringsväxlar <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-lista_kompileringsväxlar.mm>
    vim-recipes (Bram Beer-boken) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim-recipes.pdf>
    o
    Basics
    Choosing the Right Mode ............................................................................................................. 12
    Basic Navigation ............................................................................................................................... 14
    Opening Files .................................................................................................................................... 16
    Saving a File ....................................................................................................................................... 20
    Quitting Vim...................................................................................................................................... 22
    Deleting Text .................................................................................................................................... 24
    Visually Selecting Text.................................................................................................................... 26
    Copying, Cutting, and Pasting ...................................................................................................... 28
    Configuring Vim................................................................................................................................ 30
    Printing................................................................................................................................................ 34
    Getting Help...................................................................................................................................... 36
    Editing
    Indenting Lines.................................................................................................................................. 41
    Selecting Text with Motions......................................................................................................... 44
    Repeating Commands ..................................................................................................................... 48
    Changing the Case of Text........................................................................................................... 50
    Sorting Text ...................................................................................................................................... 52
    Executing External Commands .................................................................................................... 55
    Managing Sessions ............................................................................................................................ 57
    Formatting with an External Program ....................................................................................... 60
    Working with Different File Formats ........................................................................................ 62
    Typing
    Spell Checking................................................................................................................................... 65
    Using Templates............................................................................................................................... 67
    Undoing Mistakes............................................................................................................................. 71
    Auto-Completing Text ................................................................................................................... 73
    Abbreviating Common Strings ..................................................................................................... 76
    Inserting Accented or “Foreign” Characters ........................................................................... 78
    Opening the File .............................................................................................................................. 81
    Inserting the Date............................................................................................................................ 84
    Inserting Snippets............................................................................................................................. 86
    Navigation
    Navigating Text Files....................................................................................................................... 91
    Navigating Source Code ................................................................................................................ 93
    Navigating the Viewport ................................................................................................................ 95
    Navigating Buffers ............................................................................................................................ 96
    Navigating Tabs ................................................................................................................................ 98
    Manually Creating Folds...............................................................................................................100
    Navigating Folds ............................................................................................................................. 102
    Splitting the Screen .......................................................................................................................104
    Navigating Marks............................................................................................................................106
    Navigating Tags............................................................................................................................... 108
    Bookmarking Lines with Visible Markers (Signs) ..................................................................111
    GUI
    Changing the Font .........................................................................................................................115
    Maximising Screen Space .............................................................................................................117
    Creating Menus and Toolbar Buttons .....................................................................................119
    Searching
    Searching for any Word ..............................................................................................................122
    Searching Over Multiple Files.....................................................................................................123
    Searching and Replacing ...............................................................................................................126
    Searching for the Word Beneath the Cursor.......................................................................128
    Creating Regular Expressions.....................................................................................................129
    Looking up Documentation for the Keyword Under the Cursor ..................................134
    Display
    Working with Long Lines............................................................................................................136
    Displaying Line Numbers.............................................................................................................138
    Working with Remote Files .......................................................................................................139
    Changing the Status Line .............................................................................................................141
    Redefining Highlight Groups .......................................................................................................144
    Modifying the Cursor ...................................................................................................................147
    Changing the Window Title .......................................................................................................149
    Extending
    Creating Keyboard Shortcuts with Key Mappings ...............................................................153
    Changing the Colour Scheme ....................................................................................................155
    Creating Command-Line Commands .......................................................................................157
    Extending Vim with Scripts and Plugins ..................................................................................159
    Integrating Vim with Git ..............................................................................................................162
    Other Uses of Vim
    Browsing Directories....................................................................................................................167
    Using Vim as a File Manager ......................................................................................................169
    Viewing Differences Between Files ...........................................................................................172
    Outlining a Document..................................................................................................................174
    o
    vim-avanc tips och tricks.txt <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_avanc_tips_och_tricks.txt>
    vimtips.pdf <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimtips.pdf>
    Learn Vimscript the hard way :DDDD <http://learnvimscriptthehardway.stevelosh.com/chapters/00.html>
    56 delar :DD
    Quickref Vim :DDD <http://vimdoc.sourceforge.net/htmldoc/quickref.html>
    o
    o
    vimgenomgång 2010-2011.odt <file:/home/bluelegend/gdrive/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010-2011.odt>
    <vim2011-totalgenomgånggrund_ankisource.txt>
    vimgenomgång_2010-2011--h_index.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--h_index.odt>
    vimgenomgång_2010-2011--komm-rad_ex-komm_functions.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--komm-rad_ex-komm_functions.odt>
    vimtips_avanc.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimtips_avanc.odt>
    vim_avanc_tips_och_tricks.txt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_avanc_tips_och_tricks.txt>
    vimtips.pdf <file:/home/bluelegend/gdrive/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimtips.pdf>
    register x: mav$hdgg/;$^Mp'add
    vimgenomgång_utklipp_h-index <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_utklipp_h-index>
    vim_regex_avanc--lookahead_och_lookbehind <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_regex_avanc--lookahead_och_lookbehind>
    vimgenomgång5 <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång5>
    vim_user_manual.pdf <file:/home/bluelegend/gdrive/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_user_manual.pdf>
    vimgenomgång 2010.odt <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010.odt>
    VIM REFERENCE MANUAL :] <http://heather.cs.ucdavis.edu/~matloff/Vim/Doc.html>
    +fler länkar :) <http://www.google.com/search?client=ubuntu&channel=fs&q=vim+complete+reference&ie=utf-8&oe=utf-8#hl=en&client=ubuntu&hs=U2U&tbo=d&channel=fs&sclient=psy-ab&q=vim+complete+reference+manual&oq=vim+complete+reference+ma&gs_l=serp.3.0.33i21.8344.9753.0.10730.3.3.0.0.0.0.94.253.3.3.0.les%3B..0.0...1c.1.0ca6sNJDGYs&pbx=1&bav=on.2,or.r_gc.r_pw.r_qf.&fp=e8932cf2edd4a476&bpcl=38897761&biw=1366&bih=634>
    o
    plocka från .mm för vim :) <plocka_från_till_sista_vimsammanställningen.mm>
    vimgenomgång2010.odt (första stora 4-5-sidors-grundsammanställningen) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010.odt>
    vimgenomgång2010-2011.odt (senaste stora 35-sidors) :) <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång%202010-2011.odt>
    stora 'tips i vim'-bladet :DDDD !!!!!
    genomgång :h__index-lista :D <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_2010-2011--h_index.odt>
    ctrl-w(=fönster)kommandon :) [kortkort lista] <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vimgenomgång_utklipp_h-index>
    samma som till vänster (.txt) <plocka_från_till_sista_vimsammanställningen.txt>
    hemsida: vim completing mm :) <http://www.cs.oberlin.edu/~kuperman/help/vim/completion.html> 
    o
    lilypondvim_f6.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f6.png>
    lilypondvim_s-f6.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_s-f6.png>
    lilypondvim_f5.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f5.png>
    lilypondvim_f10.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f10.png>
    vim_options <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim_options>
    lista_vim_options <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lista_vim_options>
    lilypondvim_f9.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f9.png>
    vim--converting_tabs_to_spaces.html <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/vim--converting_tabs_to_spaces.html>
    lilypondvim_f4.png <file:/home/bluelegend/Ubuntu%20One/Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/lilypondvim_f4.png>
    vim hacking :DD <Dokument640/GENOMGÅNG_dataprogram_programmeringsspråk/vim/Hacking%20Vim.pdf>
    o
    zzzz
    kap2 - Personalizing Vim (s26)
    o
    Getting started
    1
    2
    |usr_03.txt| Moving around
    |usr_04.txt| Making small changes
    |usr_05.txt| Set your settings
    |usr_06.txt| Using syntax highlighting
    |usr_07.txt| Editing more than one file
    |usr_08.txt| Splitting windows
    |usr_09.txt| Using the GUI
    |usr_10.txt| Making big changes
    |usr_11.txt| Recovering from a crash
    |usr_12.txt| Clever tricks
    Editing Effectively
    |usr_20.txt| Typing command-line commands quickly
    |usr_21.txt| Go away and come back
    |usr_22.txt| Finding the file to edit
    current directory
    s108
    window-local directory :DD
    finding a file (gf mm)
    s109
    lägga till mappar i path så vim hittar dem :D (vid gf-sök mm) **
    visa path
    :echo &path
    o
    o





    You can redefine the list of files without the need to exit Vim and start it
    again. Use this command to edit three other files: :);:args five.c six.c seven.h
    specify backupdirectory*;Another option that matters here is 'backupdir'. It specifies where the backup file is written. The default, to write the backup in the same directory as the original file, will mostly be the right thing. :)
    }}}
   lite extra från ed-genomgångarna att plocka in, vid tillfälle {{{
    vi [flags] [+cmd] [filename]
    filename is the name of the file to be edited.
    The flags arguments can include one or more of the following:
    -c cmd executes the specified command before editing begins.
    -e starts in colon command mode (which I describe in the following section).
    -i starts in input mode (which I also describe in the following section).
    -m causes the editor to search through the file for something that looks like an error message from a compiler.
    -R makes the file read-only so that you can’t accidentally overwrite the file. (You can also type view filename to start the editor in this mode to simply view a file.)
    -s runs in safe mode, which turns off many potentially harmful commands.
    -v starts in visual command mode (which I describe in the following section).
    Most of the time, however, vi starts with a filename as the only argument, as follows:
    vi /etc/hosts
    Another common way to start vi is to jump to a specific line number right at startup. To begin editing at line 107 of the file /etc/X11/XF86Config, for example, use the following command:
    vi +107 /etc/X11/XF86Config
    This way of starting vi is useful if you edit a source file after the compiler reports an error at a specific line number.
    Learning vi Concepts
    If you edit a file by using vi, the editor loads the file into a buffer, displays the first few lines of the file in a full-screen window, and positions the cursor on the first line. If you type the command vi /etc/fstab in a terminal window, for example, you get a full-screen text window, as shown in Figure 11-1.
    Click To expand
    Figure 11-1: A File Displayed in a Full-Screen Text Window by the vi Editor.
    The last line shows information about the file, including the number of lines and the number of characters in the file. Later, vi uses this area as a command-entry area. It uses the rest of the lines to display the file. If the file contains fewer lines than the window, vi displays the empty lines with a tilde (~) in the first column.
    The cursor marks the current line, appearing there as a small black rectangle. The cursor appears on top of a character. In Figure 11-1, the cursor is on the first character of the first line.
    In vi, you work in one of the following three modes:
    Visual-command mode is what you get by default. In this mode, vi interprets anything that you type as a command that applies to the line containing the cursor. The vi commands are similar to those of ed, and I list the in the section “Summarizing the vi Commands,” later in this chapter.
    Colon-command mode enables you to read or write files, set vi options, and quit. All colon commands start with a colon (:). After you enter the colon, vi positions the cursor at the last line and enables you to type a command. The command takes effect after you press Enter. Notice that vi’s colon-command mode relies on the ed editor. When editing a file using vi, you can press Escape at any time to enter the command mode. In fact, if you are not sure what mode vi is in, press Escape a few times to get vi into command mode.
    Text-input mode enables you to enter text into the buffer. You can enter text-input mode by using the command a (insert after cursor), A (append at end of line), or i (insert after cursor). After entering lines of text, you must press Esc to leave text-input mode and reenter visual-command mode.
    One problem with all these modes is that you can’t easily determine vi’s current mode. Typing text, only to realize that vi isn’t in text-input mode, can be frustrating. The converse situation also is common—you may end up typing text when you want to enter a command. To ensure that vi is in command mode, just press Esc a few times. (Pressing Esc more than once doesn’t hurt.)
    Tip     
    To view online Help in vi, type :help while in command mode.
    Examining a Sample Session with vi
    To begin editing the file /etc/fstab, enter the following command (before you edit the file, please make a backup copy by typing the command cp /etc/fstab /etc/fstab-saved):
    vi /etc/fstab
    Figure 11-1, earlier in this chapter, shows you the resulting display, with the first few lines of the file appearing in a full-screen text window. The last line shows the file’s name and statistics: the number of lines and characters.
    The vi editor initially positions the cursor on the first character. One of the first things that you need to learn is how to move the cursor around. Try the following commands (each command being a single letter; just type the letter, and vi responds):
    j moves the cursor one line down.
    k moves the cursor one line up.
    h moves the cursor one character to the left.
    l moves the cursor one character to the right.
    You can also move the cursor by using the arrow keys.
    Instead of moving one line or one character at a time, you can move one word at a time. Try the following single-character commands for word-size cursor movement:
    w moves the cursor one word forward.
    b moves the cursor one word backward.
    The last type of cursor movement affects several lines at a time. Try the following commands and see what happens:
    Ctrl-D scrolls down half a screen.
    Ctrl-U scrolls up half a screen.
    The last two commands, of course, aren’t necessary if the file contains only a few lines. If you’re editing large files, however, the capability to move several lines at a time is handy.
    You can move to a specific line number at any time by using a colon command. To go to line 1, for example, type the following and then press Enter:
    :1
    After you type the colon, vi displays the colon on the last line of the screen. From then on, vi uses the text that you type as a command. You must press Enter to submit the command to vi. In colon-command mode, vi accepts all the commands that the ed editor accepts—and then some.
    To search for a string, first type a slash (/). The vi editor displays the slash on the last line of the screen. Type the search string, and then press Enter. The vi editor locates the string and positions the cursor at the beginning of that string. Thus, to locate the string cdrom in the file /etc/fstab, type the following:
    /cdrom
    To delete the line that contains the cursor, type dd. The vi editor deletes that line of text and makes the next line the current one.
    Tip     
    To begin entering text in front of the cursor, type i. The vi editor switches to text-input mode. Now you can enter text. After you finish entering text, press Esc to return to visual-command mode.
    After you finish editing the file, you can save the changes in the file by using the :w command. If you want to save the changes and exit, you can type :wq to perform both steps at the same time. The vi editor saves the changes in the file and exits. You can also save the changes and exit the editor by pressing Shift-zz (press and hold the Shift key and press z twice).
    To quit the editor without saving any changes, type the :q! command.
    Summarizing the vi Commands
    The sample editing session should give you a feel for the vi commands, especially its three modes:
    Visual-command mode (the default)
    Colon-command mode, in which you enter commands, following them with a colon (:)
    Text-input mode, which you enter by typing a, A, or i
    In addition to the few commands that the sample session illustrates, vi accepts many other commands. Table 11-2 lists the basic vi commands, organized by task.
    Table 11-2: Basic vi Commands
    Command
    Meaning
    Insert Text
    a
    Insert text after the cursor
    A
    Insert text at the end of the current line
    I
    Insert text at the beginning of the current line
    i
    Insert text before the cursor
    o
    Open a line below the current line
    O
    Open a line above the current line
    Ctrl-v
    Insert any special character in input mode
    Delete Text
    D
    Delete up to the end of the current line
    dd
    Delete the current line
    dw
    Delete from the cursor to the end of the following word
    x
    Delete the character on which the cursor rests
    Change Text
    C
    Change up to the end of the current line
    cc
    Change the current line
    cw
    Change the word
    J
    Join the current line with the next one
    rx
    Replace the character under the cursor with x (x is any character)
    ~
    Change the character under the cursor to the opposite case
    Move Cursor
    $
    Move to the end of the current line
    ;
    Repeat the last f or F command
    ^
    Move to the beginning of the current line
    e
    Move to the end of the current word
    fx
    Move the cursor to the first occurrence of character x on the current line
    Fx
    Move the cursor to the last occurrence of character x on the current line
    H
    Move the cursor to the top of the screen
    h
    Move one character to the left
    j
    Move one line down
    k
    Move one line up
    L
    Move the cursor to the end of the screen
    l
    Move one character to the right
    M
    Move the cursor to the middle of the screen
    n|
    Move the cursor to column n on current line
    nG
    Place cursor on line n
    w
    Move to the beginning of the following word
    Mark a Location
    'x
    Move the cursor to the beginning of the line that contains mark x
    `x
    Move the cursor to mark x
    mx
    Mark the current location with the letter x
    Scroll Text
    Ctrl-b
    Scroll backward by a full screen
    Ctrl-d
    Scroll forward by half a screen
    Ctrl-f
    Scroll forward by a full screen
    Ctrl-u
    Scroll backward by half a screen
    Refresh Screen
    Ctrl-L
    Redraw the screen
    Cut and Paste Text
    "xndd
    Delete n lines and move them to buffer x (x is any single lowercase character)
    "Xnyy
    Yank n (a number) lines and append them to buffer x
    "xnyy
    Yank n (a number) lines into buffer x (x is any single uppercase character)
    "xp
    Put the yanked lines from buffer x after the current line
    P
    Put the yanked line above the current line
    p
    Put the yanked line below the current line
    yy
    Yank (copy) the current line into an unnamed buffer
    Colon Commands
    :!command
    Execute the shell command
    :e filename
    Edit the file
    :f
    Display the filename and current line number
    :N
    Move to line n (n is a number)
    :q
    Quit the editor
    :q!
    Quit without saving changes
    :r filename
    Read the file and insert after the current line
    :w filename
    Write the buffer to the file
    :wq
    Save the changes and exit
    Search Text
    /string
    Search forward for string
    ?string
    Search backward for string
    n
    Find the next string
    View File Information
    Ctrl-g
    Show the filename, size, and current line number
    Miscellaneous
    u
    Undo the last command
    Esc
    End text-input mode and enter visual-command mode
    U
    Undo recent changes to the current line
   }}}
-----
}}}

rds, pdfdoks.fmt35utils {{{
___fmt35utils=1
source ~/Dropbox/bin/scripts/utils/filter/ocrpostclean_fidashesetc.vim
source ~/Dropbox/bin/scripts/utils/filter/ocrp2t-post_hstyle1.vim
source ~/Dropbox/bin/scripts/utils/filter/ocrp2t-post_hstyle2.vim
source ~/Dropbox/bin/scripts/utils/filter/ocrp2t-post_hstyle3.vim

@u: Bump Eol Progr-comment to line above-comment [***!]
    / \ze\/rdd-P    # + change '/' to '#' for Py (etc)
@m: Replace visual block with numbered list [****]
    c- 0. F0}-f0g
@f: fetch pdf filename for txt-file
    O%ciwpdf &0ctE    evince -p 1 ~/o
@n: replace ''s with incremental pdf-pagerefs (**(!!))
    /xO,ppu                #Note(!!): strips|replaces all ''s (!!(*))
    /xO"pp-"pyapzt   #-strip, ap(=double pagenums-block)
               -----------------   #manually input double pnums-blocks (=fr. "p)

    /xnxO,ppu     #double columns + strips 
    /nO,ppun      #double columns
    /nO"pp"pyapzt
                          #double :s (=2 columns),  no-strip, ap(=double pagenums-block)
  rds

    progrpearls         48%
    progrpearls-more    46%

fmt35utils (=pdftotext afterclean +fmt35) (**) {{{

@x: '/\v\n\n\zs\n{2,}d/^.'  #Cut down multiple blank lines(=epub etc exports) to one(!) blank line


java:
 - indent +1-lines of multiline commentblocks 1(!) space
    `g/^\s*\*[ \/]/norm I `
    `.,$g/^\s*\*[ \/]/norm I `

set syntax= textwidth=35 nosi ai nojs spell shiftwidth=2 | colors ron
  set syntax= textwidth=35 nosi ai nojs spell shiftwidth=4 | colors ron
--
autoformatting text**  (=but not code)
    \v\n[^%$#].{95,}  #example =unix powertools(!(**))
    + g//norm ()gqap
    ----
    preparing testing out w. linux-rute
        ((pull tog. accidently split paragr.s of pure explanat. text))
            (  this is
                 .
               a paragraph )
        - first line of paragr. longer than 60 chars(?)
            (or(!!) two lines longer than (50) with text))
        - [^%$][a-z ,.()"']  ????(!!)

⁴ = u2074


line-splitting (='line ends w. lcase, next starts w. ucase' etc)



___fmt35utils
    | to I
        [a-z,.!?] \zs|\ze \a
        ## \v(^\||\|$)
        \v(^\|\ze [a-z,.?!]|[a-z,.?!] \zs\|$)
delete spaces on empty lines(!!)
    \v^\s+$
delete spaces before commas, periods etc
        \v \/ 
    \v[^ ]\zs \ze,
    # \v[^ ]\zs \ze[,.]
    \v(\zs \ze\)|\(\zs \ze[^ ])
replace em-dashes | fancy quot.marks * 
    %s/[‘’]/'/g | %s/[“”]/"/g
     [“”]
     ' ➤ ' >> '>'
            %s/[‘’]/'/g | %s/[””]/"/g
    %s/[^ ]\zs[——]\ze[^ ]/ - /gc
     %s/[^ ]\zs[——]$/ -/gc
     %s/^[——]\ze[^ ]/- /gc
        %s/\a\zs[——]\ze\a/ - /gc
    -----
    '\v [–—] '
    '\v−'
  scri2txt
    \a \zs|$      # 'I' became '|'
    [a-z,.;] \zs|\ze \a

fn latin ligatures %]]]]]

/[\ufb00-\ufb12]
ﬁ
ﬂ
ﬀ
ﬃ
ﬄ
--


Compress Many(!!) Blank lines to 1/2 Lines
    #### g/\v\n{3,}/norm }V}{-d
     #### g/\v\n{3,}/norm }V}{2-d
'e '-style linestarts to '- '
    '%s/\v^\C[.e°¢©®»«+*>_\@oO0] /- /gc'  #'*'
     'ff\n\n\a' etc to '- '
    g/\v-\n{2,}\l/norm }V}{d
convert + pull together pointlists with various special characters
    'g/\v^[■•]$/norm r-JJ'
Change various pointsigns at line-starts to '-'
    '%s/\v^(•|¡|■■||➤➤|) ?\ze\a/- /gc'

[scri2txt: remove blank extra (=line\n\nline)-lines (**)  #+ ending w. '-'/','
    \v[^ ]-\n\n+\l
        \v\l\n\n+\l/+
        \v[a-zA-Z,-]\n\n+\l/+
    g/[a-z,-]\C\n\n\l/norm dd
     g/[a-zåäö,]\C\n\n[a-zåäö]/norm dd
    --
    g/\v-\n{2,}\C[a-zåäö]/norm }V}{d
    g/\v\C[a-zåäö-]\n{2,}\C[a-zäåö]/norm }V}{d
    --
     g/\v\l\n{2,}\l/norm dd
    g/[a-zåäö]\zs[-,]$\n\n\l/norm dd  =Lines broken after 'wo-'
      g/[-,]\n{2,}\l/norm dd
convert '1.'-style numbers to '- 1.'  #at linestart
    '\v^\ze\d{1,2}\. \C\u[a-z ]'
     '\v^\ze\d{1,2}\. \C\u[a-zåäö ]'
pull together '- '-broken lines (**)
    g/[a-z,]\zs[-‐]\n\ze\a/norm JXxf r
        \v[^ ]-\n\n+   #search for '-\n'-lines with blank lines after
     g/[a-zåäö,]\zs-\n\ze\C[a-zåäö]/norm JXxf r   #(+resplits line after curr. new(=rebuilt) word)
        \C[a-zåäö]\zs\zeoch$  #separera 'ordoch' till 'ord- och'
     g/[a-zåäö,]\zs-\n\ze\a/norm JXxf r
    g/\a\zs-\n\ze\a/norm JXx   #+run until no matches
    g/[a-zåäö]\zs-\n\ze\a/norm JXxf r
      .
    [ g/[^ ]\zs-\n\ze\a/norm JXx ]
    .,$g/^[^-].*[^ ]-\n\n\ze\a/norm }dd-JXx  #more complex: =pull together, if broken over 2(!) lines
                                                                (=w. blank line in betw.)
----
    \C\.$\n\u

set syntax= textwidth=35 nosi ai nojs spell shiftwidth=4 | colors ron
            set textwidth=35 nosi ai nojs
set syntax=python | colors tomorrownight-bright

@a: dap'apI    V}-J  #=pick up mini-headers fr. bottom of page (=rdatacollect)
@b: dap'bpI    V}-J
 ....
--
 @o: /{$  #'down' (=find start of next brace-block(!))
 @e: >iB      # indEnt inner block(!)
   @z|y: @o@e
 @w: >'e      # simple indent doWn to end of code-block(!)
--
@g: gqap{zt}       #paragraphs fmt35
@i: }ddp-J
@f: /\di <ea>    #format next 'raw' footnote-number
 @_:  #format next footnote's endnumber(!)
@u: }ddpI    o
pull upp line fr. next paragr. + indent
  @y: }ddpI  
@m: f;gElct;       #break down comments eol-comments to next line (+change ';' to '#' for py (etc))
                         #(+change amount of added space to other than 4 spaces (if needed))
@r: }ddp-Js    #'rip' =intersperse comments
@b(reak): `f/F s  `  #=break eol-comments to next line




add extra blank line above header-line (=extra separation above blocks)
    '.' + 'A-Z'
        g/\.\n\n\u\l.*\l\n\u/norm o
        g/\.\n\n\u\l.*\l\n\n\u/norm o
    '.' + "1.3"-style
        g/\v\.\n\n(\d+\.)+\d \u/norm o
        g/\v\.\n\n(\d+\.)+\d\. \u/norm o
add blank line: below header-line
    '.' + 'A-Z'
        g/\C\l\n\u/norm o
          g/\C\l\n[ABD-FH-Z]/norm o
        --
        g/\n\n\n\C\u\l.*\n\u/norm }o
        g/\n\n\C\u\l.*\n\u/norm }o
    '.' + "1.3"-style
        g/\v^(\d+\.)\d \u/norm o
         g/\v^(\d+\.)\d\. \u/norm o
add blank line: after ':'(etc)-ending lines(!!)
    g/\v[:.?!…][)"]=\n\u/norm o
    g/:\n./norm o
      ||
    g/\C\.\n\u/norm o
    g/\C\.\n[AC-OR-Z]/norm o
del. blank lines in wrongly broken|split paragraphs(** = \l + \n + \l)(!!)
    g/\C\l\n\n\l/norm dd
[add blank after 'line.' foll. by lower (=wrongly broken table-lists)]
    g/\C\.\n\l/norm o
        g/:$/norm o
        g/\.$/norm o
                ^\d\+\..*\.$\n\u
----
convert 'Note\n\nText...' to '  Note: Text...'
    g/^\CNote\n\n/norm 2ddI  Note: 

    \l$\n\u
            \C\.$\n[ABD-Z]
            \l$\n[ABD-Z]
    \.$\n[^ ]
    [[:punct:]]$\n\u
        g//norm o

    \a\zs—\ze\a
    \l\zs\n\n\l
     --

}}}

@t: :set syntax= textwidth=35 nosi ai nojs spell shiftwidth=2 | colors ron
@c: :set syntax=CODELANG textwidth=0 nosi ai nojs shiftwidth=2 | colors ron

set syntax= textwidth=35 nosi ai nojs spell shiftwidth=2 | colors ron

set syntax=cpp textwidth=35 nosi ai nojs spell shiftwidth=2 | colors monochrome
set syntax= textwidth=35 nosi ai nojs spell spelllang=sv shiftwidth=2 | colors ron
  ~/Empire/Doks/Comp/lang/

[set shiftwidth, ie. '2']
set textwidth=35 nosi ai nojs  [!!]
  set textwidth=35 ai! si! nojs

}}}
rsc.macros: = tasks, patterns (regex etc) {{{

camel-case to snake-case
  @q: '/\uvui_'

@r: ,riviW  #open next line file with ristretto (+highlight fname)  __ **

  regexes
    highlight a@-tagged paragraph  ^\a@.*\v(\n.+)+

 @i: }ddp-J
 @j: }ddp-Ji 
 @g: gqap
 @b: V'bozt   #vmark all lines down to 'b (**)

  - replace defunct paths:
        ? \V/media/bluelegend/\CVerbatim
        g??s::\~:
}}}
. script-ideas/wishlist {{{

STUDY:
https://stackoverflow.com/questions/21280403/read-contents-of-the-pdf-using-vim#21280597
  au BufRead *.pdf sil exe "!xdg-open " . shellescape(expand("%:p")) | bd | let &ft=&ft | redraw!

https://stackoverflow.com/questions/11916898/vim-is-it-possible-to-view-pdf-file-in-a-split-window
augroup nonvim
   au!
   au BufRead *.png,*.jpg,*.pdf,*.gif,*.xls* sil exe "!open " . shellescape(expand("%:p")) | bd | let &ft=&ft
   au BufRead *.ppt*,*.doc*,*.rtf let g:output_pdf = shellescape(expand("%:r") . ".pdf")
   au BufRead *.ppt*,*.doc*,*.rtf sil exe "!/usr/local/bin/any2pdf " . shellescape(expand("%:p"))
   au BufRead *.ppt*,*.doc*,*.rtf sil exe "!open " . g:output_pdf | bd | let &ft=&ft
augroup end

augroup nonvim
   au!
   au BufRead *.png,*.jpg,*.pdf,*.gif,*.xls*,*.ppt*,*.doc*,*.rtf sil exe "!open " . shellescape(expand("%:p")) | bd | let &ft=&ft
augroup end



  temp 2021last:
  nnoremap <F1> :set syntax= spell spelllang=sv<CR> | nnoremap <F2> :set syntax=cs<CR>
    java
  nnoremap <F1> :set syntax= spell<CR> | nnoremap <F2> :set syntax=python<CR>


~/Dropbox/config/transcriptclean-maps.session.vim
######  transcriptclean(.sess).vim ------ {{{
    (( csa- cs- a- ))
    g- {{{
      å ä ö p y
      a o e u i
      . q j k x
    }}}
    sa- ****  (+use 'viW' as base? (=provides visual cue(!!)))
        n(ext):     =just(!) next word
         m(ore):      =lengthen 'viw' to next word   #or sa-i(nclude)?
        ----
        b(reak):    ='.' after word, break line at blank, +Cap.case next word.
        f(ull):     'full paragraph' =break w. blank line
         --
        c(omma):    =comma after curr. word
        l(case):    =lcase curr. word
        r(eplace):     *** =c|s curr word (=del. word + enter insert-mode at point)
          d(elete):     =del. marked word(s) + advance to(+mark) next
        .
        ----  [notes|problems: (!!)]
          - overlapping|doubled transcription|text-parts
}}}

}}}

TEACHING VIM / VIMTUTOR ****** {{{
        http://www.openvim.com/  =testa och lära in vim i webläsaren-hemsidan**
            http://www.vimgenius.com/
            https://www.rollapp.com/app/gvim
            http://coolwanglu.github.io/vim.js/streamlinejs/vim.html
            https://lifehacker.com/388440/jsvi-is-an-online-vi-editor

// meningar=is/as stycken=ip/ap ord=iw/aw kodblock=b / iB/aB
___lärautvim
    :help :update

    vimtutor / evim
    $ vimtu<Tab>

    hjkl
    :w :q! :wq :wq!  :up                                        !
    iaA  <Esc> c-c 

        DotRep.(*)                                              !
    x dw d$ d0  b w e  2dw
    2w 3e
    dd 2dd
    u c-r U
    p yy
    rx
    ce c$
    :help ruler  :set ruler
    g c-g  c-g
    gg G 22G
     c-f c-b  c-d c-u  c-e c-y
    /? nN  /ignore\c  /sökor<Up>    *# g*g#                     !
    c-o c-i
    %
    :s/o/n  :s/o/n/g  :#1,#2s/o/n/g  :%s/o/n/g  :%s/o/n/gc      !

    :!ls  :!rm filnamn.ext                                      !!
    :w filnamn.ext      :up
    v(rörelse) + :w filnamn.ext  V(rörelse rader) + :w filnamn.ext  v(rörelse)d
    :r filnamn.ext  :r !ls
    oO wbe R
    0$ yp yw
    :set ignorecase(ic)  :set noic  :set hlsearch(hls)  :set incsearch(is)   :set hls!
      FILTERS (**!)
    SHELLCOMMANDS (=!ls mm **)

    OPTIONS(**) :options                                        !
     Excommands(??)
    (VimFunctions**/??)

        gR (**)
    :help <Ent>  c-w c-w  :q ZQ ZZ
    :h w  :h c_CTRL-D  :h user-manual  :h insert-index + gg   c-] c-o c-i   !
    :h insert-index  :h reference_toc
                :h                    ___2023summerNew ****
                  index               ___2023summerNew ****
                  index.txt  @@@@     ___2023summerNew ****
                  help.txt  @@@@@@    ___2023summerNew ****
                  toc                 ___2023summerNew ****
                  help-summary        ___2023summerNew ****

        :e ~/.vimrc  /  :e $VIM/_vimrc   ZZ ZQ
        :r $VIMRUNTIME/vimrc_example.vim
        :w
      :h vimrc-intro

    completion på kommandoraden:
      c-d <Tab>
    tips: för kommandoraden, :h, :set optionname=  ??******

    Netrw vs Nerdtree(!)

    Jumplist (c-o c-i mm) **  going back: =Back OUT/Back IN     !
    Changelist + g, g;  ***                                     !!

        "+ och "*  (**)                                         !

      adresser + :t/:m
    Substitute: +catching w. '()'
    GLOBAL                                                      !!
    ----
    Marks 1 + MARKS 2 (****)                                    !!
    BLOCK     ib iB at ,  aw as ap,   ( { [ " ' < `             !!
    REGISTERS(BASIC) O MAKRON ***    #+ev: "= (insert: c-r= )   !!
            (=record, execute, Edit macro)
     --
     PatternMatching (+\v):  \%, Ryska-fallet (mm mm =inklusive specialare) ******
    VimRC + Leader(*)
    spec.keys i maps(*)
      NOREMAPS **                                               !!
    Window: = Split, Tabs mm (**!)  +ZZ ZQ                      !!
    ------
    Find + Wildcards (='**' mm) *******
    args + buffers

      Plugins + Vundle(**)

    localleader (****)

    C-X Autocompletion ****  C-N, C-X C-L, C-X C-F,  C-X C-N ** !!

                        folding                                 !!
        spelling
        Dictionary/Thesaurus

    Navigera Programmeringskod **
    Ctags/Cscope **(*)
    ----
    Compile + Qf/Loclist (**)

    Grep, Vimgrep, Ag
        Ultisnips(**)

    NVIM (+TERMINAL) ****


    vimböcker mm:
        http://iccf-holland.org/click5.html

}}}
--
Vim Plugins via Channels {{{
    Great. another question I've been pondering over for a bit: I know that something called "channels" was announced in Vim 8, and would (according to at least some things I've read) make it possible to write plugins to Vim using virtually any programming language, but I've had trouble finding example code or how to set it up in Vim. Could you give me some assistance on that?

    Certainly, I can help you learn about using Vim's Channels feature to write plugins using various programming languages.

    Vim's Channels feature was introduced in version 8 and allows plugins to communicate with external processes using sockets or pipes. This opens up the possibility of writing Vim plugins in virtually any programming language that can communicate through these mechanisms.

    To set up and use Vim's Channels feature, you'll need to follow these steps:

    - 1. Enable the Channels Feature: Make sure your Vim version supports the Channels feature. Vim 8 and later versions have this feature enabled by default. If you're using an older version, you may need to compile Vim with the +channel flag.
    - 2. Create a Channel: Create a channel object in your Vim plugin using the ch_open() function. This function takes the path to the external program as an argument and returns a channel object.
    - 3. Send and Receive Data: Use the ch_send() and ch_recv() functions to send and receive data from the external process. The ch_send() function takes the channel object and the data to send as arguments, while the ch_recv() function takes the channel object and an optional buffer to receive the data into.
    - 4. Close the Channel: When you're done communicating with the external process, close the channel using the ch_close() function. This function takes the channel object as an argument.

    Here's an example of how to open a channel to the cat command and echo a line of text to it:

    Vim Script

    let channel = ch_open('/bin/cat')
    let text = 'Hello from Vim!'
    ch_send(channel, text)
    ch_close(channel)

    This code will open a channel to the cat command, send the line "Hello from Vim!" to cat, and then close the channel.

    To use this feature with a different programming language, you'll need to use that language's networking libraries to communicate with the Vim channel. For example, if you're using Python, you can use the socket library to connect to the channel and send and receive data.

    Here's an example of how to open a channel to the Vim channel from a Python script:

    Python

    import socket

    # Connect to the Vim channel
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('localhost', 1234))

    # Send data to the Vim channel
    sock.send(b'Hello from Python!')

    # Receive data from the Vim channel
    data = sock.recv(1024)
    print(data.decode('utf-8'))

    # Close the connection
    sock.close()

    This script will connect to the Vim channel on port 1234, send the line "Hello from Python!", receive up to 1024 bytes of data from the Vim channel, and then close the connection.

    I hope this helps you get started with using Vim's Channels feature to write plugins using various programming languages.

    This sounds fantastic. Could you give me an example of a piece of code doing something that would be typically done with Vimscript, something non-trivial but not overly complicated (e.g. checking and manipulating some buffer text based of some condition of your choosing), and using Dlang to do it via the above-mentioned channels?

    Sure, here is an example of a piece of code that checks and manipulates some buffer text based on a condition, typically done with Vimscript, using Dlang to do it via Vim's Channels feature:

    Dlang Code
    D

    import vim;
    import socket;

    // Open a channel to the Vim channel
    socket sock = new Socket(AF_INET, SOCK_STREAM);
    sock.connect("localhost", 1234);

    // Get the current buffer
    string bufferName = vim.getCurrentBufferName();
    vim.Buffer buffer = vim.buffers[bufferName];

    // Get the buffer text
    string bufferText = buffer.getText();

    // Check if the buffer text contains the word "Hello"
    if (indexOf(bufferText, "Hello") != -1) {
      // Replace the word "Hello" with "World"
      buffer.replaceText("Hello", "World", 0, bufferText.length);

      // Send a message to Vim indicating that the text was changed
      sock.write("\nBuffer text was changed.\n");
    } else {
      // Send a message to Vim indicating that the text was not changed
      sock.write("\nBuffer text was not changed.\n");
    }

    // Close the connection
    sock.close();

    Vimscript Code

    Vim Script
    function vim_example_check_and_manipulate_buffer_text()
      let channel = ch_open('/path/to/dlang_code')
      let buffer = winbuf#
      let bufferText = buffer.getText()

      if indexOf(bufferText, 'Hello') != -1
        let buffer.replaceText('Hello', 'World', 0, len(bufferText))
        ch_send(channel, '\nBuffer text was changed.\n')
      else
        ch_send(channel, '\nBuffer text was not changed.\n')
      endif

      ch_close(channel)
    endfunction

    command! VimExampleCheckAndManipulateBufferText :call vim_example_check_and_manipulate_buffer_text()<cr>

    To use this example, save the Dlang code as dlang_code.d and compile it using the following command:

    dmd dlang_code.d

    Then, save the Vimscript code in your Vim configuration file (~/.vimrc or ~/.vim/vimrc). To run the code, select the buffer you want to check and manipulate and then type the following command:

    :VimExampleCheckAndManipulateBufferText

    This will run the Dlang code, which will check if the buffer text contains the word "Hello". If it does, it will replace the word "Hello" with "World" and send a message to Vim indicating that the text was changed. Otherwise, it will send a message to Vim indicating that the text was not changed.


    Great. Another question on the same topic: Could the same thing be done with NeoVim?

    Yes, the same thing can be done with NeoVim. NeoVim also supports Vim's Channels feature, allowing you to write plugins using various programming languages. The process of setting up and using Channels in NeoVim is similar to Vim. Here's an overview:

    - 1. Enable the Channels Feature: Ensure your NeoVim version supports the Channels feature. NeoVim 0.5 and later versions have this feature enabled by default.
    - 2. Create a Channel: Create a channel object in your NeoVim plugin using the vim.api.nvim_create_channel() function. This function takes the path to the external program as an argument and returns a channel object.
    - 3. Send and Receive Data: Use the vim.api.nvim_channel_send() and vim.api.nvim_channel_recv() functions to send and receive data from the external process. The vim.api.nvim_channel_send() function takes the channel object and the data to send as arguments, while the vim.api.nvim_channel_recv() function takes the channel object and an optional buffer to receive the data into.
    - 4. Close the Channel: When you're done communicating with the external process, close the channel using the vim.api.nvim_channel_close() function. This function takes the channel object as an argument.

    Here's an example of how to open a channel to the cat command and echo a line of text to it using NeoVim's Channels API:

    Lua

    local channel = vim.api.nvim_create_channel('/bin/cat')
    local text = 'Hello from NeoVim!'
    vim.api.nvim_channel_send(channel, text)
    vim.api.nvim_channel_close(channel)

    To use this feature with a different programming language, you'll need to use that language's networking libraries to communicate with the NeoVim channel. For example, if you're using Python, you can use the socket library to connect to the channel and send and receive data.

    The process of writing a Dlang plugin for NeoVim using Channels is similar to the one for Vim. You would write the Dlang code that handles the communication with NeoVim and then use the NeoVim Channels API to establish a connection and exchange data.

    Overall, using NeoVim's Channels feature provides a similar approach to Vim for writing plugins in various programming languages. The specific implementation details differ slightly between the two editors, but the core concepts and steps remain similar.


Very interesting. A question linking up with something we discussed before: Would you be able to give an example of how to rewrite the two last examples here, but instead using Vim 8 channels and Dlang? ;)
Sure, here are examples of how to rewrite the two previous examples using Vim 8 channels and Dlang:

Example 1: Checking File Existence

Dlang Code

D
import vim;
import socket;

// Open a channel to the Vim channel
socket sock = new Socket(AF_INET, SOCK_STREAM);
sock.connect("localhost", 1234);

// Try to open the file
string fileName = "myfile.txt";
string command = "cat " + fileName;

// Send the command to Vim and receive the response
sock.write(command);
string response = sock.readLine();

// Check the response
if (indexOf(response, "Error") != -1) {
  // File not found, send an error message to Vim
  sock.write("\nError: File not found!\n");
} else {
  // File found, send the file contents to Vim
  sock.write(response);
}

// Close the connection
sock.close();

Vimscript Code

Vim Script
command! VimExampleCheckFileExistence :call vim_example_check_file_existence()<cr>

function vim_example_check_file_existence()
  let channel = ch_open('/path/to/dlang_code')
  let fileName = 'myfile.txt'
  let command = 'cat ' . fileName

  ch_send(channel, command)
  let response = ch_recv(channel)

  if indexOf(response, 'Error') != -1
    echoerr 'Error: File not found!'
  else
    echo response
  endif

  ch_close(channel)
endfunction

Example 2: Handling Exceptions from External Commands

Dlang Code

D
import vim;
import socket;

// Open a channel to the Vim channel
socket sock = new Socket(AF_INET, SOCK_STREAM);
sock.connect("localhost", 1234);

// Try to execute the grep command
string fileName = "myfile.txt";
string searchTerm = "searchterm";
string command = "grep -n '" + searchTerm + "' " + fileName;

// Send the command to Vim and receive the response
sock.write(command);
string response = sock.readLine();

// Check the response
if (indexOf(response, "Error") != -1) {
  // Grep command failed, send an error message to Vim
  sock.write("\nError: Grep command failed!\n");
} else {
  // Grep command succeeded, send the results to Vim
  sock.write(response);
}

// Close the connection
sock.close();

Vimscript Code

Vim Script
command! VimExampleHandleGrepException :call vim_example_handle_grep_exception()<cr>

function vim_example_handle_grep_exception()
  let channel = ch_open('/path/to/dlang_code')
  let fileName = 'myfile.txt'
  let searchTerm = 'searchterm'
  let command = 'grep -n "' . searchTerm . "' " . fileName

  ch_send(channel, command)
  let response = ch_recv(channel)

  if indexOf(response, 'Error') != -1
    echoerr 'Error: Grep command failed!'
  else
    echo response
  endif

  ch_close(channel)
endfunction

In these examples, the Dlang code is responsible for executing the commands and handling any errors. The Vimscript code simply opens a channel to the Dlang code, sends the commands, receives the responses, and displays the results to the user.

}}}
. Netrw (+in neovim) {{{
  https://neovim.io/doc/user/pi_netrw.html
  https://levelup.gitconnected.com/using-netrw-in-neovim-39c3a2515f
}}}
inline images (=neovim hologram) {{{
https://github.com/bytesnake/vim-graphical-preview
  https://gist.github.com/adsr/fc801153bd25af024fc8ab876e24f1f3

  https://alpha2phi.medium.com/neovim-101-image-viewer-7f5d35db637a
  https://github.com/edluffy/hologram.nvim
    https://sw.kovidgoyal.net/kitty/keyboard-protocol/
    https://sw.kovidgoyal.net/kitty/quickstart/
    https://sw.kovidgoyal.net/kitty/binary/
      https://duckduckgo.com/?q=kitty+console+default+keyboard+shortcuts&t=newext&atb=v369-1&ia=web
    --
    https://sw.kovidgoyal.net/kitty/actions/#tab-management
https://cheatography.com/arest/cheat-sheets/kitty/

}}}
Modularizing Vimrc[!!] {{{

http://bling.github.io/blog/2013/08/16/modularizing-vimscript/


set runtimepath+=/usr/share/lilypond/2.20.0/vim/
"Vundle
set rtp+=~/.vim/bundle/Vundle.vim

:runtime (??)

:au Syntax cpp   runtime! syntax/cpp.vim        $VIMRUNTIME/syntax/synload.vim
 MAKING YOUR OWN SYNTAX FILES
  ADDING TO AN EXISTING SYNTAX FILE
  replacing an existing syntax file
Naming Conventions
2HTML (*****)    :runtime! syntax/2html.vim
  BASH: for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
:runtime! ftplugin/man.vim    gör så mansidor dyker upp i vimfönster (så inte vim måste emulera terminal mm)
:runtime! plugin/**/*.vim
läs in skript/plugin(s)         :runtime! syntax/c.vim


Tim Pope vimrc(!)
    25:00  (=vilka plugins som laddas)
    51:30  ++


Great. I'm going to start trying to refactor some code I've written in Vimscript later, but I'll get back to that and give you some examples of some code that needs some try-catch handling, putting some code in shared modules etc. So by the way and until then: If I would like to put code for Vimscript in separate modules, the process of reading them in from the Main part of the program is just using the 'source' command, right?
Yes, you can use the source command to read in Vimscript code from separate modules into the main part of your program. This is a common practice for organizing and reusing code in Vim.

When you use the source command, Vim will execute the code in the specified file as if it were part of the current buffer. This allows you to define functions, variables, and other code in separate files and then use them in your main Vimscript code.

Here's an example of how to use the source command:

Vim Script
source mymodule.vim

This will read the contents of the file mymodule.vim into the current buffer. You can then use any of the functions or variables defined in mymodule.vim in your main Vimscript code.

Using separate modules for your Vimscript code can make your code more organized, easier to understand, and easier to reuse. It can also help you to avoid conflicts between different parts of your code.

Here are some additional benefits of using separate modules for Vimscript code:

Modular code is easier to test. You can test each module independently to make sure it works correctly before you add it to your main program.

Modular code is easier to debug. If there is a problem with your code, you can isolate the problem to the module where it occurs.

Modular code is easier to reuse. You can reuse modules in multiple Vimscript programs.

I recommend using separate modules for your Vimscript code whenever possible. It will make your code more organized, easier to understand, and easier to reuse.


Question about Vim and a related one about Emacs: I would like to split up my resource files (i.e. vimrc and init.el). Currently I have them both as long files with all kinds different functionalies, but I would like to have a more modular approach where the central resource files just loads other files, more like a Main function in many programming languages. I know that I for my vimrc can use things like rtp (=setting the runtime path). Could you comment and give me some tips on this? It would be a great help.

Organizing your Vim and Emacs resource files into a modular structure can enhance maintainability and improve the overall organization of your development environment. Here's a breakdown of how to achieve this for both Vim and Emacs:

Vim:

- 1. Create Module Files: Create separate files for each module or functionality, such as keybindings, plugins, settings, and snippets. Each file should focus on a specific aspect of your Vim configuration.

- 2. Load Module Files: In your central vimrc file, use the source command to load each module file. For instance, to load a module file named keybindings.vim, use the following command:

Vim Script
source ~/.vim/keybindings.vim

- 3. Maintain Central vimrc File: Keep the central vimrc file focused on global settings, initialization, and filetype-specific configurations. Avoid placing module-specific configurations directly into the central vimrc file.

- 4. Organize Directories: Create a directory structure that reflects the module files. For example, you could have a ~/.vim/modules directory where all the module files reside.

- 5. Use Relative Paths: Use relative paths when sourcing module files to ensure portability across different environments. This will prevent issues when moving your Vim configuration to another machine.

- 6. Utilize rtp (Runtime Path): You can also use the rtp (runtime path) setting to specify the directory where Vim should look for module files. This allows you to centralize the module files and avoid having to explicitly source each one.


By following these guidelines, you can effectively organize your Vim resource files into a modular structure, making them easier to manage, maintain, and extend.

}}}
lang syntax plugins {{{
  https://github.com/elixir-editors/vim-elixir
  https://github.com/mxw/vim-jsx
  https://github.com/dart-lang/dart-vim-plugin
    https://code-maven.com/slides/dart/dart-in-vim
  https://github.com/thosakwe/vim-flutter
  Csound

https://wiki.dlang.org/D_in_Vim
https://github.com/Sirsireesh/vim-dlang-phobos-highlighter

  search: vim latex plugins
      github: vim-latex
      https://github.com/lervag/vimtex
  vimtex vs vim-latex
      https://vi.stackexchange.com/questions/2047/what-are-the-differences-between-latex-plugins#5747 **(**)
  vim working with context
      https://wiki.contextgarden.net/Vim
  ----
  https://github.com/tomlion/vim-solidity
  https://github.com/luisjure/csound-vim https://github.com/kunstmusik/csound-repl
          https://kunstmusik.github.io/score/csound.html  (='coding examples with the repl')
  search: vim taskjuggler
      https://github.com/kalafut/vim-taskjuggler
  https://github.com/udalov/kotlin-vim
  vim supercollider**
  github vim nasm  github vim gas
  vim qml github

}}}
Compiling Code {{{
  https://www.alexeyshmalko.com/2014/using-vim-as-c-cpp-ide/
}}}
ale, coq-vim {{{
https://github.com/ms-jpq/coq_nvim
        https://github.com/ms-jpq/coq_nvim
    https://github.com/dense-analysis/ale/blob/master/supported-tools.md
    https://github.com/dense-analysis/ale
}}}
ag/ack/agrep, ripgrep (**) {{{
  https://beyondgrep.com/more-tools/
    https://github.com/ggreer/the_silver_searcher
  https://github.com/mileszs/ack.vim

https://medium.com/pragmatic-programmers/customize-the-grep-program-f5dde36904a6
    https://www.wezm.net/technical/2016/09/ripgrep-with-vim/
    https://phelipetls.github.io/posts/extending-vim-with-ripgrep/
    https://www.philipbradley.net/posts/2017-03-29-ripgrep-with-ctrlp-and-vim/
}}}
indentation {{{
  basic indentation-checklists:
    set foldmethod=marker foldlevel=2
}}}
indentwise {{{
  https://github.com/jeetsukumaran/vim-indentwise  (= ']-' etc)
}}}
practical vim {{{

GENOMG/ANTECKN GENOMLYSSN. Practical Vim =Def. Maj 2020 (*****) {{{

    evince -p xii ~/Dropbox/PRACTICAL_VIM.pdf &
        'plugins of kana natsuno'               #best extensions of vims core funct. i've come across
    evince -p xii ~/Dropbox/PRACTICAL_VIM.pdf &
        'providing the wakeup source code'      #:make command
    evince -p xxii ~/Dropbox/PRACTICAL_VIM.pdf &
        'Try quitting Vim'                      # vim -u NONE -N  (=no rc/plugins + nocompatible
    evince -p xxiii ~/Dropbox/PRACTICAL_VIM.pdf &
        'set nocompatible'              # set nocompatible,,filetype plugin on  (=simplest rc-file (**!))
    evince -p xxiii ~/Dropbox/PRACTICAL_VIM.pdf &
        'vim -u code'                   # vim -u code/essential.vim  (=custom/specify rc-file(!!))
    evince -p xxiii ~/Dropbox/PRACTICAL_VIM.pdf &
        'factory settings to'           # "vim's factory settings"  =built-in plugins enable + compatible disabl.
    evince -p xxiv ~/Dropbox/PRACTICAL_VIM.pdf &
        'implementation of'             # visualstar.vim | Qargs.vim
    evince -p xxiv ~/Dropbox/PRACTICAL_VIM.pdf &
        'MacVim'                        # Mac-version of gvim(??): MacVim
    evince -p 19 ~/Dropbox/PRACTICAL_VIM.pdf &
        'Tie-Breaker'                   # vimgolf tied: Which is most repeatable (=t.ex. daw) ***(*!)

        zzzz=s21 'What follows 007?'    # TODO: KIKA IGENOM FÖRST GENOMLYSSNADE SIDORNA LITE SNABBT
                                            INNAN FORTSÄTTER PLOCKA IN DEF. (=KIKA EV. PÅ FORMAT
                                            FÖR INSKRIVNING DOKUMENTATIONEN HÄR =SÅ BLIR DEF, BEGRIPL.
                                            , + KONCIST O LÄTT ATT FÖLJA) ****(*)
                            (IDÉ: =FORMULERA SOM VIMANKI-DUALS(***(!!)) = FRÅGA/NÅT MAN VILL GÖRA
                                        +SNABB SAMMANFATTNING KOMMANDON/OPTIONS FÖR LÖSNING (***!))

}}}

ant. pract-vim (=utplock 1, pv + modern vim(*) 2019+) ** {{{

    egna
        DD
        D+
    tips
        TODO: REMAP CAPS

            "0  pv_149
            trick: swap two words       pv_150
            paste w.out mov. curs.**    gp gP
        redig. senast               gi
        mark: stop ins.             '^  `^
        nästa märke                 ]'
        ch/yank start *             `[
         last ch.                   `.
        last jump                   `` / c-o/c-i    #co/ci =äv. efter :e mm *****
        last vis.                   `<
         hoppa mellan (, [ mm *****     %

        norc/other rc/basic config              PV_xxiii
        format/auindent*            =
        grep                        :grep Word *  PV_1
        cl/sök-hist*                q: q/
        cline till cl-hist *        c-f **
        (+  :write | !ruby %  )
          'chunk undos'
    ins
        spec.tecken                 c-v u 1234   c-v 065        #+digraphs
        teckenkod **                ga  g8
        esc(m.fl.) i text           c-v Esc     #t.ex.
        virt.replace                gR **
    plugins
        surround.vim ****           PV_129 ***
        visual-star (+VIMSCRIPT =PV_213 *********)
        matchit.vim                 % = äv. XML-tags mm *****       runtime macros/matchit.vim      PV_129
        textobj-lastpat plugin, by Kana Natsuno, a which adds an i/ text object for operating on search matches.
            =PV_209 ****
        unimpaired ([b, <silent>)   ****    PV_79
        Abolish.vim (mandog-dogman) ??
        textob-entire
    cline
        del, yank, copy, put,       PV_(52)54, 59***** ___SEMER
          move m.fl. ****
        flera rad.s adresser        5:
          **
                    :%normal A;
                    :%normal i//
                range//g/patt/normal .      10@a   :'<,'>normal @a
                range//g/patt/normal @a
        ACT WITH MACRO ON COLLECTION OF FILES  pv_170 **** ___SEMER
                            wildmode    66
            cnoremap <C-p> <Up>
            cnoremap <C-n> <Down>
        :%!sort -t',' -k2   **
        rad till slut mark.         !G  ****    74***
          (=för !-kommando)

        qflist-kommandon            grep, vimgrep, make **

        group files w. :args        80
        :args **/*.js **/*.css      **********
        :args `cat .chapters`
                :h backtick-expansion
        find + path +=**    ******   '90 percent of what plugins do' *****      +PV_96 +136
            :find Main.js       :find Mai<Tab>
        complet: c-n vs c-x c-n (??/****)
    winsplittab
        bara detta f.               c-w o ***
        win. to tab                 c-w T
          :tabonly
          :tabmove 0 / :tabmove

        :edit % <Tab>   %:h <Tab>  ****
        cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'   PV_95

        netrw  98       :e.  :E  :S  :V  :T?
            % d (m.fl.)

        :w !sudo tee % > /dev/null      103

        noremap Q <Nop>

        yas

        changelist (g; mm)  pv_133
        (suffixesadd  pv_135)
        'Set Global Mark Before Goind Code Diving'  *****  mM  mV  mO  mm****   #leaving trail and crumbs ***

        ARGDO + HIDDEN *****  pv_172


        ändra(subst.) inneh. i reg.     :let @a=substitute(@a, '\~', 'vU', 'g')

        fill in incsearch-preview           c-r c-w
          i /-sök, utan att hoppa ****
        / + smartcase  pv_184
        / regex                 \v  *****       #very magic
        /\Va.k.a.                               #very nomagic ****     +\\\\ (=pv_195)
        no-capt. par.s          %( )
        \zs \ze                 # + @<= @=      #=mycket i syntax highlight-definitions
        Räkna antal för /-träff ****            :%s///gn  ****
            &  ~  \= *****
        :%s//"\1"/g         #/\v'(([^']|'\w)+)'
        :%s//\=@0/g
        g&      #:%s//~/&  225
        :&&  226
                    nnoremap & :&&<CR>
                    xnoremap & :&&<CR>
        VIMSCRIPT IN SEARCH ****  230
                :%s//\=submatch(0)-1/g

        OPERATING ON SEARCH MATCHES ******  pv_208
        ITERATE/BUILD REG-PATTERNS (FR. SEARCH HISTORY) ***** pv_209
        SWAP TWO OR MORE WORDS + DICTIONARIES ****  230
        MULTIFILE FIND/REPLACE ****  233  (=argdo search  m hidden) *
          BUILD ARGLIST WITH VIMGREP + **/*.txt   *****

        VIMSCRIPT: QUICKFIXDO ******   235     Qargs

        global/vglobal  238**

        delete lines w. pattern (global + delete) *****

        COLLECT TODO-ITEMS IN A REGISTER ****  240

        ALPHABETIZE THE PROPERTIES OF EACH RULE IN A CSS FILE  (=g+DYNAMIC RANGE)  ***** 242
            :g/{start}/ .,{finish} [cmd]
            :g/{/ .+1,/}/-1 >
            :g/{/sil .+1,/}/-1 >

        CTAGS/CSCOPE (+c-] ********/??)  ****** 249     g_c-] #lista multi.s   #+UNIMPAIRED för snabb 
                                                                               #navigering av tagjumpslist ****
            +jsctags  +cctree(=ctagsplugin för vim) **
        ctags (-R) *.py     #output =filen 'tags'  *****        :!ctags -R
            :nnoremap <f5> :!ctags -R<CR>   #=när börjar lägga till saker som --exclude=.git, --languages=-sql mm ****
            :autocmd BufWritePost * call system("ctags -R")     #+run with 'global v.control hooks'

        COMPILE W. MAKE 260 **
            :make
            :make!      #hoppa ej till första felet (=öppna ej qflistan) *
        ++:5cnext cfirst cnfile  cc 4  copen  cclose
            :lmake  :lgrep  :lvimgrep    + :lnext lfirst  osv ****



                :colder  :cnewer

        CUSTOMIZE COMPILER *****  266     (make for javascript etc ****)
            :setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %


        GREP (+ag ackmate mm)
            grepprg="grep -n $* /dev/null"
            grepformat="%f:%l:%m,%f:%l%m,%f  %l%m"

        MAKE ':GREP' CALL ACK ******  272       +Ack.vim


        fugitive.vim (:Ggrep =git-grep mm)  273

        vimgrep  274


        AUTOCOMPLETION + INFERCASE *** 276      +AUCOMPL.CMD.LIST ********** 277

        the autocomplete-menu

        'include'-option + c-x_c-i  ***


        c-x c-]  =tags files ****

        CUSTOM DICTIONARIES + SPELL ******  282

        SPELLCHECKER  287

        the spell file 290

         insert-spell  c-x c-s


        SOME GOOD VIM SETTINGS   295 *****


        autocmd FileType ruby setlocal ts=2 sts=2 sw=2 et
        autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noet

        autocmd FileType javascript compiler nodelint

         (+ev egna ftplugins istället) ***

}}}

}}}
vimscript hardway  [+VIM PLUGINS WITH PYTHON ****] {{{
  Possible Project for Vimscr.Hardway =Create Syntax files for Nyq:SAL, F*  (**(!))
  Projects/Plugins to Code {{{
    new: langcolors.favorites(**)
    - when lang set: ??

    - statistical reporting|sorting  =for comp-lang(etc) ref-lists (!!!!!(**))    (=sort by times used (=times marked|ticked)
    - autogenerate tempfile for report-file (=generated from ___style-tags) (!!(**))  (reporter.vim)

        vim indent-folding:  hide text in top line (***(!!!!!!!))
    vim-mini: 'post-indent same as prev. line (*****)'

  guiFontLarger/guiFontSmaller (****) {{{

        ta reda på nuv. font(?=om går)
      sätt font till standard 1
          set guifont=Monospace\ Regular\ 10
      +spara satta/nuv. grundstorleken på font
      gör funkt. för font-larger/smaller
          addera 1 till sparade=satta fontstorleken
          +spara nya värdet i 'fontSizeCurr'
          sätt <silent>(??) font till nya större/mindre font-storleken    #ev. snarare än sil: echo '10 pt' (el. likn.)
       bind larger/smaller till a-+/- | C-mhjupp/ner **
      vimrc: nnoremap <A-+> :so ~/Dropbox/vim/plugins/guifontlarger.vim       #till programattinstallera(?): Ev ln -s äv. för '~/Dropbox/vim/plugins/' till '~/.vim/plugins/'
          (=EV. SE OM BEHÖVER EXTRA MEKANISM FÖR ATT ENKELT GÖRA CALL TILL SKRIPTET (=FR. VIM/VIMRC)      #VIMSCR-HARDWAY/NEXT COLORSCHEME

  }}}
  Vim: C-MouseWheel =Zoom In(**(!!))
    - silently set fontsize to 10 at start of a file
    - save num. as 'current fontsize'
    - map c-mousewheel up|down to:
     - increase curr. fontsize + sil. set fontsize to new number

  Vim: Measure WritingSpeed (!!!!!!!)
    - insmode start: count chars in file (+words); take timestamp for starttime
    - insmode stop: take timestamp at stoptime; count chars in file (+words)
    - calcul. time in insert-mode: stop-timestamp - start-timestamp
    - get num. of chars(+words) input last insert + divide by time spent in ins-mode(!)
  ------
  }}}
AU-GROUPS o OP-MAPPING  2018_def+ **** {{{

        ih      #headings i markdown
        ah
        in@

        http://learnvimscriptthehardway.stevelosh.com/chapters/15.html      #oppending =definiera egna textblock (à la 'as', 'aw' m.fl. ******* )
        http://learnvimscriptthehardway.stevelosh.com/chapters/16.html
    :onoremap p i(
    :onoremap in( :<c-u>normal! f(vi(<cr>
    :onoremap il( :<c-u>normal! F)vi(<cr>





                :setlocal wrap      #kolla i en options help om går att 'sätta local'
                :h local-options/setlocal/map-local
                :h autocmd-groups
                :h autocmd-events
                http://vimdoc.sourceforge.net/htmldoc/autocmd.html#autocmd-events

    autocmd BufLeave *.{c,cpp} mark C
    autocmd BufLeave *.h       mark H

        Global      Local
        :set        :setlocal   
        :map        :map <buffer>   
        :autocmd    :autocmd * <buffer>     
        :cd         :lcd 
        <leader>    <localleader>

    :h new-filetype     #=ev för att kunna lägga till egna lilypond-red.kommandona



    autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   execute "normal! g`\"" |
        \ endif




    bra tips för 'snippet' abbreviations för ol. progr.språk:
        return for most languages
        function for javascript
        and things like &ldquo; and &rdquo; for HTML files.

    tips för vad sätta för localoptions för filtyper:
        wrap
        list
        spell
        number


    augroup filetype_vim {{{
        autocmd!
        au BufNewFile,BufRead *.rb,*.rbw  setf ruby
        autocmd FileType vim setlocal foldmethod=marker
        autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2 comments-=:#
        autocmd FileType javascript :iabbrev <buffer> iff if ()<left>
        autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
        autocmd FileType html nnoremap <buffer> <localleader>f Vatzf

        :autocmd BufNewFile,BufRead *.html setlocal nowrap
        :autocmd BufWritePre,BufRead *.html :normal gg=G
        :au BufNewFile,BufRead *.html so <sfile>:h/html.vim
    augroup END }}}




    :autocmd FileType python let b:match_words = '\<if\>:\<elif\>:\<else\>'
    :autocmd FileType python     :iabbrev <buffer> iff if:<left>
    :autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>


    :autocmd FileType javascript :iabbrev <buffer> iff if ()<left>
    :autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>


    augroup filetype_ruby
        autocmd!
        autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2 comments-=:#
        autocmd FileType javascript :iabbrev <buffer> iff if ()<left>
        autocmd FileType ruby nnoremap <buffer> <localleader>t :!rake test
    augroup END

    au BufNewFile,BufRead *.rb,*.rbw  setf ruby


    augroup filetype_erlang
        autocmd!
        autocmd FileType erlang nnoremap <buffer> <localleader>t :!rebar eunit
    augroup END


    augroup filetype_html
        autocmd!
        autocmd FileType html nnoremap <buffer> <localleader>f Vatzf
    augroup END

    :autocmd BufNewFile,BufRead *.html setlocal nowrap
    :autocmd BufWritePre,BufRead *.html :normal gg=G
    :au BufNewFile,BufRead *.html so <sfile>:h/html.vim
    ---



}}}
try catch finally {{{

Very good, and could you also give me one or two examples of using try, catch and finally (if finally exists that is) in Vimscript?
Certainly, here are two examples of using try, catch, and finally in Vimscript:

Example 1: Checking File Existence

Vim Script
try {
  let file = fopen('myfile.txt', 'r')
  readfile(file)
  fclose(file)
} catch {
  echoerr 'Error: File not found!'
} finally {
  if exists('file') {
    fclose(file)
  }
}

This code tries to open a file named myfile.txt for reading. If the file does not exist, the catch block will be executed, and an error message will be displayed. The finally block will always be executed, regardless of whether an error occurs. It ensures that the file is closed properly, even if an error occurs.

Example 2: Handling Exceptions from External Commands

Vim Script
try {
  !grep -n 'searchterm' myfile.txt
} catch {
  echoerr 'Error: Grep command failed!'
} finally {
  if exists('grep_process') {
    kill(grep_process)
  }
}

This code tries to execute the grep command to search for the term "searchterm" in the file myfile.txt. If the grep command fails, the catch block will be executed, and an error message will be displayed. The finally block will always be executed, regardless of whether an error occurs. It ensures that the grep process is killed properly, even if an error occurs.

These are just two examples of how to use try, catch, and finally in Vimscript. These blocks can be used in a variety of situations to handle errors and ensure that resources are cleaned up properly.

}}}

  Vim Plugins with Python
  :help if_pyth.txt  #=Reference Manual Post concerning Python in Vim (*****(!!))
    https://www.youtube.com/watch?v=vMAeYp8mX_M
      https://github.com/JarrodCTaylor?tab=repositories
    https://github.com/JarrodCTaylor/vim-plugin-starter-kit
  https://github.com/JarrodCTaylor/vim-plugin-starter-kit/wiki
        https://github.com/JarrodCTaylor
  https://github.com/JarrodCTaylor/vim-plugin-starter-kit/wiki/Executing-Vim-commands-with-Python
}}}
autocommands {{{
  Search: Vim defining custom|user defined autocommand events ***(**)
    https://stackoverflow.com/questions/21535350/creating-a-user-defined-event-in-vim#22784667
}}}
modern vim {{{
  https://github.com/neovim/neovim
  https://neovide.dev/
https://mattermost.com/blog/how-to-install-and-set-up-neovim-for-code-editing/

  https://github.com/LunarVim/Neovim-from-scratch/tree/master/lua/user
https://www.youtube.com/playlist?list=PL0EgBggsoPCk1WCos2txThsxhg0fT5nqD
https://github.com/s1n7ax/dotnvim
  https://github.com/s1n7ax/nvim-terminal

https://neovim.io/
    https://neovim.io/doc/user/nvim.html#nvim-from-vim
    https://neovim.io/doc/user/vim_diff.html#vim-differences
}}}
gvimdiff for gitdiff {{{
  use vimdiff for git diff
    opendiff
}}}
snippets, ultisnips, luasnip {{{
  http://vimcasts.org/episodes/meet-ultisnips/
}}}
plugins  #nvim {{{
  https://www.youtube.com/watch?v=1f7l2-Fap2s

https://www.linode.com/docs/guides/write-a-neovim-plugin-with-lua/
https://dev.to/2nit/how-to-write-neovim-plugins-in-lua-5cca
https://neovim.io/doc/user/lua-guide.html
https://github.com/nanotee/nvim-lua-guide

  https://github.com/rockerBOO/awesome-neovim
  https://github.com/nvim-lualine/lualine.nvim
  https://hannadrehman.com/top-neovim-plugins-for-developers-in-2022
  https://breuer.dev/blog/top-neovim-plugins
 https://medium.com/linux-with-michael/a-list-of-all-my-main-neovim-plugins-8ac4ae107e16

  https://vonheikemen.github.io/devlog/tools/neovim-plugins-to-get-started/
}}}
completion {{{
  https://www.youtube.com/watch?v=2f8h45YR494  #Using complete-menu for completing words
}}}
vim c# {{{

Last question for now: What would I have to install or complement the code files with if I'm using Vim and Mono on Linux?
To use Mono on Linux with Vim, you'll need to install the necessary packages and configure your environment. Here's a step-by-step guide:

1. Install Mono:

Install the Mono runtime using your package manager. For example, on Ubuntu or Debian, use the following command:
sudo apt-get install mono-complete
2. Install OmniSharp:

Install OmniSharp, a Vim plugin that provides language support for C# and .NET development. You can install it using Vim's package manager:
vim +PlugInstall --sync vim-omni-sharp
3. Configure Vim for Mono:

Set the mono-path option in your Vim configuration file (usually .vimrc or ~/.vimrc) to point to the Mono runtime directory. For example:
set mono-path=/path/to/mono
Set the mono-regex-path option to the regular expression for matching Mono executables. For example:
set mono-regex-path=/path/to/mono/bin/mono
4. Verify Installation:

Open Vim and start a new C# file (.cs). If OmniSharp is installed and configured correctly, you should see C# syntax highlighting and code completion suggestions.
With these steps, you should have Vim and Mono configured to work together for C# development on Linux. OmniSharp will provide language support, code completion, and other features to aid your programming tasks.



I understand that it should now (like previously said, I'm using Ubuntu 22.04) no longer be necessary to run Mono when developing C# on Ubuntu. Could you say something more about this?
Yes, you are correct. It is no longer strictly necessary to run Mono when developing C# on Ubuntu 22.04. This is because Ubuntu 22.04 includes the .NET 6 runtime by default, which provides a native implementation of the .NET framework for Linux. This means that you can develop and run C# applications directly on Ubuntu without the need for a separate Mono installation.

The .NET 6 runtime provides several advantages over Mono, including:

Improved performance: .NET 6 is optimized for Linux environments and offers better performance compared to Mono.

Better integration with Linux tools: .NET 6 integrates seamlessly with various Linux tools and libraries, making it easier to develop and deploy cross-platform applications.

Reduced maintenance overhead: Since .NET 6 is the official .NET runtime for Linux, it receives regular updates and support from Microsoft, reducing the maintenance burden for developers.

If you are developing C# applications on Ubuntu 22.04, it is recommended to use the .NET 6 runtime instead of Mono. This will provide a more performant, integrated, and well-supported development environment.


And what would be the steps for installing this in Ubuntu 22.04 (and as a side-question, when is Ubuntu 24.04 due: Specifically Ubuntu Studio which I am using)?
Since .NET 6 is already included in the default installation of Ubuntu 22.04, you don't need to install it separately. To verify that you have .NET 6 installed, you can use the following command in your terminal:

dotnet --version
This should print the installed version of .NET, which should be 6.0 or higher. If you don't have .NET 6 installed, you can install it using the following command:

sudo apt install dotnet6
This will install the .NET 6 SDK, which includes the runtime and other tools for developing and running .NET applications.

Regarding the release date of Ubuntu 24.04, there is no official announcement yet. However, based on the release cycle of Ubuntu, it is expected to be released in April 2024. Ubuntu Studio is a specialized flavor of Ubuntu designed for multimedia production and creative work. It is typically released alongside the standard Ubuntu release, so it is also expected to be released in April 2024.


Great. What would be the command in Vim 8 for compiling a C# program using this dotnet 6? Currently I am compiling my programs with ':!mono program.cs'.
To compile a C# program using dotnet 6 from Vim 8, you can use the following command:

:!dotnet build program.cs
This command will invoke the dotnet build command to compile the specified C# program (.cs) file. The resulting compiled assembly will be placed in the same directory as the source file.

Here's a breakdown of the command:

!: This tells Vim to execute a shell command.
dotnet: This invokes the dotnet command-line tool.
build: This specifies the build command to compile the program.
program.cs: This is the name of the C# program file to compile.
By using this command, you can leverage dotnet 6 for compiling your C# programs directly from Vim, taking advantage of its performance and integration with Linux environments.

}}}
Lua Neovim {{{

~/Dropbox/rsc/data/lists/ref/comp/nvim-lua.txt [****]

    https://neovim.io/doc/user/lua.html
    https://neovim.io/doc/user/lua-guide.html#lua-guide
    https://vonheikemen.github.io/devlog/tools/configuring-neovim-using-lua/
      https://www.youtube.com/watch?v=J9yqSdvAKXY
    https://neovim.io/doc/user/api.html#API
    https://jacobsimpson.github.io/nvim-lua-manual/docs/interacting/
    --
    https://www.udemy.com/course/neovim-plugin-from-scratch-introduction-course/
      https://github.com/LazyVim/LazyVim
https://www.lua.org/manual/5.4/manual.html#6


    https://github.com/nanotee/nvim-lua-guide
    https://www.2n.pl/blog/how-to-write-neovim-plugins-in-lua
    https://jacobsimpson.github.io/nvim-lua-manual/docs/basic-plugin/
      https://jacobsimpson.github.io/nvim-lua-manual/docs/interacting/
            https://www.reddit.com/r/neovim/comments/134ekkp/are_there_any_advantages_to_use_vimscript_instead/
    https://www.linode.com/docs/guides/write-a-neovim-plugin-with-lua/
    https://vonheikemen.github.io/devlog/tools/neovim-plugins-to-get-started/

    https://mattermost.com/blog/turning-neovim-into-a-full-fledged-code-editor-with-lua/
    https://programmingpercy.tech/blog/learn-how-to-use-neovim-as-ide/
    https://martinlwx.github.io/en/config-neovim-from-scratch/
  https://vonheikemen.github.io/devlog/tools/configuring-neovim-using-lua/
}}}
https://www.youtube.com/watch?v=Wb91wpCUx8Q
neovim ide
  https://www.youtube.com/watch?v=stqUbv-5u2s
lfs, treesitter  #nvim {{{
    ysearch: nvim treesitter lsp
    Neovim Treesitter
}}}
nvim ide {{{
  https://mattermost.com/blog/turning-neovim-into-a-full-fledged-code-editor-with-lua/
}}}
tmux {{{
  'vim + tmux'    https://www.youtube.com/watch?v=5r6yzFEXajQ&t=3175s
}}}
vim bash {{{
    ~/Empire/Doks/Comp/vim/vimbash-hotkeys.pdf ~/Empire/Doks/Comp/vim/vim_bashsupport.pdf
}}}
vim outliner, outlaw {{{
    ~/Empire/Doks/Comp/vim/vimoutliner-manual.txt

    https://github.com/lifepillar/vim-outlaw
}}}
.vim games {{{
https://linuxhint.com/vim_editor_games/
    https://github.com/lag13/vim-games
    https://github.com/jmanoel7/vim-games
        https://github.com/johngrib/vim-game-snake
}}}
video, images, graphics  #nvim {{{
    https://github.com/hzeller/timg
}}}
org mode  #nvim {{{
  nvim org  https://github.com/nvim-orgmode/orgmode
            https://www.youtube.com/watch?v=grbtRhFiPrw
  neorg     https://github.com/nvim-neorg/neorg
}}}


~/Dropbox/rsc/Doks/phone.fmt35/todo/curr/_blender-blendPy/blscripting1.txt
~/Dropbox/rsc/Doks/phone.fmt35/todo/curr/_blender-blendPy/aux/blender-refman_pythonscripting.txt

cleaned teaching vim {{{
___lärautvim __

:update  :up        save file

  k              basic movement
h   l
  j

:write   :w         save file (regardless of change/existance)

---- v = visual mode -----------------------
V           linewise visual mode
Ctrl+v      visual block mode
    v           visual mode

---- i / a = insert / append -----------------------
i                   go to insert mode
    I               -- " --  at start of line
    a
    A               -- " --  at end of line
<Esc>    Ctrl+C     back to normal mode

    (+tips: using the s and S commands)

---- o / O = open -----------------------
o        open new line below
    O        -- " -- above
    J    Join lines

.        repeat last action (****) __

---- movement -----------------------
w        word (=to start of next)
    b       back (=to beg. of prev. word)
    e
0        start of line
    $       end of line

x        cross out (=del. a character)
    dw
    d$
    d0
    2dw
    2w
    ce
rx       replace (=one character)

---- d = delete -----------------------
dd       delete (=whole line)
    2dd
---- c = change -----------------------
ce           change (i.e. delete + go to insert-mode) **
    c$

u        Undo __
    Ctrl+r      repeat

---- y = yank -----------------------
yy       yank (=copy) whole line
    p        paste

---- more movements -------------------
gg           go to beginning of file
    G            go to end of file
    22G
c-f c-b      forward/backard (one screen)
    c-e c-y      -- " -- (one line)

#Note: 'g' is often used to modify or "enhance" other commands

---- indent/deindent ------------------
    >        indent
    <        deindent
>>       indent line
    >}       indent rest of 'paragraph'


---- 'find'/'to' (=character) ------------
f
    t
    F
    T

---- Searching -----------------------
/ ?          search forward/backward
                  #Tip: supports Regex
    n
    N
    /TODO        search for the word TODO
    /wor<Up>
*            search (forward) word under cursor
    #

Ctrl+o Ctrl+i     'Out' / 'In'
    }                 next paragraph
    %                 move between matching braces

---- 'Add' / 'Extract' -------------------------
Ctrl+a / Ctrl+x      add to / subtract from next number

---- :substitute / :global -----------------------
:substitute/pattern
:s/old/new/  :s/old/new/g  :%s/o/n/g  :%s/o/n/gc

---- setting Options -----------------------------
:set ignorecase(ic)  :set noic  :set hlsearch(hls)  :set incsearch(is)   :set hls!

---- Marks 1 ---------------------------------
ma                  set invisible mark "a"
    'a / `a             jump back to invis. mark "a"

BLOCKS / 'Text Objects'
    word
    sentence
    paragraph
    (-block
    {-Block
    [-block, <-block
    "-quotation, '-quotation, `-quotation
    tags(=html/xml) *
ib iB at ,  aw as ap,   ( { [ " ' < `             !!
    -----
Example:
    dap      delete (and copy) paragraph (+blank line after)
    das      delete (and copy) sentence (+space after it)
    ci"      change/edit text inside "-quotes
    ciB      change/edit text inside {-blocks  SUPERB FOR CODING
    cit      change/edit text in HTML/XML tags [!!!!]

More Operators:  gq, =

REGISTERS(BASIC) O MAKRON ***    #+ev: "= (insert: c-r= )   !!
    "ay / "ad           save text to register a
    "ap                 paste text from register a
    (+ concerning Ctrl+r from insert mode)

---- 'Macros' ** -----------------------------
qa                  record macro/key-sequence to register a

---- Vim Commandline -------------------------
    [see 'Options' above]





      FILTERS (**!)
    SHELLCOMMANDS (=!ls mm **)

    (VimFunctions**/??)

        gR (**)
    :help <Ent>  c-w c-w  :q ZQ ZZ
        :e ~/.vimrc  /  :e $VIM/_vimrc   ZZ ZQ

        :r $VIMRUNTIME/vimrc_example.vim
        :w
      :h vimrc-intro

    completion på kommandoraden:
      c-d <Tab>
    tips: för kommandoraden, :h, :set optionname=  ??******

    Jumplist (c-o c-i mm) **  going back: =Back OUT/Back IN     !

    "+ och "*  (**)                                         !

      adresser + :t/:m
    Substitute: +catching w. '()'
    GLOBAL                                                      !!
    ----
     --
    PatternMatching (+\v):  \%, Ryska-fallet (mm mm =inklusive specialare) ******

    Window: = Split, Tabs mm (**!)  +ZZ ZQ                      !!

    C-X Autocompletion ****  C-N, C-X C-L, C-X C-F,  C-X C-N ** !!


    Navigera Programmeringskod **


http://iccf-holland.org/click5.html

}}}

vim:fdm=marker:fdl=0:
